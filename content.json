{"meta":{"title":"吾铭子","subtitle":"","description":"","author":"吾铭子","url":"https://wumingzi.top","root":"/"},"pages":[{"title":"归档","date":"2023-01-29T06:27:52.000Z","updated":"2023-01-29T06:32:46.000Z","comments":true,"path":"archives/index.html","permalink":"https://wumingzi.top/archives/","excerpt":"","text":""},{"title":"分类","date":"2023-01-29T06:25:34.000Z","updated":"2023-02-07T07:18:28.000Z","comments":true,"path":"categories/index.html","permalink":"https://wumingzi.top/categories/","excerpt":"","text":""},{"title":"友情链接","date":"2023-10-13T05:36:04.116Z","updated":"2023-01-17T02:08:50.000Z","comments":true,"path":"links/index.html","permalink":"https://wumingzi.top/links/","excerpt":"","text":""},{"title":"关于","date":"2023-01-19T05:33:03.000Z","updated":"2023-01-19T09:45:30.000Z","comments":true,"path":"about/index.html","permalink":"https://wumingzi.top/about/","excerpt":"","text":"Bangumibilibili"},{"title":"日程表","date":"2023-01-29T06:26:51.000Z","updated":"2023-01-29T06:32:12.000Z","comments":true,"path":"schedule/index.html","permalink":"https://wumingzi.top/schedule/","excerpt":"","text":""},{"title":"站点地图","date":"2023-01-29T06:27:24.000Z","updated":"2023-01-29T06:32:28.000Z","comments":true,"path":"sitemap/index.html","permalink":"https://wumingzi.top/sitemap/","excerpt":"","text":""},{"title":"标签","date":"2023-01-29T06:21:17.000Z","updated":"2023-02-07T07:30:40.000Z","comments":true,"path":"tags/index.html","permalink":"https://wumingzi.top/tags/","excerpt":"","text":""},{"title":"分类","date":"2023-10-13T05:36:04.124Z","updated":"2023-01-29T06:33:24.000Z","comments":false,"path":"repository/index.html","permalink":"https://wumingzi.top/repository/","excerpt":"","text":""}],"posts":[{"title":"","slug":"vx","date":"2024-04-02T08:58:24.130Z","updated":"2024-03-31T02:59:19.460Z","comments":true,"path":"2024/04/02/vx/","link":"","permalink":"https://wumingzi.top/2024/04/02/vx/","excerpt":"","text":"{\"created_time\":\"2024-02-21T00:56:28Z\",\"files\":[{\"attachment_folder\":\"\",\"created_time\":\"2024-02-21T00:58:50Z\",\"id\":\"2\",\"modified_time\":\"2024-02-22T12:11:39Z\",\"name\":\"C复健计划.md\",\"signature\":\"79316869532362\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2024-02-21T00:58:50Z\",\"id\":\"3\",\"modified_time\":\"2024-02-21T00:58:50Z\",\"name\":\"FreeRTOS.md\",\"signature\":\"27206031329994\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2024-02-21T00:58:50Z\",\"id\":\"4\",\"modified_time\":\"2024-02-21T00:58:50Z\",\"name\":\"hello-world.md\",\"signature\":\"113818341821130\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2024-02-21T00:58:50Z\",\"id\":\"5\",\"modified_time\":\"2024-03-31T02:59:19Z\",\"name\":\"Linux基础.md\",\"signature\":\"82331936574154\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2024-02-21T00:58:50Z\",\"id\":\"6\",\"modified_time\":\"2024-03-13T02:23:59Z\",\"name\":\"Linux深入.md\",\"signature\":\"67535774239434\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2024-02-21T00:58:50Z\",\"id\":\"7\",\"modified_time\":\"2024-03-06T09:28:50Z\",\"name\":\"Python.md\",\"signature\":\"49299343100618\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2024-02-21T00:58:50Z\",\"id\":\"8\",\"modified_time\":\"2024-03-27T00:41:40Z\",\"name\":\"STM32.md\",\"signature\":\"126093358353098\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2024-02-21T00:58:50Z\",\"id\":\"9\",\"modified_time\":\"2024-02-21T00:58:50Z\",\"name\":\"Vim复健计划.md\",\"signature\":\"115802616711882\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2024-02-21T00:58:50Z\",\"id\":\"10\",\"modified_time\":\"2024-02-21T00:58:50Z\",\"name\":\"百年工业.md\",\"signature\":\"105073788406474\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2024-02-21T00:58:50Z\",\"id\":\"11\",\"modified_time\":\"2024-02-21T00:58:50Z\",\"name\":\"测试.md\",\"signature\":\"24504496900810\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2024-02-21T00:58:50Z\",\"id\":\"12\",\"modified_time\":\"2024-03-21T02:00:47Z\",\"name\":\"工具链.md\",\"signature\":\"120883563023050\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2024-02-21T00:58:50Z\",\"id\":\"14\",\"modified_time\":\"2024-02-21T00:58:50Z\",\"name\":\"杂项.md\",\"signature\":\"72273123166922\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2024-02-21T01:30:26Z\",\"id\":\"15\",\"modified_time\":\"2024-02-21T01:32:12Z\",\"name\":\"项目.md\",\"signature\":\"42783877714482\",\"tags\":[]}],\"folders\":[],\"id\":\"1\",\"modified_time\":\"2024-02-21T00:56:28Z\",\"signature\":\"177802136124\",\"version\":3}","categories":[],"tags":[]},{"title":"Linux深入","slug":"Linux深入","date":"2024-02-20T16:21:54.000Z","updated":"2024-03-13T02:23:59.535Z","comments":true,"path":"2024/02/21/Linux深入/","link":"","permalink":"https://wumingzi.top/2024/02/21/Linux%E6%B7%B1%E5%85%A5/","excerpt":"Linux驱动深入","text":"Linux驱动深入 Linux深入内联汇编为了保证效率或者使用特殊指令(如原子操作)时需要使用汇编，使用方法是：单独将汇编代码放在.S文件中，在C函数中使用extern声明之后就可以使用汇编文件里的函数了 对于内联汇编需要使用__asm___关键字修饰函数 同步互斥的深入在单核CPU上关中断开中断是可以实现同步互斥的，但是在多核CPU上开关中断不能保证其他CPU不会修改临界变量 原子操作对于ARMv6之前的内核，通过关中断恢复中断来实现原子操作，但是在v6之后(包括v6)，由于arm支持SMP(多核CPU)，因此不能简单的使用开关中断来实现原子操作，而是使用ldrex，strex汇编语句来实现，其根本原理是在要ldr数据上打上标记，在要str的数据上消除标记，根据能否消除标记而返回不同的值，根据值来判断是否申请资源成功，不成功的话则再次重复，直到能申请资源为止 锁自旋锁自旋锁无法休眠，当一段临界区被加上自旋锁时，如果CPU0与CPU1都竞争临界区只有CPU0获得资源的话，那么CPU1不会休眠而是会反复请求资源(当写程序时，在进中断时也要加自旋锁来防止其他CPU打断当前CPU执行irq)，因此，使用自旋锁时临界区代码要尽量精简(5行左右)，且不能休眠 自旋锁在 单核系统(UP) 还可以用来禁止调度防止抢占，对于不同的自旋锁他有不同的防止抢占方式，比如对于最普通的spin_lock()而言，他只能关闭调度，而对于spin_lock_irq()而言，它可以关闭中断 自旋锁的实现：每个自旋锁上都有当前任务编号，和当前任务编号+1的下一个任务编号，内核会检查想要申请资源的自旋锁任务编号与当前自旋锁下一个任务编号是否相同，相同的话则获得锁，否则wfe休眠一段时间 睡眠锁睡眠锁有mutex和semaphore两种 对于信号量来说，它可以休眠，因此对于临界区代码可以比自旋锁复杂很多，信号量用于多进程间访问同步和互斥，而互斥锁用于保护某个临界资源 在信号量结构体中，需要用到自旋锁 semaphore的实现：semaphore结构体中有spinlock，还有个count和wait_list，当使用spinlock_up获取semaphore时，首先需要获得spinlock，如果成功获得则需要让count++，否则把自己挂载到wait_list上 mutex的实现：与semaphore类似，但是由于追求效率会更为复杂，里面配置了宏开关来优化效率，通过宏可以选择等待mutex的线程是否休眠(休眠开销太大)。当进入临界区获取资源时也可以自动判断使用fastpath还是slowpath fastpath与slowpath：当一段临界区代码很短且需要mutex时，这时大概率会出现线程不需要等待而直接获取资源，并且解锁时也不需要唤醒其他线程，这种情况称为fastpath，而需要等待获取资源且需要唤醒其他线程称为slowpath，两个的选择取决于mutex结构体中的count(是个原子变量)，count值为1时表示unlocked，此时其他线程可以获得锁，count值为0时代表locked，需要解锁，但是当前执行任务的线程解锁后不需要唤醒其他任务此时为fastpath，当count值为-1时，代表当前任务解锁后还需要唤醒其他线程，这时是slowpath mutex的实现比semaphore更复杂，这是因为mutex追求更高的效率，在写驱动程序的时候尽量使用mutex USART访问虚拟终端中的前台终端：&#x2F;dev&#x2F;tty0访问当前程序运行的终端(考虑真实的USART等终端)：&#x2F;dev&#x2F;tty (不会输出信息到其他tty) 在驱动模块崩溃时可以查看LR来找到崩溃的函数当驱动程序错误时，可以使用strace -o log.txt .&#x2F;exe可以在log.txt里获得系统调用 printkprintk后面可以加上打印级别，如果不指定打印级别则会默认打印级别，当console设置的打印级别低于内核级别时则不会打印printk。如果想在多个控制台打印时，可以在设备树或者uboot指定console&#x3D;tty0，console&#x3D;tty1，但是只有最后指定的console会收到串口信息。实际上，uboot也是通过修改设备树来实现更改打印终端的 12echo &quot;1 4 1 7&quot; &gt; /proc/sys/kernel/prink//可以修改打印级别，第一个1为console消息级别，4为默认级别 PCI与PCIe为了简化CPU与外部设备通信及硬件连线使得访问外设像访问内存一样，PCI总线应运而生。有了PCI后，CPU不必关注具体的操作细节，比如不使用PCI，CPU与GPIO，I2C等设备直接相连时，程序员需要关注GPIO，I2C等设备的具体实现，而使用PCI总线时，直接访问PCI设备控制器即可，具体访问操作会由PCI硬件实现，同时也会简化硬件的连线复杂度但是引入PCI总线也会导致设备地址空间分配问题，为了解决这个问题，PCI采用地址偏移量的思想：首先由CPU分配设备内存地址空间，并由PCI设备控制器维护并计算所需要的地址偏移量，待到CPU需要访问具体地址时，由PCI所记录的地址偏移量即可算出真实的物理地址，PCI地址数据线是复用的为了保证传输速率，PCI一开始被设计为并行总线，但由于速率提高之后并行总线会导致信号干扰，因此新的PCIe总线也诞生了，它采用了串行总线差分信号的结构，这会支持更高的速率 在PCIe中，一对发送接收差分线称为lane，对于低速PCIe，例如PCIe转串口而言只有一条lane，对于视频音频卡而言有多条lane，两PCIe设备之间称为一条link PCI总线原理由于PCI总线为并行传输，数据地址统一不做区分的发送到AD引脚上 对于非桥设备而言会PCI会发出type0信号以表示访问非桥设备 如果想设置PCI设备的地址，首先要在IDSET引脚置高电平，然后由CPU发出cpuaddr，经PCI控制器转换后得到PCIaddr，再发送type1命令并根据type0的function number设置具体的功能，最后按照register number设置寄存器的值，具体的配置项如下图，此配置项写在PCI设备的寄存器内。包含了设备ID，厂家ID，创建设备时申请多大的PCI空间如果想读写PCI设备的地址，需要按照手册在C&#x2F;BE引脚设置值，然后设置frame引脚，再发送type0命令，当frame引脚为低电平时遇到的第一个时钟发出的AD信号是addr，第二个发出的则是data 对于桥设备而言如果需要配置PCI设备需要发送type1命令，若header type的值为01h则为桥设备，此时需要收到PCI设备根据收到的信息检测bus number，如果在子节点找到bus number那么就转发到下一层PCI设备，如果下一层设备还是桥设备的话就继续转发，直到遇到非桥设备且是目标设备为止，然后根据发送的信息判断是配置还是读写寄存器 PCIe总线原理PCIe的配置过程(基于ID的路由方式)：PCIe采用深度优先的配置模式，首先由Host将配置信号发送至子设备，首先由 A设备先进行配置，A设备的上层总线号是Bus0，下层总线号是Bus1，于是A设备在其配置寄存器内记录，由于子设备数sub并不确定，A设备先令其值为255。而后再配置A的子设备C，同理将其配置为1，2，255，之后再配置D，当配置到Bus3的下层的具体设备时，会将bus，dev，fuction的值3，0，1、3，0，0记录在设备中，由于遇到了end point，所以返回至D端口，修改sub将其从255修改至3(bus的最大值)，但由于只配置了D，因此还需要配置同层的E设备，配置方式同D下面的end point。之后返回至上层C，将sub值修改为4(C设备下总线号的最大值) PCIe将发送数据分为三层，分别为：事务层，数据链路层，物理层，每层将上下层数据处理后传递给下一层或者上一层，具体收发数据原理如下： 发送数据时： 首先由CPU发送原始数据至root complex，由rc处理数据后在事务层得到TLP 事务层将原始数据前加入header，数据后加入CRC校验，header内包含数据是读写数据还是配置寄存器，包装后的数据被称为TLP，处理后将数据发至数据链路层 数据链路层规定了数据的重传方式，为此在数据头部添加了seg段，在数据尾部添加了LCRC校验，数据处理完成后将数据发至物理层 物理层负责将信号拆分并发送出去 发送数据时： PCIe三种路由方式上述的配置使用基于ID的路由方式，所谓路由，就是如何找到通讯另一方，而隐式路由指的是地址和ID不单独声明，而是根据type确定通讯地址 物理层负责将信号接收并组合，而后发给数据链路层 接收方的数据链路层所做的与发送方相反，即去掉seg和LCRC，处理完毕后发送给事务层 同理，事务层将接收的数据，去掉CRC校验和header，从而获得原始的data 配置读、配置写：使用基于ID的路由，就是使用&lt;Bus, Device, Function&gt;来寻找对方。配置成功后，每个PCIe设备都有自己的PCIe地址空间了。 内存读、内存写或者IO读、IO写： 发出报文给对方：使用基于地址的路由 对方返回数据或者返回状态时：使用基于ID的路由 各类消息，比如中断、广播等：使用隐式路由 PCIe驱动设备模型USB2.0 USB设备插到电脑上去，接触到的设备是什么？ 是USB Host hub，一个usb controller，管理所有的USB设备 既然还没有”驱动程序”，为何能知道是”android phone” 在电脑中USB总线协议驱动程序已经写好了，USB总线根据协议知道是”android phone” 为什么一接入USB设备，PC机就能发现它？ PC的USB控制器内有下拉电阻，USB设备通过引流5v电源在Data+&#x2F;Data-引脚处产生上拉电阻，使得当USB插入主机时PC的USB控制器D+引脚有电压跳变，PC通过检测引脚的电压跳变来知道是否有设备连接 USB设备种类非常多，为什么一接入电脑，就能识别出来它的种类？ USB协议指定设备种类对应的描述符，通过描述符来知道设备的种类 PC机上接有非常多的USB设备，怎么分辨它们？ 根据分配的编号来分辨他们 USB设备刚接入PC时，还没有编号；那么PC怎么把”分配的编号”告诉它 刚接入的设备默认编号为0，通过此编号就可以与设备通信并分配新的编号 低速，全速与高速信号的识别对于USB2.0而言，支持了高速信号就不能支持低速信号，其设备速率识别方法如下 对于全速或低速设备而言，由于在Data+&#x2F;Data-引脚处有个上拉电阻，因此PC可以通过检测Data+&#x2F;Data-引脚的电平高低来检测支持的速率，如果Data+为高电平，那么支持全速速率，Data-为低电平，那么支持低速速率 对于高速设备而言，如果检测到设备支持全速速率，那么就断开上拉电阻并给设备发送一个SE0信号，如果设备支持高速模式，那么就会回应一个特殊信号，主机就知道了设备支持高速模式 工作在高速模式下的设备会断开Data的上拉电阻，这是为了保证高速传输数据时发生干扰，并且还需要在通信双方的D+&#x2F;D-引脚串联一个45Ohm的电阻，如果不串联电阻，那么发送端的信号到达接收端就会反射，当下次发射信号时，上一次反射的信号会和这一次的信号叠加使信号失真，这种加电阻的方法就叫做阻抗匹配，我们检测高速设备是否断开连接时就是检测反射信号的强弱，当设备断开连接时，接收方相当于阻抗无穷大，会造成反射信号的增强。在开发中，如果发现设备总是断开连接也有可能是阻抗匹配没有做好 USB协议通信数据如下 sop(start of package)，具体信号参见手册enp(end of package)，具体信号参见手册sync，同步信号，由于USB没有时钟线只有两条数据线，因此sync是为了确定通信速率的 数据传输特点在数据传输方面，USB采用了NRZI(Non Return Zero Inverted Code，反向不归零编码)，NRZI的编码方式为：对于数据0，波形翻转；对于数据1，波形不变。例如对01011110为例，传输的结果是11000001，使用NRZI可以发送一串0来把时钟频率告诉对方位填充：由于USB没有时钟线，因此还需要考虑通信双方晶振的误差对信号的影响，例如当传输100个0时，由于晶振的误差会产生接收端接收了99个或101个0的现象，因此协议规定数据包每隔6个1后插入1个0 协议内容一次传输由一个或多个事务实现，事务下层根据目的不同被划分成了三种包，令牌包指明传输的对象和地址，数据包只传输数据，握手包由接收方设备发出，内容为各种应答信号。每个包内部又分为各种域(field)，sop field代表传输的开始，sync field代表传输的速率，PID filed代表传输的包的ID，根据取值不同PID被分为四类，令牌类，数据类，握手类，特殊类，令牌类用于令牌包，表明发送的是令牌类数据。在PID field后的filed就是传输的数据，为了保证数据正确还需要CRC field，在传输的末尾还要加上eop field来表明传输完成 对于握手包而言没有Data field与CRC field USB设备种类繁多有不同要求，这些要求可以分为下列几种 批量传输：对实时性要求不高，但要求传输可靠，且传输的数据量很大，例如U盘 实时传输：对数据量要求不大，可靠性要求也不高，但实时性要求很高，例如摄像头 中断传输：对可靠性和实时性要求都很高：如鼠标 控制传输：对设备进行控制 对于批量传输而言，每次传输有三个阶段对于中断传输而言，每次传输有三个阶段，但需要Host定期访问设备请求数据以保证实时性对于实时传输而言，每次传输有两个阶段，去掉了握手包，类似UDP 设备配置过程 得到设备描述符 设置非零的新地址 再次获得设备描述符 获得配置描述符，并同时获得接口描述符和端点描述符 设置配置 OTGOTG(On To Go)，插上即用的缩写。OTG是USB2.0协议的补充，当设备使用OTG连接时，两方设备可以在不经过PC的情况下可以直接通信。 OTG通过内部硬件的上拉电阻来识别Host&#x2F;Device，Host通过ID引脚的取值决定是否向Device供电，供电引脚为VBUS。 引脚名 作用 VBUS 作为Host时，对外供电作为Device时，接收外部输入的电源 DM 数据信号 DP 数据信号 ID 分辨自己角色的引脚：1：作为Device0：作为Host GND 地线 当插入OTG接口时，id引脚(typec模式时为cc引脚)被连接，id引脚的取值被Host设备的主控芯片(arm)所决定，当arm板以Device模式通信时，由于arm芯片内部有100k的上拉电阻因此三极管是导通的，EN引脚为低电平，5v的电源不能输出，此时为Device模式。而当转换器接入板子时，转换器内部的下拉电阻会将arm的上拉电阻拉低，导致5v电源能够输出，此时arm板可以给外界设备供电，工作在Host模式 I2C深入对于通用的platform_device在i2c驱动模型中被称为i2c_client I2C驱动框架如图所示，在基础的设备总线驱动模型的基础上加入了adapter适配器，这可以使每一个I2C硬件设备支持不同的adapter使其产生不同的功能。具体的驱动编写框架如下： 修改设备树或者对应.c文件 调用i2c专用的register函数使其调用probe函数注册adapter 实现adapter结构体，实现master_xfer函数以作为adapter成员，master_xfer是最为关键的传输函数 总结： i2c驱动注册时： 由底层向高层注册，首先根据设备树的配置项注册adapter(i2c的Controller)，配置相关的时序，模式，频率等基本参数，使得芯片可以驱动i2c设备，在注册adapter的同时顺便把client注册了(cilent注册的时机是在adapter靠后的位置)，client负责具体的i2c外设，这由外设厂家编写，配置i2c的初始信号来访问某个固定的寄存器，确定信息传输完成后延时时间，以及对应外设芯片的寄存器配置，使得芯片可以与外设通信。 在adapter注册时需要的模型是platform-bus模型，内核会根据设备树中的adapter的数量来确定有几个adapter即几条总线，并根据驱动程序和设备树来两两匹配。在每次注册adapter的过程中还需要顺便注册client，它是device-bus模型。内核在注册client时会发送探测信号来扫描总线上是否存在设备，并根据设备树和驱动来两两匹配并注册进内核 i2c驱动使用时： 由高层向底层调用，当app需要访问某个设备时，首先会找到对应外设的client，根据内部client经过内核的i2c_core找到对应adapter，再找到对应的xfer发送函数来控制adapter发送到对应外设 inux驱动：I2C驱动学习看这一篇就够了 SPI深入SPI驱动程序设备树框架： 对于SPI控制器而言，如果使用platform_bus的match函数匹配到了platform_device与platform_driver的话就会调用SPI控制器的probe函数注册生成一个spi_master，除此之外还会生成一个spi_device 内核从上面得到的spi_device解析，并调用match函数来检测spi设备驱动spi_driver是否匹配，如果匹配就调用SPI设备的probe函数注册生成一个字符设备以及file_operation结构体 对于SPI控制器而言可以扩展多个设备，具体可以看设备树文件由于SPI控制器与SPI设备分别由内核解析，并且采用了分离的思想，因此在写SPI设备的驱动程序时需要调用Linux提供的函数接口来引入SPI控制器的资源，尤其是spi_master.transfer函数 在SPI子系统一个transfer对应一个传输，为了管理多个传输采用了链表结构，SPI控制器的驱动程序spi_master内部有一个queue，每一个具体设备spi_device都会生成一个message并挂载到queue，每一个message会有多种transfer，这些transfer会挂载到message上 新方法的spi_master的驱动程序，使用方便但规矩多，支持同步异步传输 老方法的spi_master的驱动程序，使用繁琐规矩少，支持同步异步传输 GPIO深入GPIO Controller驱动是编程的核心，其他LED，Button驱动程序只是调用GPIO Controller驱动的函数，对于LED，Button驱动程序只需要调用内核的GPIO lib库即可，我们编写控制器驱动程序的时候也只需要将驱动注册进GPIO lib库 一个GPIO Controller对应一个GPIO device结构体，其内部有chips(相当于fop)，desc(描述单个引脚的数组指针，内部描述了引脚的高低电平，输入输出模式等)，base(引脚基地址等) Pinctl子系统会统一管理引脚，GPIO引脚与Pinctl引脚的映射统一在设备树中管理 Pinctl深入使用设备树时分为Pinctl Controller与Client 每一个Pinctl Controller都会使用Pinctl device来描述，Pinctl Controller有三大功能：引脚配置，复用及命名，三者统一在pinctrl_dev.pinctrl_decs结构体中实现如果写Pinctl Controller驱动，则需要实现pinctrl_decs，并使用pinctrl_register注册 platform_device从设备树中解析得到，里面会构造一个dev.dev_pin_info结构体，内部的pinctrl与pinctrl_state结构体储存了设备树中节点的信息 Pinctl Controller下的子节点会被内核解析成一个个pinctrl_map，然后被转换为成一个个pinctrl_setting挂载到pinctrl_state，client就可以从pinctrl_state结构体中获得设备树信息","categories":[],"tags":[]},{"title":"Linux基础","slug":"Linux基础","date":"2024-02-20T16:19:52.000Z","updated":"2024-03-31T02:59:19.459Z","comments":true,"path":"2024/02/21/Linux基础/","link":"","permalink":"https://wumingzi.top/2024/02/21/Linux%E5%9F%BA%E7%A1%80/","excerpt":"基础的Linux应用与驱动开发","text":"基础的Linux应用与驱动开发 LinuxLinux基础shell负责解析命令，当用户在shell中输入命令时，根据输入的结果，shell根据PATH环境变量的位置找到相应的程序执行，因此可以通过将.o文件复制到PATH来直接在任何目录下执行程序，否则只能使用绝对路径或相对路径的方式来执行 []代表可选参数 &lt;&gt;代表必选参数 Linux基础命令与操作. 当前目录 .. 上一级目录 - 切换前上一次的目录 1234cd .. 返回到上一级目录cd - 返回到切换前上一次的目录rm -r 递归删除touch existfile 修改文件更改时间 拥有文件权限的组分别为：book用户，book用户所在组的其他用户，其他用户 123456789101112131415file 文件名 查看文件详细信息chmod 777 赋予所有权限chmod a-x filename 去除所有用户的x权限chmod u+x filename 加上拥有者的x权限chown 用户组:用户组 filename 改变文件的拥有者su 用户名 切换用户find 目录名 选项 查找条件find directoryname -name &quot;*1.txt*&quot; 在directoryname下找到包含为1.txt的文件grep 参数 &quot;字符串&quot; 文件名 grep -rwn &quot;abc&quot; * 在当前目录中查找含有abc字符串的文件，查找模式是，递归的(r)，整词的(w)，找到行号(n)ifconfig 查看网络 tar命令 12345tar cjf filename.tar.bz2 filename 文件使用bzip2压缩算法压缩tar czf filename.tar.gz filename 文件使用gzip压缩算法压缩tar xjf filename.tar.bz2 文件使用bzip2压缩算法解压tar xzf filename.tar.gz 文件使用gzip压缩算法解压 Linux环境搭建为了能够便捷配置环境以及工具链，我们需要在Linux环境下进行开发，因此我们就需要选择Ubuntu虚拟机作为我们的服务器，为了能够将Ubuntu上编译后的程序在开发板上也能运行，我们需要配置交叉编译环境，为了开发板与Ubuntu能够传输文件，我们需要设置网口，配置ip，开启nfs服务，由于我们是小白，为了能够使用win下的笔记，截图工具，我们需要win下的通信工具mobaxterm，同时我们需要保证win，Ubuntu，开发板能够互相通信 网络拓扑如下 设置NAT以及桥接网卡NAT网卡可以保证Ubuntu可以上网，NAT实现Ubuntu与Windows网络互通桥接网卡保证Ubuntu可以与开发板互通 默认ip： 开发板 192.168.5.9 windows 192.168.5.10 Ubuntu 192.168.5.11 开启NFSNFS(net file system)，为了方便开发板与Ubuntu之间通信，可以设置开启NFS 开启步骤 在Ubuntu中开启开发板访问Ubuntu的权限，在&#x2F;etc&#x2F;export中加入要共享的文件夹 开启NFS服务 在开发板中挂载Ubuntu中的某个目录(默认为&#x2F;home&#x2F;book&#x2F;nfs_rootfs)到&#x2F;mnt下 交叉编译环境的使用 环境变量有三种方式可以修改 永久修改： 修改/etc/environment，添加对应的目录，对所有用户有效 修改~/.bashrc，在行尾添加export PATH=$PATH:对应的目录，并执行source ~/.bashrc，只对当前用户有效 临时设置： 在终端执行export PATH=$PATH:对应的目录，但只对当前终端有效 由于开发板使用的是arm架构，虚拟机使用的是x86架构，且环境、资源基本不同，因此为了能够使由Ubuntu编译后的文件在开发板上使用，需要配置交叉环境编译链，百问网使用脚本自动配置，我们只需在编译时使用这些编译工具即可 如果没有使用交叉编译链编译文件，在开发板上执行时会提示格式错误 IMX6ULL工具链IMX6ULL工具链有两种分别为arm-buildroot-linux-gnueabihf-gcc 与 arm-linux-gnueabihf-gcc，前者工具链较全，包含了zlib等库，后者较为精简，有的库没有包含 编译第一个应用程序在Ubuntu上执行arm-buildroot-linux-gnueabihf-gcc -o hello hello.c使得编译后的文件能够在开发板上执行 编译第一个驱动程序由于驱动程序依赖内核，因此必须有内核的源码且内核必须编译过，这样驱动程序才能根据配置编译过的内核而运行 步骤如下： 准备好内核，设备树，并编译 将编译后的文件拷贝到nfs文件夹下，以便开发板能够访问 编译驱动模块，将驱动模块安装在nfs文件夹下 将挂载在开发板的&#x2F;mnt下的内核，驱动程序放在&#x2F;boot下，将编译产生的lib放在开发板的lib下 执行sync命令，以便将内存中的内容刷写到flash上 重启开发板，这样就诞生了一个自己编译内核的，驱动的开发板 Linux应用开发基础在int main(int argc, char** argv)中，编译执行输入./filename command时argc是2，argv[0]是filename，argv[1]是command，argv的值可以传进函数做参数 引用的头文件在哪？ 在工具链的系统目录，或者编译时-I指定目录 头文件和库文件的区别 头文件是文本文件，可供阅读，库文件是二进制文件，不可阅读，因此库文件有一定的保密性 头文件在编译阶段使用，库文件在链接阶段使用 头文件一般只包括声明，库文件包括了内部实现 头文件是手动编写的，库文件是生成的 GCCGCC操作gcc(g++) options -o 指定文件名 -fexec-charset&#x3D;GBK 指定运行时编码 -finput-charset&#x3D;UTF-8 指定源文件编码 -Wall 输出警告信息 -O(0-3) 指定代码优化等级(0为不优化) -I 指定文件目录来查找头文件(一般为.&#x2F;) -L 指定文件目录来查找库文件(一般为.&#x2F;) -v 输出编译的信息 编译过程 预处理阶段 (-E，得到.i文件)（巧记：ESC，iso） 处理#include预编译指令，将被包含的文件直接插入到预编译指令的位置 处理所有的条件预编译指令，比如#if，#else，#endif，#ifdef等 预处理器将所有的#define删除，并且展开所有的宏定义 删除所有的注释 添加行号和文件标识，以便编译错误时提供错误或警告的行号 保留所有#pragma编译器指令1gcc -E -o hello.i hello.c 编译阶段 (-S，得到.s文件) 将预处理后的file.i文件进行语法词法分析，翻译成文本文件file.s1gcc -S -o hello.s hello.i 汇编阶段 (-c，得到.o文件) 得到二进制机器码文件，生成各个段，生成符号表1234567891011121314151617181920212223242526272829303132333435363738394041gcc -c -o hello.o hello.s``` * 链接阶段 (gcc file.o) * 将链接文件链接到file.o文件中 * 静态链接：内存开销大，速度快。将所有需要的函数的二进制代码拷贝到可执行文件中去 * 动态链接：内存开销小，速度慢。不需要将所有需要的函数的二进制代码拷贝到可执行文件中去，而是记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统将这些动态库加载到内存中，然后当程序运行到指定代码时，去共享执行内存中找到已经加载动态库可执行代码，最终达到运行时链接的目的 ```shellgcc -M hello.c 打印hello.c的依赖gcc -M -MF hello.d hello.c 输出hello.c的依赖到hello.d文件内gcc -c -o hello.o hello.c -MD -MF hello.d 编译hello.c并输出依赖到hello.d文件``` **为了防止编译大型项目后再对其中某一个文件修改而重新编译整个系统，可以采用先编译大型项目，最后再链接**使用&quot;include&quot;文件代表去当前目录下查找库文件使用&lt;&gt;include文件代表去工具链目录下查找库文件静态库以.a结尾，动态库以.so结尾## Makefile * 如何判断哪个文件被更改了？ * 比较源文件与输出文件的时间，如果源文件更新的话，那就意味着源文件已经被修改了 ```makefile #makefile核心：规则#目标：依赖1 依赖二...#[TAB]命令 #下列目标文件test由a.o b.o链接生成 test:a.o b.o gcc -o test a.o b.o a.o:a.c gcc -c -o a.o a.cb.o:b.c gcc -c -o b.o b.c 通配符： *： 任意字符，但对于目标文件，优先使用%代替* $：取值 @：目标值，@后加shell命令可以不显示命令但输出结果 $@：目标文件 $&lt;：第一个依赖文件 $^：所有依赖文件$(shell 命令)可以执行shell命令假想目标文件：.PHONY 用于当目标文件与make命令重名时使用，用法：在makefile文件末尾加上.PHONY: 命令 A &#x3D; xxx 变量赋值$(A) 变量取值&#x3D; 延时变量，makefile分析完成整个文档后才会对变量赋值，没有写程序时的类似顺序执行的逻辑:&#x3D; 即时变量，类似写程序时的顺序执行的关系，需要在当前行之前声明定义变量?&#x3D; 在此行之前就已经定义变量时该语句无效，类似#ifndef+&#x3D; 附加，并不是加，是延时变量还是即时变量取决于前文 $(foreach var,list,text) 在list中的每一个var，都换为text$(filter pattern,text) 在text中取出符合pattern的值$(filter-out pattern,text) 在text中取出不符合pattern的值$(wildcard pattern) 在已存在的文件中取出符合pattern的值$(patsubst pattern,replacement,$(var)) 在var中取出符合pattern的值，并替换为replacementCFLAGS 这个变量可以后加gcc的编译选项 文件IO和标准IOLinux是参照Unix制作出来的，为了使App能够在Linux与Unix上都能运行，Linux就需要实现与Unix相同的接口，这套接口统称为POSIX接口(posix Portable Operating System Interface for uniX)，任何支持POSIX标准的操作系统都支持文件IO 文件IO，IO函数包括read&#x2F;open&#x2F;write，每次调用的时候都会直接进入内核，实现了POSIX接口的APP可以在Linux，Unix上运行 标准IO，IO函数包括fread&#x2F;fopen&#x2F;fwrite，是为了解决App读写数据时频繁进入内核而诞生的，通过App自身的buffer来减少访问内核的次数从而提高效率，标准IO是从POSIX接口封装出来的，标准IO函数包括fread&#x2F;fopen&#x2F;fwrite。同时，如果使用了标准IO开发App，经过编译后还可以Windows上运行 文件IO的内部原理是：open，read等函数在访问文件资源时，需要从用户空间转移到内核空间，此时函数的内部实现会抛出异常，也就是触发软中断，将svc或swi设置为0，对应的异常编号会放在R7寄存器(arm64架构放在R8)，而后转到内核，调用sys_call_table处理异常，这样当CPU处理异常时就知道异常的具体行为 glibc将系统调用标准IO封装出了fread&#x2F;fopen&#x2F;fwrite，不仅自带缓冲区，更可以增加代码移植性 文件0代表stdin，以后scanf等操作产生的信息将会发送到此处文件1代表stdout，以后printf等操作产生的信息将会发送到此处文件2代表stderr，以后perror等操作产生的信息将会发送到此处文件3代表文件句柄信息 :::alert-info如果用同一个open程序打开不同的文件，返回的文件操作符有可能值相等，这是为什么呢？原因在于，即使文件操作符相等，但是open程序处理的文件也处于不同的进程且有独立的进程号，因此有不同的文件句柄空间，这样，文件操作符相等也没有关系。而当不同的句柄指向同一个文件结构体时，这两个句柄也不会相互干扰，例如当一个文件中内容是123，同一个进程读两次这个文件每次读一个字符时，由于两次读文件返回的是不同的句柄，指向file结构体中的f_pos彼此独立，这样读两次的内容分别为1，1，而不是1，2。若想文件句柄相互关联，可以使用dup(fd)函数复制某个文件句柄，这样，对应句柄指向的file结构体中的f_pos也会被复制下来，于是可以读出1，2了。::: 文件IO的内部机制内核中有task结构体，其中包含了files结构体，files内还有fdt(fdtable)结构体，fdt内部有fd数组，这个数组储存了文件操作符与文件的关系，fd中每个元素都指向了一个file结构体，这样在不同task内即使fd的值相同，所指向的文件也会不同 open函数具体open函数用法和原理见 man 2 open 12/* 打开文件名为argv[1]的文件，以读写模式打开(O_RDWR)，如果没有这个文件就创建这个文件(O_CREAT)，如果文件存在，且权限是读写的话就清空文件(O_TRUNC)，设置文件访问权限为664 */fd = open(argv[1],O_RDWR | O_CREAT | O_TRUNC, 0664); //0代表8进制 write函数相关函数均可以 man 2 fun 12345/* 文件指针移到当前位置之后的第9个字符，打开文件时，默认指针位于文件开头 */lseek(fd, 9, SEEK_SET); /* 对fd文件写not字符串，3为写字符串的长度，第二个参数也可以是argv，这样的话长度使用strlen()来获取 */write(fd, &quot;not&quot;, 3);/* 上面的结果是覆盖写 */ read函数12/* 对文件读sizeof(buf)-1个内容，并存在bbuf中 */read(fd, buf, sizeof(buf)-1); 当读一个文件时，是从f_pos位置开始读的，f_pos由内核维护，每读一次文件都会更新f_pos的值 dup函数12/* 将文件句柄复制一份 */new_fd = dup(fd) 使用dup后，文件句柄被复制，对应的f_pos也被复制，下次使用new_fd打开文件时，文件指针就是f_pos的位置 1234/* 将old_fd重定向到new_fd，使用dup2后，可以将new_fd的io重定向到old_fd */dup2(old_fd, new_fd)/* 可以将stdin重定向到1.txt中，这样在shell内打印的结果就不会显示，而是输出到1.txt */dup2(1_txt_fd,1) framebufferbpp(bits per pixel) framebuffer是一个由驱动程序分配的在内存中的一段区域，其中存储了每个像素的颜色，具体由LCD的硬件控制器实现，值得注意的是写framebuffer到LCD执行会有一定的延迟，尽管肉眼看不到 framebuffer有不同的bpp(bits per pixel)，一般而言有以下几种 由于framebuffer由驱动掌管，因此读写framebuffer时需要使用mmap函数映射到用户空间 如果将32bit的像素转换为16bit的像素，则需要将RGB的高n位保留，舍弃掉低n位 fork调用fork只进行页表项的拷贝，对于物理地址的拷贝放在cow时 fork执行的时候，会有两个返回值，一个是父进程的返回值，一个是子进程的返回值 在父进程中fork的返回值是子进程的PID 在子进程中fork的返回值是0 fork失败，返回值为-1 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;unistd.h&gt; int main(int argc, char *args[])&#123; pid_t id = fork(); if (id &gt; 0) printf(&quot;father id = %d\\n&quot;, id); else printf(&quot;son id = %d\\n&quot;, id); return 0;&#125;//结果如下[negivup@negivup mycode]$ gcc -o main main.c[negivup@negivup mycode]$ ./mainfather id = 12467[negivup@negivup mycode]$ son id = 0 文本及图像显示文本显示文本显示 &#x3D; 编码 + 字体 ASCII定义了128个字符，因此在7bit位上始终为0ASNI由Windows提出，包含了ASCII，根据7bit位是否为0来判断该字是否为ASCII，若不为ASCII，则需要使用两个字节表示一个字，并且之后还需要选定字符集Unicode不需要判断字符集，主要分为UTF-16 和 UTF-8两种，UTF-16根据大小端模式分为2种，每种效率相比UTF-8较低，因此主流使用UTF-8编码 对于UTF-8，内部保存了长度信息，因此即使某部分字节信息丢失也不会影响整体信息 若要显示矢量位图文字，需要使用freetype库，注意编译freetype时还需要freetype的依赖 Linux应用输入系统编程的四种方式 对于Linux来说，输入设备多种多样，Linux把所有的输入设备的输入数据处理成3种： type：哪类事件？比如EV_ABS类 code：哪个操作？比如ABS_X value： 值 内核中使用input_event结构体来上报三种数据，除此之外，结构体还有时间信息 当type，code，value都为0时，代表已经获得了完整的数据，也称为同步事件，同步事件用来分隔普通事件 输入系统支持的API操作：阻塞，非阻塞，poll&#x2F;SELECT，异步通知 阻塞非阻塞方式访问硬件默认文件API是阻塞执行的，除非在API中或上 O_NONBLOCK，当阻塞执行时，任务收不到数据将会不断的查询，直至硬件产生数据，当非阻塞方式访问硬件资源时，任务如果得不到硬件数据就会休眠，直至内核将其唤醒 1234if (argc == 3 &amp;&amp; !strcmp(argv[2], &quot;noblock&quot;))&#123; fd = open(argv[1], O_RDWR | O_NONBLOCK);&#125; poll&#x2F;SELECT方式访问硬件APP主动访问硬件数据的通信方式，与阻塞非阻塞方式的区别是poll函数支持超时时间，poll函数还可以监测多个文件poll与select区别在于，select单个进程的连接数有限制，由FD_SETSIZE宏定义，而poll由链表实现，对于连接数没有限制 123456789101112131415161718192021222324252627282930313233struct input_event event; //存放ioctl获得的数据struct pollfd fds[1];nfds_t nfds = 1;...while (1)&#123; fds[0].fd = fd; fds[0].events = pollIN; //想要在硬件中读取数据 fds[0].revents = 0; //存放poll函数的返回值 ret = poll(fds, nfds, 5000); //5000为超时时间 /* 检查poll是否正常、不超时的返回 */ if (ret &gt; 0) &#123; /* 检查返回事件是否是预期的pollIN事件 */ if (fds[0].revents == pollIN) &#123; while (read(fd, &amp;event, sizeof(event)) == sizeof(event)) &#123; printf(&quot;get event: type = 0x%x, code = 0x%x, value = 0x%x\\n&quot;, event.type, event.code, event.value); &#125; &#125; &#125; else if (ret == 0) &#123; printf(&quot;time out\\n&quot;); &#125; else &#123; printf(&quot;poll err\\n&quot;); &#125;&#125; 异步通知硬件产生数据了主动通知APP的通信方式 通知流程： 编写信号处理函数，当硬件给APP发消息时会自动执行此函数 注册信号处理函数，使用signal函数在内核中注册信号处理函数 打开驱动设备 把进程ID告诉驱动，这样驱动才能通知指定APP 使能驱动FASYNC位，此位控制驱动是否应该发送消息给应用 123456789101112131415161718192021222324void my_sig_handler(int sig)&#123; /* Todo */&#125;int main()&#123; /* 注册信号处理函数 */ signal(SIGIO, my_sig_handler); /* 打开驱动程序 */ fd = open(argv[1], O_RDWR | O_NONBLOCK); /* Todo */ /* Todo */ /* Todo */ /* 把APP的进程号告诉驱动程序 */ fcntl(fd, F_SETOWN, getpid()); /* 使能&quot;异步通知&quot; */ flags = fcntl(fd, F_GETFL); fcntl(fd, F_SETFL, flags | FASYNC);&#125; 同步异步阻塞非阻塞只有同步才分阻塞非阻塞，非阻塞指的是当进行数据交换时才阻塞，而等待数据交换时为非阻塞。阻塞指的是全过程都阻塞 异步不分阻塞非阻塞(他本身就是非阻塞的) 网络编程本课程主要讲授TCP与UDP编程，其他网络编程可自行查找资料TCP是一种可靠的，有连接的网络通信方式，UDP是一种不可靠的，无连接的网络通信方式，相比UDP，TCP会检查双方通信数据是否送达，若不送达还会进行等待操作，对延迟敏感的可能需要考虑是否使用TCP传输数据 TCP编程 服务器 客户端 int socket(int domain, int type,int protocol); socket的返回值类似句柄，它负责表明通讯所需要的协议族及协议，函数内需要填入domain（通讯协族），type（通讯协议），protocol（由于通讯协议已经指定了，因此此处可以填0） int socket(int domain, int type,int protocol); 用法及参数同服务器 int bind(int sockfd, struct sockaddr *my_addr, int addrlen); bind负责连接socket产生的句柄和服务器参数的信息，比如在my_addr结构体内传入端口，ip，协议族信息 int listen(int sockfd,int backlog); listen负责监听端口是否被访问，它需要bind之后的socket文件描述符，而backlog指的是最多允许多少个客户端连接端口 int accept(int sockfd, struct sockaddr *addr,int *addrlen); accept负责接收客户端的连接请求，addr填入bind的客户端结构体的地址，这样服务器才能知道客户端的具体信息 int connect(int sockfd, struct sockaddr * serv_addr,int addrlen); connect负责连接服务器，sockaddr填入客户端结构体的地址，这样才能让服务器知道连接的客户端的具体信息 ssize_t recv(int sockfd, void *buf, size_t len, int flags); recv负责接收客户端数据，它需要一个buf来存储数据，len可以使用strlen来获取，flag一般填0 ssize_t send(int sockfd, const void *buf, size_t len, int flags); 用法及参数类似服务器 UDP编程 服务器 客户端 int socket(int domain, int type,int protocol); 同TCP int socket(int domain, int type,int protocol); 用法及参数同服务器 int bind(int sockfd, struct sockaddr *my_addr, int addrlen); 同TCP ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); 由于TDP是非连接型网络通讯协议，因此不需要listen和accept函数，但是向服务器传输数据时必须指明客户端的ip地址，因此在接收数据时，服务器需要定义一个struct sockaddr *src_addr结构体来储存客户端的本机ip，端口等信息 ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen); 用法及参数类似服务器 多线程编程在Linux中，调度的单位是线程，资源分配的单位是进程 互斥量用于多线程中临界资源的互斥访问，不能控制线程执行的先后顺序信号量用于多线程中程序先后执行顺序的控制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* 创建线程 */int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);/* 线程主动退出 */void pthread_exit(void *retval);/* 线程被动退出 */int pthread_cancel(pthread_t thread);/* 线程资源回收(阻塞方式)，即使用上面两个函数后，调用此函数会回收系统分配给这个线程的资源，并获得线程的返回值 */int pthread_join(pthread_t thread, void **retval);/* 线程资源回收(非阻塞方式) */int pthread_tryjoin_np(pthread_t thread, void **retval);/* 初始化互斥量 */int pthread_mutex_init(phtread_mutex_t *mutex, const pthread_mutexattr_t *restrict attr);/* 互斥量加锁/解锁 */int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex);/* 互斥量加锁(非阻塞方式) */int pthread_mutex_trylock(pthread_mutex_t *mutex);/* 互斥量销毁(非阻塞方式) */int pthread_mutex_destory(pthread_mutex_t *mutex);/* 初始化信号量 */int sem_init(sem_t *sem,int pshared,unsigned int value);/* 信号量 P/V 操作(默认为阻塞操作) */int sem_wait(sem_t *sem);int sem_post(sem_t *sem);/* 信号量申请(非阻塞方式) */int sem_trywait(sem_t *sem);/* 信号量销毁 */int sem_destory(sem_t *sem);/* 创建和销毁条件变量 */int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);//cond_attr 通常为 NULLint pthread_cond_destroy(pthread_cond_t *cond);/* 等待条件变量 */int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);//需要与互斥锁共同使用pthread_mutex_lock(&amp;g_tMutex);// 如果条件不满足则,会 unlock g_tMutex// 条件满足后被唤醒,会 lock g_tMutexpthread_cond_wait(&amp;g_tConVar, &amp;g_tMutex);/* 操作临界资源 */pthread_mutex_unlock(&amp;g_tMutex);/* 通知条件变量 */int pthread_cond_signal(pthread_cond_t *cond); 条件变量与信号量条件变量与信号量的区别： 使用条件变量可以一次唤醒所有等待者，而信号量不能 信号量始终有一个值（状态），而条件变量是没有值的 信号量的意图在于进程间同步，条件变量意图在于线程间同步 串口编程UART共有4根线，RX，TX，GND，VCC，默认情况下是低位先行TTL电平为0V~5V，RS232为-12V~12V，在转换时不仅仅是买个转接口，还需要注意是否购买电平转换芯片 开发板UART发送数据流程： 开发板从内存中读入数据，并将数据载入FIFO 移位寄存器从FIFO中获得数据，将数据通过TX口发送出去 TTYtty(teletype，电传机)，以前电脑庞大又昂贵，多个科研院所通过多个硬件终端(tty)共用一台计算机。随着科技发展，现在的计算机可以通过一台硬件终端(键鼠+显示器)来模拟多个虚拟终端 tty0代表位于前台的那个终端，因此，只要将信息发给tty0，无论位于哪个tty，都会收到信息。在当前shell中访问&#x2F;dev&#x2F;tty就可以知道当前shell使用的是哪个tty 由于历史原因，现在的UART驱动程序都放在了tty中 console(控制台)，可以理解为权限更大的终端 当PC机发送lsa+退格键+回车键命令给arm板时，首先l通过UART被发送给arm板的UART，而后经过UART Driver处理后发送给**line discipline(行规范)**，可以将行规范理解为一个缓冲区，行规范发现l是一个普通字符，于是将l保存在缓冲区中并回显给PC机：首先由行规范将l发送给UART Driver，而后由UART Driver处理将l通过UART发送给PC机，再经由PC机的UART Driver处理后发送给屏幕，此时完成回显。s，a字符同理，但当发送退格键时，行规范会执行退格操作，将缓冲区的a字符清除，之后再次回显。最后当PC发送回车键时，行规范将缓冲区的所有数据发送给APP(此时是shell)，由shell处理后的结果通过串口发送给PC机 需要注意的是，默认情况行规范会自动处理数据，在UART外接其他模块时(比如GPS)，需要将行规范的数据处理模式改为RAW，默认不处理数据，并且还要设置一有数据就返回 I2C编程i2c高位先行写操作由7位地址位+1位读写方向位构成，读写方向位中0代表写，1代表读为了防止主从设备一个输出高电平一个输出低电平导致短路，而又因为主从设备均操控SDA，SCL，因此i2c的采用了弱上拉结构一旦设备接收到信息了，那么就意味着设备需要驱动三极管使上拉电阻接地，这样ACK信号永远是低电平信号 Linux中，主设备使用i2c_adapter结构体表示，里面保存了需要的传输函数，以及自己位于第几条i2c总线，从设备使用i2c_client结构体表示，里面保存了设备地址，需要与第几条总线的主设备连接，传输时使用i2c_meg结构体保存传输数据，里面有从机地址，数据的buf 在I2C通讯中，从硬件上来说每个I2C芯片都有若干个I2C Controller(I2C Bus)，与之对应的我们在软件上需要实现若干个adapter(也可以用gpio模拟i2c实现)，但是不同的i2c协议的设备需要与之对应的通讯规则(读取某个寄存器代表开始传输)，因此对于at24芯片来说，我们还要实现与之对应的驱动，这在上图中来说就是I2C Device Driver层。I2C Controller Driver层与I2C Device Driver层之间的Core层由内核实现，简便了我们对应用程序的编写 驱动调用关系： 123456i2c_client addr i2c_adapter nr i2c_algorithm master_xfer SMB协议SMB协议是i2c的子集 相比i2c，协议增加了 对电压的规定： I2C 协议：范围很广，甚至讨论了高达 12V 的情况 SMBus：1.8V~5V 最小时钟频率、最大的 Clock Stretching(某个设备需要更多时间进行内部的处理时，它可以把 SCL 拉低占住 I2C 总线) I2C 协议：时钟频率最小值无限制，Clock Stretching 时长也没有限制 SMBus：时钟频率最小值是 10KHz，Clock Stretching 的最大时间值也有限制 地址回应 I2C 协议：没有强制要求必须发出回应信号 SMBus：强制要求必须发出回应信号，这样对方才知道该设备的状态：busy，failed，或是被移除了 重复起始条件 I2C 协议：读写寄存器时，需要发送停止信号p，再发送起始信号s SMBus：规定了重复起始条件，节省了重复操作 SMBus有低功耗版本 Linux推荐使用SMBus，即使从设备缺少硬件支持，Linux也有软件模拟SMBus的功能 Linux驱动开发基础驱动开发的原则只提供功能不提供策略，这意味着驱动开发只提供基础的查询，休眠唤醒，poll，寄存器封装等机制，但是对于这些函数怎么使用则由APP决定 驱动的框架实现驱动的步骤如下： 指定主设备号major，如果为0则代表让系统自动分配 实现具体驱动的相关函数，如open&#x2F;read&#x2F;write&#x2F;close等操作，并将操作保留在file_operations结构体中 在设备初始化函数(也称为入口函数)中调用register_chrdev以及class_create函数注册设备并在sysfs下创建设备类，并调用device_create去寻找sysfs下的设备，若找到新设备那么就在&#x2F;dev&#x2F;下创建设备 在设备退出函数(也称为出口函数)中依次调用device_destroy，class_destroy，unregister_chrdev函数注销设备 准备其他信息如module_init，module_exit等函数来初始化第4步的函数，使用MODULE_LICENSE(&quot;GPL&quot;);来表明协议(内核驱动强制开源，应用驱动可以不开源) :::alert-info驱动代码中没有主函数，并且编译时需要与内核一起编译::: 最简单的LED驱动程序 1dmesg | grep filename.c //可以获得在内核中打印的信息，用于检测驱动设备是否正常运行 对于读写硬件的驱动程序，具体操作如下 指定主设备号major，如果为0则代表让系统自动分配 实现具体驱动的相关函数，如open&#x2F;read&#x2F;write&#x2F;close等操作，并将操作保留在file_operations结构体中，同时还需要将寄存器的读写操作在具体函数中实现 在设备初始化函数(也称为入口函数)中调用register_chrdev以及class_create函数注册设备并创建设备类，并调用device_create在&#x2F;dev&#x2F;下创建设备，并且还需要使用ioremap函数来映射硬件地址到虚拟地址中 在设备退出函数(也称为出口函数)中依次调用device_destroy，class_destroy，unregister_chrdev函数注销设备，并且还需要使用iounmap来解除映射 准备其他信息如module_init，module_exit等函数来初始化第4步的函数，使用MODULE_LICENSE(&quot;GPL&quot;);来表明协议(内核驱动强制开源，应用驱动可以不开源) 驱动设计的思想面向对象file_opration结构体中有函数指针，可以使用指针来进行操作 分层123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*************************在下层的驱动文件中定义，直接操作硬件*******************/static struct led_operations board_demo_led_opr = &#123; .num = 2, .init = board_demo_led_init,//这个结构体赋值了.h文件中的结构体，并将返回值付给了get_board_led_opr .exit = board_demo_led_exit, .ctl = board_demo_led_ctl,&#125;;struct led_operations *get_board_led_opr(void)&#123; return &amp;board_demo_led_opr;&#125;/***********在.h文件中定义作为接口，上下层的驱动文件都要包含这个头文件***********/struct led_operations &#123; int num; int (*init) (int which); /* 初始化LED, which-哪个LED */ void (*exit) (int which); /* 取消初始化LED, which-哪个LED */ int (*ctl) (int which, char status); /* 控制LED, which-哪个LED, status:1-亮,0-灭 */&#125;;struct led_operations *get_board_led_opr(void);/*************************在上层的驱动文件中定义，注册驱动*******************/struct led_operations *p_led_opr;p_led_opr = get_board_led_opr();//从.h文件中得到接口的地址static int led_drv_open (struct inode *node, struct file *file)&#123; int minor = iminor(node); p_led_opr-&gt;init(minor);&#125;static ssize_t led_drv_write (struct file *file, const char __user *buf, size_t size, loff_t *offset)&#123; struct inode *inode = file_inode(file); int minor = iminor(inode); /* 根据次设备号和status控制LED */ err = copy_from_user(&amp;status, buf, 1); p_led_opr-&gt;ctl(minor, status);&#125;//给Linux内核的fop函数static struct file_operations led_drv = &#123; .owner = THIS_MODULE, .open = led_drv_open, .read = led_drv_read, .write = led_drv_write, .release = led_drv_close,&#125;; 驱动程序分为boarda.c，boardb.c，以及上层的drv.c，在前两者中，只进行寄存器和内存映射操作，是单片机的延续，后者是进行注册驱动等操作 分离除了上下层分层外，有的复杂驱动还需要同层分离，比如对于某种主板来说，尽管LED会有不同，但是芯片是只有一种的，因此对于不同的LED需要一个resource.h文件来管理具体LED寄存器，而board.c文件则需要负责将这些管理好的寄存器进行配置和高级的封装，并将函数在和结构体在resource.h文件声明，日后chip.c会直接调用resource.h的函数和结构体声明 总线设备驱动模型为了解决设备和驱动资源的相互关系，更好的解耦两者，Linux推出了Bus(虚拟总线)机制，设备会在内核中注册platform结构体，这个结构体会通过platform_device被挂载到设备链表上，驱动程序也有类似操作，最终会通过platform_driver被挂载到驱动链表上，两个链表由内核统一管理，根据在platform中注册的设备ID，名字等参数来耦合两者 设备树驱动模型随着越来越多的设备加入了内核，即使使用总线设备驱动模型也难以让各个设备使用统一的接口来接入Linux，使得相似的驱动程序充斥着内核源码，为了解决这个问题，Linux推出了设备树 进入内核根目录后执行make dtbs即可编译内核，在编译过程中，内核使用gcc将dtbs文件预处理，而后由内核中的脚本文件将预处理完成的文件转化为dtb文件 将修改的设备树挂载到设备上的操作： 123456789101112/* 进入Linux内核主目录 */make dtbs/* 将生成的dtb文件拷贝到目标机器的/boot目录下 *//* 重启目标设备 */reboot/* 查看设备树是否更新,base为设备树的根节点 */cd /sys/firmware/base 在设备树模型中，每个节点都会被内核构造成device_node，只有位于根节点下的子节点或者标明了compatile = &quot;xxxbus&quot;属性的父节点下的子节点才会有被转换成platform_device，在根节点下的I2C、SPI节点也会被转换成platform_device，但是I2C、SPI下的子节点不转换为platform_device，这是因为总线下的子节点应该交由对应的总线控制器(如I2C Controller)处理 在platform_driver中有of_match_table结构体，这个结构体中有compatible，执行probe操作时就是比较compatible :::alert-info采用了设备树后我们应该怎么调用设备树里的资源呢？使用of_开头的函数就可以调用内核解析出来的设备树的资源了，例如of_gpio_count，这是因为根节点被保存在全局变量 of_root 中,从 of_root 开始可以访问到任意节点::: Linux驱动输入系统编程的四种方式查询方式 查询与休眠唤醒对应了应用开发的阻塞非阻塞机制，查询方式是应用层使用open,read函数时调用驱动层的drv_open,drv_read来获得硬件接口状态 休眠唤醒机制 休眠唤醒机制需要在驱动层注册中断服务程序，当外部信号触发了驱动层时，会直接将获得的数据发送给应用层 在驱动层中使用wait_event(wq, condition)来完成休眠唤醒操作，但是首先需要初始化等待队列wq，这需要使用DECLARE_WAIT_QUEUE_HEAD宏来初始化 poll(轮询)机制 在休眠唤醒机制的中断基础上又发展了poll机制，首先驱动层需要在fop中实现poll函数，当应用调用poll函数时会使用驱动层的drv_poll函数，如果在给定的超时时间内触发中断，则会将数据返回，没有数据则会休眠，如果超时时间内都没有触发中断，则在超时时间后程序也会被内核自动唤醒。需要注意的是，poll的超时时间并不是一次性的，而是每隔若干时间去查看是否有数据给APP 异步通知 对于异步通知来说，驱动层需要实现drv_fasync函数，这个函数中仅仅记录进程号，在应用层需要提供注册信号处理函数signal，当触发外部中断时，由内核统一接管，首先将触发终端的数据保存，然后从驱动程序获得给注册信号处理函数的程序的进程号，并发送kill_fasync信号(kill在Linux中就是发送信号的意思)给注册信号处理函数的程序，从而通知应用程序 异步通知时启动信号函数以及恢复现场的过程： 首先根据驱动程序所保存的PID找到进程在内核的task_struct结构体，修改里面的某些成员表示收到了信号 APP从内核态返回到用户态前，内核发现APP有信号在等待处理时，会修改APP的栈，增加一个新的“运行环境”，新环境里“运行地址”是信号处理函数的地址。这样，APP从内核态返回用户态时，运行的是信号处理函数。信号处理函数执行完后，会再次返回到内核态，在内核态里再使用旧的“运行环境”恢复APP的运行 :::alert-infokill在Linux中就是发送信号的意思，使用的kill -9是将九号信号发给程序，也就是杀掉程序::: 阻塞与非阻塞APP调用open函数时，传入O_NONBLOCK，就表示要使用非阻塞方式，默认是阻塞方式:::alert-warning注意：对于普通文件、块设备文件，O_NONBLOCK 不起作用注意：对于字符设备文件，O_NONBLOCK起作用的前提是驱动程序针对O_NONBLOCK做了处理::: Pinctrl子系统由于接入设备过多，即使有数百的引脚的CPU也不能承受，此时就需要通用中断控制器(GIC)，由于此时的映射关系导致了若想知道是哪个外部设备引起的中断就必须经历CPU-&gt;GIC-&gt;GPIO-&gt;具体中断设备，这就要求了在设备树中应有多个cell来描述外部设备 为了管理数量众多的引脚(一个芯片可引出数百个引脚)，不再频繁使用IOMUX和GPIO，Linux提供了Pinctrl子系统功能，使得可以在设备树中指定资源 有的厂家，像NXP，会推出GUI的设备树代码生成软件 :::alert-info给这些引脚引入Pinctrl功能的一定是对芯片特别熟悉的人，这些人就是BSP工程师，我们驱动工程师会使用即可，但是对于优秀的驱动工程师也需要能够实现Pinctrl功能::: 可以从设备树开始学习Pinctrl，在图片中，左侧称为controller，右侧称为client，两侧都处于同一个设备树文件中，controller可以根据client的需求将引脚划分为group，并根据功能划分function，尽管在芯片厂家中并不一定看到这两个关键字，但是思想是一样的。对于client来说，可以配置若干功能，在左侧的controller可以一一对应 异常，中断与轮询中断与轮询的区别：中断是CPU处于被动状态下来接受设备的信号，而轮询是CPU主动去查询该设备是否有请求 对于一个频繁请求CPU的设备，或者有大量数据请求的网络设备，那么轮询的效率比中断高 如果是一般设备，并且该设备请求CPU的频率比较低，则用中断效率要高一些 对于外界的可以屏蔽的信号来源，比如按键，定时器，网络报文等称为中断，对于无法屏蔽的信号来源，比如指令错误，内存访问错误等称为异常，中断属于异常中的一种 由于Linux任务调度的最小单位是线程，而资源分配的最小单位是进程，因此每个线程都有一个栈，每个进程都有公共资源，比如文件句柄，全局变量 中断流程 中断源发出信号，CPU被硬件设置为强制跳转到异常向量表中的某个异常向量的地址 在异常向量表中找到要执行的中断服务函数，跳转到那个函数 保存现场 执行中断服务程序 恢复现场 Linux为了防止中断多层嵌套后导致爆栈，因此不支持中断嵌套，但是Linux不支持中断嵌套会导致一个中断服务程序执行时间过长而导致其他线程不能响应的问题，所以中断程序应该执行的越快越好，但是对于网卡这类需要在中断中读取大量数据的设备则无能为力，解决办法是中断分为上半部和下半部，在上半部分处理紧急的事务，在下半部分处理不那么紧急的事务，这个下半部分由软件中断实现，当执行完硬件中断后，系统会顺便执行软件中断，在软件中断中有标志位，用来识别这个硬件中断是否需要软件中断。 当中断下半部耗时不是很长且中断服务程序较简单时，使用tasklet，但是tasklet并不支持与APP竞争 当下半部分耗时比较长时，由于中断下半部分属于软中断，优先级比APP高，会霸占CPU使得APP卡顿，这时就需要work来将中断下半部放入workqueue，使其成为内核线程以便与APP共同竞争 但是对于多核处理器来说，使用workqueue会造成一个workqueue中work数量过多，这不利于线程并行，因此又引入了threaded irq操作来将中断线程并行化 由于初始化tasklet后需要把tasklet放入内核链表，而运行taklet函数后会把tasklet从链表中删除，因此想要再次执行tasklet函数就需要再次调度 Linux中的内核线程是一个while(1)循环，里面是一个workqueue，驱动程序使用work相关函数将想要执行的函数放入workqueue时会唤醒内核线程，并执行放入的那个函数。但是这种做法有个缺点：当内核线程里有某个线程执行时间过长时会导致下一个线程执行不及时，解决办法是在内核中单开一个内核线程运行这个线程 定时器硬件定时器systick每次中断时就会触发内核中的jiffies加一，我们只要检测jiffies是否超过定时器结构体中的expires参数就能判断是否timer超时timer定时器属于软件中断 123456789101112/* 初始化timer结构体 */setup_timer(timer, fn, data)/* 将初始化的timer结构体加入timer链表中 */void add_timer(struct timer_list *timer)/* 修改定时器的时间 */int mod_timer(struct timer_list *timer, unsigned long expires)/* 删除定时器 */int del_timer(struct timer_list *timer) mmap一般情况下，APP数据交换发生在用户态和内核态之间，但是当交换数据量很大时效率会很低，改进的方法是让APP直接读取驱动程序的buffer，这时可以使用mmap，一般读写大文件如framebuffer时需要用到此函数，当为了保证大文件的堆管理效率，malloc空间大于128k时会在系统层面自动调用mmap 地址映射地址映射是MMU维护的，MMU的两大作用： 地址映射：在访问一个被执行两次的程序中的全局变量时，全局变量的地址是一样的，但是真实的物理地址一定不同，这是由MMU维护的 权限保护：CPU访问的硬件地址需要MMU审核后才可访问 执行两次test后发现a的地址相同但值不同，这是因为CPU看到的是MMU给的虚拟地址，每一个进程都有其页表，这个局部描述表由内核维护且处于内核空间，每个进程自己的页表都有对应的虚拟地址与物理地址映射关系，因此虚拟地址可以重复。详解 进程的空间由内核维护，具体的虚拟地址与物理地址映射关系放在了页目录表里，页目录表分为一级页目录表和二级页目录表，一级页目录表大小最小为1M，二级页目录表最小为1k，Linux下默认为4k，以下是通过查找页目录表来寻找物理地址的过程： CPU 发出虚拟地址 vaddr,假设为 0x12345678 MMU 根据 vaddr[31:20](0x123)找到一级页表项里的第123项，根据读取的[1:0]发现这是个一级页表项，从而获得section base address，假如为0xabc00000 将vasddr的剩下的[20:0]与section base address拼接找到偏移地址0xabc45678，此时为真实的物理地址 对于二级页表，由于二级页表是放在一级页表中的，因此首先查询一级页表： CPU 发出虚拟地址 vaddr,假设为 0x12345678 MMU 根据 vaddr[31:20](0x123)找到一级页表项里的第123项，根据读取的[1:0]发现这是个二级页表项，从而获得level 2 descriptor base address 使用level 2 descriptor base addres找到二级页表的地址 根据vasddr的[19:12]找到二级页表的第45项，从而得到page base addr，假设为0xabc00000 将vasddr的剩下的[11:0]与page base addr拼接找到偏移地址0xabc00678，此时为真实的物理地址 为了保证数据能够尽快写入其他硬件，CPU应该绕过cache直接访问内存，有如下情况时应该使用这种方法： 读写寄存器时 读写framebuffer时 读写DMA控制的区域时 新数据由CPU写入cache的同时也从cache写入内存的方式叫做write through(写通)新数据由CPU写入cache，但需要等数据满一章后再从cache写入内存的方式叫做write back(写回)，写回操作经过写缓冲器，其本质是个FIFO cache与写buffercache负责加速CPU读数据的效率，写buffer本质上是个FIFO，能提高cache写内存的效率","categories":[],"tags":[]},{"title":"项目","slug":"项目","date":"2024-01-23T03:52:32.000Z","updated":"2024-02-21T01:32:12.271Z","comments":true,"path":"2024/01/23/项目/","link":"","permalink":"https://wumingzi.top/2024/01/23/%E9%A1%B9%E7%9B%AE/","excerpt":"项目FreeRTOS内核实现参考书籍：《FreeRTOS 内核实现与应用开发实战指南》 一个工程如果没有 main 函数是编译不成功的,会出错。因为系统在开始执行的时候先执行启动文件里面的复位程序,复位程序里面会调用 C 库函数__main,__main 的作用是初始化好系统变量,如全局变量,只读的,可读可写的等等。__main 最后会调用__rtentry,再由__rtentry 调用 main 函数,从而由汇编跳入到 C 的世界,这里面的 main 函数就需要我们手动编写,如果没有编写 main 函数,就会出现 main 函数没有定义的错误。","text":"项目FreeRTOS内核实现参考书籍：《FreeRTOS 内核实现与应用开发实战指南》 一个工程如果没有 main 函数是编译不成功的,会出错。因为系统在开始执行的时候先执行启动文件里面的复位程序,复位程序里面会调用 C 库函数__main,__main 的作用是初始化好系统变量,如全局变量,只读的,可读可写的等等。__main 最后会调用__rtentry,再由__rtentry 调用 main 函数,从而由汇编跳入到 C 的世界,这里面的 main 函数就需要我们手动编写,如果没有编写 main 函数,就会出现 main 函数没有定义的错误。 生成的startup_ARMCM3.s负责启动startup_ARMCM3.c负责时钟配置，本项目默认的时钟为25M 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*---------------------------------------------------------------------------- Define clocks *----------------------------------------------------------------------------*/#define XTAL ( 5000000UL) /* Oscillator frequency */#define SYSTEM_CLOCK (5U * XTAL)``` ![2024-01-02_10-16](vx_images/419821610240143.png) 对于这种多行宏定义，每行结尾要加 \\ 表示该行未结束 ::: alert-danger若使用 \\ 表示该行未完结务必注意 \\ 后不能加任何字符，尤其是空格或者Tab。报错如下![2024-01-02_12-05](vx_images/481670512259271.png)::: ![2024-01-02_10-44](vx_images/400010311258569.png) ![2024-01-02_11-04](vx_images/7600511266602.png) 左值不能进行类型转换，类型转换本质上是在寄存器内对原值进行位操作，得到的结果不放入内存，而左值是需要放进内存的，因此类型转换与左值冲突，若要类型转换，则需要对右值进行操作:::alert-danger当一个a.c文件需要b.h，而b.h包含了c.h，且c.h也包含了b.h时，会发生编译冲突。表现为有未定义的类型或变量，详情参考[博客园](https://www.cnblogs.com/skullboyer/p/8891579.html)，解决办法是理清编译关系，去除重复包含的头文件![2024-01-03_13-26](vx_images/211612613258570.png)::: 栈由高地址向低地址增长，栈顶是第一个进栈的元素，栈底是最后一个进栈的元素因为32位机一般指令都是32位的，栈顶指针只需4字节对齐即可，但是考虑兼容浮点运算的64位操作则需要8字节。对齐完成后，栈顶指针即可确定位置，而后开辟空间 ![2024-01-03_16-01](vx_images/151190216246437.png)项目的.c 与 .h文件可以不重名，位置可以不同，例如port.c文件放在\\freertos\\Source\\portable\\RVDS\\ARM_CM3，但是引用port.c内容的portable.h放在\\freertos\\Source\\include ```c/* 这行代码的意思是定义了TaskFunction_t类型的函数指针，参数和返回值都是void，这样就可以进行函数“赋值”，进而从Task1，Task2中抽象出TaskFunction_t这一类型了，并且使用起来很方便 */typedef void (*TaskFunction_t)( void * );/* 类似用法如下 */void tech(void) &#123; printf(&quot;tech dreamer&quot;); &#125;//命名一个类型，那么这个时候func不可以直接调用，而是一个类型了typedef void (*func)();void main()&#123; //定义一个可调用的指针变量（函数）：myfunc func myfunc; myfunc = &amp;tech; //&amp;可以不加 /* 下面两种方法体现了函数名和函数地址是一回事 */ myfunc(); //第一种调用方式，带参数也可以 (*myfunc)(); //第二种调用方式，带参数也可以&#125; 实现就绪链表123typedef void (*TaskFunction_t)( void * );//将TaskFunction_t函数指针重定义为void*类型//FreeRTOS中TaskFunction_t内部包含了一个栈顶指针，因此返回值为uint32型 :::alert&#x3D;info在FreeRTOS里TaskHandle_t是个TCB_t的指针在toyFreeRTOS里TaskHandle_t是个void*类型的指针，使用时需要类型强转::: 设置任务栈时栈顶指针的移动 首先由外部函数prvInitialiseNewTask构造出的pxTopOfStack指针传入pxPortInitialiseStack函数，此时pxTopOfStack指针指向A位置，而后移动指针至B，C点从而将xPSR，PC，LR的值依次写入栈顶，方便之后寄存器读取。配置好自动加载到寄存器的内容后再将指针下移至D并返回，从而使任务得到空闲堆栈的指针 实现调度器向量表最前面是MSP的地址 配置寄存器： 12345678/* 对0xe000ed20地址处取值，此处为SHPR3寄存器，设置的是pendsv和systick优先级 */#define portNVIC_SYSPRI2_REG *(( volatile uint32_t *) 0xe000ed20) /* 配置 PendSV 和 SysTick 的中断优先级为最低 */ portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI; //SHPR3寄存器被设置为 0x**FF **** portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI; //SHPR3寄存器被设置为 0xFFFF **** 开启第一个任务： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* 通过查找SCB_VTOR最终将__initial_sp处的指令传到msp内，然后调用svc启动第一个任务 */__asm void prvStartFirstTask( void )&#123; /* 当前栈按照8字节对齐 */ PRESERVE8 /* 将SCB_VTOR寄存器地址加载到R0，SCB_VTOR寄存器存储__initial_sp的地址， __initial_sp也是msp的地址，还是向量表的起始地址，因为CM3支持更改向量表的起始地址， 所以需要以下四条指令以重定位__initial_sp */ ldr r0, =0xE000ED08 /* 将__initial_sp的地址加载进r0,STM32的__initial_sp为0x0800 0000 */ ldr r0, [r0] /* 将__initial_sp中的值，也就是msp初始化的值加载到r0，可能是0x20005B30 */ ldr r0, [r0] /* 将上一步初始化__initial_sp在r0中的值加载到msp */ msr msp, r0 /* 开中断 */ cpsie i cpsie f /* 等待上面所有指令执行完成 */ dsb isb /* 调用SVC去启动第一个任务 */ svc 0 nop nop&#125;__asm void vPortSVCHandler( void )&#123; extern pxCurrentTCB; PRESERVE8 ldr r3, =pxCurrentTCB //TCB_t volatile *pxCurrentTCB = NULL; ldr r1, [r3] //volatile StackType_t *pxTopOfStack; ldr r0, [r1] //r0 = *pxTopOfStack ldmia r0!, &#123;r4-r11&#125; msr psp, r0 isb mov r0, #0 msr basepri, r0 //开中断 orr r14, #0xd //设置LR的值 bx r14 //此处不会返回r14(LR),而是返回到任务堆栈，具体看CM3手册&#125; __asm void xPortPendSVHandler( void )&#123; extern pxCurrentTCB; extern vTaskSwitchContext; PRESERVE8 mrs r0, psp isb ldr r3, =pxCurrentTCB ldr r2, [r3] stmdb r0!, &#123;r4-r11&#125; str r0, [r2] stmdb sp!, &#123;r3, r14&#125; mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY msr basepri, r0 dsb isb bl vTaskSwitchContext mov r0, #0 msr basepri, r0 ldmia sp!, &#123;r3, r14&#125; ldr r1, [r3] ldr r0, [r1] ldmia r0!, &#123;r4-r11&#125; msr psp, r0 isb bx r14 //此处不会返回r14(LR),而是返回到任务堆栈 nop&#125; 为什么需要PendSV？ 为了保证外部中断能够马上执行，防止出现类似“优先级翻转”的情况 调用svc(请求管理调用)的原因 用户与内核进行操作，但如需使用内核中资源时，需要通过SVC异常来触发内核异常，从而来获得特权模式，这才能执行内核代码 为什么需要SVC启动第一个任务？ 使用了os后，任务调度交给内核，因此不能同裸机一样使用任务函数来启动，必须通过内核的服务才能启动任务 :::alert-dangerfor循环无循环体时末尾加分号::: 实现调度器总结 初始化任务步骤 调用创建静态任务函数 设置TCB指针和栈指针 调用创建新任务函数，传入Handle，函数名称，参数，栈的深度等参数 返回Handle 创建新任务函数操作： 获取栈顶地址并对齐 将任务名称复制到TCB中 设置container与owner(container指的是处于哪个链表，owner是自身的TCB) 调用初始化任务栈函数，并返回一个栈顶指针 将任务的自身地址传给Handle，这样可以通过Handle控制任务 初始化任务栈函数操作： 对栈指针之前的16位进行设置以便加载到CPU寄存器中 返回空闲堆栈的栈指针 开启第一个任务步骤(汇编)： 设置堆栈按8字节对齐 从SCB_VTOR取出向量表地址，进而获得msp的内容（msp中的第一条指令是哪来的？） 开中断 调用svc指令去获取硬件权限，从而执行svc中断服务程序，并启动第一个任务(svc替代了以前的swi也就是软中断指令) svc中断服务程序的操作： 将第一个任务的参数加载到寄存器，包括第一个函数的地址，形参，返回值 开中断，使用psp寄存器，返回到任务堆栈，这样第一个任务就执行完了，CPU等待执行下一个任务 上下文切换的操作： 总体与svc中断服务程序的操作类似，但是加上了将优先级载入到basepri的操作 设置好优先级后直接运行至跳转上下文 c 函数 最后开中断，使用psp寄存器，返回到任务堆栈，CPU等待执行下一个任务，调度器功能就实现了 具体任务切换过程参考资料 临界段保护临界段就是在执行时不能被中断的代码段，典型的就是全局变量，系统时基 中断管理FreeRTOS中的中断管理通过汇编完成，对于关中断而言，其内部实现了两个中断函数，分别是能保存当前中断有返回值的函数，可以在中断中使用。另一个是不能保存当前中断无返回值的函数，不能在中断使用。 本质是操作basepri寄存器，大于等于basepri寄存器的值的中断会被屏蔽，小于则不会。但当basepri为0时，则不会屏蔽任何中断 关中断123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* 不带返回值的关中断函数,不能嵌套,不能在中断里面使用 */#define portDISABLE_INTERRUPTS() vPortRaiseBASEPRI()void vPortRaiseBASEPRI( void )&#123; //中断号大于191的中断全部被屏蔽 uint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY; __asm &#123;//将FreeRTOS最大优先级的中断加载到basepri寄存器中，这样会屏蔽FreeRTOS管理的所有中断 msr basepri, ulNewBASEPRI dsb isb &#125;&#125;/* 带返回值的关中断函数,可以嵌套,可以在中断里面使用 */#define portSET_INTERRUPT_MASK_FROM_ISR() ulPortRaiseBASEPRI()ulPortRaiseBASEPRI( void )&#123; uint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY; __asm &#123; mrs ulReturn, basepri //先对当前中断进行保存并返回 msr basepri, ulNewBASEPRI dsb isb &#125; return ulReturn;&#125;#endif /* PORTMACRO_H */``` #### 开中断 ```c/* 不带中断保护的开中断函数，与portDISABLE_INTERRUPTS()成对使用 */#define portENABLE_INTERRUPTS() vPortSetBASEPRI( 0 )/* 带中断保护的开中断函数，与portSET_INTERRUPT_MASK_FROM_ISR()成对使用 */#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x) vPortSetBASEPRI(x) void vPortSetBASEPRI( uint32_t ulBASEPRI ) &#123; __asm &#123; msr basepri, ulBASEPRI &#125;&#125; inline关键字与内联函数inline关键字用于C++，__inline，__forceinline既可用于C，也可以用于C++ 在程序中，如果在关键代码频繁调用某个函数，则会频繁的压栈出栈。为了提高效率，C语言提供了inline关键字来优化代码，例如在开关中断时需要inline关键字 inline的原理是，将某个函数内容原封不动的放入引用处，这样就不会频繁的入栈出栈了。inline减少了函数调用的开销，但使代码膨胀。 123456789101112131415161718#include &lt;stdio.h&gt; //函数定义为inline即:内联函数 inline char* dbtest(int a) &#123; return (i % 2 &gt; 0) ? &quot;奇&quot; : &quot;偶&quot;; &#125; int main() &#123; int i = 0; for (i=1; i &lt; 100; i++) &#123; printf(&quot;i:%d 奇偶性:%s /n&quot;, i, dbtest(i)); &#125; &#125; 更详细用法参考CSND inline，__inline，__forceinline等用法参考51CTO volatile作为左值时，即使类型相同右值也需要类型强转么？不需要，Keil编译器问题，但是可能会报warning甚至error，最好类型强转一下 空闲任务与阻塞延时的实现 为了能够自动进行任务调度，需要： 设置CPU重装器，设置主频并调用系统中断向量表提供的SysTic中断服务函数 提供一个函数，内部能够完成时基自增和任务延时自减**(后期会取消自减的设置，转而使用“闹钟”的思想)**，并将这个函数放入上一步的SysTick服务函数中，这样能够定时触发从而进行时基自增，在放入SysTick中时，还需要注意此函数前后需要开关中断以保证时基的实时性 将任务调度器函数vTaskSwitchContext重写，调度方式需要判定TCB中的任务延时，值为零，则触发SysTic中断服务函数，而后将任务放入就绪链表 为了加入IdleTask支持，需要： 在启动调度器函数 vTaskStartScheduler中加入空闲任务的启动，这需要设置IdleTask的TCB，栈，函数名称等参数，但不设置延时，因为CPU空闲时长不确定，设置完成后将其挂载到就绪列表 :::alert-danger注意不要在IdleTask中加入任何阻塞或者死循环，否则由于IdleTask没有设置延时，会将同一优先级的所有任务阻塞！！！::: 支持多优先级CM内核有个计算前导零的指令，以此可以优化寻找最高优先级任务的方法 主要原理是：找到一个32位变量的最高非零位，此位就是最高的有任务的链表的优先级支持多优先级实现过程如下 将uxPriority添加到TCB及其相关的函数内使其支持优先级 之后在prvInitialiseNewTask函数内添加初始化优先级，并做判断使任务初始化优先级大于等于configMAX_PRIORITIES的退化成configMAX_PRIORITIES-1 在prvInitialiseTaskLists中初始化5个就绪链表 在prvAddTaskToReadyList宏函数中完成将任务移就绪入链表的操作 记录当前优先级并将当前任务插入到获得的那个优先级链表的尾部 在prvAddNewTaskToReadyList函数中完成具体操作 如果pxCurrentTCB为空，意味着可能是第一次创建任务，则将传进来的pxNewTCB赋值给pxCurrentTCB，并且调用prvInitialiseTaskLists函数以创建任务链表 如果pxCurrentTCB不为空，则根据优先级将pxCurrentTCB设置为优先级最高的那个任务，可能是pxNewTCB也可能是pxCurrentTCB，这需要做好判定再赋值 最后调用prvAddTaskToReadyList 任务延时列表的实现 首先初始化两条链表&amp;xDelayedTaskList1与&amp;xDelayedTaskList2，并将其赋址给pxDelayedTaskList和pxOverflowDelayedTaskList 在vTaskStartScheduler中初始化全局变量xNextTaskUnblockTime为最大值，这个变量表示下一次任务被唤醒的时刻，也就是所提到的“闹钟” 在vTaskDelay函数中插入prvAddCurrentTaskToDelayedList函数，prvAddCurrentTaskToDelayedList函数实现如下 将当前任务从就绪链表中移除，并检查移除任务后，就绪链表是否为空，若为空则将优先级位图上对应的位清除 记录xTimeToWake的值，它等于当前时钟加上vTaskDelay的参数，也就是闹钟值，与xNextTaskUnblockTime相等，但是为局部变量，并将此值设置为链表节点的排序值 比较xTimeToWake与xConstTickCount大小以判断是否闹钟溢出，溢出了就将当前任务移至pxOverflowDelayedTaskList链表，否则移至pxDelayedTaskList链表 然后更新xNextTaskUnblockTime使其等于xTimeToWake 在xTaskIncrementTick函数中判断延时任务是否到期，若到期且延时链表为空，则将xNextTaskUnblockTime设为最大值。若到期但延时链表不为空，则将延时链表中的每个节点的值xItemValue取出并与当前时刻做对比，若xItemValue大于当前时刻，则将xNextTaskUnblockTime更新为xItemValue，然后将任务从延时链表移入就绪链表 判断链表为空的方式： 调用uxListRemove时会返回pxList-&gt;uxNumberOfItems，或者调用宏函数 FreeRTOS内部有两个延时链表，当系统时基计数器xTickCount没有溢出时，用一条链表(pxDelayedTaskList)，当xTickCount 溢出后，用另外一条链表(pxOverflowDelayedTaskList)。 1234567891011static void prvTaskExitError( void )&#123;/* 没有可供执行的任务时会停在这里，如果发生了这种情况，看一下空闲任务是否被执行 *//* 函数停止在这里 */for (;;);&#125; 支持时间片 抢占式调度(configUSE_PREEMPTION)：高优先级任务可以打断低优先级任务 时间片流转(configUSE_TIME_SLICING)：同优先级任务之间每隔一定时间片进行任务切换 空闲任务让步(configIDLE_SHOULD_YIELD)：空闲任务与用户任务处于同一优先级时，空闲任务等待用户任务使用完CPU后才能获取资源 默认情况，FreeRTOS上面三个选项均开启 支持时间片的操作非常简单 分别在FreeRTOSConfig.h与FreeRTOS.h文件中引入configUSE_PREEMPTION和configUSE_TIME_SLICING两个宏，默认为1 修改xPortSysTickHandler函数，使得当xTaskIncrementTick返回值为pdTrue时才进行任务切换 修改xTaskIncrementTick函数，使得在延时链表中有任务被唤醒时，判断被唤醒的延时任务优先级与当前任务优先级，若被唤醒的延时任务优先级高则返回pdTrue，意味着进行任务切换 如果当就绪链表中任务数大于1，那么每进入xTaskIncrementTick函数就意味着过去了一个时间片，因此需要进行任务切换。注意在修改该函数时还需要判断上面两个宏是否为1 自己实现信号量 初始化Semaphore链表并设置Semaphore结构体的值 完成Take函数 检测当前Semaphore个数是否大于0，若大于0则关中断，Semaphore数量–，不大于零则说明没有Semaphore可供Take，所以需要进行任务切换 完成Give函数 Give函数简单很多，只需要归还Semaphore然后开中断，将任务管理权归还给调度器即可 队列 为了保证数据能在不同函数间传递，静态创建资源时需要在创建资源的函数内传入在main函数中预设的结构体或数组的地址，对于Queue来说，官方使用 xQueueCreateStatic( UBaseType_t uxQueueLength, UBaseType_t uxItemSize, uint8_t *pucQueueStorageBuffer, StaticQueue_t *pxQueueBuffer );函数来传参 在创建函数内还需要初始化Queue链表和结构体及其参数，最后返回一个void*类型的handle 创建环形缓存区来保存数据，做好数据发送和接收的准备工作 Buffer实际上是有一个head标志变量和一个tail标志变量的数组，发送数据时head++，接收数据时tail++，当head或tail等于数组结尾时需要把他们设置为数组开头 Buffer还要有检测是否为空的功能 队列发送函数QueueSend中，在发送数据前需要关中断，发送数据后开中断 队列接收函数QueueReceive中，也需要同QueueSend开关中断 静态创建和动态创建的区别静态创建因为需要防止函数退出时销毁数据和栈，因此需要传入指针，所需的内存大小以及需要保存相关结构的地址等条件 12345678910111213141516171819202122// 示例代码#define QUEUE_LENGTH 10#define ITEM_SIZE sizeof( uint32_t )// xQueueBuffer用来保存队列结构体，内部存储了队列的相关参数StaticQueue_t xQueueBuffer;// ucQueueStorage 用来保存队列的数据// 大小为:队列长度 * 数据大小uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];void vATask( void *pvParameters )&#123; QueueHandle_t xQueue1; // 创建队列: 可以容纳QUEUE_LENGTH个数据,每个数据大小是ITEM_SIZE xQueue1 = xQueueCreateStatic( QUEUE_LENGTH, ITEM_SIZE, ucQueueStorage, &amp;xQueueBuffer );&#125; 动态存储使用malloc函数因此不需要传入指针，但是程序速度运行比静态分配慢还需要对内存进行管理 123456789101112131415161718BaseType_t QueueReceive(QueueHandle_t QueueHandle, void* const ReceiveData )&#123; Queue_t* QueueTemp; QueueTemp = (Queue_t*)QueueHandle; BaseType_t rtval = pdFALSE; portDISABLE_INTERRUPTS(); rtval = BufferReceive( ReceiveData, /* 只能使用QueueTemp这种中间变量做强制类型转换，如果写成 ((Queue_t*)QueueHandle)-&gt;uxQueueLength则会找不到成员 而报错 */ QueueTemp-&gt;uxQueueLength, QueueTemp-&gt;uxItemSize, QueueTemp-&gt;pvDataStore); portENABLE_INTERRUPTS(); return rtval;&#125; 遇到的困难与学到的经验 编译关系复杂，各种头文件相互包含导致类型重定义或者定义冲突 理清编译关系，在项目之前做好文件规划，划分各文件的职责 注意头文件引用顺序 待补充 Keil编译器有问题，有时候类型符合的赋值编译器不通过，必须类型强转才可编译通过。再或者，虽然已经定义了条件编译但还是对循环引用的头文件报错，这时就需要考虑编译器的问题了，Keil失效的通常的现象和解决办法： 一般出现编译器问题的条件是：当一个错误卡住了很长时间，并且确定这段代码没有错误，而且当按照编译器的提示将这段代码彻底的进行修改后会爆出更多error，这时就可以考虑是编译器的问题了 所有可能的解决办法都失效了，可以考虑是Keil的问题 待补充 ::: alert-danger 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100void prvIdleTask( void *p_arg )&#123;/* 永远不要在空闲任务里加入阻塞或者死循环！！！！！！！！！！！！！！！ 否则当其他任务优先级为0时，空闲任务会霸占整个时间片(没有设置时间片流转和抢占式调度的话)*/// for( ;; )// &#123;// flagIdle = 1;// flag1 = 0;// flag2 = 0;// &#125;&#125;``` 因为在第十章已经实现支持多优先级了，且Task1，Task2优先级均大于0，因此此时空闲任务内可以加循环::: * 遇到调不出来的Bug不要怕，解决方法如下 * 保持一个清醒的状态 * 快速定位问题的大概位置 * 在Bug大概位置处**逐步**调试 ```cvoid tickconst(int tick)&#123; const int consttick = tick; printf(&quot;%d\\n&quot;,consttick);&#125;// void tickstatic(int tick)// &#123;// static int statictick = tick;//static不能被变量赋值// printf(&quot;%d\\n&quot;,statictick);// &#125;int main()&#123; int i = 0; for(i=0; i&lt;10; i++) &#123; tickconst(i);//const的值可以在定义的时候被修改，但不能在其他地方被修改，也就是说，const可以被变量赋值 &#125; return 0;&#125;``` 在时基函数调用时会用到![2024-01-11_19-53](vx_images/350415319240152.png) ```c#include &lt;stdio.h&gt;int a = 4;int b = 5;//宏定义地址交换会修改值，这是因为函数宏定义不会产生栈#define swapdef(addra,addrb)\\&#123;\\ int *temp;\\ temp = a;\\ a = b;\\ b = temp;\\&#125;//地址交换不会修改值void swapadd(int* a,int* b)&#123; int* temp; temp = a; a = b; b = temp;&#125;void swapnum(int* a,int* b)&#123; int temp; temp = *a; *a = *b; *b = temp;&#125;int main()&#123; printf(&quot;原值=%d %d\\n&quot;,a,b); swapdef(&amp;a,&amp;b); printf(&quot;宏地址交换=%d %d\\n&quot;,a,b); swapadd(&amp;a,&amp;b); printf(&quot;函数地址交换=%d %d\\n&quot;,a,b); swapnum(&amp;a,&amp;b); printf(&quot;指针地址解引用交换=%d %d\\n&quot;,a,b); a = 6; printf(&quot;%d %d\\n&quot;,a,b); return 0;&#125; :::alert-info堆栈太小可能会导致程序停止在HardFault::: int (*array)[20] 与 int *arrary[20]的不同前者代表一个指向具有20个整型元素数组的指针，后者代表一个具有20个指针元素的数组 宏定义函数 为什么要使用宏定义函数？ 宏定义函数可以在预编译阶段直接展开，省下了压栈出栈的资源 那他与内联函数的区别是什么？ 宏定义函数只做展开和替换，不检查参数类型。而内联函数需要检查参数类型 C99特性在keil中可以在“魔术棒”的C&#x2F;C++设置C99模式，指定后可以在非全局作用域下定义不定长数组 1234567891011#define ListNum 5//只能使用宏定义，变量赋值也不行#define ItemNum 10/* 不能在全局作用域下定义，同时也不能加static关键字 */int arr[ListNum][ItemNum];``` #### 不允许使用void数组 ```cvoid arr[20];//非法定义，因为无法知道开辟空间的大小 电子产品量产工具调试经验:::alert-info善用printf和printk，尤其利用好 __FILE__，__FUNCTION__，__LINE__这三个宏::: 不要忽略编译器的警告，否则可能出现逻辑问题，在下图中，编译器的警告是“变量未初始化”，这是因为在错误的那行得到的是地址而不是值 1234567891011121314151617181920212223242526272829/* 中间层，只进行数据的上报和汇总 */int InputGetEvent(pInputEvent pevent)&#123; InputEvent event; int ret; pthread_mutex_lock(&amp;g_tMutex); if(GetEventBuf(&amp;event))//得到的不是InputEventbuf[iread]的数据，而是InputEventbuf[iread]的地址 &#123; *pevent = event; pthread_mutex_unlock(&amp;g_tMutex); return 0; &#125; /* ... */&#125;static int GetEventBuf(pInputEvent pEvent)&#123; if(!DataEmpty()) &#123; pEvent = &amp;InputEventbuf[iread];//error //*pEvent = InputEventbuf[iread];//correct iread = (iread + 1) % BUF_LEN; return 1; &#125; else &#123; return 0; &#125;&#125; 头文件交叉包含解决办法解决办法：将引起交叉包含的那部分内容提取出来，统一放在common.h的文件中，然后再包含common.h即可 sscanf可以处理复杂字符串 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; int day, year; char weekday[20], month[20], dtm[100]; strcpy( dtm, &quot;Saturday March 25 1989&quot; ); sscanf( dtm, &quot;%s %s %d %d&quot;, weekday, month, &amp;day, &amp;year ); printf(&quot;%s %d, %d = %s\\n&quot;, month, day, year, weekday ); return(0);&#125;","categories":[],"tags":[]},{"title":"Python","slug":"Python","date":"2024-01-23T03:31:53.000Z","updated":"2024-03-06T09:28:50.049Z","comments":true,"path":"2024/01/23/Python/","link":"","permalink":"https://wumingzi.top/2024/01/23/Python/","excerpt":"PythonPython基础解释器与编译器解释器输出运行的结果编译器输出编译的文件 字面量：写在代码中的值，可以被分为整数，浮点数，字符串，元组，列表等python的单引号和双引号意义相同，但是使用单引号可以打出双引号，但不能打出单引号。使用双引号则反之，如果想使用单引号打出单引号，则需要加上反斜杠代表转义字符","text":"PythonPython基础解释器与编译器解释器输出运行的结果编译器输出编译的文件 字面量：写在代码中的值，可以被分为整数，浮点数，字符串，元组，列表等python的单引号和双引号意义相同，但是使用单引号可以打出双引号，但不能打出单引号。使用双引号则反之，如果想使用单引号打出单引号，则需要加上反斜杠代表转义字符 注释的写法123456# 这是单行注释&quot;&quot;&quot; 这是多行注释 &quot;&quot;&quot; python中变量无类型而数据有类型，可以通过type(数据)来查看数据拥有的数据类型，同时也可以使用type(变量)来查看变量拥有的数据类型 类型转换12int(x) # 将x转换为int类型float(x) # 将x转换为float类型 float转换为int会丢失精度python舍弃精度时是四舍五入 运算符123print(9//4) # 结果为2print(9%4) # 结果为1# ** 代表取幂运算 字符串可以通过转义字符来包含引号 拼接123456# 可以进行字符串之间的拼接，也可以进行字面量和变量之间的拼接name = lzxprintf(&quot;The computer belong to &quot; + lzx + &quot;since 2023.&quot;)# 但是不能将整数或其它类型与字符串拼接，例如tel = 155printf(&quot;The computer belong to &quot; + lzx + &quot;since 2023.&quot; + &quot;tel is&quot; + tel) #运行报错，提示int类型不能与str类型进行拼接，想要拼接首先要进行格式化 占位符与格式化12345678birth = 2001name = &quot;lzx&quot;message = &quot;我是：%s，出生于：%d&quot; %(name,birth)# 或者message = f&quot;我是：&#123;name&#125;，出生于：&#123;birth&#125;&quot; # 但是这种用法不能对精度进行控制，也不会考虑数据类型 输入函数1234567891011121314input(&quot;提示语&quot;) # input得到的数据永远是字符串类型``` ### 条件语句 python用4个空格来划分所属关系```pyif condition: # todoelif condition: # todoelse: # todo 循环语句12345while condition: # todo for 临时变量 in 数据集 # for循环无法定义循环条件 #todo :::alert-infofor循环里的临时变量会自动自增，但是while需要手动自增::: range12345range(num) # 获得一个从0开始不含num的数字序列，例如range(5)，获得一个0，1，2，3，4的序列range(num1,num2,step) #获得一个从num1开始，到num结束，步进为step的不含num2的数字序列#range常用来配合for循环使用for x in range(10) 函数123456789def functionname(parameter) # function body return returnvalue temp = 0def fun1() global temp # 声明全局变量 return None 函数无返回值，返回的是None对于一些不想要设置初始值而需要定义的变量来说，可以先让这个变量赋值为None 函数作为参数传递 1234567891011def fun1(fun): print(&quot;fun1&quot;) fun() print(&quot;fun1&quot;)def fun2(): print(&quot;fun2&quot;)fun1(fun2) # 注意这里fun2不带() 数据容器 数据容器的转换其他数据容器不能转换为字典 1234567891011# 将其他数据容器转换为列表list(tuple_name()) # 字符串转列表会将字符串变为字符再装载进列表，字典转列表只会将Key值放进列表# 将其他数据容器转换为元组tuple(dict_name) # 情况与字符串列表类似# 将其他数据容器转换为字符串str(list_name) # 其他数据类型任意转换为字符串# 将其他数据容器转换为集合set(str_name) # 情况与字符串列表类似 列表(list) 列表可以存储不同数据类型的元素，并按照一定下标排序，允许重复数据存在 12345678910# 列表的字面量定义[Item1,Item2,Item3] # 列表内的元素带有下标，可以通过下标索引到元素，索引方向分为从左至右和从右至左两种，下方列表中Item3的下标可以是2，也可以是-1# 列表的变量定义list_name = [Item1,Item2,Item3]#定义空列表list_name = []list_name = list() 嵌套列表获取元素list_name[0][1] 将函数定义为类中的成员，我们称这种函数叫做方法 1234567891011121314151617181920212223#查询元素list_name.index(Item1) # 查询Item1的下标，如果找不到则报错ValueError#插入元素list_name.insert(index，Item2) # 在index处插入Item2#追加元素list_name.append(Item3) # 在列表尾部追加append#追加数据容器list_name.extend(其他数据容器) #在列表尾部追加extend#删除元素element = list_name.pop(index) # 取出index的那个元素并赋值给element，最后在列表中删除#清空整个列表list_name.clear()#统计某个元素在列表中的数量list_name.count(Item4) #统计列表中有多少元素len(list_name) # 返回值为列表中元素的个数 元组(tuple)元组一旦定义好，内部的元素就不可修改。但如果元组内嵌套了list，则可以修改list的内容,可以将元组视为不可修改元素的list元组内部数据类型可以不同 123456789# 定义元组字面量(Item1，Item2，Item3)# 定义元组变量tuple_name = (Item1，Item2，Item3)# 定义空元组tuple_name = tuple() 字符串(str)字符串是一个不可修改的数据容器 12345678my_str = &quot;hellow world&quot;# 字符串的替换new_str1 = my_str.replace(&quot;hellow&quot;,&quot;hello&quot;) # 原字符串不可修改，但得到了一个新的字符串#字符串的分割new_str2 = my_str.split(&quot; &quot;) # 按空格切分字符串 序列序列是指内容连续，有序，可使用下标索引的一类数据容器 12345# 语法数据容器[start:end:step] # 在数据容器中从start下标开始到end下标结束(不包括end下标)，每隔step-1个元素取出一个数据组成新的序列，步长为负数则代表序列从后向前取newlist = list_name[::2] 集合(set)集合内元素不能重复且无序，但允许修改因为集合不支持下标索引，所以不支持while循环，但支持for循环 1234567891011121314151617181920212223242526272829303132# 定义集合字面量&#123;Item1，Item2，Item3&#125;# 定义集合变量set_name = &#123;Item1，Item2，Item3&#125;# 定义空集合set_name = set()# 添加元素set_name.add(&quot;Item4&quot;)# 移除元素set_name.remove(&quot;Item5&quot;)# 清空集合set_name.clear()# 随机取元素set_name.pop(&quot;Item6&quot;)# 取出集合1不同于集合2的元素set1 = &#123;1,2,3&#125;set2 = &#123;1,2,4&#125;set3 = set1.difference(set2)# 消除两个集合的差集set1.difference_update(set2) # 结果set1 = &#123;2,3&#125;，set2不变# 集合的合并set3 = set1.union(set2) 字典(dict)字典无序没有索引，只能通过Key值找到对应的value字典的Key不可重复字典的Key和value可以为任意数据类型(但Key不可为字典) 123456789101112131415161718192021222324252627# 字典的定义dict_name = &#123;Key:value,Key:value,Key:value&#125;# 空字典的定义dict_name = dict()# 找到Key对应的valuekeyvalue = dict[Key]# 添加或更新元素dict_name[Key] = value # 有对应的key则更新元素，否则添加新的key及其对应元素# 删除元素Item = dict_name.pop(Key)# 清空元素dict_name.clear()# 获取全部的Key AllKeys = dict_name.keys()# 找到全部Key后遍历字典for key in AllKeys # todo# 或者直接遍历for key in dict_name: # todo 函数进阶多返回值函数1234def fun_name(): return 1,2 x,y = fun_name() 函数参数种类： 位置参数 fun_name(“小明”,10,”男”) 关键字参数 fun_name(name &#x3D; “小明”,gender &#x3D; “男”,age &#x3D; 10)，顺序可以调换，但与位置参数混用时，需要放在位置参数后面 缺省参数 函数定义时在参数列表中给参数赋值即可指定缺省参数，设置缺省参数时，设置的参数要放在参数列表最后，否则会报错 不定长参数 位置参数的形式：fun_name(*args)，传参示例：10，20，30会将传进去的参数合并成一个元组 关键字传递的形式：fun_name(**kwargs)，传参示例：age = 10，gender = male会将传进去的参数合并成一个字典 kwargs(key word args) lambda函数lambda函数是一种临时函数，使用一次后就被销毁了，下次使用只能再次重写lambda函数并且lambda函数只能写一行 lambda函数语法：lambda 参数 : 函数体 12345678910111213141516def test_fun(compete): result = compete(1,2) return result def compete(x,y): return x + y test_fun(compete)#############与下列lambda函数相同#################def test_fun(compete): result = compete(1,2) return result test_fun(lambda x, y: x + y) 异常异常的捕获12345678910111213141516171819try： 可能发生异常的代码 except： 处理异常的代码 #######################例子如下########################## 捕获到读取文件异常后(即文件不存在)，就以写的方式创建文件try: f = open(&quot;linux.txt&quot;,&#x27;r&#x27;) execept: # execept可以后加异常名称，这样就会接受指定异常，例如 execept (NameError，ZeroDivisionError) as object:，默认情况则捕获所有异常并命名为 object，或者可以写为execept Exeception:，这也是捕获所有异常的写法 f = open(&quot;linux.txt&quot;,&#x27;w&#x27;) else: # 没有异常则执行的代码 # todofinally: #无论是否出现异常都执行的代码 # todo 异常的传递异常可以根据函数调用呈现传递性 模块模块就是一个python文件，可以将模块视作功能包不同的模块，相同名称的功能，后导入进来的会覆盖先导入进来的[]代表可选的意思 1234# 只使用import会将模块中所有内容全部导入，而使用from则会将模块中的某一部分导入# 例如 from time import sleep 使用方法：sleep 或者 import time 使用方法 time.sleep [from 模块名] import [模块 | 类 | 方法 | *] [as 别名] 包python包 &#x3D; __init__.py + 若干模块文件 可以在 __init__.py文件内添加 __all__ &#x3D; [“模块名”]来定义 from package import * 的导入范围 面向对象类的定义1234567891011class 类名称: 成员变量 成员方法(函数)# 定义类的方法时与普通的函数定义有细微差别，需要在形参列表最前方加入self关键字# 在成员方法内部调用或赋值成员变量需要用到self.来引出 def add(self,para1,para2): # todo # 创建类的对象object = calss_name() 构造方法构造方法需要使用__init__()方法，与C++构造函数类似，即使不给出__init__()方法，系统也会自动调用 类进行初始化的时候会首先调用__init__()方法，，这个函数可以初始化类的成员变量 12345678910class student: name = None age = None tel = None def __init__(self,name,age,tel) self.name = name self.age = age self.tel = tel 魔术方法python中，由两个下划线前后包围起来的方法称为魔术方法定义__str__方法后，以后将类转换为字符串就会输出__str__方法中的内容__lt__，__le__，__eq__是比较两个类大小的魔术方法，由于两个类不能比较，所以需要在这三种方法内部重写比较方法，一般比较的是两个类中成员的大小 封装在成员或者方法前加两个下划线即可将成员或方法变为私有 123456class student: name = None __age = 18 # 私有成员 tel = None def __print_tel(self): # 私有方法 print(f&quot;self.tel&quot;) 继承class 类名(父类名): 类的内容 想要继承多个父类时使用：class 类名(父类1,父类2,父类3): 类的内容 如果只想继承若干个父类，而不想写类的内容，可以使用pass关键字，以补全类的内容class 类名(父类1,父类2,父类3): pass 当父类1与父类2中有同名的成员变量或成员方法时，优先继承父类1的内容，遵循先来后到原则 1234567class student: name = None age = None tel = None class Newstu(student): # 继承 gender = None 当需要对父类的成员变量或者成员方法进行改动时，可以在子类中重新定义，以达到复写的效果 1234567class student: name = None age = 18 tel = None class Newstu(student): age = 80 多态多态：同一个函数，使用不同的对象，产生不同的结果 通过多子类父类以及继承方式可以实现多态，例如 定义空调父类，定义空调的制冷方法 定义格力空调，美的空调子类，并在其内部重写制冷方法 实现通用制冷函数，可以调用传进来的类的方法 在制冷函数内传入美的或者格力空调子类，这样就实现了多态现象 此时父类称为抽象类或接口，只做大体框架或者顶层实现 闭包闭包的好处是可以将外层函数的变量置于函数内部，这样可以防止其他函数或操作修改外层函数的变量，使程序更安全。但同时内部函数会持续引用外部函数的值，增大了内存的开销 12345678def outer(add): def inner(name): print(f&quot;&lt;&#123;add&#125;&gt;&#123;name&#125;&lt;&#123;add&#125;&gt;&quot;) # 如果想要修改add的值，只需要在add前加nonlocal关键字修饰即可 return innerfn1 = outer(&quot;海城&quot;) # 按正常的操作，需要定义一个海城的全局变量来传参，但是这样做全局变量有被其他函数修改的风险，使用了闭包后则不会修改这个变量fn1(&quot;李政轩&quot;) 装饰器装饰器是闭包的一种特殊用法，他将闭包中的全局变量改为函数，可以增加原函数的功能，并支持语法糖 1234567891011121314151617181920212223242526272829303132333435#############普通的装饰器##########def outer(fun): def inner(): print(&quot;海城&quot;) fun() print(&quot;李政轩&quot;) return innerdef fun1(): print(&quot;四中&quot;)fn = outer(fun1)fn()#############带语法糖的装饰器###########def outer(fun): def inner(): print(&quot;海城&quot;) fun() print(&quot;李政轩&quot;) return inner@outer # 跟随outer函数名称改变而改变def fun1(): print(&quot;四中&quot;)fun1() # 调用的是fun1，而不是outer，这样适合对原函数增加功能后继续调用 迭代器迭代是 Python 最强大的功能之一，是访问集合元素的一种方式。 迭代器是一个可以记住遍历的位置的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 123456#!/usr/bin/python3 list=[1,2,3,4]it = iter(list) # 创建迭代器对象for x in it: print (x, end=&quot; &quot;) 输出结果： 11 2 3 4 把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与 __next__()__iter__() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 __next__() 方法并通过 StopIteration 异常标识迭代的完成__next__() 方法（Python 2 里是 next()）会返回下一个迭代器对象 123456789101112131415161718class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): x = self.a self.a += 1 return x myclass = MyNumbers()myiter = iter(myclass) print(next(myiter))print(next(myiter))print(next(myiter))print(next(myiter))print(next(myiter)) 输出结果： 1234512345 生成器在 Python 中，使用了 yield 的函数被称为生成器（generator）,生成器函数是一种特殊的函数，可以在迭代过程中逐步产生值，而不是一次性返回所有结果.跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器 当在生成器函数中使用 yield 语句时，函数的执行将会暂停，并将 yield 后面的表达式作为当前迭代的值返回。然后，每次调用生成器的 next() 方法或使用 for 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 yield 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。这样可以不必一次生成大量数据，从而节省内存空间 12345678910111213141516def countdown(n): while n &gt; 0: yield n n -= 1 # 创建生成器对象generator = countdown(5) # 通过迭代生成器获取值print(next(generator)) # 输出: 5print(next(generator)) # 输出: 4print(next(generator)) # 输出: 3 # 使用 for 循环迭代生成器for value in generator: print(value) # 输出: 2 1 生成器实现fibonacci数列 12345678910111213141516171819#!/usr/bin/python3 import sys def fibonacci(n): # 生成器函数 - 斐波那契 a, b, counter = 0, 1, 0 while True: if (counter &gt; n): return yield a a, b = b, a + b counter += 1f = fibonacci(10) # f 是一个迭代器，由生成器返回生成 while True: try: print (next(f), end=&quot; &quot;) except StopIteration: sys.exit() 输出结果： 10 1 1 2 3 5 8 13 21 34 55 设计模式单例模式类的实例化只进行一次，以后均使用这个实例化的类，这样可以节省内存，多用于工具类的创建 工厂模式将杂散的对象由某个类统一创建，这样可以方便统一管理杂散的数据，并且当其中的数据进行重新赋值时，只进行类内部重新赋值即可而不需要找到每处实例化的对象","categories":[],"tags":[]},{"title":"杂项","slug":"杂项","date":"2024-01-23T03:31:32.000Z","updated":"2024-01-23T04:09:11.036Z","comments":true,"path":"2024/01/23/杂项/","link":"","permalink":"https://wumingzi.top/2024/01/23/%E6%9D%82%E9%A1%B9/","excerpt":"杂项知识点SOC: system on chip电机会有死区电压，表现为电压很低时电机不能启动，死区电压约占额定电压的10%，此时需要给一PWM占空比最小值从而避免死区电压","text":"杂项知识点SOC: system on chip电机会有死区电压，表现为电压很低时电机不能启动，死区电压约占额定电压的10%，此时需要给一PWM占空比最小值从而避免死区电压 ![2023-12-20_22-20](vx_images&#x2F;113862122249687.png &#x3D;600x)处于三相电PWM调功率中的开关器件(如IGBT)，换相时为防止三相电任意上半桥和下半桥同时开启导致短路，我们要给死区时间，一般会占整个周期的百分之几，但当PWM占空比极小时，死区时间就会产生很大影响，最终影响输出纹波 常量保存在Flash里，全局初始化非零的变量保存在SRAM的.data段内，静态变量或者全局初始化为零的变量保存在.bss段内，函数和函数内的局部变量保存在栈上 尽量把数据保存在栈上，这样防止产生内存安全问题，并且栈上访问数据速度更快(数据局部性原理？)栈是从高地址向低地址增长，堆是从低地址向高地址增长 操作Flash前需要关中断 计算机底层是小端存储的原因是在C程序员眼里，小端更符合直觉，在不定长的int，char中可以相互转换而不改变变量值(变量长度小于int、char最小值的情况下)，但是对于传输协议来说，大部分为定长字段传输，这就造成了大端存储更符合从左至右的阅读习惯","categories":[],"tags":[]},{"title":"工具链","slug":"工具链","date":"2024-01-23T01:35:09.000Z","updated":"2024-03-21T02:00:47.083Z","comments":true,"path":"2024/01/23/工具链/","link":"","permalink":"https://wumingzi.top/2024/01/23/%E5%B7%A5%E5%85%B7%E9%93%BE/","excerpt":"工具链GitGit本地操作版本控制系统分为2种 集中式版本控制系统 如SVN 分布式版本控制系统 如Git","text":"工具链GitGit本地操作版本控制系统分为2种 集中式版本控制系统 如SVN 分布式版本控制系统 如Git 相比SVN，Git可靠性高但操作复杂 1234567891011121314git init [dir]//在dir下创建新的本地仓库，缺省则在当前目录创建/* 全局配置git仓库的用户名，对所有仓库生效，省略则为本地仓库有效 */ git config --global user.name &quot;用户名&quot; /* 全局配置git仓库的邮箱，对所有仓库生效，省略则为本地仓库有效 */ git config --global user.email &quot;邮箱&quot; /* 保存用户名和密码 */git config --global credential.helper store/* 查看当前git配置 */git config --global --list git的数据管理分为三部分 工作区 .git所在目录，正常编辑代码的区域 暂存区 .git&#x2F;index所在目录，即将提交到git的文件区域 本地仓库 .git&#x2F;objectsgit所在目录 init生成的文件区域，是git存储代码和版本信息的主要位置每次修改文件都需要提交很麻烦，因此产生了暂存区，当修改所有文件完毕后再统一提交至本地仓库 12345678910111213141516171819/* 将filename文件添加到暂存区内，支持通配符( * . 等) */git add [filename]/* 查看当前文件状态 */git status /* 提交，支持通配符 */git commit -m &quot;提交说明&quot;/* 暂存且提交，支持通配符 */git commit -a -m &quot;提交说明&quot;/* 查看提交日志 */git log/* 查看暂存区文件 */git ls-files :::alert-danger需要将文件提交到暂存区内才能使用 git commit命令::: 1234567891011121314151617/* 回退到某一版本,保留工作区和暂存区内容 */git reset [版本id] git reset --soft [版本id]/* 不保留工作区和暂存区内容 */git reset --hard/* 仅保留工作区内容 */git reset --mixed/* 恢复git reset --hard的操作 */git reflog/* 当在一个分支上进行修改而且需要转到另一个分支上时，可能会提示未保存修改，这时需要用到如下命令保存当前分支已修改的文件 */git stash 使用 –hard 参数需要谨慎考虑，git reset默认执行 –soft命令 123456789101112131415/* 从工作区和暂存区中删除文件 */git rm [filename]/* 仅在版本库中删除文件 */git rm --cached [filename]/* 查看工作区和暂存区的不同 */git diff/* 查看暂存区与本地仓库的不同 */git diff HEAD /* 查看前第n个提交版本与当前提交版本的不同 */git diff HEAD~[n] HEAD diff后红色内容表示删除内容，绿色表示增加内容 Git远程操作可以配置.gitignore来不想被版本控制的文件，只需将文件或文件夹添加到.gitignore即可，语法支持如上 12345678910111213141516171819202122232425262728293031323334353637383940/* eg git remote add origin git@github.com:1078249029/toyFreeRTOS.git */git remote add &lt;远程仓库别名&gt;&lt;远程仓库地址&gt; //仓库别名缺省为origin/* 将本地分支与远程仓库的远程分支联系起来 * eg git push -u(upstream) origin main(远程分支与本地分支重名只写一个即可) */git push -u &lt;远程仓库名&gt;&lt;远程分支名&gt; &lt;本地分支名&gt;/* 获取远程仓库名，分支名等信息 */git remote -v/* 拉取远程仓库并自动合并 */git pull &lt;远程仓库名&gt;&lt;远程分支名&gt; &lt;本地分支名&gt;/* 查看分支列表 */git branch/* 图形化查看分支图 */git log --graph --oneline --decorate --all/* 创建分支 */git branch [branch-name]/* 切换分支 */git switch [branch-name]/* 合并分支 */git merge [branch-name]/* 将主分支文件同步到其他分支 */git merge [主分支名称] //使用前需要切换到其他分支/* 删除分支 */git branch -d [branch-name] //删除已合并分支git branch -D [branch-name] //删除未合并分支/* 恢复某分支的状态 */git checkout -b [branch-name] [commit-id] ::: alert-infomerge时需要切换到主分支merge后分支依然存在，除非手动删除分支::: GitFlow适用于团队水平适中的情况 五种分支: main hotfix release develop feature main 包含项目最新的稳定代码hotfix 用于解决线上问题，均从main分离出来dev 用于开发测试release 均来源于develop，测试稳定后发布到main，发现bug发布到dev 主要分支包括dev和main GitHub Flow适用于团队水平较高的情况 整个项目只有两个分支，开发者从Master中branch一个分支用于开发，需要进行merge时发起一个Pull Request请求，待团队审核后再merge到Master GitHub配置Github的SSH密钥时，最好把密钥统一放在.ssh文件夹下(win下是C:\\Users\\李政轩.ssh)，并且写好config文件来管理多份密钥 Repo repo是什么？ repo是Google开发的用于管理Android版本库的一个工具，repo是使用Python对git进行了一定的封装，并不是用于取代git，它简化了对多个Git版本库的管理。用repo管理的版本库都需要使用git命令来进行操作。因此，使用repo工具之前，请先确保已经安装git 为什么要用repo？ 项目模块化&#x2F;组件化之后各模块也作为独立的 Git 仓库从主项目里剥离了出去，各模块各自管理自己的版本。Android源码引用了很多开源项目，每一个子项目都是一个Git仓库，每个Git仓库都有很多分支版本，为了方便统一管理各个子项目的Git仓库，需要一个上层工具批量进行处理，因此repo诞生。 repo用于Android项目管理 GCCgcc(g++) options -o 指定文件名 -fexec-charset&#x3D;GBK 指定运行时编码 -finput-charset&#x3D;UTF-8 指定源文件编码 -Wall 输出警告信息 -O(0-3) 指定代码优化等级(0为不优化) 预处理阶段 (-E，得到.i文件)（巧记：ESC，iso） 处理#include预编译指令，将被包含的文件直接插入到预编译指令的位置 处理所有的条件预编译指令，比如#if，#else，#endif，#ifdef等 预处理器将所有的#define删除，并且展开所有的宏定义 删除所有的注释 添加行号和文件标识，以便编译错误时提供错误或警告的行号 保留所有#pragma编译器指令1gcc -E -o hello.i hello.c 编译阶段 (-S，调用cc1程序得到.s文件) 将预处理后的file.i文件进行语法词法分析，翻译成文本文件file.s，里面储存了各种汇编指令1gcc -S -o hello.s hello.i 汇编阶段 (-c，调用ar程序得到.o文件) 根据编译文件中的汇编码得到二进制机器码文件，生成各个段，生成符号表123456789101112131415161718192021222324252627282930313233343536373839gcc -c -o hello.o hello.s``` * 链接阶段 (gcc file.o，调用collect2程序) * 将链接文件链接到file.o文件中 * 静态链接：内存开销大，速度快。将所有需要的函数的二进制代码拷贝到可执行文件中去 * 动态链接：内存开销小，速度慢。不需要将所有需要的函数的二进制代码拷贝到可执行文件中去，而是记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统将这些动态库加载到内存中，然后当程序运行到指定代码时，去共享执行内存中找到已经加载动态库可执行代码，最终达到运行时链接的目的 ```shellgcc -M hello.c 打印hello.c的依赖gcc -M -MF hello.d hello.c 输出hello.c的依赖到hello.d文件内gcc -c -o hello.o hello.c -MD -MF hello.d 编译hello.c并输出依赖到hello.d文件``` linux-gcc默认最终的输出文件为elf类型，经过编译的.c文件是 .o文件(object，目标文件)，链接后的为.elf文件，但同时也可以指定输出.out文件，这是一种老的可执行文件格式## GDB ```shellgcc -g //编译时记录调试信息，否则无法调试gdb 可执行文件 //调试可执行文件进入gdb后回车默认重复上一条命令r(run) 运行程序quit 退出调试list 查看源代码及行号b(break) 行号/函数名 在行号或函数名打断点info b 查看打断点的位置delet b 删除断点n(next) 逐步调试，但是不进入调用的函数内s(step) 逐步调试，进入调用的函数内p(print) 表达式 打印变量或地址watch 表达式 监视表达式的值，一旦变化，调试将会停在对应的行 shell 终端命令 调用终端命令 Makefile 如何判断哪个文件被更改了？ 比较源文件与输出文件的时间，如果源文件更新的话，那就意味着源文件已经被修改了 1234567891011121314#makefile核心：规则#目标：依赖1 依赖二...#[TAB]命令 #下列目标文件test由a.o b.o链接生成 test:a.o b.o gcc -o test a.o b.o a.o:a.c gcc -c -o a.o a.cb.o:b.c gcc -c -o b.o b.c 通配符： *： 任意字符，但对于目标文件，优先使用%代替* $：取值 @：目标值，@后加shell命令可以不显示命令但输出结果 $@：目标文件 $&lt;：第一个依赖文件 $^：所有依赖文件$(shell 命令)可以执行shell命令假想目标文件：.PHONY 用于当目标文件与make命令重名时使用，用法：在makefile文件末尾加上.PHONY: 命令 A &#x3D; xxx 变量赋值$(A) 变量取值&#x3D; 延时变量，makefile分析完成整个文档后才会对变量赋值，没有写程序时的类似顺序执行的逻辑:&#x3D; 即时变量，类似写程序时的顺序执行的关系，需要在当前行之前声明定义变量?&#x3D; 在此行之前就已经定义变量时该语句无效，类似#ifndef+&#x3D; 附加，并不是加，是延时变量还是即时变量取决于前文 $(foreach var,list,text) 在list中的每一个var，都换为text$(filter pattern,text) 在text中取出符合pattern的值$(filter-out pattern,text) 在text中取出不符合pattern的值$(wildcard pattern) 在已存在的文件中取出符合pattern的值$(patsubst pattern,replacement,$(var)) 在var中取出符合pattern的值，并替换为replacementCFLAGS 这个变量可以后加gcc的编译选项","categories":[],"tags":[]},{"title":"FreeRTOS","slug":"FreeRTOS","date":"2024-01-23T01:33:25.000Z","updated":"2024-01-23T03:59:02.335Z","comments":true,"path":"2024/01/23/FreeRTOS/","link":"","permalink":"https://wumingzi.top/2024/01/23/FreeRTOS/","excerpt":"FreeRTOS使用静态创建任务函数的话，返回值就是句柄，因此，要想对静态函数创建出来的任务进行操作的话需要创建一个临时变量以记录其返回值使用vTaskDelet函数要注意不要在自己的进程内部自杀，这样会导致空闲任务无法清理内存","text":"FreeRTOS使用静态创建任务函数的话，返回值就是句柄，因此，要想对静态函数创建出来的任务进行操作的话需要创建一个临时变量以记录其返回值使用vTaskDelet函数要注意不要在自己的进程内部自杀，这样会导致空闲任务无法清理内存 TCB结构体内部包含函数指针，SP位置，优先级，函数名字，函数参数等，但并不包括函数的指针(用来执行本函数)，也不包括函数参数，CPU通过保存所有寄存器的值来保存这两项，保存的位置在该函数栈的顶部，其中R0，R1…保存了函数的参数(约定俗成)，R15(PC)保存了函数的指针，来进行函数的跳转操作优先级最大值只能取到最大值-1，高于这个值的会自动变为最大值-1空闲任务(xIdleTask)是启动调度器时就自动创建的，空闲任务可以使用自带的钩子函数创建出来，也可以用来处理下列任务 执行一些低优先级的，后台的，需要连续执行的函数 进入省电模式 测量系统空闲时间 空闲任务的限制： 不能让空闲任务进入阻塞状态或者暂停状态取消支持时间片流转会使优先级相同的其中一个任务在未被高优先级打断前始终霸占CPU调度策略配置项 是否抢占(高优先级任务是否可以立即打断低优先级的执行) 允许抢占时，是否允许时间片流转(同一优先级任务执行时，是否允许相互打断执行) 允许抢占并且允许时间片流转时，是否允许空闲任务让步(空闲任务和用户任务在同一优先级时，空闲任务是否让出时间片)博客园 采用这种方式运行并发程序会导致Task3 Task4在将锁置为1之前就都已经进入if语句内部了，这就会导致概率性并发Bug写队列函数xQueueSend与xQueueSendToBack是一样的，都是默认在队列尾部写入数据，而xQueueSendToFront则是在头部写入数据(头部就是pcReadFrom指针所指的地址，并不是队列的最右侧)，此时还需要将pcReadFrom指针减去一个ItemSize的地址使用队列集并在队列里面写入数据时会把任务的数据写在队列里，并把任务的Handle写在队列集(Queue Set)里，读一次Queue Set后返回的Queue只能读一次，不能读多次，普通的Queue也一样因为读队列后系统自动删除数据二值信号量的Give函数会检测信号量是否为1，若为1则会返回失败，而Take函数则会检查信号量是否为0，并且可以设置阻塞时间信号量不能是负值创建二值型信号量时默认初始值是0，需要Give一下，互斥量则不需要信号量：Semaphore 互斥量：Mutex只有申请方和接收方有锁的情况下才会产生优先级反转，如果其中一方无锁则正常调度就不会产生优先级反转，解决优先级反转的办法是优先级继承互斥量有优先级继承的功能，而信号量则没有死锁的原因有两种 A函数内部二次上锁，A将自己阻塞了但其他任务并不能解锁造成死锁: A获得了锁，A调用一个库函数，这个库函数需要获得上面那个锁，死锁发生 A依赖B的锁，B又依赖A的锁，此时会死锁互斥量解决了第1点，办法是使用递归锁(Recursive Mutex)，递归锁解决了第2点，采用了谁持有谁释放的方法 事件组要么等待事件中的某一个发生，要么等待事件中的所有都发生，不能等待事件中的指定某几个发生切换任务后是直接执行在任务中断处执行，一般为while(1)循环内继续执行，因此对于在循环外部的初始化变量一定小心，例如在while(1)外部定义了i，while(1)循环内部定义了for循环，使用的变量是前面的i，这样，当第一次while(1)循环结束后i的是值为跳出循环的值，从本次循环开始，就不会再进入for内部了任务通知是多对一的关系对于任务通知来说，发送方发送的结果只有两种，要么成功要么失败，并不会等待，而对于接收方则有三种情况xQueueReceive()与xEventGroupWaitBits()中的WaitForAllBits数量有关，如果WaitForAllBits是pdFalse时，则需要一个xQueueReceive()就够了，否则会造成从未赋值的中间变量中取数据的Bug，造成的现象是同时多个数据被写入队列时会产生数据被读取多次，次数取决于并发的程序数量，不同时写入数据则会只覆盖队列中第一个数据，第二个数据始终被保留。而WaitForAllBits是pdTure时，则需要多个xQueueReceive()，这样才会有足够多的中间变量存储数据，而后被一次读走(具体实验可以看24_freertos_example_tasknotify_event_group)使用任务通知构造轻量化事件组无法等待指定的某个任务，但是可以通过判断xTaskNotifyWait()中的pulNotificationValue值来进行等待某个指定任务定时器函数在守护任务中被执行，每当产生Tick时定时器函数会比较当前Tick与预设Tick，并根据结果来执行回调函数(CallBackFun)，想要设置其定时器函数的具体参数需要经过队列通信来完成调用如上函数时，如果不加static关键字会导致每次调用函数都会产生新的栈和新的int，这样int的值就不是理想的，如果初始化cnt为0，则每次都会打印0，也不符合逻辑，解决办法是使用static关键字来存储每次产生的cntFreeRTOS对于中断会使用不同的ISR(Interrupt Service Routines)函数，这是为了保证ISR执行的时候不能处于阻塞状态，这样才能保证实时性临界资源是指能够被多个进程共享，但是同一时间只能由一个进程访问的资源，因此是互斥的用到syscall的中断可以通过调用系统函数被屏蔽掉，这样即使是优先级比较低的中断也可以安心访问临界资源，CotexM3&#x2F;M4调用syscall的中断位于中断向量表的191255位，0255位是可编程异常，-30位分别是复位、NMI、硬件错误，屏蔽中断本质上是调用191号中断，从而将191255中断屏蔽在中断中调用中断恢复函数会将中断恢复至原来的状态，可能是中断开启也可能是中断屏蔽，而在任务中调用中断恢复宏定义则会将中断打开，因此，中断恢复函数有返回值任务切换一定要给延时！尽量不要在定时器回调函数内部进行延时操作，定时器守护任务优先级及其栈深度在Config文件内被定义，默认为4，要想抢占定时器回调函数注意修改配置任务自杀后就永远不会被执行，除非被再次创建编程时，一般的逻辑错误都容易解决。难以处理的是内存越界、栈溢出等。并没有很好的方法检测内存越界，但是可以提供一些回调函数： 使用pvPortMalloc失败时，如果在FreeRTOSConfig.h里配置configUSE_MALLOC_FAILED_HOOK为1，会调用： 1void vApplicationMallocFailedHook( void ); 在切换任务(vTaskSwitchContext)时调用taskCHECK_FOR_STACK_OVERFLOW来检测栈是否溢出，如果溢出会调用： 1void vApplicationStackOverflowHook( TaskHandle_t xTask, char * pcTaskName ); 怎么判断栈溢出？有两种方法： 方法1： 当前任务被切换出去之前，它的整个运行现场都被保存在栈里，这时很可能就是它对栈的使用到达了峰值。 这方法很高效，但是并不精确 比如：任务在运行过程中调用了函数A大量地使用了栈，调用完函数A后才被调度。 方法2： 创建任务时，它的栈被填入固定的值，比如：0xa5 检测栈里最后16字节的数据，如果不是0xa5的话表示栈即将、或者已经被用完了 没有方法1快速，但是也足够快 能捕获几乎所有的栈溢出 为什么是几乎所有？可能有些函数使用栈时，非常凑巧地把栈设置为0xa5：几乎不可能 简而言之，使用上面两个Hook函数需要配置Config.h，并要求自己实现Hook函数的功能(内存回收以防止nalloc失败等) FreeRTOS的内部机制Arm架构汇编指令:读指令 LDR (Load Register) LDR R0, [addr]写指令 STR (Store Register) STR R0, [addr]加指令 ADD ADD R0,R1,R2 &#x2F;&#x2F;R0&#x3D;R1+R2PUSH指令本质是写指令， Push {R3,LR}把LR，R3 Push到内存中的栈，把LR放在高地址，R3放在低地址CPU中重要的寄存器: SP(R13) 栈顶指针寄存器 LR(R14) 返回地址寄存器 PC(R15) 当前指令寄存器 CPSR(A64架构) 状态寄存器，LR是一种特殊的PCPOP指令本质是读指令 POP {R3,LR}栈可以用来保存现场，任务可以理解为函数+函数的栈保存现场的三种情况 切换任务时，保存所有的寄存器 调用其他函数时，但由于前几个寄存器(R0,R1,R2…)被用来传参，因此不需要保存 硬件中断时，硬件会自动保存一部分寄存器，但是还需要软件保存一部分 栈的大小取决于局部变量的大小以及函数调用的深度，函数调用需要Push LRTCB结构体内部包含函数指针，SP位置，优先级，函数名字，函数参数等，但并不包括函数的指针(用来执行本函数)，也不包括函数参数，CPU通过保存所有寄存器的值来保存这两项，保存的位置在该函数栈的顶部，其中R0，R1…保存了函数的参数(约定俗成)，R15(PC)保存了函数的指针，来进行函数的跳转操作申请堆栈的指令名为SPACE，这是在初始化文件里就执行的main函数的栈是在STM32汇编文件文件中设置的，与芯片厂商相关，步骤如下 在内存中申请一段空间(首地址为__initial_sp，也是msp(Main_Stack_Pointer,也是sp)，同时会给中断函数的栈使用 然后转入向量表，找到__initial_sp 执行Reset_Handle，在Reset_Handle内部跳转到了main函数 任务调度原理: 任务存在三个大类链表中，分别是ReadyList链表数组，DelayList，PendingList。其中ReadyList链表数组按照优先级排列(0-4)共有五个链表，FreeRTOS会先从ReadyList中最高优先级的一个开始寻找任务并执行，当高优先级任务发生阻塞时会将其从ReadyList移到DelayList，这时就不会执行了，而是去找低优先级的任务去执行。当创建任务时，会有指针指向当前创建的优先级最高的任务，因此，最后创建的任务总会先执行，然后再按前文所说按优先级高低依次执行其他任务。选要注意的是，当所有任务优先级为0时，最后创建的是IdleTask。因此指针指向的是空闲任务。最终程序首先执行的IdleTask并没有现象，程序“看起来”好像是从最初的Task开始运行的在整个任务调度的过程中利用的是任务的TCB结构体为防止写队列过程中发生调度导致失败，所以在写队列中需要互斥，这是通过关闭中断来实现的(任务调度本质上是定时器产生中断)一函数写队列时，会唤醒其他等待队列的函数，当其他等待队列的函数条件符合时会准备进行切换任务，条件不符合时会将写队列的函数进行休眠以节省CPU资源。当使用队列且函数休眠时不仅把自己从ReadyList移到DelayList，还会在等待队列中写入自身，等待其他任务写队列时来唤醒它在使用队列读写数据时，首先关中断，之后读写数据，在读写之后还需要进行链表操作来调度和通知任务，最后再开中断因此使用队列有两点好处 实现互斥 节省CPU资源，提高程序运行效率队列要点 关中断实现互斥 环形缓冲区保存数据 链表实现休眠唤醒 内存中队列的构成: Queue_t(队列头)+Buffer(数据缓冲区)，队列头由队列结构体构成，内部包含xTaskWaitingToSend链表以及xTaskWaitingToReceive链表及其对应的指针，数据缓冲区大小 &#x3D; ItemSize * LengthxTaskWaitingToSend以及xTaskWaitingToReceive仅仅是为了记录哪个任务需要读写数据，真正的调度还需要去执行ReadyList与DelayList之间的操作，这样是为了防止在中断内部阻塞critical: 临界区读队列内核操作信号量是一种特殊的队列，它不传递数据，因此它只有Queue_t(队列头)，在Queue_t内部还有个链表用来记录Take失败的任务，以便之后唤醒互斥量优先级继承是通过高优先级任务的优先级赋值给低优先级任务完成的，在这之前还需要记录低优先级任务的优先级，这样才能保证Give互斥量之后回到原优先级事件组某些位被设置后会唤醒事件组里所有DelayList的任务将其移到ReadyList，然后每个任务依次检查是否符合执行条件，符合的执行，不符合的再次进入DelayList使用队列和信号量时为了防止其他任务干扰需要关调度器，同时为了防止其他中断任干扰也要关中断，但是关中断后再关调度器也就没有意义了，因此在其内部源码中只是关闭中断而已。而事件组只是关闭调度器即可，这是因为FreeRTOS不会在中断中使用事件组，本质原因是事件组的FromISR函数并没有实际切换任务，而是写一个链表，等待事件组的FromISR函数执行完毕后才会进行实际的任务切换，这样一旦对事件组的某些位设置就不会在中断中唤醒所有任务了，否则会在中断内消耗大量时间。任务通知能且只能点对点的唤醒任务，具体过程和前几种方法类似，都是先关中断，然后发通知的一方设置eaction的值，等通知的一方需要接受值，判断执行什么指令。之后由系统进行链表操作及状态转移，最后开中断对于定时器任务， FreeRTOS的处理与其他操作系统不同。其他操作系统由硬件定时器(systick)出发形成软件定时器，在软件定时器内部直接调用待处理任务。而FreeRTOS认为，软件定时器也是中断，为了防止在中断内部直接处理任务会导致阻塞，因此采用了队列的方式处理任务，这与xTaskWaitingToSend以及xTaskWaitingToReceive在关中断内记录要更改的链表操作类似定时器队列中，写队列一侧是systick，读队列一侧是守护任务。有趣的是创建Timer任务和启动Timer也是写队列，所以在函数xTimerStart(xTimer，xTicksToWait)中有两个参数，第二个参数给的就是当定时器队列满时是否接受等待中断的优先级: systick服务于任务调度，pendsv服务于任务切换，其他的类似GPIO的中断用于业务，为了能够让业务正常执行，GPIO中断优先级最高，systick和pendsv优先级最低pendsv本质上是保存现场和任务切换的汇编代码 1234567taskENTER_CRITICAL();/*访问临界资源，防止其他任务，ISR破坏*/taskEXIT_CRITICAL();----------------------------vTaskSuspendAll();/*关闭调度器，防止其他任务破坏性访问*/xTaskResumeAll(); 可以通过116行将宏消除(因为宏未定义，编译器会消除宏)FreeRTOS的链表构成如上图，xList负责产生头xMINI_List_Item，并记录链表中信息(如元素个数，当前指针的位置)，xMINI_List_Item本身作为链表头，xList_Item产生节点。要注意xList_Item的pvOwner才是学习链表时的”container”(容器)，container内部有下一个Node，Node里面也有下一个的container，而对应Node节点的就是FreeRTOS的Item。此时的pxContainer是指向新加入元素的那个List的指针内存管理:有些芯片支持对指针取指赋值，有些芯片则根本不支持，考虑的原因是防止内存不对齐而引发错误，在使用malloc函数中需要注意生成堆的本质就是申请一块全局数组heap1到heap5内存回收机制逐渐增强，一般常用heap4heap_1.c里，只实现了pvPortMalloc函数，vPortFree函数并未实现。并在malloc函数内实现了互斥，以防止其他任务再次进行malloc使用heap1进行内存申请时，首先heap1内部会定义两个指针，pucAlignedHeap与xWantedSize，pucAlignedHeap主要负责内存对齐，每次pucAlignedHeap移动到下一个内存对齐的地址(最大移动8个地址)。xWantedSize负责给出申请空间的尾地址，这样将xWantedSize赋值给pucAlignedHeap就可以知道下一次该在何处对齐内存。例如，想在0x4000 0001处申请99字节的空间，首先pucAlignedHeap会指向0x4000 0004处(32位机内存块大小为4*8字节，所以pucAlignedHeap最大偏移量为4)，而后计算xWantedSize大小，考虑99不能被4整除，因此向上取整为100，所以新申请的内存地址为0x4000 0004至0x4000 0104，而0x4000 0001到0x4000 0003处内存被丢弃heap2实现了内存回收，但没有解决内存碎片问题heap2实现的内存分配的方法是，首先生成一个链表，让链表头指向一个未分配的很大的heap(大小17k)，每当申请空间时首先会在已经空闲的block中找出是否能拆分出需求大小的block，如果不能，则从未划分block的堆中划分出一个新block，划分出的block内部包含申请空间的大小以及下一个空闲内存的指针。如果找到大于申请内存大小的block时，首先将该block裁剪为申请内存的大小，并在新申请的block记录该block大小，之后会将链表内的指针指向下一个未被占用的block。heap2实现的内存回收的方法是，当需要free时，链表头就会free指定的地址，并将当前指针向前移动(pxNextFreeBlock+xBlockSize)个地址，从而找到block起始位置，但是这种方法并没有实现将这些已经free的内存重新归还到整个未被使用的内存中，因此这种free的空间在整个内存上来看是被各种pxNextFreeBlock+xBlockSize结构体分割出来的，这就是 内存的碎片化需要注意的是，使用heap2进行malloc操作的时候，链表申请是从小到大排序的，这样方便查找需要的blockheap能够进行内存碎片回收，链表按地址排序为了增加程序的健壮性，heap4加入了block使用的标志位(1&lt;&lt;31)heap5与heap4的不同点在于heap5支持多块内存，在使用heap5时需要手动调用vPortDefineHeapRegions()函数，并以数组方式传入想要划分为堆的地址，这个数组以NULL结尾来确定数组结束的标志","categories":[],"tags":[]},{"title":"Vim复健计划","slug":"Vim复健计划","date":"2024-01-23T01:31:58.000Z","updated":"2024-01-23T03:56:14.480Z","comments":true,"path":"2024/01/23/Vim复健计划/","link":"","permalink":"https://wumingzi.top/2024/01/23/Vim%E5%A4%8D%E5%81%A5%E8%AE%A1%E5%88%92/","excerpt":"Vim复健计划命令模式o 新建下一行并切换到编辑模式O 新建上一行并切换到编辑模式[n]x 包括光标的后n位剪切，若改为X，则是光标前n位但包括光标所在的字符[n]yy 包括光标的后n行复制[n]dd 包括光标的后n行剪切[n]p 粘贴复制的内容n遍","text":"Vim复健计划命令模式o 新建下一行并切换到编辑模式O 新建上一行并切换到编辑模式[n]x 包括光标的后n位剪切，若改为X，则是光标前n位但包括光标所在的字符[n]yy 包括光标的后n行复制[n]dd 包括光标的后n行剪切[n]p 粘贴复制的内容n遍 D 包括光标的之后当前行的所有字符剪切dG 包括光标的之后所有行剪切J 将下一行合并到上一行，并用空格连接. 执行上一次操作Shift+I 光标移到行首并进入编辑模式Shift+A 光标移到行尾并进入编辑模式Ctrl+f 向下滚屏（可以用PageDown）Ctrl+b 向上滚屏（可以用PageUp）gg 光标移到第一行行首G 光标移到最后一行行首[n]gg 或[n]G 光标移到第n行行首&#x2F;内容 查找内容 n 转到下一个 N 转到上一个？ 查找上一次搜索的内容 （?内容 与 &#x2F;内容 作用一样）&#x2F;^内容 查找以内容开头的字符串&#x2F;内容$ 查找以内容结尾的字符串&#x2F;a…b 查找以a开头b结尾，中间有3个任意字符的字符串:r 文件名 在光标下一行插入文件的内容:%s&#x2F;aaa&#x2F;bbb&#x2F;gc 全文中aaa被替换为bbb，替换时确认 % 全文 s 替换 g 当前行所有字符 c 确认:set nu 显示行号 :set nonu 不显示行号","categories":[],"tags":[]},{"title":"STM32","slug":"STM32","date":"2024-01-23T01:30:55.000Z","updated":"2024-03-27T00:41:40.896Z","comments":true,"path":"2024/01/23/STM32/","link":"","permalink":"https://wumingzi.top/2024/01/23/STM32/","excerpt":"STM32STM32 常用寄存器缩写: CR 控制寄存器 SR 状态寄存器 DR 数据寄存器ST公司出品的Microcontroller(微控制器) Cortex-M内核 学习的是M3内核供电电压 2.0V-3.6V(标准3.3V)，USB输出电压是5VAHB 先进高性能总线APB 外设总线内核的外设不需要开启时钟","text":"STM32STM32 常用寄存器缩写: CR 控制寄存器 SR 状态寄存器 DR 数据寄存器ST公司出品的Microcontroller(微控制器) Cortex-M内核 学习的是M3内核供电电压 2.0V-3.6V(标准3.3V)，USB输出电压是5VAHB 先进高性能总线APB 外设总线内核的外设不需要开启时钟 复用输入指的是同一引脚默认有很多输入功能，需要对GPIO指定使用哪个功能(TIM4就无复用功能)，而重定义则是非默认功能，需要进行AFIO选择进而变为复用功能 ？？？？？？？？？？？？？？？最小系统电路: 单独的芯片不能工作，需要连接最基本的电路，由这些电路组成的就是最小系统电路 GPIORCC : 复位和时钟控制GPIO(General Purpose Input Output)通用输入输出口GPIO高低电平看外部输入输出,输入情况下,与外部电平极性相同.如果外部信号非常小,则为避免引入干扰源选择浮空输入,不清楚外部信号的情况下也选择浮空输入,输出情况下看外部负载电压要求AIN是模拟输入专用模式，此时GPIO不输入输出，防止对外界信号干扰AF_PP是复用推挽模式，片上外设使用这种模式VDD 3.3V VSS 0VGPIO 控制流程：1.激活 RCC 时钟 2.使用 GPIO_Init 初始化 GPIO 函数施密特触发器的作用是对外界信号进行滤波，规定上下限，使得当超过上限输出为1，低于下限输出为0，上下限之间输出不变，这样可以维持信号的稳定性在输出模式下，输入也是有效的OLED函数showhexnum与shownum每逢10相差6，hexnum的数值比num高6 中断NVIC (Nested Vectored Interrupt Controller) 嵌套中断向量控制器: 统一分配中断优先级和管理中断响应优先级: 完成当前任务后进行响应优先级的任务 中断优先级: 立即结束当前任务并进行中断优先级任务(可以决定中断嵌套,抢占优先级高的可以进行中断嵌套)两个优先级相同的情况下按中断号排队,所以并不是先来后到NVIC 分组在整个项目中只需要执行一次EXTI (external interrupt) 外部中断控制器EXTI 负责监控GPIO的电平变化,当产生跳变时,EXTI向NVIC发送中断申请,经NVIC裁决优先级后执行中断程序GPIO_EXTILineConfig(GPIO_PortSourceGPIOx,GPIO_PinSourcex) 是配置AFIO的函数，参数是GPIO的通道和引脚 定时器TIM (timer) 定时器TRGO(Trigger Out)定时器主模式，可以不用进中断就可以执行程序预分频器(PSC)对时钟频率进行分频,置0 不分频,置1 频率&#x3D;原时钟频率&#x2F;2 置2 频率&#x3D;原时钟频率&#x2F;3 等等 下列公式注意预分频器需要加 1,ARR加1的原因是ARR从 0 开始计数 CK_PSC是 72MHzOC(output compare) : 输出比较PWM(pause width modulation) : 脉冲宽度调制IC(Input Capture): 输入捕获输入捕获每次CNT转运到CCR时需要清0,此时可以配置从模式,让硬件电路自动清零FP(filter polarity)，滤波器极性选择主模式:让定时器内部信号映射到TRGO引脚,用于触发别的外设 从模式:接受其他外设或自身的信号用于控制自身定时器的运行滤波器也是计数器,但不会改变信号原有的频率,原理是当有x个信号均为同一性质(高电平或低电平时)才滞后输出信号,x是给定的参数值通道3,4不支持PWMI配置使用编码器时,定时器的其他功能就无法使用了通道3,4不支持编码器TI1可以选择接到TI1FP1上也可以选择TI1FP2上，这样可以通过极性选择来计算出上升沿到下降沿的时间，这个功能可以在PWMI模式中体现编码器会接管时钟,所以不需要TIM_InternalClockConfig()uint16_t 中比0小一位是65535，如果想变为-1需要把uint强制转换为int ADCADC(Analog-Digital Converter)STM32 ADC是12位的 最大值4096 可以测量0-3.3VPWM是DAC的一种，具有功率损耗小的优点，常用来给大型直流电机调速，32没有DAC外设ADC数据来源于比较器的结果，其核心是未知的外界信号与芯片给定的信号进行比较，并用逐次逼近寄存器(SAR)采用二分法分分割芯片信号，直至与外界信号相等，此时SAR的值即为外界信号值规则组支持16通道，注入组支持4通道，但规则组只有一个数据寄存器，注入组有四个。使用规则组时可以申请DMA来帮助通道转换效率EOC(End Of Convert) 规则组: EOC 注入组: JEOC注意要开启RCC_ADC的时钟通道数大于 1 扫描模式才有意义，转换是对循环而言在连续转换模式下，会自动读取EOC的值，所以不需要手动写 while 判断是否转换完毕单次连续模式是针对某个通道，扫描非扫描模式针对所有通道保持时间越长，越能抵抗毛刺信号的干扰ADC数据对齐方式一般选右对齐，左对齐是为了直接取出数据的高n位，方便裁剪分辨率，但是也可以通过右对齐然后读取出的数据进行右移的方式来操作分辨率 DMADMA(Direct Memory Access)直接存储器访问STM32有7个DMA1通道,每个通道支持软件触发和特定的硬件触发如果是Flash到SRAM的数据搬运,应使用软件触发,此时数据运输速率最快,如果是外设到SRAM,应使用硬件触发,此时不需要以最快的速度转运数据,而是需要特定时机才触发转运DMA只操作存储器到存储器的数据搬运,上面提的外设到SRAM是指外设的存储器到SRAM内核外设: NVIC SysTickDCode总线专门访问FlashDMA虽然有多个通道,但是只有一条DMA总线,需要仲裁器进行仲裁,使优先级高的通过获得数据,通道号越小优先级越高数据宽度参数 字节: 8位 半字: 16位 字: 32位自动重装器决定传输计数器自减到0后是否恢复到初值,如果恢复到初值则为连续模式,否则为单次模式软件触发不能与自动重装器同时使用,那样DMA就停不下来了M2M位置1是软件触发,M2M置0是硬件触发传输计数器等于0后需要将DMA_Cmd DISABLE,然后改变传输计数器的值,再DMA_Cmd ENABLE,DMA才能重新工作,简而言之,写传输计数器需要关闭DMA小位数数据转移到大位数数据会在高位补0,大位数数据转移到小位数数据会舍弃高位DMA和CPU对同一地址进行访问时,仲裁器会优先选择CPU进行访问,但是也会为DMA保留一半的总线带宽Flash存储编译后的C代码和常量数据const定义的常量存储在Flash里 普通变量存储在SRAM里ADC -&gt; DR 得到的是DR的值 &amp;ADC -&gt; DR得到的是DR的地址 UARTUSART支持同步异步传输，有时钟线，并对协议进行增强UART仅支持异步传输，没有时钟线 全双工: 通信双方能够同时双向通信 一般两根通信线，一根发射一根接收半双工: 通信双方同时只能有一方通信单工：无论何时都只有一方能进行通信，另一方始终接收全双工: 打电话 半双工: 对讲机 对讲机: 广播差分信号抗干扰能力强，传输速度和距离会很高硬件流控制: 当信息发送方和接收方I2C 和 SPI 有时钟线，所以是同步时钟USART默认为低位先行RS232 1 0 位如此设置的原因是增加抗干扰能力RS485 是差分信号，传输距离可达上千米二进制调制情况下波特率 &#x3D;&#x3D; 比特率奇偶校验: 校验位补 0 或 1 使得数据位+校验位有偶数或奇数个 1数据流控的: 通过告知其他带有数据流控的设备，本机是否可以接受或发送数据，从而解决通信双方处理数据能力不同而导致一方在忙，另一方发送的数据丢失或覆盖之前发送数据的问题TXE(发送数据寄存器非空)与RXNE(接受移位寄存器非空) 是TDR与RDR置位的 单片机的TX和RX与USB转串口模块的TX和RX要交叉连接波特率除以16是因为采样时钟(fpclk)是以波特率的16倍速度进行采样的，具体数值硬件会帮忙算，我们只需要直接给出波特率就行Odd 奇数 Even 偶数固定包长适合载荷数据与包头包尾重复率高的情况，这样利于分割以及接收数据在发送数据时需要加上包头包尾(个人规定0xFF为包头，0xFE为包尾)相比文本数据包，HEX数据包效率高，因为文本还需要编码译码的过程HEX数据包接收运用了状态机的思想，通过不同的S的值进中断后的行为不同，进而执行相应的动 I2CI2C(inter IC Bus)同步协议需要时钟线来控制数据的读写，好处是对时钟要求不严格，不需要硬件电路的配合，而异步需要硬件电路产生准确的时钟信号才能通信。因此同步协议主打低端市场。同时，如果主机进入中断，异步协议就会出错，而同步协议利用时钟线则不会出错第一个数据帧最低位0为写，1为读I2C两根总线为避免主从设备同时输出造成电源短路现象，规定了SDA与SCL均采用开漏输出模式，这样，无论主从设备是否同时输出，均不会达到强上拉，而是在外接电阻R的作用下被限制为弱上拉，下拉模式不受影响。同时，在下拉状态中，多主机情况下可以进行I2C控制权的仲裁0表示应答 1表示非应答SCL低电平变换SDA数据，高电平读取SDA数据由于I2C对硬件要求不高，因此软件可以完全模拟I2C协议硬件I2C与USART类似，都是通过TXE和RXNE寄存器控制数据收发，只不过I2C是高位先行，因此移位寄存器向左移位，而USART低位先行，是向右移位，这里的高低位先行指的是HEX数据的发送接收模式，正常的文本模式下仍按照人类的从左至右(从高到低)发送文本7位寻址与10位寻址的区别是，10位寻址时前两个数据包是寻址，之后的是数据，而7位则是第一个数据包是寻址EV(event): 事件，产生多个标志位I2C在频率很高时，由于开漏模式弱上拉的作用，实际的SCL和SDA并不完美，当频率快到一定程度时，SCL的方波甚至会被压缩至三角波，为了给SDA传送数据时所需要的上拉一定时间，所以需要SCL低电平时占空比适当增加由于I2C的弱上拉的作用，使得在标准模式下支持100KHz的信号，快速模式下也只能支持400KHz的信号硬件I2C下，STM32默认为从模式STM32的I2C被分为主从两种模式，每种模式又被分为发送和接受两种模式硬件I2C接收模式下，要在发送最后一个字节前将STOP置1，并把Ack置0，这是因为停止位(EV7_1)配置位于接收数据之前，只有接受下个数据后，才能把之前设置的停止事件发送出去。而发送模式的停止事件(EV8_2)位于发送数据后 SPISPI(serial peripheral interface)，应用领域与I2C类似，都用来负责主控与外挂芯片之间的通信，支持一主多从但不支持多主机。通信模式为同步，全双工。与I2C区别在于，I2C是用最少的硬件资源实现最多的功能.SPI有四根通信线，分别为SCK(serial clock)，MOSI(master output slave input)，MISO(master input slave output)，SS(slave select)SPI与I2C一样，均采用高位先行的传输模式SPI没有应答机制，有几个从机就有几个SS线为防止多个从机的MISO互相冲突，SPI规定当从机的SS没有被选中(置0)时，从机的MISO默认为高阻态，SS被选中时，MISO才被改为推挽输出。主机输入为上拉输出(MISO)，主机输出为推挽(包括片选，时钟，MOSI)输出引脚为推挽输出，输入引脚为浮空或上拉SPI的理解可以不采用江科大的上升下降沿分别移入移出的思想，可以采用纯采样的思想CSDN知乎存储器划分 Block - Sector，并且，整个存储空间全被划分成了Page发送的3个字节组成的地址，最低位是页里的字节地址，高2个字节是页地址由于结构特性，Flash的数据bit位只能由1变为0，不能由0变为1，因此写入数据前必须先擦除，将所有数据由0“擦除”至1，而后写入数据.为了防止误操作，Flash使用前需要先写使能驱动层是沟通应用层与通信层的桥梁事前等待就是把WaitBusy放在读写函数之前的位置，这样可以提高效率，但安全性会降低(因为程序在读写操作后可能会运行其他代码，这样可以节省时间，但安全性会降低，比如读写操作后再次进行类似读写的操作)，事后代码效率较低但安全性高。并且需要注意的是事前等待需要放在读写函数之前，但事后等待仅放在写函数后即可写入不能跨页，读取能跨页，写入超过页的限制之后会从页头开始覆盖SPI要想接收数据必须发送数据，因此可以发一些没用的数据(Dummy Data)给从机 BKP与RTCUNIX时间戳默认从1970年1月1日开始，而有些C库默认为1900年开始HSE(高速外部时钟)RTC时钟优先选择LSE，因为频率为2^15^因而容易分频 PWR只有外部中断才能唤醒STM32的停止模式，因此PVD，RTC，USB，ETH等可以通向EXTI中断从上到下越来越省电，但也越来越难被唤醒系统进入停机模式时，HSI被选为系统时钟，此时系统主频8MHz，而正常情况下使用的是HSE*9&#x3D;72MHz，因此会发生Running刷新不及时的现象，此时需要SystemInit来重新初始化时钟待机模式唤醒后，程序从头开始执行，因此，不需要调用SystemInit 看门狗看门狗负责复位程序独立看门狗精度低，使用LSI时钟(40KHz)，窗口看门狗精度高，使用PCLK1的时钟(APB1的时钟，36MHz)键寄存器可以以理解为多位的控制寄存器，这样设计是为了防止外界干扰导致一位的控制寄存器失效，因此设置多位早期唤醒中断可以进行保存数据，再次喂狗等紧急操作，以防止程序未被喂狗而复位窗口时间即为进入WWDG最小的时间，并非通常意义的”窗口”时间利用内部闪存编程时，当读取内部闪存时CPU会被暂停，因为程序放在闪存里，CPU运行的程序需要从闪存中取出，如果此时正在执行中断函数时中断会卡住一段时间。&#x2F;&#x2F;CPU暂停了那谁在执行读闪存的任务？ 启动文件详解野火Startup_file.html","categories":[],"tags":[]},{"title":"C复健计划","slug":"C复健计划","date":"2024-01-23T01:29:46.000Z","updated":"2024-02-22T12:11:39.238Z","comments":true,"path":"2024/01/23/C复健计划/","link":"","permalink":"https://wumingzi.top/2024/01/23/C%E5%A4%8D%E5%81%A5%E8%AE%A1%E5%88%92/","excerpt":"C复健计划printf函数无法打印多行字符串，若要打印多行字符串则需要在每行后加换行符\\n\\n代表换行，\\n\\代表下一行是上一行的延续，如果改为\\n则会报错变量名第一个字母不能是数字ANSI C C99 C11 关键字数量分别是32 32+5 37+7%11.2f代表输出11个占位符，其中浮点型输出到小数点后2位，如果%a.bf，其中b比a大，则直接输出到小数点后b位而忽略a的值%x: 十六进制 (hex) %o: 八进制(oct) %d: 十进制(dec)","text":"C复健计划printf函数无法打印多行字符串，若要打印多行字符串则需要在每行后加换行符\\n\\n代表换行，\\n\\代表下一行是上一行的延续，如果改为\\n则会报错变量名第一个字母不能是数字ANSI C C99 C11 关键字数量分别是32 32+5 37+7%11.2f代表输出11个占位符，其中浮点型输出到小数点后2位，如果%a.bf，其中b比a大，则直接输出到小数点后b位而忽略a的值%x: 十六进制 (hex) %o: 八进制(oct) %d: 十进制(dec) &quot; 代表 “ \\ 代表 \\&#x2F;* *&#x2F;代表多行注释&lt;&gt;表示导入系统文件 “”表示导入自定义文件&#96;Tab &#x3D;&#x3D; 8个空格，或者4个空格 编译分为四步 预编译：宏定义展开，头文件展开，条件编译等，并将注释删除（条件编译是指根据系统位数，编译库的选择确定编译环境） 编译：将预编译后的文件生成汇编文件 汇编：将汇编文件生成为目标文件（二进制代码） 链接：把库链接到可执行程序中（预编译只是说明函数格式） float 默认保留六位小数，%.2 表示保留小数点后两位（四舍五入）常量定义方法：（不能对值进行修改）const 数据类型 常量名 &#x3D; 值 或 数据类型 const 常量名 &#x3D; 值 ( 在函数中定义的常量不安全，而全局常量则安全 )# define 常量名 值第一种不安全，利用指针可以修改 const 定义的值十六进制用 0x 开头 八进制用 0 开头 C不支持定义二进制数有符号数最高位是符号位，0 代表正数，1 代表负数scanf(“%d”,&amp;a); 不要加\\n%hd 短整型 %p 输出指针的地址char ‘单个字母’ 此时 %c 打印字母 %d 打印ASC2码%c 对应的变量如果是整型，则输出ASC2码所对的字符0 的ASC2码是 48 A 65 a 97 小写字母 - 大写字母 &#x3D;&#x3D; 32科学计数法赋值: float a &#x3D; 3.2e3 //3.2*1000%e 以科学计数法表示数字WORD 双字节 16bit DWORD (double word) 32bit正数: 原码 &#x3D;&#x3D; 反码 &#x3D;&#x3D; 补码负数: 反码 &#x3D;&#x3D; 原码除符号位取反 补码 &#x3D;&#x3D; 反码 + 1 (若最高位进位，则进位舍弃)数据存储时，把 -0 定为区间最小值: 1111 1111 (-127) 1000 0000 (-128) 对于8bit数据，取值范围是: 2^7-1 ~ -2^7%s 输出一个字符串，遇到\\0停止\\0 代表字符串的结尾 printf(“hello\\0 word\\n”); 输出的只有helloscanf(“%d,%d”,&amp;a,&amp;b); 键盘输入的时候应严格双引号中的格式输入，只能输入 整数，整数 不能输入 整数 整数 或其它格式。putchar getchar 只能对单个字符进行操作所有非 0 的值都是真值C语言浮点型数据不能取余单目运算符优先级高于双目运算符int a &#x3D; 10; int b &#x3D; 20; 则 a &amp;&amp; b &#x3D;&#x3D; 1强制类型转换不考虑四舍五入，后果是损失精度，系统自动类型转换时也会损失精度(int) a*b 是先将 a,b 损失精度，再计算结果 (int) (a*b)是先保留精度计算，再损失精度表达式 ? 语句1 : 语句2 表达式为真，执行语句1，否则执行语句2switch 中可加 default 并且 case 后要接 breakfor 循环可以有多个判断代码，需用 , 隔开，只要一个表达式不满足就跳出循环goto FLAG; ………… FLAG: …………数组下标必须是常量，不能写为下例：int i &#x3D; 10; int arr[i];当一个数组初始化（开辟内存空间）时，内部元素默认是乱码。只有当赋值时，默认才是0eg： int arr[4] &#x3D; {1}; &#x2F;&#x2F;内部元素：1,0,0,0 int arr[4]; arr[0] &#x3D; 1; &#x2F;&#x2F;内部元素：1,数字,数字,数字数字 0 等同于 \\0 但不等同于字符 ‘0’char arr[] &#x3D; “hello”; 此时arr数组共有6位（最后一位是\\0）char arr[5] &#x3D; {‘h’,’e’,’l’,’l’,’o’}; 此时只有六位，打印的时候到 o 不会停止，会继续打印乱码，所以char arr[n]的数组只能存储n-1个字符scanf接收到空格或回车就代表接收的结束gets() 与 scanf() 的区别是，get 能接收空格，scanf 则不能sizeof() 测量字符串数组长度时包括 &#x2F;0 strlen() 则不包括函数返回值传给寄存器后内存中的函数会被销毁函数声明: extern int fun_name( type a, type b ); &#x3D;&#x3D; int fun_name( type a, type b ); &#x3D;&#x3D; int fun_name( type , type ); 可以不用写在主函数之内声明不需要内存exit(); 在子函数中使用主函数也会退出导入自己的头文件用 “myfile.h”#ifndef “myfile.h” #define 文件名 #endifchar 占1个字节分配1个地址 int 占4个字节分配4个地址win 存储方式是小端对齐 即 低位数据存在低位地址中&amp; 是取址符号，是升维的 * 是取值符号，是降维野指针: 指向某一个未知空间的指针变量int const *p &#x3D;&#x3D; const int* p 只能给 p 赋值，不能给 p 指向的变量赋值 因为 const 离 “*”近 int* const p 只能给 p 指向的变量赋值，不能给 p 赋值，因为 const 离 “p” 近指针 +1 &#x3D;&#x3D; 内存地址 +(sizeof(type 指针))数组做为函数参数时会退化为指针，损失数组的大小信息，所以需要额外的数组长度做为函数参数p[-2] 等于当前指向某一数组的指针 p 向前数2个的那个元素2个指针相减后的结果是步长，不能相加int* arr[3] 指针数组arr[i] &#x3D;&#x3D; *(arr+i)一级指针加偏移量相当于跳过元素，二级指针加偏移量相当于跳过一维数组 ‘ 字母 ‘ 代表字母的ASCII码值，并可以用 %c 输出其值 while 是先判断后执行主函数是程序的入口，是程序首先执行的函数全局变量作用域 : 整个项目的所有文件，其他文件调用时需要声明 extern int a; 生命周期是从程序创建到程序销毁全局变量可以与局部变量重名，调用时程序采用就近原则的方法静态局部变量在数据区存储，只会初始化一次并且发生在函数创建前，作用域 : 函数内部 生命周期 : 从程序创建到销毁 ( 作用域与局部变量一样，生命周期与全局变量一样 )静态全局变量作用域 : 只可在本文件中使用，但不能在其他文件中使用，生命周期 : 从程序创建到程序结束定义函数默认是全局的，可以在其他文件中调用，静态函数只能在本文件中使用，即使在其他文件中声明也不能使用即使没有声明也可以调用函数，但是在 vstudio 转到定义功能不能使用静态函数可以和全局函数重名malloc 开辟的是连续的堆空间栈由高地址向低地址增长，栈底是第一个进栈的数据，栈顶就是最后一个进栈的数据。同理，申请0字节的空间也会报上述错误下图报错原因是对 NULL 指针进行赋值操作。本质上由于68行函数开辟了一个堆空间同时创建形参p，在申请10个int大小的空间后fun08就被销毁了，同时销毁的还有形参p。相当于68行是废语句free 空指针不会报错结构体成员大小按最大结构体成员的倍数取，，下图中， char name 的大小为 21( sizeof(name) &#x3D;&#x3D;21 )，但是偏移对齐过后为24 ( int的整数倍 )typedef 类型名 别名;struct 结构体类型名 {}; struct 结构体类型名 结构体名 &#x3D; {}；&#x2F;&#x2F;注意{}中的变量用 ; 隔开结构体指针 -&gt; 成员 结构体变量 . 成员联合体 union 所有数据共用一块内存空间，只能输出最后一次被赋值的成员文件操作中的分隔符推荐以 &#x2F; 正斜杠表示，如果是反斜杠，则需要输入两次读取文件若干个字符时不能修改文件指针，文件在读取时指针会自动向下加 1文件默认结尾是 -1 和 EOF结构变量名不是地址for函数条件用 ; 隔开可以将枚举值赋给其他变量define 只做替换，所以不加 ; 否则会出现 #define NUM 3; printf(“%d”,3;);退出函数后，static的变量不会被销毁，仍然保留在静态区内，但是此变量只能在本函数内部使用define 在预处理阶段有效，仅作字符串替换，typedef 在编译阶段有效，因此会做类型检查&amp;&amp;: 逻辑与 &amp;: 按位与 || : 逻辑或 | : 按位或左移丢弃符号位，右移补偿符号位数字前面补零编译器会认为是八进制数字，因此数字为09时编译器会报错博客链接volatile用法：如果开启了编译器优化，或者利用无意义加减变量进行其他工作，亦或者多线程编程，读写与硬件相关的存储器时，需要加volatile关键字，防止编译器优化并提示编译器注意一致性问题，使其每次使用变量时都要去内存中取值。 一个参数既可以是const又可以是volatile么？ const volatile常用在对于状态寄存器重新读取数值的时候，因为状态寄存器的值易变，因此加volatile，因为程序不应该修改状态寄存器的值，因此为const 一个指针可以是volatile的么？ 可以但不常见，当需要一个经常被修改的指针时需要这么做，比如在中断子程序中修改的buffer指针 上述答案详解 SRAM没有电容结构，因此充放电比DRAM快，读取数据也就比DRAM快，并且也不需要刷新数据需要使用malloc来申请结构体的情况: 结构体大小需要动态分配(结构体内包含本身的指针) 结构体生命周期较长，需要在函数结束时不销毁结构体时需要 对性能要求不大，在栈上分配和释放内存通常比堆上快，对性能不做要求时可以使用malloc即使在函数参数给出了const限定，但是依然有变量被更改的风险12345678910111213141516171819#include &lt;stdio.h&gt;int add(int* const a,int* const b)&#123; int* temp1 = a; int* temp2 = b; *temp1 = 6; *temp2 = 4; return *a+*b;&#125;int main()&#123; int a = 5; int b = 3; int c = add(&amp;a,&amp;b); printf(&quot;%d\\n&quot;,c); return 0;&#125; ::: alert-danger结果是10:::对新生成的链表进行操作时，注意新生成的链表的内存是否是malloc动态分配的，否则会出现Segmentation fault(为啥啊？)define定义宏的时候不用括号括起来可能导致运算错误 12#define N 3+2int a = N*N; //a = 3+2*3+2 内存对齐 为什么要进行内存对齐 32位计算机是以地址为4的倍数读取数据的，如果不进行内存对齐可能会引发CPU额外进行数据裁剪与合并操作，降低CPU效率 怎样计算内存对齐？ gcc中默认#pragma pack(4)，即默认内存对齐有效值为4字节，我们可以在编译器内设置这个值。结构体一个成员的大小为有效值和那个成员的整数倍，并且满足结构体总大小为内存对齐有效值的整数倍 1234567891011121314151617181920212223242526struct&#123; int i; char c1; char c2; &#125;x1;struct&#123; char c1; int i; char c2; &#125;x2;struct&#123; char c1; char c2; int i; &#125;x3;int main()&#123; printf(&quot;%d\\n&quot;,sizeof(x1)); // 输出8 printf(&quot;%d\\n&quot;,sizeof(x2)); // 输出12 printf(&quot;%d\\n&quot;,sizeof(x3)); // 输出8 return 0;&#125; ##可以表示粘连两个字符串，例如下面使用##定义了两个不同的变量NAMEa与NAMEb 123456789101112131415161718#include &lt;stdio.h&gt; #define NAME(n) int_name##n int main() &#123; int NAME(a); int NAME(b); NAME(a) = 520; NAME(b) = 111; printf(&quot;%d\\n&quot;, NAME(a)); printf(&quot;%d\\n&quot;, NAME(b)); return 0; &#125; 结果：","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-10-13T05:36:44.069Z","updated":"2023-01-29T09:24:20.000Z","comments":true,"path":"2023/10/13/hello-world/","link":"","permalink":"https://wumingzi.top/2023/10/13/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"百年工业","slug":"百年工业","date":"2023-02-07T06:47:09.000Z","updated":"2023-02-07T07:25:10.000Z","comments":true,"path":"2023/02/07/百年工业/","link":"","permalink":"https://wumingzi.top/2023/02/07/%E7%99%BE%E5%B9%B4%E5%B7%A5%E4%B8%9A/","excerpt":"百年激荡 资本主义 100 年所创造的物质财富超过了以往一切时代的总和 —— 卡尔·马克思","text":"百年激荡 资本主义 100 年所创造的物质财富超过了以往一切时代的总和 —— 卡尔·马克思 前工业时代为了阐述工业体系的奇特之处，我们必须回到广义的工业革命之前，也就是大概1600~1700年。尽管距离珍妮机的出现还有一段不短的时间，但在历史上的科技进步思潮来说，这一段时间，世界发展模式发生了重大变化。欧洲从黑暗的中世纪走了出来，攫取着五大洲的财富，美洲正在开荒，东亚的明王朝余威尚在，南亚印度莫卧儿王朝虽然即将走向分裂，但尚可维持统一，中东的奥斯曼帝国如日中天。更重要的是，对于后世影响极为深刻的发明发现在此时涌现。需要强调的是，这些发明发现连接了人类农业时代与工业时代，沟通了人类的理性认识与感性认识，尽管在不同地区这些特点有所不同，但不可否认的是这一段时间是人类进入定居农耕后绝无仅有的经历。就我个人观点而言，这一段时期的重要性甚至超过了由铜器时代发展到铁器时代的重要性，是仅次于工业革命的辉煌时期。下面列举几例这期间的科技爆点： 1596年中国李时珍《本草纲目》 1637年中国宋应星《天工开物》，同年法国笛卡尔创立解析几何. 1639年中国徐光启《农政全书》 1643年意大利托里拆利发现了大气压，11年后马德堡半球公开实验 1653年法国帕斯卡发现帕斯卡定律 1661年英国玻义耳提出元素定义,把化学确立为科学 1665年英国胡克首次用显微镜观察植物细胞 1670s年牛顿和莱布尼茨分别创立微积分 1676年丹麦勒麦证明光以有限速度传播 1676年法国马略特发现气体的玻义耳-马略特定律 1703年德国施塔尔将燃素说系统化 1712年英国纽可门制成第一架实用蒸汽机 前工业时代科技发明发现的特点 这些发明发现大多是全面性的，总结性的知识或者思想前卫的理论的非直接应用于生产性质的。 这些发明发现是农业时代的集大成之作，也是工业时代的先导。 这些发明发现彼此关联不大，即使有关联的因果关系也不明朗，甚至出现实际应用早于理论提出的现象。 这些发明发现最主要出现在东亚和欧洲，且两个地区的发明发现有着迥然不同的特点。而南亚次大陆，伊斯兰传统地区以及中亚的发明发现则很少，北非以南基本没有。 这些发明发现集中涌现，频度广度超过了此前任何时代。 相关特点的解释工业革命之前人类首先要满足自己的生存需要，对于事物内在的联系和特点则不太关心，对其有深入研究的多是在社会中占据统治地位的人，他们占据了劳动产品的大多数，少数对事物发展原理有浓厚兴趣的人就成了古典的哲学家和博物学家。受限于知识经验的匮乏，他们的研究多是广博而不深入的，形成的知识经验体系也是框架式的指导性的哲学，所以不能产出深刻的本质理论且难以运用于生产。尽管研究的不彻底，但相关研究的基础是农业时代积攒千年的经验知识。因此，这种工业革命前期的研究具有全面性先导性的特点，且那时人们对庞大的农业手工业知识需要梳理，而因受战争瘟疫影响下人均资源较为丰富的社会环境也有助于人类科技的进一步发展，这两点就导致了发明发现的集中涌现。此时的农业时代的生产力远非之前各种时代所能比的，这样，各种发明发现出现如此的烈度也就不奇怪了。可理论不深刻的后果就是这些发明发现彼此是孤立的，那些这些哲学家和博物学家并没有发现他们之间的内在联系。当时的手工匠人还是依靠经验进行生产，比如，在制糖业中，搅糖师傅要依靠眼力和手感判断出糖的时机，烧火的师傅需要用皮肤和眼睛感受火炉温度的变化，尽管在随后的工业化进程中出现了专职搅拌蔗液的机器来取代制糖师傅，还有仅靠训练几天就看懂温度计的童工来取代烧火师傅，但是此时的生产还是应用高于理论，人们对温度，工艺经验和定量考察的联系认识不足。直有到了第二次工业革命科学家工程师群体才成为推进世界生产技术进步的重要力量，在此之前，成为一名手工匠人依然是普通人最好的出路。从农业社会的历史角度来看，传统的强势农业政权一共有三处，分别是位于地中海沿岸的欧洲，位于两河流域的中东以及地理位置较为封闭的东亚与南亚。其他的地区如中亚或者印度周围强敌环伺，不仅面临传统农业强权的竞争压力还面临着北方骑兵的威胁。对于中东来说，奥斯曼帝国建立后占据着东亚与欧洲沟通的必经之路，这时以国家的名义收过路费显然是收益率最高的方式。于是，本来可以凭借亚欧路上沟通进而搭上工业革命的浪潮的中东终于在欧洲人发现新航线之后落后了，而东亚和南亚本来作为新航线的目的地的打算也在哥伦布误打误撞的发现新大陆的现实下消失，在美洲种植甘蔗和香料远比亚洲容易得多，自此，中国和欧洲的科技模式发生了变化，彼此走向了不同的发展道路。 机器时代世界背景上述的发明发现彼此孤立，倘若没有煤铁，没有自迭代的加工技术的话我们大概率还会停留在比较发达的农业社会，经历着几百年的农业周期。但是，人类运气比较好，自从蒙古铁蹄踏破了亚欧大陆后，蒙古人带来了战争和瘟疫，也同时带来科技与生机。瘟疫战乱使欧洲的人口快速减少，破坏了传统基督文化削弱了教会势力。蒙古势力阻碍中欧交流的同时迫使西方开启大航海时代，间接促进了新大陆的发现。而传统教会势力的孱弱也给了文艺复兴一个绝佳的机会。 这样，绵延百年的战乱瘟疫所导致的中西欧劳动力匮乏与宗教势力的削弱，迫使了新科学的出现，新技术的应用以及新航线新大陆的发现。至此，一个空前的农业周期出现在欧洲，无尽的白银香料糖流入欧洲再流向中国。同时输入性通胀带来的无尽财富使得明政权不思进取，由外部环境导致的内部压力导致了千年来最严格的海禁，这更为欧洲带来了绝佳的机会，此时南亚的莫卧儿王朝也处在分裂中，这里有无限的劳动力和市场等着欧洲来攫取。随着航海时代的来临，荷兰由于其独特的国家模式，迅速的成为一支不可忽视的力量。在荷兰霸权的后期仍然可以组建一支14万人的雇佣兵部队与法国作战，而这时是1687年。但荷兰的霸权是必然的，原因有很多，例如过度投机的国家模式，狭小的国土与过少的人口。无论怎样，荷兰霸权不会永远持续下去，获胜者不管是英国法国还是普鲁士，这都不影响接下来发生的事。 煤，铁和布早期的工业是分工细化的手工业，例如玻璃作坊有专职烧火的，专职制作玻璃液的，专职吹制玻璃的，纺织工场有专职煮棉的，专职纺线的，专职织布的。在手工业中，最枯燥，最耗费劳动力的莫非纺线和织布。早在珍妮机之前，英国人也在改良生产工具，但是珍妮机及其改进型的效率使得它的前辈都相形见绌。 对劳动力渴望的还有煤矿，自古以来，下矿都是一件极其耗费心力体力的事，劳动强度大，死亡率高。在奴隶制时代，也只有奴隶才下矿井，封建时代，就只有卖身奴，契约奴和战俘和囚犯才干这事。人们对煤的需求并不是天生的，但早期农业的燃料获取和战乱破坏了地表植被，人们不得不寻求更廉价更以获取的燃料来源。冶铁业比较发达的国家需要各种炭类来提供普通燃料达不到的高温，但是开采煤矿经常伴随渗水，一旦地下的含水层被打破，排水问题始终难以解决。在蒸汽机出现之前一般靠人力或者畜力运用机械排水，效率低耗时长。在纽可门发明第一台实用化的蒸汽机之后，排水的问题便被解决了。在此强调一点蒸汽机的材料是铁，燃料是煤，工质是水。但是这种类型的蒸汽机效率很低，但是无所谓，有了需求总会有人改进的。 煤矿里的另一个问题是运力。煤矿多于山上，道路崎岖运煤困难，早期的解决方案是用硬木做成木轨，马拉货车运煤。但是这种方式运力低下费用高昂：在机器时代马还是昂贵的牲畜。解决这一问题的是瓦特，尽管瓦特并没有做出蒸汽机车，但最早的蒸汽机车结构就是把瓦特的蒸汽机小型化搬上了轨道车。此时是1804年。这样，由煤（需要排水） — 铁（需要高温） — 机械加工技术 — 蒸汽机（需要能源和工质） — 煤（需要排水） 的工业循环就初步形成了。 但是这时的工业爆发还缺少一个临门一脚的条件 — 那就是能够发展上述循环的自迭代的功能。如果没有这个条件的话，这次的技术爆炸可能在人类历史上只不过是一轮非常不错的农业周期，最终农业政权还是会走向分裂，战争，导致人口减少，然后再次重启一个新的周期。然而这个条件是人类走向那时那刻的必要条件，没有它，人类绝不会造出蒸汽机，绝不会改进纺织机，也绝不会把荷兰拉下海上霸主的地位而这个条件就是以机床为代表的机械制造技术和熟练工人。蒸汽机的核心部件是气缸，要想做出不漏气又可滑移的气缸需要足够精密的机械加工技术。为了提高蒸汽机效率需要提高缸内气压，这又进一步对加工技术和材料提出了更高的要求，从而促进了发现品质更好的煤铁矿，改进更优良的工艺。此外，机床的制造也需要更精密的加工技术更优良的材料和更优秀的工人。 至此，煤（需要排水） — 铁（需要高温） — 机床（能够自迭代） — 蒸汽机（需要能源和工质） — 煤（需要排水） 的循环已经进化为 更多更好的煤（需要排水） — 更优质的铁（需要高温） — 更精密的机床（能够自迭代） — 性能更好的蒸汽机（需要能源和工质） — 比循环之初还要更多更好的煤（需要排水）。现在只要有一个动力让这个循环持续下去那么工业革命就到来了。那么是什么推动了这个循环呢？—— 是利润。 其实推动工业循环可以不是利润，例如初期的苏联采用了指令式的计划经济，那时推动工业循环的是忍受统治压力和竞争压力的技术官僚所推动的。但是在此时的欧洲，资本主义的奴隶贸易风头无两，因此相对于保守的封建主义，发展工业最成熟的工具只剩下资本主义了。利润的条件一旦满足，无论是何种产业，只要利用上述三个条件这个循环就会永无止境的运动下去。最早担当这一重任的产业是纺织和远洋物流。首先说纺织，上文提到，纺织业需要大量劳动力纺线织布，而有了瓦特蒸汽机车作为动力源，珍妮机便织出了巨量财富。又密又匀的机器布远非手工布所能比的。这样，依靠着全球殖民体系，在几十年的时间内英国机械纺织业便打垮了印度持续千年的繁荣手工纺织业。对于远洋物流来说，最早的动力是人力以及风力，而有了蒸汽机之后，船舶的航速航程便极大的提高，更重要的是在逆风条件下的船速稳定性也会显著提高，这不仅提高了民用货船的运输效率，而且还提高了海军和海盗的机动力。于是，物质信息流转速度显著提高，资本周转速度，利润积累速度显著变快，世界被更紧密的连接在了一起。进一步，由机器产生的更多的利润被用来扩大再生产，产生出比原来多得多的利润被再次用于投资，工业体系迎来了指数级别的增长。 第一次工业革命爆发了。 工业革命的代价任何有利事物都有其相反面，这种相反面总给人类不利因素，这就是代价。工业革命作为人类历史上最为重大的事件，极大地便利了民众生活的同时也带来了极其惨痛的代价。欧洲人做梦也想不到，在爆发了两次工业革命的土地上竟然戏剧性的爆发了两次世界大战，在付出了上亿人生命之后把世界霸主的地位送给了美国，并且几乎是错失了第四次工业革命。除了战争外，在工业革命的早期，环境的破坏以及工作环境的恶化甚至让普通民众生活水平还不如农业时代，资本原始积累带来巨大的贫富差距，不合理的城市化政策让数以万计的贫民死于火灾和空气污染，频繁的经贸摩擦带来的政治甚至军事摩擦也为民族主义和世界大战埋下伏笔。 电气时代世界背景电气革命的源头实际上与机器革命爆发是同一时期的，早在1746年莱茵瓶就诞生了，而在1780年伽伐尼发现的电流更激起科学界的极大兴趣。直到1799年伏特堆诞生，真正意义上的的电力时代开启了。此时工业革命的先发地正处于增长的狂欢中，百年的殖民历程和数十年的工业积累让日不落帝国的赫赫威名响彻全球。但是第二次工业革命首先爆发在德国和美国。早在一战前，德国就已经完成了工业化的整合，凭借着优越的煤铁矿，德国在鲁尔区整合成了欧洲最大的煤钢联合企业，美国由于其得天独厚的自然资源和地理优势以及百年建设，在一战前建成了世界最大的工业国。同时，渴望劳动力与市场的为代表的同盟国与已瓜分完毕现存殖民地的协约国有着结构性矛盾，这一矛盾直接导致了一战的爆发。 电气设备，内燃机及化学工程与科研人员第二次工业革命与上一次形式相同而内容不同。上一次工业革命的是以 蒸汽机 — 煤铁复合体 — 机床 — 蒸汽机 为循环的，这次是以 电气设备&#x2F;内燃机 — 石油&#x2F;电气寡头 — 机床 — 科学家 — 电气设备&#x2F;内燃机 为循环的。这一循环比第一次周转更快，技术水平更高，初步展现了工业体系的复杂。 其中电气设备&#x2F;内燃机为工业循环提供动力，电机的出现使得世界能源格局出现重大调整，人们不必以煤矿为中心建设经济，这直接导致之后的传统工业区衰落。实际上，这种能源格局的调整相比当时重要的电气发明并没有多么立竿见影，把电气设备抬上第二次工业革命宝座的是电子通讯设备。在电子通讯设备出现之前，人类传递信息的能力与传递宏观物质的能力是一样的，除了少部分用生物，光学等耗资巨大且消息传递不准确的途径外人类再也找不出其他更快速更准确的信息传递方式了。但是自从1837年电报诞生后，人类沟通全世界的雄心与日俱增。在仅仅11年后，世界第一条海底电缆横空出世，又过了8年，世界第一条跨洋电缆完工，而此时是1858年，距离我们熟知的近代史开端仅仅过去了18年。 19世纪中叶就有了内燃机的设想，只不过当时充当燃料的是煤气。随着石化工业的发展，一种在原油中占比巨大的燃料进入了人们的视野。早期机械工艺能力不过关，而汽油机结构复杂，因而第一台实用化的内燃机是用于发电和船用的结构简单的大型柴油机。归根结底，内燃机的原理与蒸汽机相同，只不过工质由水变为燃油。但是内燃机对材料和润滑的要求很高，对机械加工技术要求更甚。但材料依靠上次工业革命的铁基合金，润滑依靠石化工业，做到这两点都不难，唯一的问题是机加工技术，这一点需要足够的时间和市场来保证。 如果说体现第一次工业革命的化学水平是三酸两碱，那么第二次工业革命的代表化学产物就是代表实际应用的有机化学。此时的化学工程主要为机械产品服务，无论是钢材的冶炼，表面处理，硫化橡胶，还是工业油的生产，木质机械的化学处理，这些都占据了化学产品的大部分。少数其他行业如绝缘塑料，化肥，炸药，医药等产品，虽然在今天看来无比重要，但是在当时这些产品还未发展成熟且产量较低，少数的高产量成熟产品也主要被用于战争，典型的是炸药和医药。那时的发明家无论如何也想不到，为人类移山填海的炸药竟然被用来消灭人类自身，而检验救死扶伤的医药产品的最方便方式竟然是战争。无论如何，化学工业在这次工业革命中雨中春笋般的涌现出来，他将会在二战后迎来属于他的高潮。 科学家群体早在前工业时代就活跃于各个领域，但那时的科学家的研究主要依靠个人兴趣，并且大多涉猎广泛。大量直接应用于生产的科学研究发生在此次工业革命。第一次工业革命参与者主要是各种手工匠人，他们依靠经验来改进工艺和机器。这很容易理解，工业革命早期生产资料匮乏，没有足够的试验器具供科学家们研究，少数能靠大脑推理演绎得出可靠结论的都是万里挑一的天才。但自从此次工业革命以来，大量的质量优秀的仪器被开发出来，科学家们首次运用大量仪器以量的角度观察这个世界。更振奋人心的是，此时的原动机，机械加工设备和化工过程的复杂度抽象度远超第一次工业革命，这正需要科学家解密原理以更好的应用在生产过程中。并且从上述分析可知，这时 生产 — 科学家 — 生产 的循环也建立起来了，工业革命将继续以生产出超越以往所有世代物质财富的速度进行下去，甚至包括第一次工业革命。 世界大战无论如何改进技术更新产品，工业循化的形式是不会发生根本变化的，但是工业循化的内容是会发生变化的，比如原动机由蒸汽机变为内燃机能源由蒸汽变为电力等，这是由于工业自迭代的本质所决定的。另一个不发生变化的是工业循环的动力。无论动力是什么，工业循环总是需要动力持续下去的，只不过现在的动力是利润。 产生利润，意味着必须要有劳动力和原材料把产品生产出来，然后再把产品拿到市场上交换，并且必须被交换成功，此时利润便产生了。因而，产生利润需要两点条件： 足够的劳动力，原材料和生产工具 能够成功交换即产品占有市场一战前夕，殖民地被英法俄瓜分完毕，英国拿到了最肥美的运河，南亚，北非，南非和北美，法国获得了除英国外的绝大部分非洲，俄国得到了东亚，中亚，中东的一部分，以及东北欧的一部分。后发的以德国为代表的国家，因为落后了第一次工业革命而没有足够的殖民地。但在第二次工业革命中，工业的增长速度远远超过第一次工业革命，这样，德国在战前就超过了英国从而取得了欧洲最大工业国的地位，但足够的产品生产出来却又没有足够的市场致使利润无法收回。为了维持工业循环以保持足够的工业产能，防止被国际竞争压力中压溃，所以德国不得不发动战争。 经过上述分析，一战的爆发可以说是必然。只不过一战的爆发过于戏剧性，包括德国在内每个国家都想保持在第一次工业革命中原有的低烈度战争，可笑的是几乎所有国家都一方面告诫其他国家不要进行动员以保持有限的和平，另一方面惧怕其他国家的动员而又私下进行动员。于是原本不堪重负的工业循环就迅速转向服务于军工产品，而军工产品不直接作用于生产，它的利润是以敌对国家的战败为基础的，要想获得胜利必须在军工业的投资与敌对国家保持同等量级甚至超过对方。随着每个国家都在倍增军工业的投资，欧洲的局势迅速恶化，离大战爆发只差个火星。 这次战争让世人第一次看清工业化的战争的残酷，上千万受过工业化基本教育的士兵被派往战场，数百万标准化的栓动枪械源源不断的从工厂运往前线，几万公里铁路的修建只是为了赢得战争。在此次战争中战争的形式也发生了巨大转变，骑兵在机枪和炮弹的火力下难以突破防线，步兵的机动力受到极大阻碍，以战壕为为核心的绵延不断的多层防线便成为战争的最佳选择，上百万士兵在前进中失去生命仅仅为了十几公里。此外，多种新式战争机器在战争中也被首次运用，典型的是装载了内燃机的坦克和飞机，尽管作用有限，在工业产能的加持下产量迅速增长且下次战争中他们中的任何一个都会发挥更为巨大的作用。同时，新兴的化学工业也被运用在战争中，氯气的使用对这种绵延防线有巨大破坏，但是由于难以预测风向而运用较少。海军主要起保证贸易网的作用，主要作战舰艇是受巡洋舰保护的战列舰和潜艇。因德国开启无限制潜艇战之后误伤了美国客轮，这给美国下场留下了借口，随着美国下场，本就在作战兵力和自然资源都难以为继的同盟国更加雪上加霜。 历经四年的战争以德国战败为结束，原有的阿尔萨斯洛林被割给了法国，莱茵兰也被划为非军事地区，东部的土地被划给了波兰，实际上，德国的战败并未伤害到德国的核心利益，原本意图得到殖民地的德国仅仅是失去了一次机会。相比较协约国的处境就很尴尬，法国人付出了120万人死亡的代价仅仅得到了半个工业区和若有若无的战争赔款，更何况同盟国根本支付不起。英国人付出了90万人死亡的代价仅仅维持了表面的世界霸主地位，而德国付出了170万人死亡的便做到了重创英法联盟，并且顺便把俄国皇帝赶下了台。奥匈帝国被一分为二，匈牙利得到了梦寐以求的独立地位。俄国承受了不能承受的战争负担因此迅速走向分裂，最终退出了战争并且在战争结束后建立了世界第一个无产阶级政权。这次战争最大的受益国是美国和日本，前者大发战争财，后者得到了德国在东亚殖民地的主权以及喘息的时间。 这场终结一切战争的战争除了战争外终结了一切，风雨飘摇的德国经济得到了美国的注资，一代人的伤亡会将用一代人的时间来抚平，可仇恨不会。得到了注资的德国重新焕发经济活力，9年后德国经济恢复到战前状态。又过了一年，德国经济地位重新回到世界第二，欧洲第一的战前地位。对殖民地和原材料的渴望同时也夹杂了对英法的民族主义仇恨推动了德国再次走向世界大战。但是这次不同，随着德国进入莱茵兰，吞并奥地利，英国的绥靖政策使法国以及一系列小国彻底失望，强硬的协约国再也不复存在。此时，法国因为一战损失了一代人而不想发动总动员，发动总动员的前提是英国也对等总动员，但随着德国入侵波兰，英国的保独政策终于起效，法国也随之对德宣战。 这次战争的残酷是绝无仅有的，原本在一战中崭露头角的武器在二战中迅速发展。随着化学技术的提高多种新式炸药被研制出来，炸药的威力逐步增加，安全性和烟尘问题也得到一定改善。在化学技术迅猛发展的同时，传统的机械控制在二战时也达到顶峰，新式的火控系统让坦克和火炮成为新的陆战主力。而空军由于石化技术的提高和飞机整体设计的进步在战争中得到了广泛的应用。在海军方面，以巡洋舰，战列舰保护的航母是主要作战核心，这一配置打败了以战列舰为海战核心的作战思想。在陆战方面，内燃机的运用使陆军的机动力大幅提高。相比一战的弹性防御的堑壕战思想，二战的机动作战能够迅速将堑壕分隔包围，没有补给的堑壕战犹如瓮中之鳖。典型的案例是德国对抗法国，装备了内燃机的坦克和现代化的运输卡车使得德军能够绕道阿登森林直取巴黎，这100公里的行程仅仅用了2天，而一战时，这个数字是2个月。于是从入侵法国到法国投降，德国装甲部队仅用了6个星期就完成了这一壮举。电子设备的出现使得不同部队配合程度大幅提高，因此主动的，进攻式的作战策略占据上风。依靠无线电台，指挥部可在千里之外收到侦察机的信号，这使得战场范围迅速扩大。东线战场上，由于苏联战前准备不足，内部大清洗还有余波，因而战争前期迅速失去大部分土地和工业，好在两个五年计划给了苏联足够的工业实力，使得苏联培养了足够的士兵和技术干部。相比德国的资源匮乏走的技术路线，苏联合理利用资源走了一条数量路线，在人员装备方面量大压倒了质优。在斯大林格勒战役中，前期由于德军战斗经验和装备精良使德军迅速的推进到城内，而在城内，战争的废墟阻挡了德军现代化的坦克和空军部队，并且由于气候的严酷和补给的缺乏更使得德军单兵实力大大下降。终于，苏联的兵力优势以及顽强的抵抗斗志占了上风，德军在斯大林格勒遭到重大挫败。之后在库尔斯克会战中，成群的 T34 击败了 “虎式”“豹式”，量大管饱的炮火让德军吃尽苦头。从美国正式参战开始，德国就必定走向失败的道路，战前的美国工业实力是英法德的总和，控制的资源更是德国急缺的石油和橡胶。于是，二战的结束只是时间问题了。东亚战场上，日本的工业实力甚至没能超越意大利，中国的工业实力连日本都不如。因此亚洲战场不在本文叙述范围内。 信息时代世界背景二战后，世界格局发生重大变化，传统的英帝国被打成废墟，德国被一分为二。美国依靠百万奴工和两次世界大战大发横财，苏联依靠计划经济抄底大萧条崛起。在东欧和东亚，苏联占据主导地位，在中西欧和美洲，美国占据主导地位。两极格局正式形成。从民用工业体系角度来看，美国在汽车，石化，食品，农业等产业占优，基础机械，基础化学更甚。而苏联在军事工业上占优，在枪炮坦，航空航天，纺织，基础材料加工，大宗原材料生产方面占优。但总体而言，苏联的生产效率是远不如美国的。 核能，集成电路与传统专门工业的巅峰核能一个应用路线是用作武器。核武器的出现尤其是实战令各国震惊不已，特别是当核武器被无法控制战争的烈度的人类掌握时，核武器的威慑力就大大增加了。核不扩散条约于1968年被联大审议通过，尽管我们知道印度，巴基斯坦，朝鲜都“非法”拥有核武器。这使条约看起很可笑，但我们可以从这一点看出，核武器作为平衡国际国际实力的有效手段是可以被“允许的”，前提是要支付代价。这也是在委婉的表达：核武器并不能毁灭世界，甚至连毁灭人类都不可以。从目前的和武器数量来说：它最多只能把人类现有的中大型城市毁灭，广大的乡村地区不属于它的工作职责。 核能另一个路线是能源，它与第二次工业革命的成果结合就是核能发电。核裂变发电我这里先不谈，这种发电方式不仅没有什么前途而且在人类总发电量中只占很少一部分。与之对应的核聚变发电的方式被视作解决人类能源的最终方法，因为在已探明宇宙中氢元素丰度最高，按质量算约占宇宙可见物质的四分之三，而可供聚变的氘和氚在氢元素中约占十万分之三，也就是说哪怕是在人类宇宙航行时最可靠的能源来源依然是核聚变。合适的聚变温度应在5千万-2亿度，因此现在聚变发电的难点在于控制高温粒子流不把容器打穿，而保护容器的难点在于研发恰当的材料以及提供快速准确的控制方式。可控核聚变作为庞大的系统工程，其实施难度，应用可行性远超前人预料，在通往解决人类能源问题的道路上我们还要准备过渡方案。 但在这里需要强调的是，核聚变作为人类可能的终极能源并不能解决人类社会一切矛盾。一种比较广泛的观点是，廉价的能源有助于人类到达“理想国”。但是不幸的是，包括能源突破在内没有哪项技术是真正的帮助完成这种最终的理想社会的。一千年之前人们把理想社会的实现建立在农业和水利工程的技术进步上，五百年的人认为繁荣和平的航海贸易就能建成人间天堂，到了一百年之前，理想社会就变成了苏维埃和全国电气化。如今只不过是把可控核聚变这层皮给披上去而已，无视了其他因素有尤其是社会因素的重要作用。对于建成理想社会的相关问题我的想法还不成熟，需要时间的磨练，我打算日后再谈。 集成电路考虑到集成电路的极端重要性，我这里有必要单开一节来论述集成电路。 集成电路的出现反映了人类对于计算的需求，自从第二次工业革命以来，人类对于客观世界的认识由质的层面飞跃到量的层面。等待着科学家和工程师们的是无穷尽的客观条件所决定的各种物化参数，这种计算复杂量远远超过传统查表计算和计算尺计算的能力，新的计算工具呼之欲出。最早担任这一重任的是机械式计算机，这种计算机早在二战时期便已大规模应用，具体原理就是利用机械运动来做出能够进行基本计算的零件，进而由这些零件和其他辅助计算的部分组成整体式的机械计算机。无论是密码破译，核定经济，计算强度、产率，还是计算弹道，船舶运行参数，设计飞行器等老式的计算机都有大规模的应用。但是这种计算机有着价格昂贵，速度慢，难以维护等缺点，因此在真空管出现后被迅速取代。 早期的真空管也称阴极射线管，其主要结构是一个内部含有电子放射源和收集电子装置的真空管，并且在放射源和收集装置之间还有与真空管外部相连的可以收集电子的回路。这样，只要持续给放射源供电，放射源就会发出电子，这些电子经过未导通的电子回路可以到达收集装置，但如果电子回路被导通，放射电子就会优先被收集电子的回路所吸引，电子就不能到达收集装置。我们把发射源叫做发射极，收集装置叫做集电极，收集电子的回路叫做基级，这样用基极就可以控制集电极的导通与否了。 有了基本的真空管和二极管，我们可以做成基本门电路，有了基本门电路后，我们还能做出复杂的逻辑电路。例如，可由四个与非门组成的JK触发器进一步组成T触发器，从而实现计数功能，计数的位数由JK触发器的个数决定，若再由若干门电路和二极管便可组成译码器，使得计数器可以将结果显示在十进制的数码显示管上。有了复杂电路后人们就可以应用于生产和科研，比如新的电子式的显示设备取代了机械式的数字显示设备。 集成电路复杂的逻辑首先被用在设计计算机上。高速，高可靠性，结构简单的电子式计算机迅速赢得美国军方的青睐。随着晶体管的小型化和MOS管的诞生，集成电路迅速小型化，使其可以装在飞机，坦克，火炮上。集成电路除了被制成计算机，还被广泛用于自动化控制上。早期的控制原件多采用机械式原理，结构庞大成本很高，当集成电路被小型化后，传统的机械式控制迅速被电气式取代，较低的成本高速的计算性能使得工业生产率大幅提高。在新世纪后，集成电路产业的迅速发展催生了互联网， 信息终端设备，工业自动化，信息处理软件等新兴行业，创造了惊人物质财富。 传统专门工业的巅峰二战后的废墟并不能阻挡人们重建家园的愿望，消灭了过剩产品和社会不稳定因素的二战虽然给人类造成了永久的创伤但另一方面也促进了人类科技的蓬勃发展，在和平的历史条件下进步缓慢的重工业在二战中迅速发展，同时各个传统工业门类迅速分化。例如机械这个传统工业门类在二战中与控制领域结合，产生了坦克火炮控制系统，并且同领域的航天也衍生出了飞行控制系统。机械领域与化学领域结合，诞生了高品质合金钢，表面处理工艺。在二战后期，由于战后重建的需要，机械与土木结合促进了工程机械大爆发等等。我们可以看到，这种专业门类的深入化和细分化颇有预见性的为接下来70年的工业化道路指明了方向。 集成电路出现后各门类工业模式发生了变化，它在取代了原有领域的部分产品的基础上也推动了自己的发展。例如，老式的气动管道物流传输系统被广泛用于医院，传媒和政府机关部门。但是及时，准确，易维护，投资低的电子式信息系统成了最新选择，除了少数对物流要求颇高的应用场合还在维持运行，绝大部分的气动管道系统在之后的电子设备大发展的时代被迅速抛弃。这种变化也是那时工业发展变化的一个缩影：代表着先进生产力的，能够节约劳动力的电子式系统占据了绝大部分发展通道，而催生出这一产业的机械化学和材料等产业却只能停留在改进工艺，探索物质新的组织方式这种古板的发展道路上。这种发展模式让人不得不联想第一次工业革命早期，那时传统的第一产业已经达到了发展的巅峰，它们无法再带领人类继续提高生产力了，只有剥削自己榨出足够的剩余农产品帮助工业成长，才能在此之后依靠工业获得足够的发展机会。两种情形对比来看，这实在让人唏嘘。 但总之，无论人类喜不喜欢，这种潮流还会持续下去的，拥抱变化的人努力地活着，墨守成规的人寂静的死去。新式的计算机结合工业的技术在80年代诞生，世纪末已经有了一部分应用，在下个世纪初的头十年是这种技术迅速发展的阶段。 在最后我还要强调一件事，那就是我写在文章开头的那句话：“资本主义 100 年所创造的物质财富超过了以往一切时代的总和。”马克思这句话并不准确，资本主义除了传统的工商业资本主义的形式外，还有农业的，宗教的，军事的等等，作为工具的资本主义是不会创造出如此的丰富的物质世界。我个人更喜欢把这句话改写成这样：“大工业生产 100 年所创造的物质财富超过了以往一切时代的总和”。并且这句话在此时依然是成立的，二战的消耗虽然庞大但而工业发展和恢复的速度更为迅速，这种迅速使得人类在此之前一切物质的生产和消耗都相形见绌。在二战中西欧70%的工业被摧毁，而各国50年代初的经济便达到了战前水平，此时离二战结束不过5年。 总结新世纪前后的工业是我想要论述的重点，但碍于篇幅且本文行文较为抽象，与叙述新世纪的工业模式变化需要详实的数据的情况不，因此关于具体阐释世纪前后的工业变化将另开一文。虽然本文缺失了现代工业发展模式，但强调工业脉络目的已然达成，我们可以从上文总结出工业的特点，这并不妨碍我们所归纳结论的准确性和全面性。这些特点是我从大学四年的学习中获得的经验所总结出来的，我会在力求准确的基础上保证尽量简洁。详细解释将会发在本系列的下篇文章。 工业的特点 ^1 工业需要自迭代系统，自我循环的结构和推动循环的动力。 工业的增长脱离了人力畜力的限制，打破了农业社会发展上限。 工业极度渴望增长，且增长的速度和带来的矛盾前所未有。 现代的工业与资本主义绑定，于是逐利和过剩也成了其根本标志。 经过百年发展，工业中的不同行业分化极其严重，生产过程极其复杂。 工业时代的社会也有危机，并且这种危机不仅频繁破坏性还更大。 满足需求新的工业产品收益丰厚，但产品改良到一定程度收益会下降。","categories":[{"name":"生产","slug":"生产","permalink":"https://wumingzi.top/categories/%E7%94%9F%E4%BA%A7/"}],"tags":[{"name":"工业","slug":"工业","permalink":"https://wumingzi.top/tags/%E5%B7%A5%E4%B8%9A/"},{"name":"机械","slug":"机械","permalink":"https://wumingzi.top/tags/%E6%9C%BA%E6%A2%B0/"},{"name":"历史","slug":"历史","permalink":"https://wumingzi.top/tags/%E5%8E%86%E5%8F%B2/"}]},{"title":"测试","slug":"测试","date":"2023-01-19T09:46:24.000Z","updated":"2023-01-29T09:24:02.000Z","comments":true,"path":"2023/01/19/测试/","link":"","permalink":"https://wumingzi.top/2023/01/19/%E6%B5%8B%E8%AF%95/","excerpt":"本文测试 Markdown，网页排版及渲染","text":"本文测试 Markdown，网页排版及渲染 一级标题二级标题三级标题斜体重点删除 无序列表 1 无序列表 2 有序列表 1 有序列表 2 链接：百度 脚注[^1][^1]: 脚注内容 上标^上标^ 下标下标 分割线 引用1引用2 引用2.1引用2.2 #include&lt;stdio.h&gt; int main() &#123; printf(&quot;代码测试&quot;); &#125; 高亮","categories":[],"tags":[]}],"categories":[{"name":"生产","slug":"生产","permalink":"https://wumingzi.top/categories/%E7%94%9F%E4%BA%A7/"}],"tags":[{"name":"工业","slug":"工业","permalink":"https://wumingzi.top/tags/%E5%B7%A5%E4%B8%9A/"},{"name":"机械","slug":"机械","permalink":"https://wumingzi.top/tags/%E6%9C%BA%E6%A2%B0/"},{"name":"历史","slug":"历史","permalink":"https://wumingzi.top/tags/%E5%8E%86%E5%8F%B2/"}]}