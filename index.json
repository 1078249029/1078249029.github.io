[{"categories":[""],"content":" 日志撰写规范考虑到日志的内容丰富多变性及其篇幅，因此对其规范如下 本规范仅适用于日志，其余博文无体裁要求 日志结构由时间构成，从下至上按顺序时间排列，以年、月为第一级、第二级标题，为了减少工作量并便于浏览内容，日期标题除非有内容产出否则不应标明 为方便迁移数据，日志按照符合doit框架样式(包含shortcode)的markdown语法进行撰写，并且应优先使用标准markdown格式 为了阐明doit格式，现对doit格式做以下规定 doit格式底层为markdown基本语法，但是融合了markdown扩展语法(包括数学公式，emoji等)，并包含doit平台特有的shortcode(如admonition，music，aplayer，bilibili等) 使用doit格式时，对于流媒体平台，除非资源稀有且很难获取，否则应当使用外链来减轻github服务器的压力，尽管可能会由于各种原因导致资源无法访问 使用doit格式时，尽量减少admonition的使用，并尽量使用blockquotes来代替之 日志内容不做限制，凡是无法系统化为博文的均可以发在日志中。因此，音乐，技术，思哲，生活日常均可以发在这里 应当定期或不定期对日志进行系统性总结，即使不能总结的也应当使用markdown的分割线---作为回复总结之前日志的标志 凡是日志均应当使用tag来标志日志分类，由于markdown以及doit不支持单个文章内标记tag，因此日志内部使用了自定义scss来进行标记。使用时只需输入#事件1 就可以标记为事件1的tag了 ","date":"2025-04-07","objectID":"/essay/:0:0","series":null,"tags":[""],"title":"日志","uri":"/essay/#日志撰写规范"},{"categories":[""],"content":" 2030s","date":"2025-04-07","objectID":"/essay/:0:0","series":null,"tags":[""],"title":"日志","uri":"/essay/#2030s"},{"categories":[""],"content":" 2025","date":"2025-04-07","objectID":"/essay/:1:0","series":null,"tags":[""],"title":"日志","uri":"/essay/#2025"},{"categories":[""],"content":" 12月","date":"2025-04-07","objectID":"/essay/:1:1","series":null,"tags":[""],"title":"日志","uri":"/essay/#12月"},{"categories":[""],"content":" 11月","date":"2025-04-07","objectID":"/essay/:1:2","series":null,"tags":[""],"title":"日志","uri":"/essay/#11月"},{"categories":[""],"content":" 10月","date":"2025-04-07","objectID":"/essay/:1:3","series":null,"tags":[""],"title":"日志","uri":"/essay/#10月"},{"categories":[""],"content":" 9月","date":"2025-04-07","objectID":"/essay/:1:4","series":null,"tags":[""],"title":"日志","uri":"/essay/#9月"},{"categories":[""],"content":" 8月","date":"2025-04-07","objectID":"/essay/:1:5","series":null,"tags":[""],"title":"日志","uri":"/essay/#8月"},{"categories":[""],"content":" 7月","date":"2025-04-07","objectID":"/essay/:1:6","series":null,"tags":[""],"title":"日志","uri":"/essay/#7月"},{"categories":[""],"content":" 6月","date":"2025-04-07","objectID":"/essay/:1:7","series":null,"tags":[""],"title":"日志","uri":"/essay/#6月"},{"categories":[""],"content":" 5月","date":"2025-04-07","objectID":"/essay/:1:8","series":null,"tags":[""],"title":"日志","uri":"/essay/#5月"},{"categories":[""],"content":" 4月","date":"2025-04-07","objectID":"/essay/:1:9","series":null,"tags":[""],"title":"日志","uri":"/essay/#4月"},{"categories":[""],"content":" 3月","date":"2025-04-07","objectID":"/essay/:1:10","series":null,"tags":[""],"title":"日志","uri":"/essay/#3月"},{"categories":[""],"content":" 2月","date":"2025-04-07","objectID":"/essay/:1:11","series":null,"tags":[""],"title":"日志","uri":"/essay/#2月"},{"categories":[""],"content":" 1月","date":"2025-04-07","objectID":"/essay/:1:12","series":null,"tags":[""],"title":"日志","uri":"/essay/#1月"},{"categories":[""],"content":" 2020s","date":"2025-04-07","objectID":"/essay/:0:0","series":null,"tags":[""],"title":"日志","uri":"/essay/#2020s"},{"categories":[""],"content":" 2024","date":"2025-04-07","objectID":"/essay/:1:0","series":null,"tags":[""],"title":"日志","uri":"/essay/#2024"},{"categories":[""],"content":" 12月","date":"2025-04-07","objectID":"/essay/:1:1","series":null,"tags":[""],"title":"日志","uri":"/essay/#12月-1"},{"categories":[""],"content":" 11月","date":"2025-04-07","objectID":"/essay/:1:2","series":null,"tags":[""],"title":"日志","uri":"/essay/#11月-1"},{"categories":[""],"content":" 10月","date":"2025-04-07","objectID":"/essay/:1:3","series":null,"tags":[""],"title":"日志","uri":"/essay/#10月-1"},{"categories":[""],"content":" 9月","date":"2025-04-07","objectID":"/essay/:1:4","series":null,"tags":[""],"title":"日志","uri":"/essay/#9月-1"},{"categories":[""],"content":" 8月","date":"2025-04-07","objectID":"/essay/:1:5","series":null,"tags":[""],"title":"日志","uri":"/essay/#8月-1"},{"categories":[""],"content":" 7月","date":"2025-04-07","objectID":"/essay/:1:6","series":null,"tags":[""],"title":"日志","uri":"/essay/#7月-1"},{"categories":[""],"content":" 6月","date":"2025-04-07","objectID":"/essay/:1:7","series":null,"tags":[""],"title":"日志","uri":"/essay/#6月-1"},{"categories":[""],"content":" 5月","date":"2025-04-07","objectID":"/essay/:1:8","series":null,"tags":[""],"title":"日志","uri":"/essay/#5月-1"},{"categories":[""],"content":" 4月","date":"2025-04-07","objectID":"/essay/:1:9","series":null,"tags":[""],"title":"日志","uri":"/essay/#4月-1"},{"categories":[""],"content":" 3月","date":"2025-04-07","objectID":"/essay/:1:10","series":null,"tags":[""],"title":"日志","uri":"/essay/#3月-1"},{"categories":[""],"content":" 2月","date":"2025-04-07","objectID":"/essay/:1:11","series":null,"tags":[""],"title":"日志","uri":"/essay/#2月-1"},{"categories":[""],"content":" 1月","date":"2025-04-07","objectID":"/essay/:1:12","series":null,"tags":[""],"title":"日志","uri":"/essay/#1月-1"},{"categories":[""],"content":" 2023","date":"2025-04-07","objectID":"/essay/:2:0","series":null,"tags":[""],"title":"日志","uri":"/essay/#2023"},{"categories":[""],"content":" 12月","date":"2025-04-07","objectID":"/essay/:2:1","series":null,"tags":[""],"title":"日志","uri":"/essay/#12月-2"},{"categories":[""],"content":" 11月","date":"2025-04-07","objectID":"/essay/:2:2","series":null,"tags":[""],"title":"日志","uri":"/essay/#11月-2"},{"categories":[""],"content":" 10月","date":"2025-04-07","objectID":"/essay/:2:3","series":null,"tags":[""],"title":"日志","uri":"/essay/#10月-2"},{"categories":[""],"content":" 9月","date":"2025-04-07","objectID":"/essay/:2:4","series":null,"tags":[""],"title":"日志","uri":"/essay/#9月-2"},{"categories":[""],"content":" 8月","date":"2025-04-07","objectID":"/essay/:2:5","series":null,"tags":[""],"title":"日志","uri":"/essay/#8月-2"},{"categories":[""],"content":" 7月","date":"2025-04-07","objectID":"/essay/:2:6","series":null,"tags":[""],"title":"日志","uri":"/essay/#7月-2"},{"categories":[""],"content":" 6月","date":"2025-04-07","objectID":"/essay/:2:7","series":null,"tags":[""],"title":"日志","uri":"/essay/#6月-2"},{"categories":[""],"content":" 5月","date":"2025-04-07","objectID":"/essay/:2:8","series":null,"tags":[""],"title":"日志","uri":"/essay/#5月-2"},{"categories":[""],"content":" 4月","date":"2025-04-07","objectID":"/essay/:2:9","series":null,"tags":[""],"title":"日志","uri":"/essay/#4月-2"},{"categories":[""],"content":" 3月","date":"2025-04-07","objectID":"/essay/:2:10","series":null,"tags":[""],"title":"日志","uri":"/essay/#3月-2"},{"categories":[""],"content":" 2月","date":"2025-04-07","objectID":"/essay/:2:11","series":null,"tags":[""],"title":"日志","uri":"/essay/#2月-2"},{"categories":[""],"content":" 1月","date":"2025-04-07","objectID":"/essay/:2:12","series":null,"tags":[""],"title":"日志","uri":"/essay/#1月-2"},{"categories":[""],"content":" 2022","date":"2025-04-07","objectID":"/essay/:3:0","series":null,"tags":[""],"title":"日志","uri":"/essay/#2022"},{"categories":[""],"content":" 12月","date":"2025-04-07","objectID":"/essay/:3:1","series":null,"tags":[""],"title":"日志","uri":"/essay/#12月-3"},{"categories":[""],"content":" 11月","date":"2025-04-07","objectID":"/essay/:3:2","series":null,"tags":[""],"title":"日志","uri":"/essay/#11月-3"},{"categories":[""],"content":" 10月","date":"2025-04-07","objectID":"/essay/:3:3","series":null,"tags":[""],"title":"日志","uri":"/essay/#10月-3"},{"categories":[""],"content":" 9月","date":"2025-04-07","objectID":"/essay/:3:4","series":null,"tags":[""],"title":"日志","uri":"/essay/#9月-3"},{"categories":[""],"content":" 8月","date":"2025-04-07","objectID":"/essay/:3:5","series":null,"tags":[""],"title":"日志","uri":"/essay/#8月-3"},{"categories":[""],"content":" 7月","date":"2025-04-07","objectID":"/essay/:3:6","series":null,"tags":[""],"title":"日志","uri":"/essay/#7月-3"},{"categories":[""],"content":" 6月","date":"2025-04-07","objectID":"/essay/:3:7","series":null,"tags":[""],"title":"日志","uri":"/essay/#6月-3"},{"categories":[""],"content":" 5月","date":"2025-04-07","objectID":"/essay/:3:8","series":null,"tags":[""],"title":"日志","uri":"/essay/#5月-3"},{"categories":[""],"content":" 4月","date":"2025-04-07","objectID":"/essay/:3:9","series":null,"tags":[""],"title":"日志","uri":"/essay/#4月-3"},{"categories":[""],"content":" 3月","date":"2025-04-07","objectID":"/essay/:3:10","series":null,"tags":[""],"title":"日志","uri":"/essay/#3月-3"},{"categories":[""],"content":" 2月","date":"2025-04-07","objectID":"/essay/:3:11","series":null,"tags":[""],"title":"日志","uri":"/essay/#2月-3"},{"categories":[""],"content":" 1月","date":"2025-04-07","objectID":"/essay/:3:12","series":null,"tags":[""],"title":"日志","uri":"/essay/#1月-3"},{"categories":[""],"content":" 2021","date":"2025-04-07","objectID":"/essay/:4:0","series":null,"tags":[""],"title":"日志","uri":"/essay/#2021"},{"categories":[""],"content":" 12月","date":"2025-04-07","objectID":"/essay/:4:1","series":null,"tags":[""],"title":"日志","uri":"/essay/#12月-4"},{"categories":[""],"content":" 11月","date":"2025-04-07","objectID":"/essay/:4:2","series":null,"tags":[""],"title":"日志","uri":"/essay/#11月-4"},{"categories":[""],"content":" 10月","date":"2025-04-07","objectID":"/essay/:4:3","series":null,"tags":[""],"title":"日志","uri":"/essay/#10月-4"},{"categories":[""],"content":" 9月","date":"2025-04-07","objectID":"/essay/:4:4","series":null,"tags":[""],"title":"日志","uri":"/essay/#9月-4"},{"categories":[""],"content":" 8月","date":"2025-04-07","objectID":"/essay/:4:5","series":null,"tags":[""],"title":"日志","uri":"/essay/#8月-4"},{"categories":[""],"content":" 7月","date":"2025-04-07","objectID":"/essay/:4:6","series":null,"tags":[""],"title":"日志","uri":"/essay/#7月-4"},{"categories":[""],"content":" 6月","date":"2025-04-07","objectID":"/essay/:4:7","series":null,"tags":[""],"title":"日志","uri":"/essay/#6月-4"},{"categories":[""],"content":" 5月","date":"2025-04-07","objectID":"/essay/:4:8","series":null,"tags":[""],"title":"日志","uri":"/essay/#5月-4"},{"categories":[""],"content":" 4月","date":"2025-04-07","objectID":"/essay/:4:9","series":null,"tags":[""],"title":"日志","uri":"/essay/#4月-4"},{"categories":[""],"content":" 3月","date":"2025-04-07","objectID":"/essay/:4:10","series":null,"tags":[""],"title":"日志","uri":"/essay/#3月-4"},{"categories":[""],"content":" 2月","date":"2025-04-07","objectID":"/essay/:4:11","series":null,"tags":[""],"title":"日志","uri":"/essay/#2月-4"},{"categories":[""],"content":" 1月","date":"2025-04-07","objectID":"/essay/:4:12","series":null,"tags":[""],"title":"日志","uri":"/essay/#1月-4"},{"categories":[""],"content":" 2020","date":"2025-04-07","objectID":"/essay/:5:0","series":null,"tags":[""],"title":"日志","uri":"/essay/#2020"},{"categories":[""],"content":" 12月","date":"2025-04-07","objectID":"/essay/:5:1","series":null,"tags":[""],"title":"日志","uri":"/essay/#12月-5"},{"categories":[""],"content":" 11月","date":"2025-04-07","objectID":"/essay/:5:2","series":null,"tags":[""],"title":"日志","uri":"/essay/#11月-5"},{"categories":[""],"content":" 10月","date":"2025-04-07","objectID":"/essay/:5:3","series":null,"tags":[""],"title":"日志","uri":"/essay/#10月-5"},{"categories":[""],"content":" 9月","date":"2025-04-07","objectID":"/essay/:5:4","series":null,"tags":[""],"title":"日志","uri":"/essay/#9月-5"},{"categories":[""],"content":" 8月","date":"2025-04-07","objectID":"/essay/:5:5","series":null,"tags":[""],"title":"日志","uri":"/essay/#8月-5"},{"categories":[""],"content":" 7月","date":"2025-04-07","objectID":"/essay/:5:6","series":null,"tags":[""],"title":"日志","uri":"/essay/#7月-5"},{"categories":[""],"content":" 6月","date":"2025-04-07","objectID":"/essay/:5:7","series":null,"tags":[""],"title":"日志","uri":"/essay/#6月-5"},{"categories":[""],"content":" 5月","date":"2025-04-07","objectID":"/essay/:5:8","series":null,"tags":[""],"title":"日志","uri":"/essay/#5月-5"},{"categories":[""],"content":" 4月","date":"2025-04-07","objectID":"/essay/:5:9","series":null,"tags":[""],"title":"日志","uri":"/essay/#4月-5"},{"categories":[""],"content":" 3月","date":"2025-04-07","objectID":"/essay/:5:10","series":null,"tags":[""],"title":"日志","uri":"/essay/#3月-5"},{"categories":[""],"content":" 2月","date":"2025-04-07","objectID":"/essay/:5:11","series":null,"tags":[""],"title":"日志","uri":"/essay/#2月-5"},{"categories":[""],"content":" 1月","date":"2025-04-07","objectID":"/essay/:5:12","series":null,"tags":[""],"title":"日志","uri":"/essay/#1月-5"},{"categories":[""],"content":" 2019","date":"2025-04-07","objectID":"/essay/:6:0","series":null,"tags":[""],"title":"日志","uri":"/essay/#2019"},{"categories":[""],"content":" 12月","date":"2025-04-07","objectID":"/essay/:6:1","series":null,"tags":[""],"title":"日志","uri":"/essay/#12月-6"},{"categories":[""],"content":" 11月","date":"2025-04-07","objectID":"/essay/:6:2","series":null,"tags":[""],"title":"日志","uri":"/essay/#11月-6"},{"categories":[""],"content":" 10月","date":"2025-04-07","objectID":"/essay/:6:3","series":null,"tags":[""],"title":"日志","uri":"/essay/#10月-6"},{"categories":[""],"content":" 9月","date":"2025-04-07","objectID":"/essay/:6:4","series":null,"tags":[""],"title":"日志","uri":"/essay/#9月-6"},{"categories":[""],"content":" 8月","date":"2025-04-07","objectID":"/essay/:6:5","series":null,"tags":[""],"title":"日志","uri":"/essay/#8月-6"},{"categories":[""],"content":" 7月","date":"2025-04-07","objectID":"/essay/:6:6","series":null,"tags":[""],"title":"日志","uri":"/essay/#7月-6"},{"categories":[""],"content":" 6月","date":"2025-04-07","objectID":"/essay/:6:7","series":null,"tags":[""],"title":"日志","uri":"/essay/#6月-6"},{"categories":[""],"content":" 5月","date":"2025-04-07","objectID":"/essay/:6:8","series":null,"tags":[""],"title":"日志","uri":"/essay/#5月-6"},{"categories":[""],"content":" 4月","date":"2025-04-07","objectID":"/essay/:6:9","series":null,"tags":[""],"title":"日志","uri":"/essay/#4月-6"},{"categories":[""],"content":" 3月","date":"2025-04-07","objectID":"/essay/:6:10","series":null,"tags":[""],"title":"日志","uri":"/essay/#3月-6"},{"categories":[""],"content":" 2月","date":"2025-04-07","objectID":"/essay/:6:11","series":null,"tags":[""],"title":"日志","uri":"/essay/#2月-6"},{"categories":[""],"content":" 1月","date":"2025-04-07","objectID":"/essay/:6:12","series":null,"tags":[""],"title":"日志","uri":"/essay/#1月-6"},{"categories":[""],"content":" 2018","date":"2025-04-07","objectID":"/essay/:7:0","series":null,"tags":[""],"title":"日志","uri":"/essay/#2018"},{"categories":[""],"content":" 12月","date":"2025-04-07","objectID":"/essay/:7:1","series":null,"tags":[""],"title":"日志","uri":"/essay/#12月-7"},{"categories":[""],"content":" 11月","date":"2025-04-07","objectID":"/essay/:7:2","series":null,"tags":[""],"title":"日志","uri":"/essay/#11月-7"},{"categories":[""],"content":" 10月","date":"2025-04-07","objectID":"/essay/:7:3","series":null,"tags":[""],"title":"日志","uri":"/essay/#10月-7"},{"categories":[""],"content":" 9月","date":"2025-04-07","objectID":"/essay/:7:4","series":null,"tags":[""],"title":"日志","uri":"/essay/#9月-7"},{"categories":[""],"content":" 8月","date":"2025-04-07","objectID":"/essay/:7:5","series":null,"tags":[""],"title":"日志","uri":"/essay/#8月-7"},{"categories":[""],"content":" 7月","date":"2025-04-07","objectID":"/essay/:7:6","series":null,"tags":[""],"title":"日志","uri":"/essay/#7月-7"},{"categories":[""],"content":" 6月","date":"2025-04-07","objectID":"/essay/:7:7","series":null,"tags":[""],"title":"日志","uri":"/essay/#6月-7"},{"categories":[""],"content":" 5月","date":"2025-04-07","objectID":"/essay/:7:8","series":null,"tags":[""],"title":"日志","uri":"/essay/#5月-7"},{"categories":[""],"content":" 4月","date":"2025-04-07","objectID":"/essay/:7:9","series":null,"tags":[""],"title":"日志","uri":"/essay/#4月-7"},{"categories":[""],"content":" 3月","date":"2025-04-07","objectID":"/essay/:7:10","series":null,"tags":[""],"title":"日志","uri":"/essay/#3月-7"},{"categories":[""],"content":" 2月","date":"2025-04-07","objectID":"/essay/:7:11","series":null,"tags":[""],"title":"日志","uri":"/essay/#2月-7"},{"categories":[""],"content":" 1月","date":"2025-04-07","objectID":"/essay/:7:12","series":null,"tags":[""],"title":"日志","uri":"/essay/#1月-7"},{"categories":[""],"content":" 2017","date":"2025-04-07","objectID":"/essay/:8:0","series":null,"tags":[""],"title":"日志","uri":"/essay/#2017"},{"categories":[""],"content":" 12月","date":"2025-04-07","objectID":"/essay/:8:1","series":null,"tags":[""],"title":"日志","uri":"/essay/#12月-8"},{"categories":[""],"content":" 11月","date":"2025-04-07","objectID":"/essay/:8:2","series":null,"tags":[""],"title":"日志","uri":"/essay/#11月-8"},{"categories":[""],"content":" 10月","date":"2025-04-07","objectID":"/essay/:8:3","series":null,"tags":[""],"title":"日志","uri":"/essay/#10月-8"},{"categories":[""],"content":" 9月","date":"2025-04-07","objectID":"/essay/:8:4","series":null,"tags":[""],"title":"日志","uri":"/essay/#9月-8"},{"categories":[""],"content":" 8月","date":"2025-04-07","objectID":"/essay/:8:5","series":null,"tags":[""],"title":"日志","uri":"/essay/#8月-8"},{"categories":[""],"content":" 7月","date":"2025-04-07","objectID":"/essay/:8:6","series":null,"tags":[""],"title":"日志","uri":"/essay/#7月-8"},{"categories":[""],"content":" 6月","date":"2025-04-07","objectID":"/essay/:8:7","series":null,"tags":[""],"title":"日志","uri":"/essay/#6月-8"},{"categories":[""],"content":" 5月","date":"2025-04-07","objectID":"/essay/:8:8","series":null,"tags":[""],"title":"日志","uri":"/essay/#5月-8"},{"categories":[""],"content":" 4月","date":"2025-04-07","objectID":"/essay/:8:9","series":null,"tags":[""],"title":"日志","uri":"/essay/#4月-8"},{"categories":[""],"content":" 3月","date":"2025-04-07","objectID":"/essay/:8:10","series":null,"tags":[""],"title":"日志","uri":"/essay/#3月-8"},{"categories":[""],"content":" 2月","date":"2025-04-07","objectID":"/essay/:8:11","series":null,"tags":[""],"title":"日志","uri":"/essay/#2月-8"},{"categories":[""],"content":" 1月","date":"2025-04-07","objectID":"/essay/:8:12","series":null,"tags":[""],"title":"日志","uri":"/essay/#1月-8"},{"categories":[""],"content":" 2016","date":"2025-04-07","objectID":"/essay/:9:0","series":null,"tags":[""],"title":"日志","uri":"/essay/#2016"},{"categories":[""],"content":" 12月","date":"2025-04-07","objectID":"/essay/:9:1","series":null,"tags":[""],"title":"日志","uri":"/essay/#12月-9"},{"categories":[""],"content":" 11月","date":"2025-04-07","objectID":"/essay/:9:2","series":null,"tags":[""],"title":"日志","uri":"/essay/#11月-9"},{"categories":[""],"content":" 10月","date":"2025-04-07","objectID":"/essay/:9:3","series":null,"tags":[""],"title":"日志","uri":"/essay/#10月-9"},{"categories":[""],"content":" 9月","date":"2025-04-07","objectID":"/essay/:9:4","series":null,"tags":[""],"title":"日志","uri":"/essay/#9月-9"},{"categories":[""],"content":" 8月","date":"2025-04-07","objectID":"/essay/:9:5","series":null,"tags":[""],"title":"日志","uri":"/essay/#8月-9"},{"categories":[""],"content":" 7月","date":"2025-04-07","objectID":"/essay/:9:6","series":null,"tags":[""],"title":"日志","uri":"/essay/#7月-9"},{"categories":[""],"content":" 6月","date":"2025-04-07","objectID":"/essay/:9:7","series":null,"tags":[""],"title":"日志","uri":"/essay/#6月-9"},{"categories":[""],"content":" 5月","date":"2025-04-07","objectID":"/essay/:9:8","series":null,"tags":[""],"title":"日志","uri":"/essay/#5月-9"},{"categories":[""],"content":" 4月","date":"2025-04-07","objectID":"/essay/:9:9","series":null,"tags":[""],"title":"日志","uri":"/essay/#4月-9"},{"categories":[""],"content":" 3月","date":"2025-04-07","objectID":"/essay/:9:10","series":null,"tags":[""],"title":"日志","uri":"/essay/#3月-9"},{"categories":[""],"content":" 2月","date":"2025-04-07","objectID":"/essay/:9:11","series":null,"tags":[""],"title":"日志","uri":"/essay/#2月-9"},{"categories":[""],"content":" 1月","date":"2025-04-07","objectID":"/essay/:9:12","series":null,"tags":[""],"title":"日志","uri":"/essay/#1月-9"},{"categories":[""],"content":" 2015","date":"2025-04-07","objectID":"/essay/:10:0","series":null,"tags":[""],"title":"日志","uri":"/essay/#2015"},{"categories":[""],"content":" 12月","date":"2025-04-07","objectID":"/essay/:10:1","series":null,"tags":[""],"title":"日志","uri":"/essay/#12月-10"},{"categories":[""],"content":" 11月","date":"2025-04-07","objectID":"/essay/:10:2","series":null,"tags":[""],"title":"日志","uri":"/essay/#11月-10"},{"categories":[""],"content":" 10月","date":"2025-04-07","objectID":"/essay/:10:3","series":null,"tags":[""],"title":"日志","uri":"/essay/#10月-10"},{"categories":[""],"content":" 9月","date":"2025-04-07","objectID":"/essay/:10:4","series":null,"tags":[""],"title":"日志","uri":"/essay/#9月-10"},{"categories":[""],"content":" 8月","date":"2025-04-07","objectID":"/essay/:10:5","series":null,"tags":[""],"title":"日志","uri":"/essay/#8月-10"},{"categories":[""],"content":" 7月","date":"2025-04-07","objectID":"/essay/:10:6","series":null,"tags":[""],"title":"日志","uri":"/essay/#7月-10"},{"categories":[""],"content":" 6月","date":"2025-04-07","objectID":"/essay/:10:7","series":null,"tags":[""],"title":"日志","uri":"/essay/#6月-10"},{"categories":[""],"content":" 5月","date":"2025-04-07","objectID":"/essay/:10:8","series":null,"tags":[""],"title":"日志","uri":"/essay/#5月-10"},{"categories":[""],"content":" 4月","date":"2025-04-07","objectID":"/essay/:10:9","series":null,"tags":[""],"title":"日志","uri":"/essay/#4月-10"},{"categories":[""],"content":" 3月","date":"2025-04-07","objectID":"/essay/:10:10","series":null,"tags":[""],"title":"日志","uri":"/essay/#3月-10"},{"categories":[""],"content":" 2月","date":"2025-04-07","objectID":"/essay/:10:11","series":null,"tags":[""],"title":"日志","uri":"/essay/#2月-10"},{"categories":[""],"content":" 1月","date":"2025-04-07","objectID":"/essay/:10:12","series":null,"tags":[""],"title":"日志","uri":"/essay/#1月-10"},{"categories":["Tech"],"content":"较为系统的介绍rtos的ota技术以及linux系统的启动流程 ","date":"2025-06-01","objectID":"/posts/booting-process-in-embedded/:0:0","series":null,"tags":["Tech"],"title":"嵌入式中的启动流程","uri":"/posts/booting-process-in-embedded/#"},{"categories":["Tech"],"content":" mcu的bootloader与ota拥有ota功能的app通常会将flash等rom分为三个区域：bootloader，app以及download区域。bootloader区用于存储启动加载程序，其内部进行硬件初始化，判断是否需要刷写app以及刷写app的执行细节。app区存放应用程序，该区域也是bootloader的刷写对象。download区用于存放需要app镜像，该区域一般由app刷写，当app刷写完成后，下次启动时bootloader就会从该区域获得app镜像，并刷写到app区。因此在分区时，bootloader区可以给最小，app区域和download区给最大。对于采用不同更新和压缩方式的镜像，app区和download区的相对大小不同。例如当使用全量更新，不对镜像进行压缩时，app区和download区大小应当相等。当使用全量更新，对镜像进行gzip压缩时，download区大小应当是app区的50%(gzip压缩率在50%~70%之间)。对于进行增量更新(使用diff算法)，不进行压缩的情况，尽管大多数情况增量更新的镜像包都很小，但有时也会出现很大的情况，这时就需要根据经验设计这两个区域的大小了 每次系统启动时，bootloader都会检测当前是否需要进行升级，这可能是上次程序运行时app收到上位机发来的ota指令，也可能是本次启动时bootloader主动查询服务器是否有新的固件版本。当确定有新的固件版本时，新固件大小和内容等信息就已经发送到设备上了，之后bootloader只需要执行升级固件包操作随后调用软件重启代码(例如NVIC_SystemReset)，再次启动时就能进入更新后的app 以flash大小64KB为例，若bootloader需要16KB(0x4000)，app需要48KB。那么实现ota需要修改三处程序： 烧录地址，将bootloader的烧录地址设为0x8000 0000，app的烧录地址设为0x8000 4000 链接地址，设置为烧录地址的相同的值 中断向量表，将bootloader的中断向量表基地址寄存器设置为0x0(0偏移量)，app的中断向量表基地址寄存器设置为0x4000(0x4000偏移量)，没错，含有bootloader的程序内有两套中断向量表 ","date":"2025-06-01","objectID":"/posts/booting-process-in-embedded/:1:0","series":null,"tags":["Tech"],"title":"嵌入式中的启动流程","uri":"/posts/booting-process-in-embedded/#mcu的bootloader与ota"},{"categories":["Tech"],"content":" uboot与内核","date":"2025-06-01","objectID":"/posts/booting-process-in-embedded/:2:0","series":null,"tags":["Tech"],"title":"嵌入式中的启动流程","uri":"/posts/booting-process-in-embedded/#uboot与内核"},{"categories":["Tech"],"content":" 使用uboot的步骤 进入uboot工程目录 执行make boardxxx_vendorxxx_defconfig生成默认配置文件(.config)。如果没有defconfig文件或想要自定义uboot，可以使用make menuconfig进行自定义配置，该命令会将之前.make boardxxx_vendorxxx_defconfig生成的.config中相同的选项覆盖掉 执行make即可完成编译，对于该命令uboot会进行以下操作 将uboot提供的默认配置u-boot.cfg(内部设置了uboot的压缩方式，是作为linux内核还是qemu的启动器等选项)，uboot启动过程中需要的依赖(如emmc控制器驱动，串口驱动)以及用户生成的.config文件打包为能够被make识别的文件以及一个头文件 按照makefile.build的规则进行编译，首先编译uboot源码得到u-boot-nodtb.bin，而后编译dts/boardxxx_vendorxxx.dts得到对应板厂的dtb文件boardxxx_vendorxxx.dtb 将u-boot-nodtb.bin和boardxxx_vendorxxx.dtb链接成u-boot-dtb.bin 由于需要将uboot加载到ddr中运行，因此uboot前面还需要有能够初始化ddr内存的片段。该片段可能是uboot的start.S生成的start.o，也可能是spl(second process loader)，还有可能是由于sram太小导致spl不能放下而产生的tpl，最终该片段会在sram中执行，因此需要将该片段放在uboot头部 将引导uboot的片段和uboot打包在一起就得到了最终的镜像文件 ","date":"2025-06-01","objectID":"/posts/booting-process-in-embedded/:2:1","series":null,"tags":["Tech"],"title":"嵌入式中的启动流程","uri":"/posts/booting-process-in-embedded/#使用uboot的步骤"},{"categories":["Tech"],"content":" 使用内核的步骤使用内核与使用uboot类似，首先使用patch命令打补丁，如果没有补丁就跳过。之后使用make menuconfig命令配置，或者将厂家提供的config文件复制到指定目录并命名为.config，亦或者使用内核的默认配置文件。如果想在厂家或内核的默认配置文件上修改配置，可以再次执行make menuconfig进行二次配置。配置完成后使用make就可以编译了 进行配置时，部分选项支持被编译为内核模块，由于根据.config生成的autoconfig.h只能判别是否纳入编译或确定编译中对应宏的值(对应的选项是y或者数值)，对于编程为模块还是编进内核不能确定，因此内核模块的编译需要在为makefile准备的auto.conf中被标记为obj-m，正常的内核选项被标记为obj-y，未被标记的选项被标记为obj-。这样我们就可以单独将其编译为xxx.ko了。内核模块可以动态加载，这意味着加载内核模块后不需要重启内核，尽管相比直接编译进内核有一定性能损失，但是在某些场景下还是很有用处的，例如对于usb转ttl驱动而言就可以将其编译为内核模块，这样不必每次开机时都加载这个驱动，其他可选功能一般也被配置为内核模块，例如虚拟化模块kvm 编译内核时，.config会生成两个文件：auto.conf和autoconf.h。前者被顶层makefile包含进编译过程，内部含有make menuconfig时设置的编译模式，如内核模块的编译需要在该文件中被标记为obj-m。后者作为内核的头文件也被纳入编译过程，控制代码的宏开关和其他固定变量就在这里定义 下面是伪代码： makefile # auto.conf文件： CONFIG_FOO=y CONFIG_BAR=m CONFIG_BAZ=n # makefile文件： # 静态编译进内核 obj-$(CONFIG_FOO) += foo.o # 编译为模块 obj-$(CONFIG_BAR) += bar.o 下面是makefile的总结 makefile all: vmlinux zImage Image xipImage bootpImage uImage: vmlinux vmlinux: $(vmlinux-lds) $(vmlinux-init) $(vmlinux-main) $(kallsyms.o) FORCE vmlinux-init := $(head-y) $(init-y) head-y := arch/arm/kernel/head$(MMUEXT).o/arch/arm/kernel/init_task.o init-y := init/ init-y := $(patsubst %/, %/built-in.o, $(init-y)) # = init/buildt-in.o vmlinux-main := $(core-y) $(libs-y) $(drivers-y) $(net-y) core-y := usr/ kernel/ mm/ fs/ ipc/ security/ crypto/ block/ core-y := $(patsubst %/, %/built-in.o, $(core-y)) # = usr/buildt-in.o kernel/buildt-in.o mm/buildt-in.o fs/buildt-in.o ipc/buildt-in.o security/buildt-in.o crypto/buildt-in.o block/buildt-in.o libs-y = lib/lib.a lib/buildt-in.o drivers-y := drivers/buildt-in.o sound/buildt-in.o net-y := net/buildt-in.o vmlinux-all := $(vmlinux-init) $(vmlinux-main) vmlinux-lds := arch/$(ARCH)/kernel/vmlinux.lds 可以很清楚的看出，真正的内核是vmlinux，并且uImage依赖于vmlinux 上面还有一些编写编译脚本的技巧： 在第四行的结尾有FORCE这个关键字，这意味着无论$(vmlinux-lds) $(vmlinux-init) $(vmlinux-main) $(kallsyms.o)是否有变化，都要强制生成一次vmlinux 无论是init-y，core-y还是libs-y，都使用了$(patsubst %/, %/built-in.o, $(core-y))将内部的子文件夹下所有文件统一编译并部分链接为buildt-in.o。实际上，buildt-in.o是生成最终vmlinux.o的中间文件，内部包含了未能确定链接地址的符号和已经确定链接地址的符号。如果不进行这种分步骤操作，内核就需要一次将所有符号链接完成，这种大量，分散的符号链接会增大cpu和链接器的负担。同时使用这种结构还可以强制分模块编译，防止各模块耦合，尽管还有部分符号需要在生成最终链接文件时确定，那也不会加重系统负担 ","date":"2025-06-01","objectID":"/posts/booting-process-in-embedded/:2:2","series":null,"tags":["Tech"],"title":"嵌入式中的启动流程","uri":"/posts/booting-process-in-embedded/#使用内核的步骤"},{"categories":["Tech"],"content":" uboot与内核启动加载流程启动加载流程会根据具体环境而不同，下面介绍一般的过程 cpu在上电后会自动读取地址0x0处的代码，此处一般位于bootrom。需要注意的是，bootrom并不是flash，而是固化在芯片上的代码，因此cpu不需要将bootrom加载到sram。bootrom会进行最基本的硬件初始化，例如时钟，sram，emmc控制器，nand控制器等部分的初始化，并将外部存储介质中位于uboot之前的片段加载到sram中(该片段可能是start.o，spl或由于资源受限时的tpl构成)。并在此时获取启动引脚等信息，判断是否进行烧录固件或者作为linux还是qemu项目的启动器 在sram的片段会将ddr初始化，并将其他外设进一步初始化，例如将bootrom时期初始化的低速时钟重新初始化为高速时钟，较为全面地cpu初始化等。同时片段会将uboot完全载入ddr内存，并继承bootrom阶段时获取的启动引脚等信息。之后进入uboot启动阶段 uboot首先进行重定位，该过程会根据厂商和arm公司提供的启动文件计算获得ddr的起始地址和大小，而后将ram划分堆，栈，bss以及用于向内核传输数据的段等区域。之后将完整的uboot拷贝到ddr的预定位置中。至此uboot的重定位完成。除了uboot本身的重定位，我们还需要将uboot中的_rel_dyn_start段中的所有符号重定位，因为在uboot对自身重定位时地址也发生了变化。该段内的符号来源于无法单独依靠链接获得位置无关码的符号，例如全局变量，函数，命令列表等，我们可以在加载地址时动态获取想要加载的位置然后对_rel_dyn_start段中的所有符号批量更改即可。例如在加载地址为flash的0x0，某个全局函数的地址为0x100，如果uboot初次定位到dr中的0x3000 0000地址处，我们就可以将_rel_dyn_start段中的所有符号的地址与0x3000 0000相加获得新地址，那么该符号的地址就被修改为0x3000 0100。当uboot进行二次重定位时，例如需要放在0x3002 f000，我们可以再次让_rel_dyn_start段中的所有符号的地址和0x3002 f000，0x3000 0000两者之差再相加，该全局符号的地址就变为了0x3002 f100=0x3000 0100+(0x3002 f000 - 0x3000 0000)，这样就可以完成uboot的全部符号的重定位 之后进入uboot启动内核流程，uboot会将板级信息放入到上一步开辟过的向内核传输数据的段内(该段信息的格式被称为TAG，内部包含芯片id，板子id，设备树，内存大小和地址，启动引脚等信息)，而后将uImage放入ddr中合适的位置。此处的uImage指的是信息头+内核，信息头内部标明了内核创建时间，crc校验，魔数，cpu架构等信息，其中最重要的是内核入口点和加载点，这两者之差就是信息头大小。因此我们只需要将内核解压缩并让程序跳转到信息头标明的内核入口点运行即可启动内核。启动内核是通过解析boot命令进行的，即通过文本解析找到位于命令列表(位于uboot并在链接脚本中声明的段)中的对应函数，并将参数(也就是启动时指定的启动设备，内核在启动设备中的位置)传入。rtthread命令列表可能就从中获取灵感。执行启动命令后就正式进入了内核初始化阶段 内核初始化阶段是uboot到内核的第一个c函数strat_kernel之间的阶段，该阶段由汇编实现，其中做了如下操作： 简单处理uboot参数，判断机器id，是否支持这个cpu，判断是否支持这个单板 建立页表 使能mmu 跳转到strat_kernel strat_kernel首先处理上步没有处理完的uboot参数，例如启动介质，控制台输出方式，解析完成后将其解析为文本放在.init.setup段内。随后进行一系列硬件初始化(网络，缓存系统，磁盘，usb，声音系统等)，在某些初始化完成后找到对应的段并将文本作为参数传入相关的初始化函数，如通过sd卡启动根文件系统这个过程中，内核只提供启动函数，但不清楚是从sd还是其他的存储介质启动，因此就需要uboot传入的参数并将其解析为文本参数传给内核中对应的启动函数。最后挂载根文件系统并执行应用程序 ","date":"2025-06-01","objectID":"/posts/booting-process-in-embedded/:2:3","series":null,"tags":["Tech"],"title":"嵌入式中的启动流程","uri":"/posts/booting-process-in-embedded/#uboot与内核启动加载流程"},{"categories":["Tech"],"content":" 根文件系统启动流程首先简单介绍busybox，busybox是一个小型的init程序，当内核执行init后调用busybox就可以进入根文件系统，同类产品还有systemd和SysVinit。不同的产品的启动流程和启动脚本也不同。进入根文件系统后，任何常用的命令(如cd，rm，ps(需要proc驱动)，mv等)都是busybox下对应程序的软链接(ls-\u003e/bin/busybox) 内核根据uboot传入的信息打开相关设备(例如/dev/console)作为标准输入，并将这个设备复制两份作为标准输出和标准错误。而后内核会根据uboot传入的init=xxx将xxx作为自己的第一个程序，如果并未指定程序，内核会按照顺序依次运行/sbin/init, /etc/init, /bin/init/, /bin/sh中的一个并陷入。而init进程则是busybox的链接。具体的应用程序调用链如下： c 内核调用相关的init程序，此处调用busybox内部的init_main busybox内部的init_main parse_inittab file=fopen(INITTAB,\"r\"); // #define INITTAB \"/etc/inittab\" new_init_action; //利用打开的/etc/inittab文件创建一个init_action结构，把这个结构填充进链表 run_actions(SYSINIT); waitfor(a,0); //执行应用程序，并等待其执行完毕 run(a); //创建子进程(/etc/inittab中指定的应用程序) waitpid(); //等待结束 run_actions(WAIT); //与run_actions(SYSINIT)类似 run_actions(ONCE); //与run_actions(SYSINIT)类似 while(1){ run_actions(RESPAWN); run_actions(ASKFIRST); wpid=wait(); //等待任意一个子进程退出 while(wpid \u003e 0){ //如果是父进程收到了子进程退出的信号 for(a = init_action_list; a; a = a-\u003enext){ a-\u003epid=0; //将所有退出的子进程的pid全设为0以便重启任务 } } } 可以看到内核init程序首先调用busybox的init_main程序，而后init_main读取/etc/inittab配置文件，而后解析配置文件并创建任务链表(任务来自配置文件)，最后依次执行链表中的程序，如果其中有退出的程序就将其重启，否则就进入死循环始终等待。这一过程类似于shell等待命令的过程 那么/etc/inittab中的文件是什么样子呢，下面是内核给出/etc/inittab的默认配置示例 c \u003cid\u003e:\u003crunlevels\u003e:\u003caction\u003e:\u003cprocess\u003e id: /dev/id，用于终端，常用console，null或tty作为参数 runlevels: 忽略 action: 执行时机，包含sysinit，wait，once，respawn，askfirst，reboot，shutdown等参数 process: 应用程序或脚本，由用户指定 对于内核的默认/etc/inittab配置如下： ::shutdown:umount -a -r ::restart:init tty2::askfirst:-/bin/sh tty3::askfirst:-/bin/sh ::sysinit:/etc/init.d/rcS 这样，配置文件就被解析为对不同设备的操作或指令存储在链表中，甚至最后还运行了自动化脚本文件 由上述过程我们就可以知道根文件系统的组成： init程序本身，嵌入式系统中使用busybox作为init程序来构建根文件系统，对于pc，服务器或其他发行版领域则是systemd或者SysVinit /etc/inittab，该文件指定了开机时启动的应用程序及其启动方式 /etc/inittab中的应用程序 /etc/inittab中的应用程序所依赖的库 /dev/console，/dev/null或者/dev/tty，用于指定串口输入输出设备 ","date":"2025-06-01","objectID":"/posts/booting-process-in-embedded/:2:4","series":null,"tags":["Tech"],"title":"嵌入式中的启动流程","uri":"/posts/booting-process-in-embedded/#根文件系统启动流程"},{"categories":["Tech"],"content":" 构建根文件系统 构建并安装busybox选择busybox作为系统的init程序后就可以使用类似uboot，rtthread等操作进行编译 进入busybox源码文件夹，执行make menuconfig进行配置 之后make编译 在上一步获得编译产物后执行make CONFIG_PREFIX=/path/from/root install将buysbox安装到目标机器上，注意这里需要添加参数，防止将busybox安装到pc机上破坏系统 在执行完上述步骤后，对应的/path/from/root文件夹内就会出现bin，linuxrc，sbin，usr目录，其中linuxrc-\u003e/bin/busybox 之后创建/dev/console和/dev/null设备 在本机内获得这两个设备的设备号，ls /dev/console /dev/null -l 在/path/from/root创建文件夹，mkdir dev 在dev内创建设备节点，sudo mknod console c 设备号，这里的c代表字符设备 设备节点创建完毕 而后修改/etc/inittab mkdir etc vi /etc/inittab 写入console::askfirst:-/bin/sh，这样开机就可以进入shell 下面安装c库，这里的c库来源于交叉编译工具链的c库 创建lib文件夹存放动态链接库文件，mkdir lib cp /path/to/cross-tools/gcc-version-glibc-version/\\*.so\\* lib -d，这里的-d代表将链接文件拷贝过来，而不是将链接的源文件拷贝过来，这样可以减小根文件系统体积 至此文件系统就构建好了，尽管没有指定用户编写的应用程序，但这并不妨碍文件系统正常启动 这里我们还需要将根文件系统制作成映像文件 这里使用yaffs作为映像文件制作工具 安装yaffs，步骤与上面类似 make(不需要menuconfig) 将编译产物放到宿主机的/bin并给予执行权限 mkyaffs2image myfs myfs.yaffs，这样就制作完成映像文件系统了 将映像文件烧录进带有内核的目标机上就可以启动根文件系统 此时根文件系统下有如下目录：bin dev etc lib linuxrc lost+found sbin usr 支持ps命令此时执行ls，cat，rm等命令都可以正常执行，但是执行ps命令就会失败 这是因为ps需要根文件系统支持proc设备和proc文件系统，在这里就需要将proc作为虚拟文件系统挂载到内核 执行mount -t proc none /proc这里的none指的是不依赖实际硬件设备 想要将上述步骤自动化，需要作如下修改 vi /etc/inittab 写入::sysinit:/etc/init.d/rcS 创建/etc/init.d/rcS文件并给予执行权限 在该文件内写入mount -t proc none /proc 此时根文件系统下有如下目录：bin dev etc lib linuxrc lost+found proc sbin usr (新增proc文件夹) 这里的lost+found文件夹是内核自动创建的，而在映像文件系统内没有这个文件夹 进一步支持多种文件系统除了mount -t mount_point device命令，还有一个更简便的mount -a命令，该命令会查找/etc/fstab文件中查找对应的为文件系统并挂载，想要支持ps命令，需要如下操作 vi /etc/init.d/rcS 在该文件内写入mount -a vi /etc/fstab 写入如下内容 config # device mount-point type options dump fsck order proc /proc proc defaults 0 0 使用udev更进一步简化设备挂载过程udev是内核支持的一个能够自动创建设备节点的机制，是为了避免根文件系统内所有设备都执行sudo mknod console c 设备号创建设备节点的灾难性场景所提出的解决方案，linux提供udev机制来自动创建设备节点并挂载设备，该机制依赖于热插拔系统。在busybox中则需要使用mdev，这是udev的简化版本 下面是该机制的使用方法 vi /etc/fstab 写入如下内容 config # device mount-point type options dump fsck order proc /proc proc defaults 0 0 sysfs /sys sysfs defaults 0 0 tmpfs /dev tmpfs defaults 0 0 tmpfs /tmp tmpfs defaults 0 0 vi /etc/init.d/rcS 写入如下内容 shell mount -a mkdir /dev/pts mount -t devpts devpts /dev/pts echo /bin/mdev \u003e /proc.sys/kernel/hotplug # 将mdev的设备加载到热插拔目录中，这样插入或拔出新设备时会自动创建或删除设备节点 mdev -s # 主动加载mdev，创建节点 这样，进入根文件系统后就会自动挂载设备并创建设备节点，此时根文件系统下有如下目录：bin dev etc lib linuxrc lost+found proc sbin sys usr (新增sys文件夹) ","date":"2025-06-01","objectID":"/posts/booting-process-in-embedded/:2:5","series":null,"tags":["Tech"],"title":"嵌入式中的启动流程","uri":"/posts/booting-process-in-embedded/#构建根文件系统"},{"categories":["Tech"],"content":" 构建根文件系统 构建并安装busybox选择busybox作为系统的init程序后就可以使用类似uboot，rtthread等操作进行编译 进入busybox源码文件夹，执行make menuconfig进行配置 之后make编译 在上一步获得编译产物后执行make CONFIG_PREFIX=/path/from/root install将buysbox安装到目标机器上，注意这里需要添加参数，防止将busybox安装到pc机上破坏系统 在执行完上述步骤后，对应的/path/from/root文件夹内就会出现bin，linuxrc，sbin，usr目录，其中linuxrc-\u003e/bin/busybox 之后创建/dev/console和/dev/null设备 在本机内获得这两个设备的设备号，ls /dev/console /dev/null -l 在/path/from/root创建文件夹，mkdir dev 在dev内创建设备节点，sudo mknod console c 设备号，这里的c代表字符设备 设备节点创建完毕 而后修改/etc/inittab mkdir etc vi /etc/inittab 写入console::askfirst:-/bin/sh，这样开机就可以进入shell 下面安装c库，这里的c库来源于交叉编译工具链的c库 创建lib文件夹存放动态链接库文件，mkdir lib cp /path/to/cross-tools/gcc-version-glibc-version/\\*.so\\* lib -d，这里的-d代表将链接文件拷贝过来，而不是将链接的源文件拷贝过来，这样可以减小根文件系统体积 至此文件系统就构建好了，尽管没有指定用户编写的应用程序，但这并不妨碍文件系统正常启动 这里我们还需要将根文件系统制作成映像文件 这里使用yaffs作为映像文件制作工具 安装yaffs，步骤与上面类似 make(不需要menuconfig) 将编译产物放到宿主机的/bin并给予执行权限 mkyaffs2image myfs myfs.yaffs，这样就制作完成映像文件系统了 将映像文件烧录进带有内核的目标机上就可以启动根文件系统 此时根文件系统下有如下目录：bin dev etc lib linuxrc lost+found sbin usr 支持ps命令此时执行ls，cat，rm等命令都可以正常执行，但是执行ps命令就会失败 这是因为ps需要根文件系统支持proc设备和proc文件系统，在这里就需要将proc作为虚拟文件系统挂载到内核 执行mount -t proc none /proc这里的none指的是不依赖实际硬件设备 想要将上述步骤自动化，需要作如下修改 vi /etc/inittab 写入::sysinit:/etc/init.d/rcS 创建/etc/init.d/rcS文件并给予执行权限 在该文件内写入mount -t proc none /proc 此时根文件系统下有如下目录：bin dev etc lib linuxrc lost+found proc sbin usr (新增proc文件夹) 这里的lost+found文件夹是内核自动创建的，而在映像文件系统内没有这个文件夹 进一步支持多种文件系统除了mount -t mount_point device命令，还有一个更简便的mount -a命令，该命令会查找/etc/fstab文件中查找对应的为文件系统并挂载，想要支持ps命令，需要如下操作 vi /etc/init.d/rcS 在该文件内写入mount -a vi /etc/fstab 写入如下内容 config # device mount-point type options dump fsck order proc /proc proc defaults 0 0 使用udev更进一步简化设备挂载过程udev是内核支持的一个能够自动创建设备节点的机制，是为了避免根文件系统内所有设备都执行sudo mknod console c 设备号创建设备节点的灾难性场景所提出的解决方案，linux提供udev机制来自动创建设备节点并挂载设备，该机制依赖于热插拔系统。在busybox中则需要使用mdev，这是udev的简化版本 下面是该机制的使用方法 vi /etc/fstab 写入如下内容 config # device mount-point type options dump fsck order proc /proc proc defaults 0 0 sysfs /sys sysfs defaults 0 0 tmpfs /dev tmpfs defaults 0 0 tmpfs /tmp tmpfs defaults 0 0 vi /etc/init.d/rcS 写入如下内容 shell mount -a mkdir /dev/pts mount -t devpts devpts /dev/pts echo /bin/mdev \u003e /proc.sys/kernel/hotplug # 将mdev的设备加载到热插拔目录中，这样插入或拔出新设备时会自动创建或删除设备节点 mdev -s # 主动加载mdev，创建节点 这样，进入根文件系统后就会自动挂载设备并创建设备节点，此时根文件系统下有如下目录：bin dev etc lib linuxrc lost+found proc sbin sys usr (新增sys文件夹) ","date":"2025-06-01","objectID":"/posts/booting-process-in-embedded/:2:5","series":null,"tags":["Tech"],"title":"嵌入式中的启动流程","uri":"/posts/booting-process-in-embedded/#构建并安装busybox"},{"categories":["Tech"],"content":" 构建根文件系统 构建并安装busybox选择busybox作为系统的init程序后就可以使用类似uboot，rtthread等操作进行编译 进入busybox源码文件夹，执行make menuconfig进行配置 之后make编译 在上一步获得编译产物后执行make CONFIG_PREFIX=/path/from/root install将buysbox安装到目标机器上，注意这里需要添加参数，防止将busybox安装到pc机上破坏系统 在执行完上述步骤后，对应的/path/from/root文件夹内就会出现bin，linuxrc，sbin，usr目录，其中linuxrc-\u003e/bin/busybox 之后创建/dev/console和/dev/null设备 在本机内获得这两个设备的设备号，ls /dev/console /dev/null -l 在/path/from/root创建文件夹，mkdir dev 在dev内创建设备节点，sudo mknod console c 设备号，这里的c代表字符设备 设备节点创建完毕 而后修改/etc/inittab mkdir etc vi /etc/inittab 写入console::askfirst:-/bin/sh，这样开机就可以进入shell 下面安装c库，这里的c库来源于交叉编译工具链的c库 创建lib文件夹存放动态链接库文件，mkdir lib cp /path/to/cross-tools/gcc-version-glibc-version/\\*.so\\* lib -d，这里的-d代表将链接文件拷贝过来，而不是将链接的源文件拷贝过来，这样可以减小根文件系统体积 至此文件系统就构建好了，尽管没有指定用户编写的应用程序，但这并不妨碍文件系统正常启动 这里我们还需要将根文件系统制作成映像文件 这里使用yaffs作为映像文件制作工具 安装yaffs，步骤与上面类似 make(不需要menuconfig) 将编译产物放到宿主机的/bin并给予执行权限 mkyaffs2image myfs myfs.yaffs，这样就制作完成映像文件系统了 将映像文件烧录进带有内核的目标机上就可以启动根文件系统 此时根文件系统下有如下目录：bin dev etc lib linuxrc lost+found sbin usr 支持ps命令此时执行ls，cat，rm等命令都可以正常执行，但是执行ps命令就会失败 这是因为ps需要根文件系统支持proc设备和proc文件系统，在这里就需要将proc作为虚拟文件系统挂载到内核 执行mount -t proc none /proc这里的none指的是不依赖实际硬件设备 想要将上述步骤自动化，需要作如下修改 vi /etc/inittab 写入::sysinit:/etc/init.d/rcS 创建/etc/init.d/rcS文件并给予执行权限 在该文件内写入mount -t proc none /proc 此时根文件系统下有如下目录：bin dev etc lib linuxrc lost+found proc sbin usr (新增proc文件夹) 这里的lost+found文件夹是内核自动创建的，而在映像文件系统内没有这个文件夹 进一步支持多种文件系统除了mount -t mount_point device命令，还有一个更简便的mount -a命令，该命令会查找/etc/fstab文件中查找对应的为文件系统并挂载，想要支持ps命令，需要如下操作 vi /etc/init.d/rcS 在该文件内写入mount -a vi /etc/fstab 写入如下内容 config # device mount-point type options dump fsck order proc /proc proc defaults 0 0 使用udev更进一步简化设备挂载过程udev是内核支持的一个能够自动创建设备节点的机制，是为了避免根文件系统内所有设备都执行sudo mknod console c 设备号创建设备节点的灾难性场景所提出的解决方案，linux提供udev机制来自动创建设备节点并挂载设备，该机制依赖于热插拔系统。在busybox中则需要使用mdev，这是udev的简化版本 下面是该机制的使用方法 vi /etc/fstab 写入如下内容 config # device mount-point type options dump fsck order proc /proc proc defaults 0 0 sysfs /sys sysfs defaults 0 0 tmpfs /dev tmpfs defaults 0 0 tmpfs /tmp tmpfs defaults 0 0 vi /etc/init.d/rcS 写入如下内容 shell mount -a mkdir /dev/pts mount -t devpts devpts /dev/pts echo /bin/mdev \u003e /proc.sys/kernel/hotplug # 将mdev的设备加载到热插拔目录中，这样插入或拔出新设备时会自动创建或删除设备节点 mdev -s # 主动加载mdev，创建节点 这样，进入根文件系统后就会自动挂载设备并创建设备节点，此时根文件系统下有如下目录：bin dev etc lib linuxrc lost+found proc sbin sys usr (新增sys文件夹) ","date":"2025-06-01","objectID":"/posts/booting-process-in-embedded/:2:5","series":null,"tags":["Tech"],"title":"嵌入式中的启动流程","uri":"/posts/booting-process-in-embedded/#支持ps命令"},{"categories":["Tech"],"content":" 构建根文件系统 构建并安装busybox选择busybox作为系统的init程序后就可以使用类似uboot，rtthread等操作进行编译 进入busybox源码文件夹，执行make menuconfig进行配置 之后make编译 在上一步获得编译产物后执行make CONFIG_PREFIX=/path/from/root install将buysbox安装到目标机器上，注意这里需要添加参数，防止将busybox安装到pc机上破坏系统 在执行完上述步骤后，对应的/path/from/root文件夹内就会出现bin，linuxrc，sbin，usr目录，其中linuxrc-\u003e/bin/busybox 之后创建/dev/console和/dev/null设备 在本机内获得这两个设备的设备号，ls /dev/console /dev/null -l 在/path/from/root创建文件夹，mkdir dev 在dev内创建设备节点，sudo mknod console c 设备号，这里的c代表字符设备 设备节点创建完毕 而后修改/etc/inittab mkdir etc vi /etc/inittab 写入console::askfirst:-/bin/sh，这样开机就可以进入shell 下面安装c库，这里的c库来源于交叉编译工具链的c库 创建lib文件夹存放动态链接库文件，mkdir lib cp /path/to/cross-tools/gcc-version-glibc-version/\\*.so\\* lib -d，这里的-d代表将链接文件拷贝过来，而不是将链接的源文件拷贝过来，这样可以减小根文件系统体积 至此文件系统就构建好了，尽管没有指定用户编写的应用程序，但这并不妨碍文件系统正常启动 这里我们还需要将根文件系统制作成映像文件 这里使用yaffs作为映像文件制作工具 安装yaffs，步骤与上面类似 make(不需要menuconfig) 将编译产物放到宿主机的/bin并给予执行权限 mkyaffs2image myfs myfs.yaffs，这样就制作完成映像文件系统了 将映像文件烧录进带有内核的目标机上就可以启动根文件系统 此时根文件系统下有如下目录：bin dev etc lib linuxrc lost+found sbin usr 支持ps命令此时执行ls，cat，rm等命令都可以正常执行，但是执行ps命令就会失败 这是因为ps需要根文件系统支持proc设备和proc文件系统，在这里就需要将proc作为虚拟文件系统挂载到内核 执行mount -t proc none /proc这里的none指的是不依赖实际硬件设备 想要将上述步骤自动化，需要作如下修改 vi /etc/inittab 写入::sysinit:/etc/init.d/rcS 创建/etc/init.d/rcS文件并给予执行权限 在该文件内写入mount -t proc none /proc 此时根文件系统下有如下目录：bin dev etc lib linuxrc lost+found proc sbin usr (新增proc文件夹) 这里的lost+found文件夹是内核自动创建的，而在映像文件系统内没有这个文件夹 进一步支持多种文件系统除了mount -t mount_point device命令，还有一个更简便的mount -a命令，该命令会查找/etc/fstab文件中查找对应的为文件系统并挂载，想要支持ps命令，需要如下操作 vi /etc/init.d/rcS 在该文件内写入mount -a vi /etc/fstab 写入如下内容 config # device mount-point type options dump fsck order proc /proc proc defaults 0 0 使用udev更进一步简化设备挂载过程udev是内核支持的一个能够自动创建设备节点的机制，是为了避免根文件系统内所有设备都执行sudo mknod console c 设备号创建设备节点的灾难性场景所提出的解决方案，linux提供udev机制来自动创建设备节点并挂载设备，该机制依赖于热插拔系统。在busybox中则需要使用mdev，这是udev的简化版本 下面是该机制的使用方法 vi /etc/fstab 写入如下内容 config # device mount-point type options dump fsck order proc /proc proc defaults 0 0 sysfs /sys sysfs defaults 0 0 tmpfs /dev tmpfs defaults 0 0 tmpfs /tmp tmpfs defaults 0 0 vi /etc/init.d/rcS 写入如下内容 shell mount -a mkdir /dev/pts mount -t devpts devpts /dev/pts echo /bin/mdev \u003e /proc.sys/kernel/hotplug # 将mdev的设备加载到热插拔目录中，这样插入或拔出新设备时会自动创建或删除设备节点 mdev -s # 主动加载mdev，创建节点 这样，进入根文件系统后就会自动挂载设备并创建设备节点，此时根文件系统下有如下目录：bin dev etc lib linuxrc lost+found proc sbin sys usr (新增sys文件夹) ","date":"2025-06-01","objectID":"/posts/booting-process-in-embedded/:2:5","series":null,"tags":["Tech"],"title":"嵌入式中的启动流程","uri":"/posts/booting-process-in-embedded/#进一步支持多种文件系统"},{"categories":["Tech"],"content":" 构建根文件系统 构建并安装busybox选择busybox作为系统的init程序后就可以使用类似uboot，rtthread等操作进行编译 进入busybox源码文件夹，执行make menuconfig进行配置 之后make编译 在上一步获得编译产物后执行make CONFIG_PREFIX=/path/from/root install将buysbox安装到目标机器上，注意这里需要添加参数，防止将busybox安装到pc机上破坏系统 在执行完上述步骤后，对应的/path/from/root文件夹内就会出现bin，linuxrc，sbin，usr目录，其中linuxrc-\u003e/bin/busybox 之后创建/dev/console和/dev/null设备 在本机内获得这两个设备的设备号，ls /dev/console /dev/null -l 在/path/from/root创建文件夹，mkdir dev 在dev内创建设备节点，sudo mknod console c 设备号，这里的c代表字符设备 设备节点创建完毕 而后修改/etc/inittab mkdir etc vi /etc/inittab 写入console::askfirst:-/bin/sh，这样开机就可以进入shell 下面安装c库，这里的c库来源于交叉编译工具链的c库 创建lib文件夹存放动态链接库文件，mkdir lib cp /path/to/cross-tools/gcc-version-glibc-version/\\*.so\\* lib -d，这里的-d代表将链接文件拷贝过来，而不是将链接的源文件拷贝过来，这样可以减小根文件系统体积 至此文件系统就构建好了，尽管没有指定用户编写的应用程序，但这并不妨碍文件系统正常启动 这里我们还需要将根文件系统制作成映像文件 这里使用yaffs作为映像文件制作工具 安装yaffs，步骤与上面类似 make(不需要menuconfig) 将编译产物放到宿主机的/bin并给予执行权限 mkyaffs2image myfs myfs.yaffs，这样就制作完成映像文件系统了 将映像文件烧录进带有内核的目标机上就可以启动根文件系统 此时根文件系统下有如下目录：bin dev etc lib linuxrc lost+found sbin usr 支持ps命令此时执行ls，cat，rm等命令都可以正常执行，但是执行ps命令就会失败 这是因为ps需要根文件系统支持proc设备和proc文件系统，在这里就需要将proc作为虚拟文件系统挂载到内核 执行mount -t proc none /proc这里的none指的是不依赖实际硬件设备 想要将上述步骤自动化，需要作如下修改 vi /etc/inittab 写入::sysinit:/etc/init.d/rcS 创建/etc/init.d/rcS文件并给予执行权限 在该文件内写入mount -t proc none /proc 此时根文件系统下有如下目录：bin dev etc lib linuxrc lost+found proc sbin usr (新增proc文件夹) 这里的lost+found文件夹是内核自动创建的，而在映像文件系统内没有这个文件夹 进一步支持多种文件系统除了mount -t mount_point device命令，还有一个更简便的mount -a命令，该命令会查找/etc/fstab文件中查找对应的为文件系统并挂载，想要支持ps命令，需要如下操作 vi /etc/init.d/rcS 在该文件内写入mount -a vi /etc/fstab 写入如下内容 config # device mount-point type options dump fsck order proc /proc proc defaults 0 0 使用udev更进一步简化设备挂载过程udev是内核支持的一个能够自动创建设备节点的机制，是为了避免根文件系统内所有设备都执行sudo mknod console c 设备号创建设备节点的灾难性场景所提出的解决方案，linux提供udev机制来自动创建设备节点并挂载设备，该机制依赖于热插拔系统。在busybox中则需要使用mdev，这是udev的简化版本 下面是该机制的使用方法 vi /etc/fstab 写入如下内容 config # device mount-point type options dump fsck order proc /proc proc defaults 0 0 sysfs /sys sysfs defaults 0 0 tmpfs /dev tmpfs defaults 0 0 tmpfs /tmp tmpfs defaults 0 0 vi /etc/init.d/rcS 写入如下内容 shell mount -a mkdir /dev/pts mount -t devpts devpts /dev/pts echo /bin/mdev \u003e /proc.sys/kernel/hotplug # 将mdev的设备加载到热插拔目录中，这样插入或拔出新设备时会自动创建或删除设备节点 mdev -s # 主动加载mdev，创建节点 这样，进入根文件系统后就会自动挂载设备并创建设备节点，此时根文件系统下有如下目录：bin dev etc lib linuxrc lost+found proc sbin sys usr (新增sys文件夹) ","date":"2025-06-01","objectID":"/posts/booting-process-in-embedded/:2:5","series":null,"tags":["Tech"],"title":"嵌入式中的启动流程","uri":"/posts/booting-process-in-embedded/#使用udev更进一步简化设备挂载过程"},{"categories":["Tech"],"content":"本文是笔者学习RISC-V时系统总结而成的，包含上下两部分，第一部分对RISC-V进行系统性介绍，包含RISC-V项目的基本情况与规范，基本命令的介绍，与OS的关系等内容。其参考资料为b站的rvos，视频由中科院软件所汪辰主讲，PLCT项目负责人吴伟发布。第二部分系统的介绍了RISCV体系结构部分，虽然与源码级别工程仍有差距，但作为嵌入式软件/系统工程师来说深度广度足够了，该部分参考书籍为《RISCV体系结构编程与实践 -笨叔》，笨叔也有arm相关的著作以及更为出名的Linux相关的书籍，因此笔者也推荐使用笨叔的两本不同体系结构的书籍对比学习。 ","date":"2025-01-01","objectID":"/posts/risc-v/:0:0","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#"},{"categories":["Tech"],"content":" RISC-V","date":"2025-01-01","objectID":"/posts/risc-v/:0:0","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#risc-v"},{"categories":["Tech"],"content":" 前置知识ISA: 指令集架构，是底层硬件向上层软件提供的一层接口规范。ISA的出现使得软件开发者不必关心具体的硬件电路结构 ISA定义了如下方面 基本数据类型(byte,word,halfword) 寄存器 指令 寻址模式 异常和中断 …… 微架构：硬件对指令集架构的实现，更关注功耗，发热，速度，成本等制造的问题 ISA的宽度与指令宽度无关，它指的是通用寄存器的宽度 riscv灵感来自于mips，mips最初是斯坦福大学教授的产品，后来由于经营问题失败，该教授也是riscv之父 ","date":"2025-01-01","objectID":"/posts/risc-v/:1:0","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#前置知识"},{"categories":["Tech"],"content":" RISCV的ISA基本情况riscv由一个基本指令集+若干个可选的扩展指令集组成，基本指令集永远不会变 riscv每条指令宽度32位(虽然有16位的压缩指令集)，但是并没有64位宽的指令。这是由于无论是riscv32还是riscv64都只有32个通用寄存器，处理器位数的差异只在于寄存器的位宽是32位还是64位，因此控制这32个寄存器只需要5个位宽的索引就够了，这样32位宽的指令就已足够使用。尽管只有32位宽的指令，我们也可以通过LUI以及ADDI指令将64位数加载进寄存器从而灵活访问超过4GB内存大小的地址 基本整数指令集(I)：唯一要求强制实现的指令集，其他指令集都是扩展模块 扩展指令集：M(整数乘法指令集)，A(原子指令集)，F(浮点指令集)，D(双精度指令集)，C(压缩指令集) 特定组合：IMAFD被称为通用组合，用G表示 RV64I：64位的riscv整数指令集，兼容RV32I 压缩指令集是为了提高指令密度出现的。有时arm的一条指令可以执行两个操作，例如LDP和STP内存存储指令，但是在riscv中需要两条指令才能完成: 一条负责执行加载/存储内存数据，另一条负责修改基地址。而这直接导致了编译同一份代码，riscv生成的机器码指令多于arm，最终不仅需要更大的存储空间还会降低缓存命中率。因此riscv使用16位宽指令代替32位宽的指令产生了RVC指令集，这样，尽管32位寄存器只能运算1条16位指令，但指定位数降低降低了存储压力也提高了缓存命中率。RVC兼容性也很好，可用于RV32，RV64，RV128上 RISC-V 定义了 32 个通用寄存器（x0 至 x31）以及一个程序计数器（pc）。与 ARM 或 x86 架构不同，RISC-V 的 pc 无法被显式地在用户程序中直接读取或修改，它只能通过跳转和分支指令间接更改 这一设计在 RV32I、RV64I 和 RV128I 等基础整数指令集中是一致的 RV32E 是为嵌入式系统设计的精简版本，仅保留了前 16 个通用寄存器（x0–x15），以减少硬件资源开销 若实现支持浮点扩展（如 F 或 D 模块），还需额外提供 32 个浮点寄存器（f0–f31） hart(hardware thread)：为了防止因超线程导致线程概念被混淆，riscv标准规定了hart概念，一个hart对应的就是一个超线程 riscv规定了三个特权级：machine，supervisor和user，三个特权级权限依次降低 特权级别的区分在于他们分别有各自的csr(control and state)寄存器，高特权级别可以访问低级别的csr 物理内存保护和虚拟内存： 物理内存保护类似x86的实模式，在machine模式中可以指定user模式下可以访问的内存空间及其权限。该机制可以看作是一种简单的段式内存保护机制，但它并不等同于 x86 实模式中的分段 虚拟内存需要supervisor和mmu的支持 异常与中断：尽管在之前已经多次学习了这两个概念，但是在riscv规范中表述更严谨，下列结论也同时使用arm和x86架构 当程序触发异常时，cpu会跳转到异常处理程序，这个处理程序由开发者自行编写，当处理程序执行完毕后跳回到发生异常的代码重新执行 当触发中断时，cpu会跳转到中断处理程序，这个处理程序由开发者自行编写，当处理程序执行完毕后跳回到发生中断的下一行代码执行 elf文件主要有四类： .o .out .so 核心转储core文件 elf文件大致内容如下 2025-01-01_21-57 elf header指定了该elf文件的基本内容，包括编译器，可运行的架构等内容，program header table指定了运行时该以何种方式加载进内存。section header table表示了该文件链接时是如何生成的。不将这些section直接加载进内存的原因是这些段需要内存对齐，一旦对齐会浪费很多空间。因此program header table将相似的section作为segment来将其加载进内存 由于elf文件内有许多运行代码时不需要的调试信息，我们可以生成.bin文件来删除这些信息 ","date":"2025-01-01","objectID":"/posts/risc-v/:2:0","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#riscv的isa基本情况"},{"categories":["Tech"],"content":" RISCV汇编下面的指令均以RV32I为例 汇编程序语法与编译器有很大关系，在gnu工具链上的可以运行的汇编程序在llvm可能运行失败 riscv汇编的结构： [label:][operation][comment] label：gnu汇编中，任何以冒号为结尾的标识符都被视作标号，label可以被视为地址 operation： instruction：直接对应机器指令的汇编指令 pseudo-instruction：一条伪指令可以产生多条机器指令 directive：以\".“用来控制汇编器处理代码的指令 macro：采用.macro自定义的宏 comment：注释，常用# ; // 指令长度ILEN：32bits(RV32I) 指令对齐IALIGN：32bits(RV32I) 指令在内存中按小端序排列 大段序：数据高位放在内存低地址 小段序：数据低位放在内存低地址 RISC-V 指令的基本长度为 32 位（压缩指令 RV32C 为 16 位），按功能分为 6 种主要格式： 格式名称 用途 主要指令示例 R-type 寄存器-寄存器操作 add, sub, and, or, sll I-type 立即数操作、加载、跳转 addi, lw, jalr S-type 存储指令 sw, sh, sb B-type 条件分支 beq, bne, blt U-type 长立即数（高位） lui, auipc J-type 无条件跳转 jal 压缩指令（RV32C）也有类似的分类，但采用 16 位编码 下图是整数指令集的指令： ","date":"2025-01-01","objectID":"/posts/risc-v/:3:0","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#riscv汇编"},{"categories":["Tech"],"content":" 算数运算指令rs：register source rd：register destination 立即数指令 riscv没有subi指令，因为subi可以用addi代替 直接加载一个大数会出现符号问题 由于addi指令会对立即数进行符号扩展，即不满32位的立即数，其高位/低位会按符号位的值进行填充，这时会出现addi x1,x1,0xfff实际上加的是0xffff ffff，也就是-1的情况 代码中常用li指令赋值，之后由汇编器进行判断对指令转换成何种形式 auipc用于构造相对地址，相对寻址和生成位置无关码 使用la伪指令后，链接器会自动找到label的地址并替换，最后使用auipc进行相对寻址 ","date":"2025-01-01","objectID":"/posts/risc-v/:3:1","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#算数运算指令"},{"categories":["Tech"],"content":" 逻辑运算指令riscv只提供了与，或，异或等指令，并没有直接提供非指令，非指令通过伪指令来提供，实际上它是使用异或来实现的 如下异或运算 10101010 ^ 11111111 = 01010101 因此可以凭借异或取反 ","date":"2025-01-01","objectID":"/posts/risc-v/:3:2","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#逻辑运算指令"},{"categories":["Tech"],"content":" 移位运算指令移位运算可以通过寄存器指定移位的值，也可以通过立即数指定 算数移位只有右移没有左移，因为左移会把符号位移丢弃 ","date":"2025-01-01","objectID":"/posts/risc-v/:3:3","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#移位运算指令"},{"categories":["Tech"],"content":" 内存读写指令sign-extended：符号扩展，如果取到的数的位数不足32bit，那么剩下的bit使用该数的符号位填充剩余的位 zero-extended：零扩展，如果取到的数的位数不足32bit，那么剩下的bit使用0填充剩余的位 LW没有符号扩展和零扩展的原因是加载数据的宽度已经是32位了，无需再将数据扩展至寄存器宽度 内存写指令没有0扩展或者符号扩展是因为磁盘存储单位是字节，而不是寄存器的32位的字，因此无需任何扩展 ","date":"2025-01-01","objectID":"/posts/risc-v/:3:4","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#内存读写指令"},{"categories":["Tech"],"content":" 条件分支指令 ","date":"2025-01-01","objectID":"/posts/risc-v/:3:5","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#条件分支指令"},{"categories":["Tech"],"content":" 无条件跳转指令 ","date":"2025-01-01","objectID":"/posts/risc-v/:3:6","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#无条件跳转指令"},{"categories":["Tech"],"content":" 汇编函数调用约定注意：ra存放的是函数返回地址，a0存放的是函数参数和返回值 函数参数使用a0-a7传递，返回值使用a0和a1传递 我们在编程时常使用伪指令，尤其是call和ret 编写汇编调用函数时需要在被调用的函数最前方写压栈操作，末尾写出栈操作。在编写c代码时不必如此，因为编译器会自动生成这些代码 ","date":"2025-01-01","objectID":"/posts/risc-v/:4:0","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#汇编函数调用约定"},{"categories":["Tech"],"content":" 汇编与C混合编程在汇编中调用c函数直接使用call func_name即可 在c中调用汇编代码规则如下： c asm volatile(可选)( \"汇编指令\" :输出操作数(可选) :输入操作数(可选) :可能影响的寄存器(可选) ); volatile可以取消编译器的优化 例如如下代码 首先是复杂一点的 c int add(int a, int b){ int c; asm volatile( \"add %[sum], %[add1], %[add2]\" :[sum]\"=r\"(c) // 输出：c 的值通过寄存器写入 :[add1]\"r\"(a),[add2]\"r\"(b) // 输入：a 的值通过寄存器读取，输入：b 的值通过寄存器读取 ); return c; } sum，add1，add2是寄存器的代号，这里要求编译器提供，因为如果我们强行指定寄存器可能会丢失这个寄存器之前的内容。“r\"代表让编译器为当前变量分配一个通用寄存器，\"=“代表输出(只写)，时我们也可以使用m代表对内存进行操作 由于sum，add1，add2是寄存器的代号，因此上面的代码还可以利用匿名操作数进行简化 c int add(int a, int b){ int c; asm volatile( \"add %0, %1, %2\" //这里可以不必指定名称 :\"=r\"(c) :\"r\"(a),\"r\"(b) ); return c; } ","date":"2025-01-01","objectID":"/posts/risc-v/:5:0","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#汇编与c混合编程"},{"categories":["Tech"],"content":" 杂项在启动时，无论有多少个核，只会有一个hart id为0的才会进入启动流程，其他核都被wfi c _start: #park hart with id != 0 csrr t0 mhartid mv tp t0 bnez t0 park park: wfi j park csrr是csrrs的伪指令，csrrs(control state register atomic read and set)，csrr只保留了读取csr的功能 RISC-V 采用了类似 ARM 的统一编址（Unified Addressing）机制，即内存和外设共享同一个地址空间。因此，不像 x86 那样需要通过专门的 I/O 指令（如 in / out）来访问外设，RISC-V 只需通过普通的内存读写指令即可访问外设寄存器，就像操作内存一样。不过，在使用前，必须将外设的寄存器地址映射到系统的物理地址空间中。这一映射过程与内存（如 DRAM）类似。例如，尽管某系统中的 DRAM 被映射在 0x80000000 到 0x88000000 之间，占用 128MB 的地址空间，但这并不意味着系统一定安装了 128MB 的物理内存，它只是预留了一个最大支持范围为 128MB 的地址区间。DRAM 实际可访问的大小取决于具体硬件配置。同样，外设的 I/O 寄存器也被分配到物理地址空间的某些区域，CPU 访问这些地址时，本质上就是在与外设进行读写通信。但系统必须通过 SoC 内部的总线或内存映射（Memory-Mapped I/O, MMIO）机制，将这些地址与对应外设正确连接起来 各个.o文件统一被链接为可执行文件的过程会使用链接器脚本，脚本内部指定了链接时各个.o文件的各个段该如何合并为一个.elf文件中的一个段，以及该段应该被加载进内存的哪个位置。因此，链接脚本的内容会根据板子的不同而不同 链接器脚本会自动帮我们算出各段的起始地址和大小，我们可以给予其名称来在c代码中调用 ","date":"2025-01-01","objectID":"/posts/risc-v/:6:0","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#杂项"},{"categories":["Tech"],"content":" rvosrvos启动流程(没有bootloader)： 设置全局栈的大小 选择id为0的hart 利用该hart和全局栈大小初始化栈指针 跳转到start_kernel函数 在start_kernel内初始化第一个任务(将第一个任务的地址放入ra，第一个任务的栈地址放入sp)并执行调度器 ","date":"2025-01-01","objectID":"/posts/risc-v/:7:0","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#rvos"},{"categories":["Tech"],"content":" 中断和异常riscv的csr mtvec类似arm的中断向量表的基址寄存器，该寄存器有两种模式： Direct模式不需要设置中断向量表，但是需要软件主动查询mcause寄存器来判断是异常还是中断，并进一步判断调用哪个处理函数 Vectored模式需要中断向量表，也就是中断处理函数必须以数组的形式放在内存的某一处并进行内存对齐。该模式会由硬件根据mcause的值自动计算中断号，并跳转到对应函数执行 mtvec的vectored mode类似于arm的中断向量表 类似函数调用时需要保存当前指令地址的作用，调用中断处理函数也需要保存当前正在执行的函数的执行位置，这时应把发生中断时的指令或下一条指令保存到mepc mcause是中断异常原因寄存器 mtval是mcause的补充，可以获得更详细的异常信息，例如发生异常时的指令或地址，错误的返回值等 mstatus的xpie可用于恢复中断时获取原中断状态，xpp用于保存中断发生值前的权限级别(supervisor/machine)，注意，mstatus并不包含user特权级的中断保存，这是因为user特权级没有资格处理中断 xpie与xpp的p指的是previous riscv的trap处理流程分为上下两部分，上半部通过硬件设置寄存器完成，下半部通过软件处理trap完成 从特权模式下返回 mie可以被写，用来控制中断开关，mip可以被读，用来获取中断状态 plic(paltform level interrupt controller)类似于linux的pinctrl子系统中的gic，它负责将多个中断源汇聚起来分配给若干个hart 软中断不同于由硬件事件触发的外部中断或定时器中断，它是一种由软件发起的中断。在 RISC-V 架构中，可以通过向 CLINT（Core Local Interruptor） 中的 msip（Machine Software Interrupt Pending）寄存器写入 1 来触发软中断。这会使对应 Hart（硬件线程）产生一个软件中断，从而进入中断处理流程，实现了软件控制中断的目的 异常处理流程总结 发生异常时，触发异常的指令被保存进mepc寄存器内 随后记录异常，mcause 寄存器会被设置为当前异常或中断的类型编号，同时最高位标志位（bit[63]）表示是中断（1）还是同步异常（0） 将mstatus寄存器的mie位保存进mpie位，并将mie位清零即禁止中断，同时还要通过软件将触发异常时的权限模式保存进mstatus的mpp位 将pc值修改为mtvec寄存器的值，该值保存了异常处理入口的地址 处理异常 处理完成后使用mret指令返回 该指令将pc设置为触发异常时保存的mepc的值 将mstatus的mpie位恢复到mie位来恢复中断，并将 MPP 中保存的特权级恢复为当前特权级，回到原来的上下文 ","date":"2025-01-01","objectID":"/posts/risc-v/:7:1","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#中断和异常"},{"categories":["Tech"],"content":" 内核态与用户态rvos只实现了m，u两种状态，其原理是在start_kernel之前的汇编代码中需要设置mstatus寄存器的mpp标志位来使中断恢复后系统位于m特权级，为了支持用户态，我们只需取消设置mpp位即可，这样在中断恢复时系统会变为用户态 在用户态我们就无法获取内核态所能访问的寄存器，例如mhartid寄存器，当用户态强行访问该寄存器时会触发异常，之后系统会转到异常调用表里执行对应异常处理函数(此时并未涉及到系统调用号) 从用户态转为内核态时需要使用ecall指令，内核处理完成转为用户态时使用eret指令 ecall 指令类似arm体系结构中的svc，用于主动触发一个环境调用（Environment Call）异常，通常用于从用户态或更低特权级请求操作系统提供服务（即系统调用）。异常发生时，异常类型会根据当前的特权级不同而设置为不同的异常码（mcause 或 scause 中会体现） 当 ecall 触发异常时，CPU 会将当前指令的地址（即 ecall 指令的地址）保存在 mepc（或 sepc）寄存器中。由于 mepc 保存的是异常发生时的地址，如果在异常处理程序中不手动将其加上指令长度（通常为 4 字节），那么执行 mret 指令返回后将重新执行 ecall，从而导致死循环 因此，在异常处理函数中，通常需要手动执行： c mepc += 4; 最后，通过执行 mret（或 sret）指令，CPU 将从异常处理程序返回，恢复到异常发生前的状态，并切换回用户态或之前的特权级，继续正常执行 与其他体系架构不同的是，riscv在切换特权级别时并没有寄存器或者比特位来存储系统调用号，它参考linux系统调用，规定了系统调用号放在a7寄存器中 上图的trap_handler是根据riscv芯片手册指定的异常处理函数编写的，内部包含了缺页异常，io异常，系统调用，除零异常等异常 对于syscall头文件需要分为两份，一份给c库，一份给内核。这样在程序开发者的手中可以根据libc的库文件编译出来包含系统调用的app，app在运行时就可以通过系统调用进入内核 ","date":"2025-01-01","objectID":"/posts/risc-v/:7:2","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#内核态与用户态"},{"categories":["Tech"],"content":" RISCV体系结构编程与实践 -笨叔","date":"2025-01-01","objectID":"/posts/risc-v/:8:0","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#riscv体系结构编程与实践-----笨叔"},{"categories":["Tech"],"content":" 链接器与脚本链接器ld(loader)：在早期unix系统中被称为加载器，是os的一部分，后来由于os越来越复杂，链接器就独立出来了 ld常用选项： -T 指定链接脚本 -Map 输出一个符号表文件 链接脚本：采用AT\u0026T链接脚本语言 c SECTIONS{ .=0x80000000; .text:{\\*(.text)} .=0x80002000; .data:{\\*(.data)} .bss:{\\*(.bss)} } “.“表示当前位置计数器，用于把代码段和数据段的链接地址设置为0x80000000和0x80002000 “*“表示所有.o文件，*(.text)表示所有.o文件的代码段。可以看出，连接器脚本只指定段，符号的地址，而不能指定符号的值，符号的值是在高级语言内指定的 在实际的编程中，我们常常要访问链接脚本的符号(如rtt中将at命令单独放在一命名符号段)，我们可以进行如下操作 c start_of_ROM=.ROM end_of_ROM=.ROM+SIZEOF(ROM) start_of_FLASH=.FLASH 在C中可以通过以下操作访问符号的段 c extern char start_of_ROM, end_of_ROM, start_of_FLASH; memcpy(\u0026start_of_FLASH, \u0026start_of_ROM, \u0026end_of_ROM - \u0026start_of_ROM); 这样就可以将ROM段的内容拷贝到FALSH 实际上，我们也可以将段视为数组 c extern char start_of_ROM[], end_of_ROM[], start_of_FLASH[]; memcpy(start_of_FLASH, start_of_ROM, end_of_ROM - start_of_ROM); 这样就不用取址了 脚本语言内置函数 ABSOLUTE(exp) c SECTIONS { .=0xb000; .myoffset:{ myoffset1 = ABSOLUTE(0x100); #myoffset1地址: 0x100 myoffset2 = (0x100); #myoffset2地址: 0xb100 } } SIZEOF(SECTION) 返回一个段的大小 PROVIDE 将链接脚本中的一个符号导出 INCLUDE 引入另外的链接脚本 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:1","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#链接器与脚本"},{"categories":["Tech"],"content":" 内联汇编与C宏结合宏参数使用”#\"，预处理器会将其转为字符串 “##“用于连接两个标识符 c #define ATOMIC_OP(op,asm_op,i,asm_type,c_type,prefix) \\ static __always_inline \\ void atomic##prefix##_##op(c_type,I,atomic##prefix##_t *v) \\ { \\ __asm__ __volatile__( \\ \"amo\"#asm_op\".\"#asm_type\"zero, %1, %0\" #假设asm_op参数为add，那么该行被改写为amoadd.w zero %1, %0 \\ :\"+A\"(v-\u003ecounter) \\ :\"r\"(I) \\ :\"memory\"); \\ } #define ATOMIC_OPS(op, asm_op,I) ATOMIC_OP(op,asm_op,I,w,int,I) ATOMIC_OPS(add,add,i) ATOMIC_OPS(add,add,-i) ","date":"2025-01-01","objectID":"/posts/risc-v/:8:2","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#内联汇编与c宏结合"},{"categories":["Tech"],"content":" 链接地址，加载地址与运行地址链接地址：链接时生成的地址，在含有mmu的系统中链接地址通常被设置为0x0或其他固定地址，并通过PIC(位置无关码)生成受mmu支持的程序。在不含有mmu的系统中，链接地址与rom中的存储地址相同(也被称为加载地址)。需要注意的是即使生成了PIC，但是一些静态、全局数据依然需要确定绝对地址，而这是通过got表(存放全局变量地址)，rel.got表(存放函数地址)，rel.dyn表，动态加载器，指定数据放入链接脚本中已经规划好的段等方式来解决的 加载地址：程序在rom中的存储地址，在arm中rom与ram不共享存储空间，在一些riscv中，ram与rom可能共享存储空间 运行地址：程序在ram中的地址，运行地址可以通过PIC与链接地址解耦 再次强调，使用PIC后，程序可以在链接地址!=加载地址!=运行地址的情况下运行 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:3","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#链接地址加载地址与运行地址"},{"categories":["Tech"],"content":" 启动过程中的加载重定位下面以使用opensbi，uboot和linux的情况下的启动过程为例来介绍启动过程中的加载重定位 系统启动时，cpu从固化在芯片中的bootrom取出第一行代码并执行，直至将bootrom中所有代码执行完毕。bootrom程序内部包含了基本硬件初始化，但更重要的是它将硬盘中0x0地址处内存页大小的数据(4KB)搬运到芯片中的内存(sram)中。注意此时bootrom是固化在芯片上的，因此他不占用内存地址空间，运行地址为空，加载地址和链接地址相等，并且都为硬盘中的第一个块/扇区的地址0x0。我们还可以发现，当不考虑bootrom时，包含bootloader的系统的rom上第一个块/扇区存储的就是bootloader，对于没有bootloader的系统，rom第一个块/扇区存储的是中断向量表，并在中断向量表中的reset处理函数内执行系统软硬件初始化(对于stm32而言会在hal层的__main进行)，执行完毕后最终跳转到用户main函数。前者将这一阶段放到了os内部进行，例如linux会在内核启动时获得uboot传入的设备树 cpu从sram中读取这4KB代码并执行，其内容是初始化ddr并将m模式的opensbi以及uboot装载进ddr(没有opensbi的系统会直接装载uboot)的0x8000 0000地址处(该地址为ddr的地址空间的初始地址，可以由厂商指定存放位置)。这里没有装载进sram的原因是sram太小了(10KB~100KB)，并且由于此时刚完成ddr的初始化，所以优先将opensbi装载到ddr 随后处于m模式的openabi将权限交给s模式的uboot，uboot进行启动准备工作，在将linux内核复制到ddr中的0x8000 2000地址处后将权限交给内核。注意这里内核与uboot地址相距0x2000，这是为了防止内核覆盖掉uboot 内核进行硬件初始化，并开启mmu等操作 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:4","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#启动过程中的加载重定位"},{"categories":["Tech"],"content":" 链接器松弛优化链接器松弛优化可以分为两种优化方式 函数跳转优化 这种优化可以减少不必要的指令，本质是编译器使用jal指令代替auipc(20位imm左移12位)+jalr(12位有符号数内寻址)指令，前者可在PC±2GB(32位有符号数)范围内寻址，后者可在PC±1MB(21位有符号数)范围内寻址 例如如下指令 c auipc ra 0x0 jalr -24(ra) #5fc\u003cfoo\u003e //跳转到ra寄存器 - 24处的地址。编译器提示该处地址为5fc，是foo函数的地址 可被替换为 c jal ra, 5fc \u003cfoo\u003e 符号地址访问优化 使用gp(x3)寄存器进行相对寻址以节省指令，gp指向.sdata段(小数据段)中部的一个固定地址，若某变量位于该地址±2KB范围内，可以使用lw或addi来代替auipc+addi指令 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:5","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#链接器松弛优化"},{"categories":["Tech"],"content":" SBISBI(system binary interface)：sbi与abi类似，前者是isa给os提供的接口，用于串口打印(opensbi也将串口标准化了)，中断管理，tlb管理以及启动管理，后者是os给app提供的接口，用于资源管理，锁管理等等 sbi提高了硬件的可移植性，可以在不同种类的os上无感移植，并且提高了芯片的安全性。sbi固件运行在m模式，给s模式的os提供接口 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:6","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#sbi"},{"categories":["Tech"],"content":" 异常处理riscv支持的异常处理模式 直接访问模式 所有陷入m模式的异常都会跳转到mtvec的base字段的地址，但需要软件去判别mcause的值并指定对应的异常处理程序，该种方式不需要中断向量表，中断处理函数可以分布在代码各处 向量访问模式 跳转到异常向量标的某一项，该项由硬件查询mcause的值并计算出来，无需软件帮助，该种方式需要中断向量表，中断处理函数集中放在内存固定区域，函数地址需进行内存对齐 异常不仅有m模式还有s模式，这可以避免因模式切换带来的性能损失.常见的s模式异常包括：ecall，非法指令异常，指定地址未对齐，加载页错误，存储页错误等 riscv中断分为本地中断(软件，定时器)，和外部中断(外设等)，本地终端通过CLINT(core local interruptor)产生并直接发送给hart来处理，外部中断由外设等产生，经由PLIC路由再发给对应的hart处理，因此内部中断无需PLIC路由 svc是arm的触发软件中断进入内核层的命令，ecall是riscv的。svc通过立即数传递系统调用号，ecall通过寄存器a7传递。并且ecall还支持从s模式向m模式切换 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:7","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#异常处理"},{"categories":["Tech"],"content":" 主存，高速缓存与TLB简要介绍多进程访问同一个虚拟地址可以成功的原因是，每个进程都有自己的运行空间，也就有一套自己的页表，根本原因是切换进程时可以通过切换页表基地址寄存器来访问不同进程的页表，这样在查找n级页表时就是对应进程的n级页表了 rv64通常使用3级(sv39)或4级页表(sv48)，rv32使用2级页表(sv32)，所谓的svxx指的是虚拟地址的低xx位用于页表索引 以内存为视角，体系结构分为两种：UMA(统一内存访问)， NUMA(非统一内存访问) tlb(translation lookaside buffer，翻译后备缓冲区)，该硬件位于mmu内，缓存了查询页表的结果 以vipt(virtual index physical tagged)为例讲解cpu寻址过程： cpu访问虚拟地址时，会将虚拟地址同时发给tlb和高速缓存，若tlb未命中，则需访问对应线程的页表(通常位于主存)，并将地址和数据写入高速缓存中以待cpu读取。若tlb命中，则直接获取物理地址，并根据该地址从高速缓存中获取数据 同时高速缓存根据虚拟地址的索引来确定所需的数据位于哪个组，并通过标记域在组内寻找高速缓存的某一行，若找到就被称为高速缓存命中。若未命中，则需要重新从主存获取数据 高速缓存高速缓存的组织方式包括以下三种 直接映射 全相联映射 组相联映射 由于高速缓存是按行来组织的，因此cpu每次访问内存都至少会将一个高速缓存行大小的数据写入高速缓存，这样，内存中实际的最小单元就不是字节而是高速缓存行大小了。例如某个高速缓存有如下组织： 1路，每路64行，每行512字节，共64KB高速缓存。因此，主存就被划分为若干块的区域，每块大小64KB(64KB除以1路)，内存地址与高速缓存的地址映射关系是：数据在高速缓冲区的行号=主存地址%32KB/512，在缓存行的内的偏移量为主存地址%32KB%512 如果我们采用直接映射的缓存组织方式，假设访问内存的数据都落在0x80000000-0x8000000FF(共64KB)，高速缓存将发挥他的最大威力，但是当我们访问的数据位于0x80000000，0x80000100，0x80000200，那么高速缓存的第一个缓存行就会被频繁的换入换出，这就是高速缓存颠簸 为了解决缓存颠簸问题我们采用了组相连缓存的组织方法，我们只需要将原来的缓存大小一分为二，这被称为2路组相连缓存，其中一个作为备份以应对缓存颠簸，当颠簸发生时，我们有50%的可能性会发生缓存换入换出的问题，如果是4路，该问题发生的可能性降低为25% 注意，当采用组相连缓存时，新的组概念意味着彼此不同路的行的集合，路概念被保留 cpu访问高速缓存时，传入的地址是虚拟地址还是物理地址？这实际上分为3种情况 PIPT：cpu通过物理地址查询高速缓存，这种方式每次都需要tlb介入，部分情况下甚至需要mmu进行地址转换，效率较低 VIVT：cpu通过虚拟地址查询高速缓存 实际上，还有一种物理地址和虚拟地址结合的查找方式，详见下文 当cpu通过地址来查找高速缓存时，该地址被解析为标记域和索引域。也就是说标记域与索引域可能来自虚拟地址也可能来自物理地址，因此有如下3种情况 PIPT(physical index physical tagged)，传入的是mmu转换过的物理地址，该地址的索引段和标记段均由物理地址组成，不会导致重名问题以及别名问题。该种组织方式对于大规模高速缓存很友好，但代价是每次获取数据时都需要mmu的参与 VIPT(virtual index physical tagged)，传入的是物理地址与虚拟地址的混合体，该地址的索引段为虚拟地址，标记段为物理地址。查找缓冲区项时，需要比较虚拟索引查找高速缓存组与并使用物理标记判断是否为所需的内存地址，这会有重名问题 VIVT(virtual index virtual tagged)，传入的是虚拟地址，会导致重名问题以及别名问题，相比PIPT方式，该方式实现的mmu更简单 VIPT可以完全避免歧义问题，这是因为无论进程如何切换，尽管va可以重复，但仍需pt才能识别对应的高速缓存行。而pt则是唯一的，因此VIPT可以完全避免歧义问题 VIPT解决别名问题的办法：由于别名问题产生的根本原因是多个va引用了同一个pa导致数据不同步的现象，并且在同一个进程内是不会产生别名的，哪怕该进程使用了共享内存。因此要避免别名只需上下文切换时通过冲刷高速缓存(先使主存有效，后令高速缓存无效)保证数据同步即可 下面是页表，高速缓存，tlb和内存在切换上下文时的更新顺序： 切换上下问时会更新页表，因此页表是最早更新的，由于页表主要存储在主存以及保证缓存一致性，我们需要将页表写入主存中 在多核系统下，为了能够让其他核和硬件也能察觉页表被更改，我们需要执行fence指令 此时本核或本簇的tlb还未更新，执行sfence.vma指令使tlb失效并重新载入主存的页表 最后冲刷高速缓存，将脏的高速缓存写回内存，并让部分高速缓存失效，这可以避免别名问题(同一个va指向不同pa) 对于有ASID机制的cpu，不一定要冲刷tlb且即使冲刷也可能会有硬件帮助其自动化 tlb的作用类似高速缓冲区，因此可以由直接映射，全相联映射，组相联映射三种方式组成 arm9采用的是VIVT方式，arm11采用的是VIPT方式，arm偏爱虚拟索引的原因是不必每次访存都依赖mmu，后期采用物理标记的原因是避免虚拟标记产生的重名问题 重名(也被称为歧义)问题：多个不同的VA映射到一个PA 缺点： 浪费高速缓存空间 缓存一致性问题 同名(也被称为别名)问题：相同的VA对应不同的PA，这产生于进程切换时，由于不同进程的VA空间是相同的，这就造成了不同进程可能拥有相同的VA，但VA对应的PA不同 缺点： 获取到其他线程数据造成错误 解决办法：切换线程时把脏的高速缓存写回内存，然后使所有高速缓存行失效，这样新进程就会得到干净的虚拟高速缓存，同时，也有对tlb执行清除操作。每次切换进程时都需要让高速缓存的数据失效，这会造成效率问题，因此rv架构给出了ASID的解决方案，这会在后文详细介绍 在rv规范中，要求处理器不允许产生别名问题，因此该问题需要在微架构层面得到解决，该机制被称为ASID 重名(歧义)问题的解决： 重名问题产生的原因是系统为了支持虚拟内存而允许多个虚拟地址对应同一个物理地址，这可能是不同线程有相同的虚拟空间造成的，也有可能是cow或同一个线程的mmap了同一个fd导致的。我们通过PT理应只能查找到同一页的内容，因为无论是在查找多级页表还是tlb的过程中，PT的职能始终是确定要查找地址的页内偏移。而高速缓存足够大时，PT的位数便不够用了，例如当高速缓存总大小达到了8KB，我们想要查找位于2KB地址的内容，但通过PT会发现有两个候选项2KB和6KB地址处的内容，其中6KB地址处的内容是上次访存留下的。这样当修改2KB地址的内容后也需要修改6KB地址处的内容，否则就会造成缓存一致性问题 这里会有一个问题：访存指令是32/64位的，足够在内存空间确定唯一地址了，为什么还会出现歧义的问题？这是因为虚拟地址已经在索引高速缓存的过程中已经被用掉了，所以无法确定唯一地址，ASID就采用了引入额外数据——进程号，因此有ASID机制的系统可以解决不同进程造成的歧义问题，但是对于同一个进程产生的歧义问题(例如mmap，cow等操作)就无能为力了 接下来让我们看下如何彻底解决歧义问题。我们通过PT查找高速缓存时，只有组的限制而没有路的限制，因为路映射着内存的另一页，通过index可以被索引到不同的路，也就是说路与路之间不存在歧义问题。而在组的内部，就产生了重名问题，也就是说： $高缓一路的总大小\\leq{页大小}$ 换句话说： $高缓组数\\times{行大小}\\leq{页大小}$ 举一个例子： 参数 值 页大小 4KB Cache line 大小 64B Cache 组数 64 sets 组相联路数 4-way 总 Cache 大小 64 × 64 × 4 = 16KB 这里还需要注意的是，歧义问题，页表，tlb，虚拟地址空间都是对于进程来说的，尽管linux的调度单元是线程，但只有不同进程才拥有不同的虚拟地址空间。也就是说，页表和tlb等操作的调度单位是进程 重名，同名问题都存在于虚拟高速缓存中 高速缓存策略： 写命中时(在高速缓冲区找到要写的数据) 直写：将数据不通过写缓冲区直接写回内存，这会占用总线带宽 回写：将数据暂存到写缓冲区里，等到合适的时机再写回内存，这会产生缓存一致性的问题 写未命中时 写分配：把要写的数据加载到高速缓存中，后修改缓存内容 无写分配：不分配高速缓存，直接写回内存 一致性策略：LRU，最近最少使用算法 高速缓存管理指令： 失效(CBO.INVAL)：使某一缓存行失效，丢弃上面的数据 清理(CBO.CLEAN)：把标记位脏的缓存行写入下一级缓存或内存，然后清除脏位 冲刷(CBO.FLUSH)：失效+清理 在缓存一致性系统中，一个数据可能在各种主控制器(cpu，gpu，加速器等)内有多个副本，其中任意一个主控制器执行高速缓存管理指令就会通过广播导致其他所有主控制器也执行该指令，这样其他主控制器就会始终获得最新数据 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:8","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#主存高速缓存与tlb简要介绍"},{"categories":["Tech"],"content":" 主存，高速缓存与TLB简要介绍多进程访问同一个虚拟地址可以成功的原因是，每个进程都有自己的运行空间，也就有一套自己的页表，根本原因是切换进程时可以通过切换页表基地址寄存器来访问不同进程的页表，这样在查找n级页表时就是对应进程的n级页表了 rv64通常使用3级(sv39)或4级页表(sv48)，rv32使用2级页表(sv32)，所谓的svxx指的是虚拟地址的低xx位用于页表索引 以内存为视角，体系结构分为两种：UMA(统一内存访问)， NUMA(非统一内存访问) tlb(translation lookaside buffer，翻译后备缓冲区)，该硬件位于mmu内，缓存了查询页表的结果 以vipt(virtual index physical tagged)为例讲解cpu寻址过程： cpu访问虚拟地址时，会将虚拟地址同时发给tlb和高速缓存，若tlb未命中，则需访问对应线程的页表(通常位于主存)，并将地址和数据写入高速缓存中以待cpu读取。若tlb命中，则直接获取物理地址，并根据该地址从高速缓存中获取数据 同时高速缓存根据虚拟地址的索引来确定所需的数据位于哪个组，并通过标记域在组内寻找高速缓存的某一行，若找到就被称为高速缓存命中。若未命中，则需要重新从主存获取数据 高速缓存高速缓存的组织方式包括以下三种 直接映射 全相联映射 组相联映射 由于高速缓存是按行来组织的，因此cpu每次访问内存都至少会将一个高速缓存行大小的数据写入高速缓存，这样，内存中实际的最小单元就不是字节而是高速缓存行大小了。例如某个高速缓存有如下组织： 1路，每路64行，每行512字节，共64KB高速缓存。因此，主存就被划分为若干块的区域，每块大小64KB(64KB除以1路)，内存地址与高速缓存的地址映射关系是：数据在高速缓冲区的行号=主存地址%32KB/512，在缓存行的内的偏移量为主存地址%32KB%512 如果我们采用直接映射的缓存组织方式，假设访问内存的数据都落在0x80000000-0x8000000FF(共64KB)，高速缓存将发挥他的最大威力，但是当我们访问的数据位于0x80000000，0x80000100，0x80000200，那么高速缓存的第一个缓存行就会被频繁的换入换出，这就是高速缓存颠簸 为了解决缓存颠簸问题我们采用了组相连缓存的组织方法，我们只需要将原来的缓存大小一分为二，这被称为2路组相连缓存，其中一个作为备份以应对缓存颠簸，当颠簸发生时，我们有50%的可能性会发生缓存换入换出的问题，如果是4路，该问题发生的可能性降低为25% 注意，当采用组相连缓存时，新的组概念意味着彼此不同路的行的集合，路概念被保留 cpu访问高速缓存时，传入的地址是虚拟地址还是物理地址？这实际上分为3种情况 PIPT：cpu通过物理地址查询高速缓存，这种方式每次都需要tlb介入，部分情况下甚至需要mmu进行地址转换，效率较低 VIVT：cpu通过虚拟地址查询高速缓存 实际上，还有一种物理地址和虚拟地址结合的查找方式，详见下文 当cpu通过地址来查找高速缓存时，该地址被解析为标记域和索引域。也就是说标记域与索引域可能来自虚拟地址也可能来自物理地址，因此有如下3种情况 PIPT(physical index physical tagged)，传入的是mmu转换过的物理地址，该地址的索引段和标记段均由物理地址组成，不会导致重名问题以及别名问题。该种组织方式对于大规模高速缓存很友好，但代价是每次获取数据时都需要mmu的参与 VIPT(virtual index physical tagged)，传入的是物理地址与虚拟地址的混合体，该地址的索引段为虚拟地址，标记段为物理地址。查找缓冲区项时，需要比较虚拟索引查找高速缓存组与并使用物理标记判断是否为所需的内存地址，这会有重名问题 VIVT(virtual index virtual tagged)，传入的是虚拟地址，会导致重名问题以及别名问题，相比PIPT方式，该方式实现的mmu更简单 VIPT可以完全避免歧义问题，这是因为无论进程如何切换，尽管va可以重复，但仍需pt才能识别对应的高速缓存行。而pt则是唯一的，因此VIPT可以完全避免歧义问题 VIPT解决别名问题的办法：由于别名问题产生的根本原因是多个va引用了同一个pa导致数据不同步的现象，并且在同一个进程内是不会产生别名的，哪怕该进程使用了共享内存。因此要避免别名只需上下文切换时通过冲刷高速缓存(先使主存有效，后令高速缓存无效)保证数据同步即可 下面是页表，高速缓存，tlb和内存在切换上下文时的更新顺序： 切换上下问时会更新页表，因此页表是最早更新的，由于页表主要存储在主存以及保证缓存一致性，我们需要将页表写入主存中 在多核系统下，为了能够让其他核和硬件也能察觉页表被更改，我们需要执行fence指令 此时本核或本簇的tlb还未更新，执行sfence.vma指令使tlb失效并重新载入主存的页表 最后冲刷高速缓存，将脏的高速缓存写回内存，并让部分高速缓存失效，这可以避免别名问题(同一个va指向不同pa) 对于有ASID机制的cpu，不一定要冲刷tlb且即使冲刷也可能会有硬件帮助其自动化 tlb的作用类似高速缓冲区，因此可以由直接映射，全相联映射，组相联映射三种方式组成 arm9采用的是VIVT方式，arm11采用的是VIPT方式，arm偏爱虚拟索引的原因是不必每次访存都依赖mmu，后期采用物理标记的原因是避免虚拟标记产生的重名问题 重名(也被称为歧义)问题：多个不同的VA映射到一个PA 缺点： 浪费高速缓存空间 缓存一致性问题 同名(也被称为别名)问题：相同的VA对应不同的PA，这产生于进程切换时，由于不同进程的VA空间是相同的，这就造成了不同进程可能拥有相同的VA，但VA对应的PA不同 缺点： 获取到其他线程数据造成错误 解决办法：切换线程时把脏的高速缓存写回内存，然后使所有高速缓存行失效，这样新进程就会得到干净的虚拟高速缓存，同时，也有对tlb执行清除操作。每次切换进程时都需要让高速缓存的数据失效，这会造成效率问题，因此rv架构给出了ASID的解决方案，这会在后文详细介绍 在rv规范中，要求处理器不允许产生别名问题，因此该问题需要在微架构层面得到解决，该机制被称为ASID 重名(歧义)问题的解决： 重名问题产生的原因是系统为了支持虚拟内存而允许多个虚拟地址对应同一个物理地址，这可能是不同线程有相同的虚拟空间造成的，也有可能是cow或同一个线程的mmap了同一个fd导致的。我们通过PT理应只能查找到同一页的内容，因为无论是在查找多级页表还是tlb的过程中，PT的职能始终是确定要查找地址的页内偏移。而高速缓存足够大时，PT的位数便不够用了，例如当高速缓存总大小达到了8KB，我们想要查找位于2KB地址的内容，但通过PT会发现有两个候选项2KB和6KB地址处的内容，其中6KB地址处的内容是上次访存留下的。这样当修改2KB地址的内容后也需要修改6KB地址处的内容，否则就会造成缓存一致性问题 这里会有一个问题：访存指令是32/64位的，足够在内存空间确定唯一地址了，为什么还会出现歧义的问题？这是因为虚拟地址已经在索引高速缓存的过程中已经被用掉了，所以无法确定唯一地址，ASID就采用了引入额外数据——进程号，因此有ASID机制的系统可以解决不同进程造成的歧义问题，但是对于同一个进程产生的歧义问题(例如mmap，cow等操作)就无能为力了 接下来让我们看下如何彻底解决歧义问题。我们通过PT查找高速缓存时，只有组的限制而没有路的限制，因为路映射着内存的另一页，通过index可以被索引到不同的路，也就是说路与路之间不存在歧义问题。而在组的内部，就产生了重名问题，也就是说： $高缓一路的总大小\\leq{页大小}$ 换句话说： $高缓组数\\times{行大小}\\leq{页大小}$ 举一个例子： 参数 值 页大小 4KB Cache line 大小 64B Cache 组数 64 sets 组相联路数 4-way 总 Cache 大小 64 × 64 × 4 = 16KB 这里还需要注意的是，歧义问题，页表，tlb，虚拟地址空间都是对于进程来说的，尽管linux的调度单元是线程，但只有不同进程才拥有不同的虚拟地址空间。也就是说，页表和tlb等操作的调度单位是进程 重名，同名问题都存在于虚拟高速缓存中 高速缓存策略： 写命中时(在高速缓冲区找到要写的数据) 直写：将数据不通过写缓冲区直接写回内存，这会占用总线带宽 回写：将数据暂存到写缓冲区里，等到合适的时机再写回内存，这会产生缓存一致性的问题 写未命中时 写分配：把要写的数据加载到高速缓存中，后修改缓存内容 无写分配：不分配高速缓存，直接写回内存 一致性策略：LRU，最近最少使用算法 高速缓存管理指令： 失效(CBO.INVAL)：使某一缓存行失效，丢弃上面的数据 清理(CBO.CLEAN)：把标记位脏的缓存行写入下一级缓存或内存，然后清除脏位 冲刷(CBO.FLUSH)：失效+清理 在缓存一致性系统中，一个数据可能在各种主控制器(cpu，gpu，加速器等)内有多个副本，其中任意一个主控制器执行高速缓存管理指令就会通过广播导致其他所有主控制器也执行该指令，这样其他主控制器就会始终获得最新数据 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:8","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#高速缓存"},{"categories":["Tech"],"content":" 缓存一致性与MESI协议尽管MESI协议对软件透明且解决了大部分一致性问题，但仍有少部分问题需要软件解决 cpu簇的一致性需要AXI总线协议实现 解决多核间缓存一致性的方法： 关闭高速缓存：这会造成功耗上升，性能下降 使用软件维护一致性：调试难度上升，增加软件复杂度 使用硬件维护一致性：MESI协议，实现该协议的硬件被称为scu(snoop control unit)，监听控制单元 系统间缓存一致性的方法需要使用缓存一致性总线协议，如ACE 下面对MESI协议做简要介绍： M(modify)：数据有效，已被修改，只存在于本地cpu高速缓存中 E(exclusive)：数据有效，数据和内存中一致，只存在于本地cpu高速缓存中 S(shared)：数据有效，已被修改，存在于多个cpu高速缓存中 I(invalid)：数据无效 假设系统有cpu0-cpu3 共4个cpu，每个cpu都有各自的一级缓存，他们都想访问数据a T0时，4个cpu默认状态为I(数据无效) T1时，cpu0率先访问a(读)，cpu0进行本地读时发现并没有数据，因此通过总线发送BusyRd信号询问其他cpu，其他cpu回应无数据，因此，cpu0只能老老实实的从主存中获取数据，并将高速缓存行状态设置为E(数据和内存状态一致) T2时，cpu1发起读操作并广播询问其他cpu是否有数据，在其他cpu全部应答之前cpu1不会在主存中查找数据，此时只有cpu0有副本，因此cpu0会应答cpu1的读操作并将数据发送，同时cpu0，cpu1将状态设置为S T3时，cpu2想修改a(写)，cpu2发送BusRdX(总线写)信号到总线，其他cpu会将数据对应的的高速缓冲行失效，也就是设置为I，并发送应答信号。cpu2收集所有应答信号后将本地高速缓存设置为M状态(与内存不同)，并写入a的值 高速缓存伪共享当某2个数据位于高速缓存行的同一行且有2个cpu想修改这2个数据时就会出现问题，其表现是2个cpu会反复修改本地的缓存行并反复让对方的缓存行失效，这会带来严重的性能问题 解决的办法是在软件中避免此类问题 缓存行对齐技术：使用 __attribute__((aligned(x))) 指令将结构体整体对齐到缓存行边界（例如 64 字节）。这适用于结构体数组中每个元素被单独访问的情况，有助于避免相邻元素共享缓存行导致两个cpu对相邻元素相互修改导致伪共享的情况 缓存行对齐技术的例子： c #include \u003cstdio.h\u003e #include \u003cstdatomic.h\u003e #define CACHE_LINE_SIZE 64 struct __attribute__((aligned(CACHE_LINE_SIZE))) AlignedCounter { atomic_long value; }; struct AlignedCounter counters[4]; // 每个元素占满一个缓存行 void thread_func(int idx) { for (int i = 0; i \u003c 1000000; ++i) { atomic_fetch_add(\u0026counters[idx].value, 1); } } 缓存行填充技术：通过数组占位来使结构体成员对齐到不同行，其中需要频繁修改的成员单独占一行。这常用于无法使用缓存行对齐技术的大型结构体 缓存行填充技术的例子： c struct zone{ spinlock_t lock; struct zone_padding pad2; //填充数组使两个自旋锁分别位于缓存行两行 spinlock_t lru_lock; } strcut zone_padding{ char x[0]; }__cacheline__internodealigned_in_smp; //使用该内建函数可以填充某一个高速缓存行 高速缓存伪共享十分影响性能，我们可以使用perfC2C工具检查代码是否存在高速缓存伪共享的问题 DMA与高速缓存一致性DMA的数据运输对cpu来说是高效但透明的，因此会产生一致性问题 问题解决： 当数据需要从内存发送到设备fifo时 cpu侧软件的数据先对内存中的DMA段进行刷写，防止DMA数据是旧的或者cpu的高速缓存已经产生新的数据但并未同步到DMA 外设通过DMA将DMA缓冲区的数据转移到外设fifo中 当cpu软件侧产生新数据时立即使用缓存清理命令将数据刷写到内存的DMA缓冲区中 当数据需要从设备fifo发送到内存时 首先由设备接受新的数据并转交给内存中的DMA段 若高速缓冲区有数据则令其失效，因为此时的数据是上次传输的旧数据 DMA将设备数据由fifo搬运到DMA缓冲区中 因此，DMA的缓存一致性问题只需要考虑两个方面 最新的数据在cpu侧还是设备侧？若为cpu侧则立即清理高速缓冲区，若为设备侧，则令缓冲行失效 DMA缓冲区对应的高速缓冲区的数据是最新的还是过时的？是最新的则清理，过时的就失效 还需要注意的是，有些系统会将高速缓存的冲洗（flush）操作安排在上下文切换过程中完成，这样一来，CPU 在每次读写高速缓存时就不需要显式地进行缓存同步。然而，这种方式不适用于异步 I/O 这是因为异步 I/O 的核心思想是：进程和 I/O 操作可以并行进行，即在发起 I/O 请求后，进程可以继续执行而无需等待 I/O 完成。而高速缓存的冲洗通常是一个同步的过渡操作，它介于用户空间对数据的访问和 DMA（或外设）对内存的访问之间，目的是确保数据一致性 由于 DMA 和 I/O 控制器本身并不执行缓存同步，而冲洗操作又无法自然地嵌入异步 I/O 的非阻塞流程中，因此不能将高速缓存冲洗纳入异步 I/O 的框架中。如果不显式进行缓存同步，可能导致外设读取到过时或未提交的数据，从而破坏数据完整性 MESI协议的问题与内存屏障MESI进行数据同步时需要操作发起方进行等待，如cpu0想要写a这个变量，如果此时a不在cpu0的本地，那么当前cpu就会发送BusRdX信号给其他cpu，并等待其他cpu的结果。其他cpu会将a标记为I(无效)并广播修改完毕的信号。此时cpu0才能收集到全部信息并写a的值。可以看出，上述过程会使cpu0进入停滞(stall) 解决办法是在cpu和l1缓存之间另设存储缓冲区，这样在cpu0等待时可以执行其他操作，并将a写入存储缓冲区，等到其他cpu完成广播后再将数据从存储缓冲区转移到l1缓存 但是这也带来了乱序的问题，例如当代码的其他部分依赖于a时，由于本地cpu实际上并未使a失效，只是将a阻塞在本地的存储缓冲区内，这样由于乱序执行，如果本地cpu再次使用a，则会使用到a的旧值 这个问题的解决办法是使用写内存屏障指令(fence w w)，即确保在屏障之前的所有写操作完成并对其他处理器可见之后，才会执行屏障之后的写操作。这种方式确保写操作的顺序和可见性，防止因写缓冲乱序导致的伪共享或一致性问题 例如下图会将abcd写入l1完成后，再写入ef，否则其他cpu先应答e数据，而后应答d数据的情况 同样地，在 MESI 协议中，当一个 CPU 想要写入一块本地未缓存的数据时，需要首先让其他 CPU 将该数据标记为无效(I)。这个失效操作涉及总线通信，往往存在一定延迟。如果系统频繁进行加载和写入操作，这种同步机制可能导致整体性能下降 为优化效率，可以引入无效队列机制：当 CPU 收到失效请求时，不立即执行失效操作，而是将相关条目挂入本地无效队列，并立刻发送应答信号。这样可以缩短总线占用时间，提高系统响应速度，尤其在高并发场景下提升吞吐量 然而，该优化方式也引入了乱序执行问题：如果失效操作尚未真正生效，而其他 CPU 发起对该数据的读请求，就可能读到过期的旧值，从而破坏数据一致性 为避免这种问题，需要使用读内存屏障指令（fence r, r），强制在执行后续读操作之前，确保所有挂在失效队列中的条目已完成失效操作。这样可确保读取操作不会早于数据失效，从而维持正确的内存可见性和执行顺序 特性 存储缓冲区 无效队列 面向对象 本 CPU 的写请求 其他 CPU 发来的无效请求 是否异步处理 是，写操作异步提交 是，无效请求异步响应 主要目标 降低写阻塞，提高写吞吐 降低失效同步阻塞，提高并发性能 风险 写乱序 → 伪共享、可见性错误 读乱序 → 读到失效前的旧值 解决机制 写内存屏障（fence w,w） 读内存屏障（fence r,r） 对于自旋锁而言，不同体系结构有不同实现方式，对于x86而言，由于其内部结构是强内存一致性模型，自旋锁实现就隐含了内存屏障。但对于rv的rvwmo规范，其实现的是弱一致性模型，而自旋锁的实现并不包括内存屏障指令，这也是弱一致性模型效率高的表现但也会造成指令乱序的问题。因此rv为了保证锁的正确性，在自旋锁的实现中也引入了内存屏障指令作为每次调用smp自旋锁后的api，这样，在linux内核中rv的锁编程会多出一步调用内存屏障指令api的操作来保证多核cpu条件下锁状态的正常 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:9","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#缓存一致性与mesi协议"},{"categories":["Tech"],"content":" 缓存一致性与MESI协议尽管MESI协议对软件透明且解决了大部分一致性问题，但仍有少部分问题需要软件解决 cpu簇的一致性需要AXI总线协议实现 解决多核间缓存一致性的方法： 关闭高速缓存：这会造成功耗上升，性能下降 使用软件维护一致性：调试难度上升，增加软件复杂度 使用硬件维护一致性：MESI协议，实现该协议的硬件被称为scu(snoop control unit)，监听控制单元 系统间缓存一致性的方法需要使用缓存一致性总线协议，如ACE 下面对MESI协议做简要介绍： M(modify)：数据有效，已被修改，只存在于本地cpu高速缓存中 E(exclusive)：数据有效，数据和内存中一致，只存在于本地cpu高速缓存中 S(shared)：数据有效，已被修改，存在于多个cpu高速缓存中 I(invalid)：数据无效 假设系统有cpu0-cpu3 共4个cpu，每个cpu都有各自的一级缓存，他们都想访问数据a T0时，4个cpu默认状态为I(数据无效) T1时，cpu0率先访问a(读)，cpu0进行本地读时发现并没有数据，因此通过总线发送BusyRd信号询问其他cpu，其他cpu回应无数据，因此，cpu0只能老老实实的从主存中获取数据，并将高速缓存行状态设置为E(数据和内存状态一致) T2时，cpu1发起读操作并广播询问其他cpu是否有数据，在其他cpu全部应答之前cpu1不会在主存中查找数据，此时只有cpu0有副本，因此cpu0会应答cpu1的读操作并将数据发送，同时cpu0，cpu1将状态设置为S T3时，cpu2想修改a(写)，cpu2发送BusRdX(总线写)信号到总线，其他cpu会将数据对应的的高速缓冲行失效，也就是设置为I，并发送应答信号。cpu2收集所有应答信号后将本地高速缓存设置为M状态(与内存不同)，并写入a的值 高速缓存伪共享当某2个数据位于高速缓存行的同一行且有2个cpu想修改这2个数据时就会出现问题，其表现是2个cpu会反复修改本地的缓存行并反复让对方的缓存行失效，这会带来严重的性能问题 解决的办法是在软件中避免此类问题 缓存行对齐技术：使用 __attribute__((aligned(x))) 指令将结构体整体对齐到缓存行边界（例如 64 字节）。这适用于结构体数组中每个元素被单独访问的情况，有助于避免相邻元素共享缓存行导致两个cpu对相邻元素相互修改导致伪共享的情况 缓存行对齐技术的例子： c #include #include #define CACHE_LINE_SIZE 64 struct __attribute__((aligned(CACHE_LINE_SIZE))) AlignedCounter { atomic_long value; }; struct AlignedCounter counters[4]; // 每个元素占满一个缓存行 void thread_func(int idx) { for (int i = 0; i \u003c 1000000; ++i) { atomic_fetch_add(\u0026counters[idx].value, 1); } } 缓存行填充技术：通过数组占位来使结构体成员对齐到不同行，其中需要频繁修改的成员单独占一行。这常用于无法使用缓存行对齐技术的大型结构体 缓存行填充技术的例子： c struct zone{ spinlock_t lock; struct zone_padding pad2; //填充数组使两个自旋锁分别位于缓存行两行 spinlock_t lru_lock; } strcut zone_padding{ char x[0]; }__cacheline__internodealigned_in_smp; //使用该内建函数可以填充某一个高速缓存行 高速缓存伪共享十分影响性能，我们可以使用perfC2C工具检查代码是否存在高速缓存伪共享的问题 DMA与高速缓存一致性DMA的数据运输对cpu来说是高效但透明的，因此会产生一致性问题 问题解决： 当数据需要从内存发送到设备fifo时 cpu侧软件的数据先对内存中的DMA段进行刷写，防止DMA数据是旧的或者cpu的高速缓存已经产生新的数据但并未同步到DMA 外设通过DMA将DMA缓冲区的数据转移到外设fifo中 当cpu软件侧产生新数据时立即使用缓存清理命令将数据刷写到内存的DMA缓冲区中 当数据需要从设备fifo发送到内存时 首先由设备接受新的数据并转交给内存中的DMA段 若高速缓冲区有数据则令其失效，因为此时的数据是上次传输的旧数据 DMA将设备数据由fifo搬运到DMA缓冲区中 因此，DMA的缓存一致性问题只需要考虑两个方面 最新的数据在cpu侧还是设备侧？若为cpu侧则立即清理高速缓冲区，若为设备侧，则令缓冲行失效 DMA缓冲区对应的高速缓冲区的数据是最新的还是过时的？是最新的则清理，过时的就失效 还需要注意的是，有些系统会将高速缓存的冲洗（flush）操作安排在上下文切换过程中完成，这样一来，CPU 在每次读写高速缓存时就不需要显式地进行缓存同步。然而，这种方式不适用于异步 I/O 这是因为异步 I/O 的核心思想是：进程和 I/O 操作可以并行进行，即在发起 I/O 请求后，进程可以继续执行而无需等待 I/O 完成。而高速缓存的冲洗通常是一个同步的过渡操作，它介于用户空间对数据的访问和 DMA（或外设）对内存的访问之间，目的是确保数据一致性 由于 DMA 和 I/O 控制器本身并不执行缓存同步，而冲洗操作又无法自然地嵌入异步 I/O 的非阻塞流程中，因此不能将高速缓存冲洗纳入异步 I/O 的框架中。如果不显式进行缓存同步，可能导致外设读取到过时或未提交的数据，从而破坏数据完整性 MESI协议的问题与内存屏障MESI进行数据同步时需要操作发起方进行等待，如cpu0想要写a这个变量，如果此时a不在cpu0的本地，那么当前cpu就会发送BusRdX信号给其他cpu，并等待其他cpu的结果。其他cpu会将a标记为I(无效)并广播修改完毕的信号。此时cpu0才能收集到全部信息并写a的值。可以看出，上述过程会使cpu0进入停滞(stall) 解决办法是在cpu和l1缓存之间另设存储缓冲区，这样在cpu0等待时可以执行其他操作，并将a写入存储缓冲区，等到其他cpu完成广播后再将数据从存储缓冲区转移到l1缓存 但是这也带来了乱序的问题，例如当代码的其他部分依赖于a时，由于本地cpu实际上并未使a失效，只是将a阻塞在本地的存储缓冲区内，这样由于乱序执行，如果本地cpu再次使用a，则会使用到a的旧值 这个问题的解决办法是使用写内存屏障指令(fence w w)，即确保在屏障之前的所有写操作完成并对其他处理器可见之后，才会执行屏障之后的写操作。这种方式确保写操作的顺序和可见性，防止因写缓冲乱序导致的伪共享或一致性问题 例如下图会将abcd写入l1完成后，再写入ef，否则其他cpu先应答e数据，而后应答d数据的情况 同样地，在 MESI 协议中，当一个 CPU 想要写入一块本地未缓存的数据时，需要首先让其他 CPU 将该数据标记为无效(I)。这个失效操作涉及总线通信，往往存在一定延迟。如果系统频繁进行加载和写入操作，这种同步机制可能导致整体性能下降 为优化效率，可以引入无效队列机制：当 CPU 收到失效请求时，不立即执行失效操作，而是将相关条目挂入本地无效队列，并立刻发送应答信号。这样可以缩短总线占用时间，提高系统响应速度，尤其在高并发场景下提升吞吐量 然而，该优化方式也引入了乱序执行问题：如果失效操作尚未真正生效，而其他 CPU 发起对该数据的读请求，就可能读到过期的旧值，从而破坏数据一致性 为避免这种问题，需要使用读内存屏障指令（fence r, r），强制在执行后续读操作之前，确保所有挂在失效队列中的条目已完成失效操作。这样可确保读取操作不会早于数据失效，从而维持正确的内存可见性和执行顺序 特性 存储缓冲区 无效队列 面向对象 本 CPU 的写请求 其他 CPU 发来的无效请求 是否异步处理 是，写操作异步提交 是，无效请求异步响应 主要目标 降低写阻塞，提高写吞吐 降低失效同步阻塞，提高并发性能 风险 写乱序 → 伪共享、可见性错误 读乱序 → 读到失效前的旧值 解决机制 写内存屏障（fence w,w） 读内存屏障（fence r,r） 对于自旋锁而言，不同体系结构有不同实现方式，对于x86而言，由于其内部结构是强内存一致性模型，自旋锁实现就隐含了内存屏障。但对于rv的rvwmo规范，其实现的是弱一致性模型，而自旋锁的实现并不包括内存屏障指令，这也是弱一致性模型效率高的表现但也会造成指令乱序的问题。因此rv为了保证锁的正确性，在自旋锁的实现中也引入了内存屏障指令作为每次调用smp自旋锁后的api，这样，在linux内核中rv的锁编程会多出一步调用内存屏障指令api的操作来保证多核cpu条件下锁状态的正常 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:9","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#高速缓存伪共享"},{"categories":["Tech"],"content":" 缓存一致性与MESI协议尽管MESI协议对软件透明且解决了大部分一致性问题，但仍有少部分问题需要软件解决 cpu簇的一致性需要AXI总线协议实现 解决多核间缓存一致性的方法： 关闭高速缓存：这会造成功耗上升，性能下降 使用软件维护一致性：调试难度上升，增加软件复杂度 使用硬件维护一致性：MESI协议，实现该协议的硬件被称为scu(snoop control unit)，监听控制单元 系统间缓存一致性的方法需要使用缓存一致性总线协议，如ACE 下面对MESI协议做简要介绍： M(modify)：数据有效，已被修改，只存在于本地cpu高速缓存中 E(exclusive)：数据有效，数据和内存中一致，只存在于本地cpu高速缓存中 S(shared)：数据有效，已被修改，存在于多个cpu高速缓存中 I(invalid)：数据无效 假设系统有cpu0-cpu3 共4个cpu，每个cpu都有各自的一级缓存，他们都想访问数据a T0时，4个cpu默认状态为I(数据无效) T1时，cpu0率先访问a(读)，cpu0进行本地读时发现并没有数据，因此通过总线发送BusyRd信号询问其他cpu，其他cpu回应无数据，因此，cpu0只能老老实实的从主存中获取数据，并将高速缓存行状态设置为E(数据和内存状态一致) T2时，cpu1发起读操作并广播询问其他cpu是否有数据，在其他cpu全部应答之前cpu1不会在主存中查找数据，此时只有cpu0有副本，因此cpu0会应答cpu1的读操作并将数据发送，同时cpu0，cpu1将状态设置为S T3时，cpu2想修改a(写)，cpu2发送BusRdX(总线写)信号到总线，其他cpu会将数据对应的的高速缓冲行失效，也就是设置为I，并发送应答信号。cpu2收集所有应答信号后将本地高速缓存设置为M状态(与内存不同)，并写入a的值 高速缓存伪共享当某2个数据位于高速缓存行的同一行且有2个cpu想修改这2个数据时就会出现问题，其表现是2个cpu会反复修改本地的缓存行并反复让对方的缓存行失效，这会带来严重的性能问题 解决的办法是在软件中避免此类问题 缓存行对齐技术：使用 __attribute__((aligned(x))) 指令将结构体整体对齐到缓存行边界（例如 64 字节）。这适用于结构体数组中每个元素被单独访问的情况，有助于避免相邻元素共享缓存行导致两个cpu对相邻元素相互修改导致伪共享的情况 缓存行对齐技术的例子： c #include #include #define CACHE_LINE_SIZE 64 struct __attribute__((aligned(CACHE_LINE_SIZE))) AlignedCounter { atomic_long value; }; struct AlignedCounter counters[4]; // 每个元素占满一个缓存行 void thread_func(int idx) { for (int i = 0; i \u003c 1000000; ++i) { atomic_fetch_add(\u0026counters[idx].value, 1); } } 缓存行填充技术：通过数组占位来使结构体成员对齐到不同行，其中需要频繁修改的成员单独占一行。这常用于无法使用缓存行对齐技术的大型结构体 缓存行填充技术的例子： c struct zone{ spinlock_t lock; struct zone_padding pad2; //填充数组使两个自旋锁分别位于缓存行两行 spinlock_t lru_lock; } strcut zone_padding{ char x[0]; }__cacheline__internodealigned_in_smp; //使用该内建函数可以填充某一个高速缓存行 高速缓存伪共享十分影响性能，我们可以使用perfC2C工具检查代码是否存在高速缓存伪共享的问题 DMA与高速缓存一致性DMA的数据运输对cpu来说是高效但透明的，因此会产生一致性问题 问题解决： 当数据需要从内存发送到设备fifo时 cpu侧软件的数据先对内存中的DMA段进行刷写，防止DMA数据是旧的或者cpu的高速缓存已经产生新的数据但并未同步到DMA 外设通过DMA将DMA缓冲区的数据转移到外设fifo中 当cpu软件侧产生新数据时立即使用缓存清理命令将数据刷写到内存的DMA缓冲区中 当数据需要从设备fifo发送到内存时 首先由设备接受新的数据并转交给内存中的DMA段 若高速缓冲区有数据则令其失效，因为此时的数据是上次传输的旧数据 DMA将设备数据由fifo搬运到DMA缓冲区中 因此，DMA的缓存一致性问题只需要考虑两个方面 最新的数据在cpu侧还是设备侧？若为cpu侧则立即清理高速缓冲区，若为设备侧，则令缓冲行失效 DMA缓冲区对应的高速缓冲区的数据是最新的还是过时的？是最新的则清理，过时的就失效 还需要注意的是，有些系统会将高速缓存的冲洗（flush）操作安排在上下文切换过程中完成，这样一来，CPU 在每次读写高速缓存时就不需要显式地进行缓存同步。然而，这种方式不适用于异步 I/O 这是因为异步 I/O 的核心思想是：进程和 I/O 操作可以并行进行，即在发起 I/O 请求后，进程可以继续执行而无需等待 I/O 完成。而高速缓存的冲洗通常是一个同步的过渡操作，它介于用户空间对数据的访问和 DMA（或外设）对内存的访问之间，目的是确保数据一致性 由于 DMA 和 I/O 控制器本身并不执行缓存同步，而冲洗操作又无法自然地嵌入异步 I/O 的非阻塞流程中，因此不能将高速缓存冲洗纳入异步 I/O 的框架中。如果不显式进行缓存同步，可能导致外设读取到过时或未提交的数据，从而破坏数据完整性 MESI协议的问题与内存屏障MESI进行数据同步时需要操作发起方进行等待，如cpu0想要写a这个变量，如果此时a不在cpu0的本地，那么当前cpu就会发送BusRdX信号给其他cpu，并等待其他cpu的结果。其他cpu会将a标记为I(无效)并广播修改完毕的信号。此时cpu0才能收集到全部信息并写a的值。可以看出，上述过程会使cpu0进入停滞(stall) 解决办法是在cpu和l1缓存之间另设存储缓冲区，这样在cpu0等待时可以执行其他操作，并将a写入存储缓冲区，等到其他cpu完成广播后再将数据从存储缓冲区转移到l1缓存 但是这也带来了乱序的问题，例如当代码的其他部分依赖于a时，由于本地cpu实际上并未使a失效，只是将a阻塞在本地的存储缓冲区内，这样由于乱序执行，如果本地cpu再次使用a，则会使用到a的旧值 这个问题的解决办法是使用写内存屏障指令(fence w w)，即确保在屏障之前的所有写操作完成并对其他处理器可见之后，才会执行屏障之后的写操作。这种方式确保写操作的顺序和可见性，防止因写缓冲乱序导致的伪共享或一致性问题 例如下图会将abcd写入l1完成后，再写入ef，否则其他cpu先应答e数据，而后应答d数据的情况 同样地，在 MESI 协议中，当一个 CPU 想要写入一块本地未缓存的数据时，需要首先让其他 CPU 将该数据标记为无效(I)。这个失效操作涉及总线通信，往往存在一定延迟。如果系统频繁进行加载和写入操作，这种同步机制可能导致整体性能下降 为优化效率，可以引入无效队列机制：当 CPU 收到失效请求时，不立即执行失效操作，而是将相关条目挂入本地无效队列，并立刻发送应答信号。这样可以缩短总线占用时间，提高系统响应速度，尤其在高并发场景下提升吞吐量 然而，该优化方式也引入了乱序执行问题：如果失效操作尚未真正生效，而其他 CPU 发起对该数据的读请求，就可能读到过期的旧值，从而破坏数据一致性 为避免这种问题，需要使用读内存屏障指令（fence r, r），强制在执行后续读操作之前，确保所有挂在失效队列中的条目已完成失效操作。这样可确保读取操作不会早于数据失效，从而维持正确的内存可见性和执行顺序 特性 存储缓冲区 无效队列 面向对象 本 CPU 的写请求 其他 CPU 发来的无效请求 是否异步处理 是，写操作异步提交 是，无效请求异步响应 主要目标 降低写阻塞，提高写吞吐 降低失效同步阻塞，提高并发性能 风险 写乱序 → 伪共享、可见性错误 读乱序 → 读到失效前的旧值 解决机制 写内存屏障（fence w,w） 读内存屏障（fence r,r） 对于自旋锁而言，不同体系结构有不同实现方式，对于x86而言，由于其内部结构是强内存一致性模型，自旋锁实现就隐含了内存屏障。但对于rv的rvwmo规范，其实现的是弱一致性模型，而自旋锁的实现并不包括内存屏障指令，这也是弱一致性模型效率高的表现但也会造成指令乱序的问题。因此rv为了保证锁的正确性，在自旋锁的实现中也引入了内存屏障指令作为每次调用smp自旋锁后的api，这样，在linux内核中rv的锁编程会多出一步调用内存屏障指令api的操作来保证多核cpu条件下锁状态的正常 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:9","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#dma与高速缓存一致性"},{"categories":["Tech"],"content":" 缓存一致性与MESI协议尽管MESI协议对软件透明且解决了大部分一致性问题，但仍有少部分问题需要软件解决 cpu簇的一致性需要AXI总线协议实现 解决多核间缓存一致性的方法： 关闭高速缓存：这会造成功耗上升，性能下降 使用软件维护一致性：调试难度上升，增加软件复杂度 使用硬件维护一致性：MESI协议，实现该协议的硬件被称为scu(snoop control unit)，监听控制单元 系统间缓存一致性的方法需要使用缓存一致性总线协议，如ACE 下面对MESI协议做简要介绍： M(modify)：数据有效，已被修改，只存在于本地cpu高速缓存中 E(exclusive)：数据有效，数据和内存中一致，只存在于本地cpu高速缓存中 S(shared)：数据有效，已被修改，存在于多个cpu高速缓存中 I(invalid)：数据无效 假设系统有cpu0-cpu3 共4个cpu，每个cpu都有各自的一级缓存，他们都想访问数据a T0时，4个cpu默认状态为I(数据无效) T1时，cpu0率先访问a(读)，cpu0进行本地读时发现并没有数据，因此通过总线发送BusyRd信号询问其他cpu，其他cpu回应无数据，因此，cpu0只能老老实实的从主存中获取数据，并将高速缓存行状态设置为E(数据和内存状态一致) T2时，cpu1发起读操作并广播询问其他cpu是否有数据，在其他cpu全部应答之前cpu1不会在主存中查找数据，此时只有cpu0有副本，因此cpu0会应答cpu1的读操作并将数据发送，同时cpu0，cpu1将状态设置为S T3时，cpu2想修改a(写)，cpu2发送BusRdX(总线写)信号到总线，其他cpu会将数据对应的的高速缓冲行失效，也就是设置为I，并发送应答信号。cpu2收集所有应答信号后将本地高速缓存设置为M状态(与内存不同)，并写入a的值 高速缓存伪共享当某2个数据位于高速缓存行的同一行且有2个cpu想修改这2个数据时就会出现问题，其表现是2个cpu会反复修改本地的缓存行并反复让对方的缓存行失效，这会带来严重的性能问题 解决的办法是在软件中避免此类问题 缓存行对齐技术：使用 __attribute__((aligned(x))) 指令将结构体整体对齐到缓存行边界（例如 64 字节）。这适用于结构体数组中每个元素被单独访问的情况，有助于避免相邻元素共享缓存行导致两个cpu对相邻元素相互修改导致伪共享的情况 缓存行对齐技术的例子： c #include #include #define CACHE_LINE_SIZE 64 struct __attribute__((aligned(CACHE_LINE_SIZE))) AlignedCounter { atomic_long value; }; struct AlignedCounter counters[4]; // 每个元素占满一个缓存行 void thread_func(int idx) { for (int i = 0; i \u003c 1000000; ++i) { atomic_fetch_add(\u0026counters[idx].value, 1); } } 缓存行填充技术：通过数组占位来使结构体成员对齐到不同行，其中需要频繁修改的成员单独占一行。这常用于无法使用缓存行对齐技术的大型结构体 缓存行填充技术的例子： c struct zone{ spinlock_t lock; struct zone_padding pad2; //填充数组使两个自旋锁分别位于缓存行两行 spinlock_t lru_lock; } strcut zone_padding{ char x[0]; }__cacheline__internodealigned_in_smp; //使用该内建函数可以填充某一个高速缓存行 高速缓存伪共享十分影响性能，我们可以使用perfC2C工具检查代码是否存在高速缓存伪共享的问题 DMA与高速缓存一致性DMA的数据运输对cpu来说是高效但透明的，因此会产生一致性问题 问题解决： 当数据需要从内存发送到设备fifo时 cpu侧软件的数据先对内存中的DMA段进行刷写，防止DMA数据是旧的或者cpu的高速缓存已经产生新的数据但并未同步到DMA 外设通过DMA将DMA缓冲区的数据转移到外设fifo中 当cpu软件侧产生新数据时立即使用缓存清理命令将数据刷写到内存的DMA缓冲区中 当数据需要从设备fifo发送到内存时 首先由设备接受新的数据并转交给内存中的DMA段 若高速缓冲区有数据则令其失效，因为此时的数据是上次传输的旧数据 DMA将设备数据由fifo搬运到DMA缓冲区中 因此，DMA的缓存一致性问题只需要考虑两个方面 最新的数据在cpu侧还是设备侧？若为cpu侧则立即清理高速缓冲区，若为设备侧，则令缓冲行失效 DMA缓冲区对应的高速缓冲区的数据是最新的还是过时的？是最新的则清理，过时的就失效 还需要注意的是，有些系统会将高速缓存的冲洗（flush）操作安排在上下文切换过程中完成，这样一来，CPU 在每次读写高速缓存时就不需要显式地进行缓存同步。然而，这种方式不适用于异步 I/O 这是因为异步 I/O 的核心思想是：进程和 I/O 操作可以并行进行，即在发起 I/O 请求后，进程可以继续执行而无需等待 I/O 完成。而高速缓存的冲洗通常是一个同步的过渡操作，它介于用户空间对数据的访问和 DMA（或外设）对内存的访问之间，目的是确保数据一致性 由于 DMA 和 I/O 控制器本身并不执行缓存同步，而冲洗操作又无法自然地嵌入异步 I/O 的非阻塞流程中，因此不能将高速缓存冲洗纳入异步 I/O 的框架中。如果不显式进行缓存同步，可能导致外设读取到过时或未提交的数据，从而破坏数据完整性 MESI协议的问题与内存屏障MESI进行数据同步时需要操作发起方进行等待，如cpu0想要写a这个变量，如果此时a不在cpu0的本地，那么当前cpu就会发送BusRdX信号给其他cpu，并等待其他cpu的结果。其他cpu会将a标记为I(无效)并广播修改完毕的信号。此时cpu0才能收集到全部信息并写a的值。可以看出，上述过程会使cpu0进入停滞(stall) 解决办法是在cpu和l1缓存之间另设存储缓冲区，这样在cpu0等待时可以执行其他操作，并将a写入存储缓冲区，等到其他cpu完成广播后再将数据从存储缓冲区转移到l1缓存 但是这也带来了乱序的问题，例如当代码的其他部分依赖于a时，由于本地cpu实际上并未使a失效，只是将a阻塞在本地的存储缓冲区内，这样由于乱序执行，如果本地cpu再次使用a，则会使用到a的旧值 这个问题的解决办法是使用写内存屏障指令(fence w w)，即确保在屏障之前的所有写操作完成并对其他处理器可见之后，才会执行屏障之后的写操作。这种方式确保写操作的顺序和可见性，防止因写缓冲乱序导致的伪共享或一致性问题 例如下图会将abcd写入l1完成后，再写入ef，否则其他cpu先应答e数据，而后应答d数据的情况 同样地，在 MESI 协议中，当一个 CPU 想要写入一块本地未缓存的数据时，需要首先让其他 CPU 将该数据标记为无效(I)。这个失效操作涉及总线通信，往往存在一定延迟。如果系统频繁进行加载和写入操作，这种同步机制可能导致整体性能下降 为优化效率，可以引入无效队列机制：当 CPU 收到失效请求时，不立即执行失效操作，而是将相关条目挂入本地无效队列，并立刻发送应答信号。这样可以缩短总线占用时间，提高系统响应速度，尤其在高并发场景下提升吞吐量 然而，该优化方式也引入了乱序执行问题：如果失效操作尚未真正生效，而其他 CPU 发起对该数据的读请求，就可能读到过期的旧值，从而破坏数据一致性 为避免这种问题，需要使用读内存屏障指令（fence r, r），强制在执行后续读操作之前，确保所有挂在失效队列中的条目已完成失效操作。这样可确保读取操作不会早于数据失效，从而维持正确的内存可见性和执行顺序 特性 存储缓冲区 无效队列 面向对象 本 CPU 的写请求 其他 CPU 发来的无效请求 是否异步处理 是，写操作异步提交 是，无效请求异步响应 主要目标 降低写阻塞，提高写吞吐 降低失效同步阻塞，提高并发性能 风险 写乱序 → 伪共享、可见性错误 读乱序 → 读到失效前的旧值 解决机制 写内存屏障（fence w,w） 读内存屏障（fence r,r） 对于自旋锁而言，不同体系结构有不同实现方式，对于x86而言，由于其内部结构是强内存一致性模型，自旋锁实现就隐含了内存屏障。但对于rv的rvwmo规范，其实现的是弱一致性模型，而自旋锁的实现并不包括内存屏障指令，这也是弱一致性模型效率高的表现但也会造成指令乱序的问题。因此rv为了保证锁的正确性，在自旋锁的实现中也引入了内存屏障指令作为每次调用smp自旋锁后的api，这样，在linux内核中rv的锁编程会多出一步调用内存屏障指令api的操作来保证多核cpu条件下锁状态的正常 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:9","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#mesi协议的问题与内存屏障"},{"categories":["Tech"],"content":" ASID由于tlb内部存储了VA与PA的对应关系，而PA不会改变，因此没有重名问题(不同的VA映射到同一个PA)，但在线程切换时会有同名问题，尽管可以通过刷新tlb解决，但这严重影响效率，更好的解决方案是使用ASID tlb可以分为以下两种 全局类型tlb：用于内核空间，可以不刷新 进程独有tlb：用户进程空间，应当刷新 因此rv体系提供了这样一种方案：让tlb识别ASID属于哪个进程。这样，即使是进程独有的tlb，与可以在进程切换时不刷新tlb了，rv的ASID储存在satp寄存器(Supervisor Address Translation and Protection)中，同时satp也存储了页表基地址 这样通过tlb查询页表步骤如下： 通过va的索引域在tlb内找到对应的组 通过虚拟地址的标记域(也就是PA)找到组内某行 和stap寄存器的ASID以及属性进行匹配，若匹配，则tlb命中，这是新增的步骤 在页表项内，还有一位和tlb相关，这就是G位，用于表示全局类型的tlb页表项 tlb刷新查找页表的操作已被OpenSBI实现了，并开放接口给Linux ","date":"2025-01-01","objectID":"/posts/risc-v/:8:10","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#asid"},{"categories":["Tech"],"content":" BBM(break before make)Linux中，在一些复杂的替换操作执行前，首先要让被替换的内容失效，以防止其他进程引用了过时的资源导致错误 原子指令是一个整体，不能用仿真器调试，如下3-5行 c my_atomic_set: 1: lr.d a2 (a1) or a2, a2, a5 sc.d a3, a2, (a1) bnez a3,1b ","date":"2025-01-01","objectID":"/posts/risc-v/:8:11","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#bbmbreak-before-make"},{"categories":["Tech"],"content":" 原子指令与CASrv中，原子指令的实现方式并不做规定，不同厂家有不同厂家的实现方式 cas（Compare And Swap，比较并交换）是arm的重要特性，该指令用于比较并交换值，常用于无锁编程。其原理为：cas检查某个值是否是原值，若为原值则赋为新值，否则什么都不做。但是在rv中却没有对应的指令，这是由于cas会有ABA的问题：既原值在检查时变化了两次，比如由1变3再变回1，这就会使系统误以为原值未改变，因而rv推荐使用lr/sc（Load-Reserved / Store-Conditional）命令监视所有写操作的地址，因此能够避免该问题 内存一致性：由于乱序执行，多发射，超标量，编译优化带来的cpu执行代码顺序与源代码顺序不一致的现象 解决办法：使用内存屏障指令 rv中使用fence作为内存屏障指令 内存屏障指令格式：fence iorw, iorw iorw：要约束的前后指令类型，io代表设备输入输出类型指令，rw代表读写类型指令 fence rw, w 代表fence语句之前的rw操作不应越过fence语句，同时fence语句之后的w操作不应越过fence语句 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:12","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#原子指令与cas"},{"categories":["Tech"],"content":" C语言陷阱类型转换：C的隐式类型转换会造成该问题。例如在赋值表达式中，表达式右侧的值会自动的隐式转换为表达式左边的值。在算术表达式中，短类型，有符号的数据有向着长类型，无符号的数据类型进行隐式转换的趋势。这就带来了隐式转换的问题 c #include \u003cstdio.h\u003e void main() { unsigned int i = 3; printf(\"0x%x\\n\",i * -1); } 输出结果 c 0xffff fffd 这是因为-1被隐式的转换为unsigned int，其十六进制表达式为0xffff ffff，i * -1就变成了3 * 0xffff ffff 整型提升：使用短类型的数据时，如果该数据可以用int表示则转换为int，否则用unsigned int表示。这么做的目的是使cpu内部的alu充分利用通用寄存器的长度，对于两个char类型的计算，cpu难以实现字节相加的运算，这就需要在cpu内部要转换为通用寄存器的长度再运算 c #include \u003cstdio.h\u003e void main() { char a; unsigned int b; unsigned long c; a = 0x88; b = ~a; c = ~a; printf(\"a = 0x%x, ~a = 0x%x, b = 0x%x, c = 0x%x\\n\",a, ~a, b, c); } 结果为 c a = 0x88 ~a = 0xffff ff77 b = 0xffff ff77 c = 0xffff ffff ffff ff77 这是因为~a会转为int类型 移位操作：在C中，整数变量被看作int类型，如果移位范围超过int的位数，就会产生ub c #include \u003cstdio.h\u003e void main() { unsigned long reg = 1\u003c\u003c33; printf(\"0x%x\\n\", reg); } 上面的代码虽然可以编译通过，但是有警告，正确的做法是使用1UL，这样编译器会把1视作unsigned long类型 C语言还有符号扩展的问题，当把一个带符号的整数提升为统一类型或更长类型的无符号整数时，它首先被提升为更长类型的带符号等价数值，然后转换为无符号值 c #include \u003cstdio.h\u003e struct foo{ unsigned int a:19; //a占据这个结构体的19位宽的大小，究竟是高位19位还是低位19位取决于编译器 unsigned int b:13; } void main() { struct foo addr; unsigned long base; addr.a = 0x40000; base = addr.a \u003c\u003c 13; printf(\"0x%x, 0x%lx\\n\", addr.a \u003c\u003c 13, base); } 结果为 c 0x8000 0000, 0xffff ffff 8000 0000 给base赋值时，addr.a«13为int类型，它先转换为long再转为unsigned long，从int转为long会发生符号扩展，被移动到最高位的1被认为是符号，被扩展到其余高位以补码形式存在，因此高位显示为ffff。而addr.a « 13的结果是32位的，因此无法进行符号扩展，所以也就没有显示符号位了 系统启动时建立恒等映射是必要的，这有助于mmu的启动，因为一旦mmu启动，它就会将已经预取的指令按va的方式进行地址转换，因此如果不建立恒等映射使va=pa，那么指令流水就会失败 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:13","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#c语言陷阱"},{"categories":["Tech"],"content":" 可伸缩矢量计算与优化SISD(single instruction single data，单指令单数据)，同一时刻只能处理一条数据，大多数rv指令是sisd的 当处理小数据时，需要将一个8位数据对应的加载到一个单独的64位寄存器中，不能有效利用cpu资源 simd对多个数据元素同时执行相同的操作，这些数据元素被打包在更大的寄存器中的独立通道(也被称为元素)，假设矢量寄存器的长度是128位，那么add指令会把4个32位数据元素加在一起，这些值被打包到两对128寄存器(v1，v2)中的通道中，然后让第一个源寄存器的每个通道与第二个源寄存器的对应通道相加，结果存在v0对应通道中 simd非常适合图像处理场景。图像常用rgb565，rgba8888，yuv422等格式的数据，这些格式的特点是一个像素的一个分量用3或4个8位数据表示，处理的时候是能够并行处理 SIMD的历史1999年，Intel推出SSE(streaming SIMD extension， 流式SIMD扩展)指令集，解决浮点数运算问题并把矢量寄存器的宽度升级到128位 2008年，Intel发布AVX(advanced vector extension， 高级矢量扩展)，兼容sse的同时把矢量寄存器的长度从128位提升至256位 2013年，Intel发布AVX512，矢量寄存器长度进一步提高至512位 arm阵营中，armv7a推出NEON指令集，矢量寄存器128位，在v8下为256位 由于上述指令集都属于定长度指令集，64位矢量寄存器无法运行128位的程序，因此arm在armv8.2中引入了可伸缩矢量扩展(SVE，scalable vector extension)指令集，其编程模型被称为可变矢量长度(VLA)模型 rv架构中，rvv也支持可伸缩矢量计算，且支持的矢量长度最大达65536位 矢量运算指令提供3个版本：矢量，标量，立即数 矢量版本：把矢量寄存器1的所有通道与矢量寄存器2的所有通道进行计算 标量版本：通用寄存器的数据与矢量寄存器进行计算 立即数版本：矢量寄存器与矢量寄存器生成的立即数进行计算 rvv寄存器组rvv为矢量计算提供了一个全新的寄存器组，包括 32个矢量寄存器(v0~v31) 7个非特权级寄存器：vtype，vl，vlenb，vstart，vxvm，vxsat，vcsr 参与运算的矢量长度：必须是$2^n$，最大长度为$2^{16}$(65536位) 元素长度：必须是$2^n$，最小长度为8位 mstatus寄存器：内部的vs字段(Bit[10:9])不仅描述矢量上下文状态，还会映射到sstatus寄存器的Bit[10:9]。当vs字段处于初始状态也就是0时，使用rvv指令或访问非特权寄存器都会改变状态触发指令异常 vtype寄存器：用来描述矢量寄存器中数据类型，决定了数据组织方式和如何对多个矢量寄存器进行分组。vlmul字段决定了多少个矢量寄存器可以组成一个矢量寄存器组，这样一条指令就可以同时操作这个寄存器组了，vlmul不仅可以被设置为整数也可以设置为分数，所以支持高位宽rvv指令集对低位宽指令集的兼容 vlmul(lmul的) 取值 表达式 寄存器组大小 使用的 v 寄存器 含义 000 m1 1 个 v0 标准长度 001 m2 2 个 v0, v1 两倍长度 010 m4 4 个 v0–v3 四倍长度 011 m8 8 个 v0–v7 八倍长度 111 mf2 1/2 个 v0 (部分使用) 半长 110 mf4 1/4 个 v0 (部分使用) 1/4 长 101 mf8 1/8 个 v0 (部分使用) 1/8 长 示例代码： c vsetvli t0, a2, e32, m4 # 设置 vtype，使用4个寄存器组成一个逻辑向量组 vadd.vv v0, v4, v8 # 对应的加法 整个指令的行为是 c [v0,v1,v2,v3] = [v4,v5,v6,v7] + [v8,v9,v10,v11] vl寄存器：用来记录在矢量指令中处理元素的数量 vlenb寄存器：指定一个矢量寄存器内有多少字节，该值在硬件设计时就确定了，因此该寄存器是只读的 vstart寄存器：用来指示第一个参与运算数据元素的索引，通常为0，不为0时执行某些运算会触发指令异常 VLA模型VLA(Vector Length Agnostic，可变向量长度编程模型) vla的实现依靠软硬件共同完成，硬件方面由底层提供配置寄存器，vtype以及vl，前者配置要处理数据类型的位宽，后者配置每次处理数据元素的个数 一般使用vsetvli指令设置： c //初始化vl和vtype寄存器，其中有效元素位宽为8(eew=8)，有效组乘系数=1(emul=1，使用一个寄存器组成一个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为16 //并把vl的值存在t0寄存器中，a2表示要处理的字节数 vsetvli t0, a2, e8, m1 //初始化vl和vtype寄存器，其中有效元素位宽为16(eew=16)，有效组乘系数=1/2(emul=1/2，使用一个寄存器组成两个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为8 vsetvli t0, a2, e16, mf2 一般情况下，矢量寄存器的长度组乘系数与有效组乘系数是相等的(lmul=emul)，并且sew=eew。但在处理不同位宽的数据（如 8 位与 16 位数据相加）时，EMUL 会大于 LMUL。例如，在将 8 位数据与 16 位数据进行矢量加法操作时，为了保证结果宽度足够，可能需要设置 EMUL = 2 × LMUL，以容纳更宽的运算结果 加载和存储指令 单位步长模式 c //从rs1指向的地址加载8位宽的数据元素，vm为掩码操作数 vle8.v vd (rs1) vm //向rs1指向的地址存储16位宽的数据元素，vm为掩码操作数 vse16.v vd (rs1) vm 掩码操作数：rvv提供可以控制每一个数据的方法，若vm为v0.t，则表述用v0矢量寄存器作为掩码，每位表示一个数据元素的状态，若v0[i]==1，表示第i个元素被激活，被激活的元素参与计算，未被激活的则不参与。若未激活的元素的计算策略除了保持不变外还有可能令其为1，这就被称为未知策略，保持不变的策略被称为不打扰策略。这两种策略可以通过配置vtype寄存器的vta，vma字段实现。当掩码操作数在汇编代码中为空时代表激活所有的元素 .v 被称为修饰符，该符号决定了要操作的寄存器的元素的类型，例子如下： .vv：矢量数据元素与矢量数据元素 .vx：矢量数据元素与整型标量数据元素 .vf：矢量数据元素与浮点标量数据元素 .vi：矢量数据元素与立即数数据元素 .m：掩码元素 任意步长格式加载指令 c //任意步长模式会从内存中以rs1为起始地址，每隔r2为步长，依次将下一个元素加载到vd中，r2的值可以为负数或0 vlse8.v vd (vs1), rs2, vm 存储指令 c vsse8.v vs (vs1), rs2, vm 聚合加载与离散存储聚合加载与离散存储均支持以下两种模式 有序索引：在访问内存时按照索引的顺序有序的访问 无序索引：访问内存时不保证访问的顺序 有序索引的聚合加载指令 c //加载8位宽度数据 vloxei8.v vd, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从内存有序的加载元素到vd中 有序索引的离散存储指令 c vsoxei8.v vs, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从vs2有序的存储元素到内存中 无序索引的聚合加载指令 c vluxei8.v vd, (rs1), vs2, vm 无序索引的离散存储指令 c vsuxei8.v vs, (rs1), vs2, vm 打包数据的加载与存储现实中有一些数据是以一定格式打包的，如rgb24，正常情况下需要将rgb24加载到矢量寄存器中，之后将其解包为r，g，b三个不同的寄存器组，但这个过程很麻烦。为此rvv推出此指令，打包数据的加载存储指令也有单位步长，任意步长，聚合加载与离散存储三种模式 单位步长的打包数据加载存储指令如下： c vlseg\u003cnf\u003ee\u003ceew\u003e.v vd, (rs1), vm vsseg\u003cnf\u003ee\u003ceew\u003e.v vs, (rs1), vm 其中，nf是构成打包数据的元素个数，eew是每个元素的位宽，cpu会影响vdvd+nf-1/vsvs+nf-1个向量寄存器 对于rgb24： c //从a1地址开始加载rgb24数据到v4，v5，v6矢量寄存器中 vsseg3e8.v v4, (a1) 加载和存储全部矢量数据 c //从rs地址处开始将n个矢量寄存器大小的数据加载进vd到vd+n-1的寄存器中 vl\u003cn\u003er.v vd, (rs) //存储指令 vs\u003cn\u003er.v vs, (rs1) 矢量掩码指令 逻辑操作指令我们可以让两个矢量之间进行逻辑运算 c vmand.mm vd, vs2, vs1 vmxor.mm vd, vs2, vs1 vmor.mm vd, vs2, vs1 与位操作指令不同的是，掩码制控制数据元素的激活与否，而位操作指令是修改元素的值 此外，rvv的指令集还支持如下伪指令 c //将vs中数据全部复制到vd vmmv.m vd, vs //将vd中数据全部清0 vmclr.m vd //将vd中数据全部置","date":"2025-01-01","objectID":"/posts/risc-v/:8:14","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#可伸缩矢量计算与优化"},{"categories":["Tech"],"content":" 可伸缩矢量计算与优化SISD(single instruction single data，单指令单数据)，同一时刻只能处理一条数据，大多数rv指令是sisd的 当处理小数据时，需要将一个8位数据对应的加载到一个单独的64位寄存器中，不能有效利用cpu资源 simd对多个数据元素同时执行相同的操作，这些数据元素被打包在更大的寄存器中的独立通道(也被称为元素)，假设矢量寄存器的长度是128位，那么add指令会把4个32位数据元素加在一起，这些值被打包到两对128寄存器(v1，v2)中的通道中，然后让第一个源寄存器的每个通道与第二个源寄存器的对应通道相加，结果存在v0对应通道中 simd非常适合图像处理场景。图像常用rgb565，rgba8888，yuv422等格式的数据，这些格式的特点是一个像素的一个分量用3或4个8位数据表示，处理的时候是能够并行处理 SIMD的历史1999年，Intel推出SSE(streaming SIMD extension， 流式SIMD扩展)指令集，解决浮点数运算问题并把矢量寄存器的宽度升级到128位 2008年，Intel发布AVX(advanced vector extension， 高级矢量扩展)，兼容sse的同时把矢量寄存器的长度从128位提升至256位 2013年，Intel发布AVX512，矢量寄存器长度进一步提高至512位 arm阵营中，armv7a推出NEON指令集，矢量寄存器128位，在v8下为256位 由于上述指令集都属于定长度指令集，64位矢量寄存器无法运行128位的程序，因此arm在armv8.2中引入了可伸缩矢量扩展(SVE，scalable vector extension)指令集，其编程模型被称为可变矢量长度(VLA)模型 rv架构中，rvv也支持可伸缩矢量计算，且支持的矢量长度最大达65536位 矢量运算指令提供3个版本：矢量，标量，立即数 矢量版本：把矢量寄存器1的所有通道与矢量寄存器2的所有通道进行计算 标量版本：通用寄存器的数据与矢量寄存器进行计算 立即数版本：矢量寄存器与矢量寄存器生成的立即数进行计算 rvv寄存器组rvv为矢量计算提供了一个全新的寄存器组，包括 32个矢量寄存器(v0~v31) 7个非特权级寄存器：vtype，vl，vlenb，vstart，vxvm，vxsat，vcsr 参与运算的矢量长度：必须是$2^n$，最大长度为$2^{16}$(65536位) 元素长度：必须是$2^n$，最小长度为8位 mstatus寄存器：内部的vs字段(Bit[10:9])不仅描述矢量上下文状态，还会映射到sstatus寄存器的Bit[10:9]。当vs字段处于初始状态也就是0时，使用rvv指令或访问非特权寄存器都会改变状态触发指令异常 vtype寄存器：用来描述矢量寄存器中数据类型，决定了数据组织方式和如何对多个矢量寄存器进行分组。vlmul字段决定了多少个矢量寄存器可以组成一个矢量寄存器组，这样一条指令就可以同时操作这个寄存器组了，vlmul不仅可以被设置为整数也可以设置为分数，所以支持高位宽rvv指令集对低位宽指令集的兼容 vlmul(lmul的) 取值 表达式 寄存器组大小 使用的 v 寄存器 含义 000 m1 1 个 v0 标准长度 001 m2 2 个 v0, v1 两倍长度 010 m4 4 个 v0–v3 四倍长度 011 m8 8 个 v0–v7 八倍长度 111 mf2 1/2 个 v0 (部分使用) 半长 110 mf4 1/4 个 v0 (部分使用) 1/4 长 101 mf8 1/8 个 v0 (部分使用) 1/8 长 示例代码： c vsetvli t0, a2, e32, m4 # 设置 vtype，使用4个寄存器组成一个逻辑向量组 vadd.vv v0, v4, v8 # 对应的加法 整个指令的行为是 c [v0,v1,v2,v3] = [v4,v5,v6,v7] + [v8,v9,v10,v11] vl寄存器：用来记录在矢量指令中处理元素的数量 vlenb寄存器：指定一个矢量寄存器内有多少字节，该值在硬件设计时就确定了，因此该寄存器是只读的 vstart寄存器：用来指示第一个参与运算数据元素的索引，通常为0，不为0时执行某些运算会触发指令异常 VLA模型VLA(Vector Length Agnostic，可变向量长度编程模型) vla的实现依靠软硬件共同完成，硬件方面由底层提供配置寄存器，vtype以及vl，前者配置要处理数据类型的位宽，后者配置每次处理数据元素的个数 一般使用vsetvli指令设置： c //初始化vl和vtype寄存器，其中有效元素位宽为8(eew=8)，有效组乘系数=1(emul=1，使用一个寄存器组成一个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为16 //并把vl的值存在t0寄存器中，a2表示要处理的字节数 vsetvli t0, a2, e8, m1 //初始化vl和vtype寄存器，其中有效元素位宽为16(eew=16)，有效组乘系数=1/2(emul=1/2，使用一个寄存器组成两个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为8 vsetvli t0, a2, e16, mf2 一般情况下，矢量寄存器的长度组乘系数与有效组乘系数是相等的(lmul=emul)，并且sew=eew。但在处理不同位宽的数据（如 8 位与 16 位数据相加）时，EMUL 会大于 LMUL。例如，在将 8 位数据与 16 位数据进行矢量加法操作时，为了保证结果宽度足够，可能需要设置 EMUL = 2 × LMUL，以容纳更宽的运算结果 加载和存储指令 单位步长模式 c //从rs1指向的地址加载8位宽的数据元素，vm为掩码操作数 vle8.v vd (rs1) vm //向rs1指向的地址存储16位宽的数据元素，vm为掩码操作数 vse16.v vd (rs1) vm 掩码操作数：rvv提供可以控制每一个数据的方法，若vm为v0.t，则表述用v0矢量寄存器作为掩码，每位表示一个数据元素的状态，若v0[i]==1，表示第i个元素被激活，被激活的元素参与计算，未被激活的则不参与。若未激活的元素的计算策略除了保持不变外还有可能令其为1，这就被称为未知策略，保持不变的策略被称为不打扰策略。这两种策略可以通过配置vtype寄存器的vta，vma字段实现。当掩码操作数在汇编代码中为空时代表激活所有的元素 .v 被称为修饰符，该符号决定了要操作的寄存器的元素的类型，例子如下： .vv：矢量数据元素与矢量数据元素 .vx：矢量数据元素与整型标量数据元素 .vf：矢量数据元素与浮点标量数据元素 .vi：矢量数据元素与立即数数据元素 .m：掩码元素 任意步长格式加载指令 c //任意步长模式会从内存中以rs1为起始地址，每隔r2为步长，依次将下一个元素加载到vd中，r2的值可以为负数或0 vlse8.v vd (vs1), rs2, vm 存储指令 c vsse8.v vs (vs1), rs2, vm 聚合加载与离散存储聚合加载与离散存储均支持以下两种模式 有序索引：在访问内存时按照索引的顺序有序的访问 无序索引：访问内存时不保证访问的顺序 有序索引的聚合加载指令 c //加载8位宽度数据 vloxei8.v vd, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从内存有序的加载元素到vd中 有序索引的离散存储指令 c vsoxei8.v vs, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从vs2有序的存储元素到内存中 无序索引的聚合加载指令 c vluxei8.v vd, (rs1), vs2, vm 无序索引的离散存储指令 c vsuxei8.v vs, (rs1), vs2, vm 打包数据的加载与存储现实中有一些数据是以一定格式打包的，如rgb24，正常情况下需要将rgb24加载到矢量寄存器中，之后将其解包为r，g，b三个不同的寄存器组，但这个过程很麻烦。为此rvv推出此指令，打包数据的加载存储指令也有单位步长，任意步长，聚合加载与离散存储三种模式 单位步长的打包数据加载存储指令如下： c vlsege.v vd, (rs1), vm vssege.v vs, (rs1), vm 其中，nf是构成打包数据的元素个数，eew是每个元素的位宽，cpu会影响vdvd+nf-1/vsvs+nf-1个向量寄存器 对于rgb24： c //从a1地址开始加载rgb24数据到v4，v5，v6矢量寄存器中 vsseg3e8.v v4, (a1) 加载和存储全部矢量数据 c //从rs地址处开始将n个矢量寄存器大小的数据加载进vd到vd+n-1的寄存器中 vlr.v vd, (rs) //存储指令 vsr.v vs, (rs1) 矢量掩码指令 逻辑操作指令我们可以让两个矢量之间进行逻辑运算 c vmand.mm vd, vs2, vs1 vmxor.mm vd, vs2, vs1 vmor.mm vd, vs2, vs1 与位操作指令不同的是，掩码制控制数据元素的激活与否，而位操作指令是修改元素的值 此外，rvv的指令集还支持如下伪指令 c //将vs中数据全部复制到vd vmmv.m vd, vs //将vd中数据全部清0 vmclr.m vd //将vd中数据全部置","date":"2025-01-01","objectID":"/posts/risc-v/:8:14","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#simd的历史"},{"categories":["Tech"],"content":" 可伸缩矢量计算与优化SISD(single instruction single data，单指令单数据)，同一时刻只能处理一条数据，大多数rv指令是sisd的 当处理小数据时，需要将一个8位数据对应的加载到一个单独的64位寄存器中，不能有效利用cpu资源 simd对多个数据元素同时执行相同的操作，这些数据元素被打包在更大的寄存器中的独立通道(也被称为元素)，假设矢量寄存器的长度是128位，那么add指令会把4个32位数据元素加在一起，这些值被打包到两对128寄存器(v1，v2)中的通道中，然后让第一个源寄存器的每个通道与第二个源寄存器的对应通道相加，结果存在v0对应通道中 simd非常适合图像处理场景。图像常用rgb565，rgba8888，yuv422等格式的数据，这些格式的特点是一个像素的一个分量用3或4个8位数据表示，处理的时候是能够并行处理 SIMD的历史1999年，Intel推出SSE(streaming SIMD extension， 流式SIMD扩展)指令集，解决浮点数运算问题并把矢量寄存器的宽度升级到128位 2008年，Intel发布AVX(advanced vector extension， 高级矢量扩展)，兼容sse的同时把矢量寄存器的长度从128位提升至256位 2013年，Intel发布AVX512，矢量寄存器长度进一步提高至512位 arm阵营中，armv7a推出NEON指令集，矢量寄存器128位，在v8下为256位 由于上述指令集都属于定长度指令集，64位矢量寄存器无法运行128位的程序，因此arm在armv8.2中引入了可伸缩矢量扩展(SVE，scalable vector extension)指令集，其编程模型被称为可变矢量长度(VLA)模型 rv架构中，rvv也支持可伸缩矢量计算，且支持的矢量长度最大达65536位 矢量运算指令提供3个版本：矢量，标量，立即数 矢量版本：把矢量寄存器1的所有通道与矢量寄存器2的所有通道进行计算 标量版本：通用寄存器的数据与矢量寄存器进行计算 立即数版本：矢量寄存器与矢量寄存器生成的立即数进行计算 rvv寄存器组rvv为矢量计算提供了一个全新的寄存器组，包括 32个矢量寄存器(v0~v31) 7个非特权级寄存器：vtype，vl，vlenb，vstart，vxvm，vxsat，vcsr 参与运算的矢量长度：必须是$2^n$，最大长度为$2^{16}$(65536位) 元素长度：必须是$2^n$，最小长度为8位 mstatus寄存器：内部的vs字段(Bit[10:9])不仅描述矢量上下文状态，还会映射到sstatus寄存器的Bit[10:9]。当vs字段处于初始状态也就是0时，使用rvv指令或访问非特权寄存器都会改变状态触发指令异常 vtype寄存器：用来描述矢量寄存器中数据类型，决定了数据组织方式和如何对多个矢量寄存器进行分组。vlmul字段决定了多少个矢量寄存器可以组成一个矢量寄存器组，这样一条指令就可以同时操作这个寄存器组了，vlmul不仅可以被设置为整数也可以设置为分数，所以支持高位宽rvv指令集对低位宽指令集的兼容 vlmul(lmul的) 取值 表达式 寄存器组大小 使用的 v 寄存器 含义 000 m1 1 个 v0 标准长度 001 m2 2 个 v0, v1 两倍长度 010 m4 4 个 v0–v3 四倍长度 011 m8 8 个 v0–v7 八倍长度 111 mf2 1/2 个 v0 (部分使用) 半长 110 mf4 1/4 个 v0 (部分使用) 1/4 长 101 mf8 1/8 个 v0 (部分使用) 1/8 长 示例代码： c vsetvli t0, a2, e32, m4 # 设置 vtype，使用4个寄存器组成一个逻辑向量组 vadd.vv v0, v4, v8 # 对应的加法 整个指令的行为是 c [v0,v1,v2,v3] = [v4,v5,v6,v7] + [v8,v9,v10,v11] vl寄存器：用来记录在矢量指令中处理元素的数量 vlenb寄存器：指定一个矢量寄存器内有多少字节，该值在硬件设计时就确定了，因此该寄存器是只读的 vstart寄存器：用来指示第一个参与运算数据元素的索引，通常为0，不为0时执行某些运算会触发指令异常 VLA模型VLA(Vector Length Agnostic，可变向量长度编程模型) vla的实现依靠软硬件共同完成，硬件方面由底层提供配置寄存器，vtype以及vl，前者配置要处理数据类型的位宽，后者配置每次处理数据元素的个数 一般使用vsetvli指令设置： c //初始化vl和vtype寄存器，其中有效元素位宽为8(eew=8)，有效组乘系数=1(emul=1，使用一个寄存器组成一个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为16 //并把vl的值存在t0寄存器中，a2表示要处理的字节数 vsetvli t0, a2, e8, m1 //初始化vl和vtype寄存器，其中有效元素位宽为16(eew=16)，有效组乘系数=1/2(emul=1/2，使用一个寄存器组成两个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为8 vsetvli t0, a2, e16, mf2 一般情况下，矢量寄存器的长度组乘系数与有效组乘系数是相等的(lmul=emul)，并且sew=eew。但在处理不同位宽的数据（如 8 位与 16 位数据相加）时，EMUL 会大于 LMUL。例如，在将 8 位数据与 16 位数据进行矢量加法操作时，为了保证结果宽度足够，可能需要设置 EMUL = 2 × LMUL，以容纳更宽的运算结果 加载和存储指令 单位步长模式 c //从rs1指向的地址加载8位宽的数据元素，vm为掩码操作数 vle8.v vd (rs1) vm //向rs1指向的地址存储16位宽的数据元素，vm为掩码操作数 vse16.v vd (rs1) vm 掩码操作数：rvv提供可以控制每一个数据的方法，若vm为v0.t，则表述用v0矢量寄存器作为掩码，每位表示一个数据元素的状态，若v0[i]==1，表示第i个元素被激活，被激活的元素参与计算，未被激活的则不参与。若未激活的元素的计算策略除了保持不变外还有可能令其为1，这就被称为未知策略，保持不变的策略被称为不打扰策略。这两种策略可以通过配置vtype寄存器的vta，vma字段实现。当掩码操作数在汇编代码中为空时代表激活所有的元素 .v 被称为修饰符，该符号决定了要操作的寄存器的元素的类型，例子如下： .vv：矢量数据元素与矢量数据元素 .vx：矢量数据元素与整型标量数据元素 .vf：矢量数据元素与浮点标量数据元素 .vi：矢量数据元素与立即数数据元素 .m：掩码元素 任意步长格式加载指令 c //任意步长模式会从内存中以rs1为起始地址，每隔r2为步长，依次将下一个元素加载到vd中，r2的值可以为负数或0 vlse8.v vd (vs1), rs2, vm 存储指令 c vsse8.v vs (vs1), rs2, vm 聚合加载与离散存储聚合加载与离散存储均支持以下两种模式 有序索引：在访问内存时按照索引的顺序有序的访问 无序索引：访问内存时不保证访问的顺序 有序索引的聚合加载指令 c //加载8位宽度数据 vloxei8.v vd, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从内存有序的加载元素到vd中 有序索引的离散存储指令 c vsoxei8.v vs, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从vs2有序的存储元素到内存中 无序索引的聚合加载指令 c vluxei8.v vd, (rs1), vs2, vm 无序索引的离散存储指令 c vsuxei8.v vs, (rs1), vs2, vm 打包数据的加载与存储现实中有一些数据是以一定格式打包的，如rgb24，正常情况下需要将rgb24加载到矢量寄存器中，之后将其解包为r，g，b三个不同的寄存器组，但这个过程很麻烦。为此rvv推出此指令，打包数据的加载存储指令也有单位步长，任意步长，聚合加载与离散存储三种模式 单位步长的打包数据加载存储指令如下： c vlsege.v vd, (rs1), vm vssege.v vs, (rs1), vm 其中，nf是构成打包数据的元素个数，eew是每个元素的位宽，cpu会影响vdvd+nf-1/vsvs+nf-1个向量寄存器 对于rgb24： c //从a1地址开始加载rgb24数据到v4，v5，v6矢量寄存器中 vsseg3e8.v v4, (a1) 加载和存储全部矢量数据 c //从rs地址处开始将n个矢量寄存器大小的数据加载进vd到vd+n-1的寄存器中 vlr.v vd, (rs) //存储指令 vsr.v vs, (rs1) 矢量掩码指令 逻辑操作指令我们可以让两个矢量之间进行逻辑运算 c vmand.mm vd, vs2, vs1 vmxor.mm vd, vs2, vs1 vmor.mm vd, vs2, vs1 与位操作指令不同的是，掩码制控制数据元素的激活与否，而位操作指令是修改元素的值 此外，rvv的指令集还支持如下伪指令 c //将vs中数据全部复制到vd vmmv.m vd, vs //将vd中数据全部清0 vmclr.m vd //将vd中数据全部置","date":"2025-01-01","objectID":"/posts/risc-v/:8:14","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#rvv寄存器组"},{"categories":["Tech"],"content":" 可伸缩矢量计算与优化SISD(single instruction single data，单指令单数据)，同一时刻只能处理一条数据，大多数rv指令是sisd的 当处理小数据时，需要将一个8位数据对应的加载到一个单独的64位寄存器中，不能有效利用cpu资源 simd对多个数据元素同时执行相同的操作，这些数据元素被打包在更大的寄存器中的独立通道(也被称为元素)，假设矢量寄存器的长度是128位，那么add指令会把4个32位数据元素加在一起，这些值被打包到两对128寄存器(v1，v2)中的通道中，然后让第一个源寄存器的每个通道与第二个源寄存器的对应通道相加，结果存在v0对应通道中 simd非常适合图像处理场景。图像常用rgb565，rgba8888，yuv422等格式的数据，这些格式的特点是一个像素的一个分量用3或4个8位数据表示，处理的时候是能够并行处理 SIMD的历史1999年，Intel推出SSE(streaming SIMD extension， 流式SIMD扩展)指令集，解决浮点数运算问题并把矢量寄存器的宽度升级到128位 2008年，Intel发布AVX(advanced vector extension， 高级矢量扩展)，兼容sse的同时把矢量寄存器的长度从128位提升至256位 2013年，Intel发布AVX512，矢量寄存器长度进一步提高至512位 arm阵营中，armv7a推出NEON指令集，矢量寄存器128位，在v8下为256位 由于上述指令集都属于定长度指令集，64位矢量寄存器无法运行128位的程序，因此arm在armv8.2中引入了可伸缩矢量扩展(SVE，scalable vector extension)指令集，其编程模型被称为可变矢量长度(VLA)模型 rv架构中，rvv也支持可伸缩矢量计算，且支持的矢量长度最大达65536位 矢量运算指令提供3个版本：矢量，标量，立即数 矢量版本：把矢量寄存器1的所有通道与矢量寄存器2的所有通道进行计算 标量版本：通用寄存器的数据与矢量寄存器进行计算 立即数版本：矢量寄存器与矢量寄存器生成的立即数进行计算 rvv寄存器组rvv为矢量计算提供了一个全新的寄存器组，包括 32个矢量寄存器(v0~v31) 7个非特权级寄存器：vtype，vl，vlenb，vstart，vxvm，vxsat，vcsr 参与运算的矢量长度：必须是$2^n$，最大长度为$2^{16}$(65536位) 元素长度：必须是$2^n$，最小长度为8位 mstatus寄存器：内部的vs字段(Bit[10:9])不仅描述矢量上下文状态，还会映射到sstatus寄存器的Bit[10:9]。当vs字段处于初始状态也就是0时，使用rvv指令或访问非特权寄存器都会改变状态触发指令异常 vtype寄存器：用来描述矢量寄存器中数据类型，决定了数据组织方式和如何对多个矢量寄存器进行分组。vlmul字段决定了多少个矢量寄存器可以组成一个矢量寄存器组，这样一条指令就可以同时操作这个寄存器组了，vlmul不仅可以被设置为整数也可以设置为分数，所以支持高位宽rvv指令集对低位宽指令集的兼容 vlmul(lmul的) 取值 表达式 寄存器组大小 使用的 v 寄存器 含义 000 m1 1 个 v0 标准长度 001 m2 2 个 v0, v1 两倍长度 010 m4 4 个 v0–v3 四倍长度 011 m8 8 个 v0–v7 八倍长度 111 mf2 1/2 个 v0 (部分使用) 半长 110 mf4 1/4 个 v0 (部分使用) 1/4 长 101 mf8 1/8 个 v0 (部分使用) 1/8 长 示例代码： c vsetvli t0, a2, e32, m4 # 设置 vtype，使用4个寄存器组成一个逻辑向量组 vadd.vv v0, v4, v8 # 对应的加法 整个指令的行为是 c [v0,v1,v2,v3] = [v4,v5,v6,v7] + [v8,v9,v10,v11] vl寄存器：用来记录在矢量指令中处理元素的数量 vlenb寄存器：指定一个矢量寄存器内有多少字节，该值在硬件设计时就确定了，因此该寄存器是只读的 vstart寄存器：用来指示第一个参与运算数据元素的索引，通常为0，不为0时执行某些运算会触发指令异常 VLA模型VLA(Vector Length Agnostic，可变向量长度编程模型) vla的实现依靠软硬件共同完成，硬件方面由底层提供配置寄存器，vtype以及vl，前者配置要处理数据类型的位宽，后者配置每次处理数据元素的个数 一般使用vsetvli指令设置： c //初始化vl和vtype寄存器，其中有效元素位宽为8(eew=8)，有效组乘系数=1(emul=1，使用一个寄存器组成一个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为16 //并把vl的值存在t0寄存器中，a2表示要处理的字节数 vsetvli t0, a2, e8, m1 //初始化vl和vtype寄存器，其中有效元素位宽为16(eew=16)，有效组乘系数=1/2(emul=1/2，使用一个寄存器组成两个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为8 vsetvli t0, a2, e16, mf2 一般情况下，矢量寄存器的长度组乘系数与有效组乘系数是相等的(lmul=emul)，并且sew=eew。但在处理不同位宽的数据（如 8 位与 16 位数据相加）时，EMUL 会大于 LMUL。例如，在将 8 位数据与 16 位数据进行矢量加法操作时，为了保证结果宽度足够，可能需要设置 EMUL = 2 × LMUL，以容纳更宽的运算结果 加载和存储指令 单位步长模式 c //从rs1指向的地址加载8位宽的数据元素，vm为掩码操作数 vle8.v vd (rs1) vm //向rs1指向的地址存储16位宽的数据元素，vm为掩码操作数 vse16.v vd (rs1) vm 掩码操作数：rvv提供可以控制每一个数据的方法，若vm为v0.t，则表述用v0矢量寄存器作为掩码，每位表示一个数据元素的状态，若v0[i]==1，表示第i个元素被激活，被激活的元素参与计算，未被激活的则不参与。若未激活的元素的计算策略除了保持不变外还有可能令其为1，这就被称为未知策略，保持不变的策略被称为不打扰策略。这两种策略可以通过配置vtype寄存器的vta，vma字段实现。当掩码操作数在汇编代码中为空时代表激活所有的元素 .v 被称为修饰符，该符号决定了要操作的寄存器的元素的类型，例子如下： .vv：矢量数据元素与矢量数据元素 .vx：矢量数据元素与整型标量数据元素 .vf：矢量数据元素与浮点标量数据元素 .vi：矢量数据元素与立即数数据元素 .m：掩码元素 任意步长格式加载指令 c //任意步长模式会从内存中以rs1为起始地址，每隔r2为步长，依次将下一个元素加载到vd中，r2的值可以为负数或0 vlse8.v vd (vs1), rs2, vm 存储指令 c vsse8.v vs (vs1), rs2, vm 聚合加载与离散存储聚合加载与离散存储均支持以下两种模式 有序索引：在访问内存时按照索引的顺序有序的访问 无序索引：访问内存时不保证访问的顺序 有序索引的聚合加载指令 c //加载8位宽度数据 vloxei8.v vd, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从内存有序的加载元素到vd中 有序索引的离散存储指令 c vsoxei8.v vs, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从vs2有序的存储元素到内存中 无序索引的聚合加载指令 c vluxei8.v vd, (rs1), vs2, vm 无序索引的离散存储指令 c vsuxei8.v vs, (rs1), vs2, vm 打包数据的加载与存储现实中有一些数据是以一定格式打包的，如rgb24，正常情况下需要将rgb24加载到矢量寄存器中，之后将其解包为r，g，b三个不同的寄存器组，但这个过程很麻烦。为此rvv推出此指令，打包数据的加载存储指令也有单位步长，任意步长，聚合加载与离散存储三种模式 单位步长的打包数据加载存储指令如下： c vlsege.v vd, (rs1), vm vssege.v vs, (rs1), vm 其中，nf是构成打包数据的元素个数，eew是每个元素的位宽，cpu会影响vdvd+nf-1/vsvs+nf-1个向量寄存器 对于rgb24： c //从a1地址开始加载rgb24数据到v4，v5，v6矢量寄存器中 vsseg3e8.v v4, (a1) 加载和存储全部矢量数据 c //从rs地址处开始将n个矢量寄存器大小的数据加载进vd到vd+n-1的寄存器中 vlr.v vd, (rs) //存储指令 vsr.v vs, (rs1) 矢量掩码指令 逻辑操作指令我们可以让两个矢量之间进行逻辑运算 c vmand.mm vd, vs2, vs1 vmxor.mm vd, vs2, vs1 vmor.mm vd, vs2, vs1 与位操作指令不同的是，掩码制控制数据元素的激活与否，而位操作指令是修改元素的值 此外，rvv的指令集还支持如下伪指令 c //将vs中数据全部复制到vd vmmv.m vd, vs //将vd中数据全部清0 vmclr.m vd //将vd中数据全部置","date":"2025-01-01","objectID":"/posts/risc-v/:8:14","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#vla模型"},{"categories":["Tech"],"content":" 可伸缩矢量计算与优化SISD(single instruction single data，单指令单数据)，同一时刻只能处理一条数据，大多数rv指令是sisd的 当处理小数据时，需要将一个8位数据对应的加载到一个单独的64位寄存器中，不能有效利用cpu资源 simd对多个数据元素同时执行相同的操作，这些数据元素被打包在更大的寄存器中的独立通道(也被称为元素)，假设矢量寄存器的长度是128位，那么add指令会把4个32位数据元素加在一起，这些值被打包到两对128寄存器(v1，v2)中的通道中，然后让第一个源寄存器的每个通道与第二个源寄存器的对应通道相加，结果存在v0对应通道中 simd非常适合图像处理场景。图像常用rgb565，rgba8888，yuv422等格式的数据，这些格式的特点是一个像素的一个分量用3或4个8位数据表示，处理的时候是能够并行处理 SIMD的历史1999年，Intel推出SSE(streaming SIMD extension， 流式SIMD扩展)指令集，解决浮点数运算问题并把矢量寄存器的宽度升级到128位 2008年，Intel发布AVX(advanced vector extension， 高级矢量扩展)，兼容sse的同时把矢量寄存器的长度从128位提升至256位 2013年，Intel发布AVX512，矢量寄存器长度进一步提高至512位 arm阵营中，armv7a推出NEON指令集，矢量寄存器128位，在v8下为256位 由于上述指令集都属于定长度指令集，64位矢量寄存器无法运行128位的程序，因此arm在armv8.2中引入了可伸缩矢量扩展(SVE，scalable vector extension)指令集，其编程模型被称为可变矢量长度(VLA)模型 rv架构中，rvv也支持可伸缩矢量计算，且支持的矢量长度最大达65536位 矢量运算指令提供3个版本：矢量，标量，立即数 矢量版本：把矢量寄存器1的所有通道与矢量寄存器2的所有通道进行计算 标量版本：通用寄存器的数据与矢量寄存器进行计算 立即数版本：矢量寄存器与矢量寄存器生成的立即数进行计算 rvv寄存器组rvv为矢量计算提供了一个全新的寄存器组，包括 32个矢量寄存器(v0~v31) 7个非特权级寄存器：vtype，vl，vlenb，vstart，vxvm，vxsat，vcsr 参与运算的矢量长度：必须是$2^n$，最大长度为$2^{16}$(65536位) 元素长度：必须是$2^n$，最小长度为8位 mstatus寄存器：内部的vs字段(Bit[10:9])不仅描述矢量上下文状态，还会映射到sstatus寄存器的Bit[10:9]。当vs字段处于初始状态也就是0时，使用rvv指令或访问非特权寄存器都会改变状态触发指令异常 vtype寄存器：用来描述矢量寄存器中数据类型，决定了数据组织方式和如何对多个矢量寄存器进行分组。vlmul字段决定了多少个矢量寄存器可以组成一个矢量寄存器组，这样一条指令就可以同时操作这个寄存器组了，vlmul不仅可以被设置为整数也可以设置为分数，所以支持高位宽rvv指令集对低位宽指令集的兼容 vlmul(lmul的) 取值 表达式 寄存器组大小 使用的 v 寄存器 含义 000 m1 1 个 v0 标准长度 001 m2 2 个 v0, v1 两倍长度 010 m4 4 个 v0–v3 四倍长度 011 m8 8 个 v0–v7 八倍长度 111 mf2 1/2 个 v0 (部分使用) 半长 110 mf4 1/4 个 v0 (部分使用) 1/4 长 101 mf8 1/8 个 v0 (部分使用) 1/8 长 示例代码： c vsetvli t0, a2, e32, m4 # 设置 vtype，使用4个寄存器组成一个逻辑向量组 vadd.vv v0, v4, v8 # 对应的加法 整个指令的行为是 c [v0,v1,v2,v3] = [v4,v5,v6,v7] + [v8,v9,v10,v11] vl寄存器：用来记录在矢量指令中处理元素的数量 vlenb寄存器：指定一个矢量寄存器内有多少字节，该值在硬件设计时就确定了，因此该寄存器是只读的 vstart寄存器：用来指示第一个参与运算数据元素的索引，通常为0，不为0时执行某些运算会触发指令异常 VLA模型VLA(Vector Length Agnostic，可变向量长度编程模型) vla的实现依靠软硬件共同完成，硬件方面由底层提供配置寄存器，vtype以及vl，前者配置要处理数据类型的位宽，后者配置每次处理数据元素的个数 一般使用vsetvli指令设置： c //初始化vl和vtype寄存器，其中有效元素位宽为8(eew=8)，有效组乘系数=1(emul=1，使用一个寄存器组成一个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为16 //并把vl的值存在t0寄存器中，a2表示要处理的字节数 vsetvli t0, a2, e8, m1 //初始化vl和vtype寄存器，其中有效元素位宽为16(eew=16)，有效组乘系数=1/2(emul=1/2，使用一个寄存器组成两个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为8 vsetvli t0, a2, e16, mf2 一般情况下，矢量寄存器的长度组乘系数与有效组乘系数是相等的(lmul=emul)，并且sew=eew。但在处理不同位宽的数据（如 8 位与 16 位数据相加）时，EMUL 会大于 LMUL。例如，在将 8 位数据与 16 位数据进行矢量加法操作时，为了保证结果宽度足够，可能需要设置 EMUL = 2 × LMUL，以容纳更宽的运算结果 加载和存储指令 单位步长模式 c //从rs1指向的地址加载8位宽的数据元素，vm为掩码操作数 vle8.v vd (rs1) vm //向rs1指向的地址存储16位宽的数据元素，vm为掩码操作数 vse16.v vd (rs1) vm 掩码操作数：rvv提供可以控制每一个数据的方法，若vm为v0.t，则表述用v0矢量寄存器作为掩码，每位表示一个数据元素的状态，若v0[i]==1，表示第i个元素被激活，被激活的元素参与计算，未被激活的则不参与。若未激活的元素的计算策略除了保持不变外还有可能令其为1，这就被称为未知策略，保持不变的策略被称为不打扰策略。这两种策略可以通过配置vtype寄存器的vta，vma字段实现。当掩码操作数在汇编代码中为空时代表激活所有的元素 .v 被称为修饰符，该符号决定了要操作的寄存器的元素的类型，例子如下： .vv：矢量数据元素与矢量数据元素 .vx：矢量数据元素与整型标量数据元素 .vf：矢量数据元素与浮点标量数据元素 .vi：矢量数据元素与立即数数据元素 .m：掩码元素 任意步长格式加载指令 c //任意步长模式会从内存中以rs1为起始地址，每隔r2为步长，依次将下一个元素加载到vd中，r2的值可以为负数或0 vlse8.v vd (vs1), rs2, vm 存储指令 c vsse8.v vs (vs1), rs2, vm 聚合加载与离散存储聚合加载与离散存储均支持以下两种模式 有序索引：在访问内存时按照索引的顺序有序的访问 无序索引：访问内存时不保证访问的顺序 有序索引的聚合加载指令 c //加载8位宽度数据 vloxei8.v vd, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从内存有序的加载元素到vd中 有序索引的离散存储指令 c vsoxei8.v vs, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从vs2有序的存储元素到内存中 无序索引的聚合加载指令 c vluxei8.v vd, (rs1), vs2, vm 无序索引的离散存储指令 c vsuxei8.v vs, (rs1), vs2, vm 打包数据的加载与存储现实中有一些数据是以一定格式打包的，如rgb24，正常情况下需要将rgb24加载到矢量寄存器中，之后将其解包为r，g，b三个不同的寄存器组，但这个过程很麻烦。为此rvv推出此指令，打包数据的加载存储指令也有单位步长，任意步长，聚合加载与离散存储三种模式 单位步长的打包数据加载存储指令如下： c vlsege.v vd, (rs1), vm vssege.v vs, (rs1), vm 其中，nf是构成打包数据的元素个数，eew是每个元素的位宽，cpu会影响vdvd+nf-1/vsvs+nf-1个向量寄存器 对于rgb24： c //从a1地址开始加载rgb24数据到v4，v5，v6矢量寄存器中 vsseg3e8.v v4, (a1) 加载和存储全部矢量数据 c //从rs地址处开始将n个矢量寄存器大小的数据加载进vd到vd+n-1的寄存器中 vlr.v vd, (rs) //存储指令 vsr.v vs, (rs1) 矢量掩码指令 逻辑操作指令我们可以让两个矢量之间进行逻辑运算 c vmand.mm vd, vs2, vs1 vmxor.mm vd, vs2, vs1 vmor.mm vd, vs2, vs1 与位操作指令不同的是，掩码制控制数据元素的激活与否，而位操作指令是修改元素的值 此外，rvv的指令集还支持如下伪指令 c //将vs中数据全部复制到vd vmmv.m vd, vs //将vd中数据全部清0 vmclr.m vd //将vd中数据全部置","date":"2025-01-01","objectID":"/posts/risc-v/:8:14","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#加载和存储指令"},{"categories":["Tech"],"content":" 可伸缩矢量计算与优化SISD(single instruction single data，单指令单数据)，同一时刻只能处理一条数据，大多数rv指令是sisd的 当处理小数据时，需要将一个8位数据对应的加载到一个单独的64位寄存器中，不能有效利用cpu资源 simd对多个数据元素同时执行相同的操作，这些数据元素被打包在更大的寄存器中的独立通道(也被称为元素)，假设矢量寄存器的长度是128位，那么add指令会把4个32位数据元素加在一起，这些值被打包到两对128寄存器(v1，v2)中的通道中，然后让第一个源寄存器的每个通道与第二个源寄存器的对应通道相加，结果存在v0对应通道中 simd非常适合图像处理场景。图像常用rgb565，rgba8888，yuv422等格式的数据，这些格式的特点是一个像素的一个分量用3或4个8位数据表示，处理的时候是能够并行处理 SIMD的历史1999年，Intel推出SSE(streaming SIMD extension， 流式SIMD扩展)指令集，解决浮点数运算问题并把矢量寄存器的宽度升级到128位 2008年，Intel发布AVX(advanced vector extension， 高级矢量扩展)，兼容sse的同时把矢量寄存器的长度从128位提升至256位 2013年，Intel发布AVX512，矢量寄存器长度进一步提高至512位 arm阵营中，armv7a推出NEON指令集，矢量寄存器128位，在v8下为256位 由于上述指令集都属于定长度指令集，64位矢量寄存器无法运行128位的程序，因此arm在armv8.2中引入了可伸缩矢量扩展(SVE，scalable vector extension)指令集，其编程模型被称为可变矢量长度(VLA)模型 rv架构中，rvv也支持可伸缩矢量计算，且支持的矢量长度最大达65536位 矢量运算指令提供3个版本：矢量，标量，立即数 矢量版本：把矢量寄存器1的所有通道与矢量寄存器2的所有通道进行计算 标量版本：通用寄存器的数据与矢量寄存器进行计算 立即数版本：矢量寄存器与矢量寄存器生成的立即数进行计算 rvv寄存器组rvv为矢量计算提供了一个全新的寄存器组，包括 32个矢量寄存器(v0~v31) 7个非特权级寄存器：vtype，vl，vlenb，vstart，vxvm，vxsat，vcsr 参与运算的矢量长度：必须是$2^n$，最大长度为$2^{16}$(65536位) 元素长度：必须是$2^n$，最小长度为8位 mstatus寄存器：内部的vs字段(Bit[10:9])不仅描述矢量上下文状态，还会映射到sstatus寄存器的Bit[10:9]。当vs字段处于初始状态也就是0时，使用rvv指令或访问非特权寄存器都会改变状态触发指令异常 vtype寄存器：用来描述矢量寄存器中数据类型，决定了数据组织方式和如何对多个矢量寄存器进行分组。vlmul字段决定了多少个矢量寄存器可以组成一个矢量寄存器组，这样一条指令就可以同时操作这个寄存器组了，vlmul不仅可以被设置为整数也可以设置为分数，所以支持高位宽rvv指令集对低位宽指令集的兼容 vlmul(lmul的) 取值 表达式 寄存器组大小 使用的 v 寄存器 含义 000 m1 1 个 v0 标准长度 001 m2 2 个 v0, v1 两倍长度 010 m4 4 个 v0–v3 四倍长度 011 m8 8 个 v0–v7 八倍长度 111 mf2 1/2 个 v0 (部分使用) 半长 110 mf4 1/4 个 v0 (部分使用) 1/4 长 101 mf8 1/8 个 v0 (部分使用) 1/8 长 示例代码： c vsetvli t0, a2, e32, m4 # 设置 vtype，使用4个寄存器组成一个逻辑向量组 vadd.vv v0, v4, v8 # 对应的加法 整个指令的行为是 c [v0,v1,v2,v3] = [v4,v5,v6,v7] + [v8,v9,v10,v11] vl寄存器：用来记录在矢量指令中处理元素的数量 vlenb寄存器：指定一个矢量寄存器内有多少字节，该值在硬件设计时就确定了，因此该寄存器是只读的 vstart寄存器：用来指示第一个参与运算数据元素的索引，通常为0，不为0时执行某些运算会触发指令异常 VLA模型VLA(Vector Length Agnostic，可变向量长度编程模型) vla的实现依靠软硬件共同完成，硬件方面由底层提供配置寄存器，vtype以及vl，前者配置要处理数据类型的位宽，后者配置每次处理数据元素的个数 一般使用vsetvli指令设置： c //初始化vl和vtype寄存器，其中有效元素位宽为8(eew=8)，有效组乘系数=1(emul=1，使用一个寄存器组成一个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为16 //并把vl的值存在t0寄存器中，a2表示要处理的字节数 vsetvli t0, a2, e8, m1 //初始化vl和vtype寄存器，其中有效元素位宽为16(eew=16)，有效组乘系数=1/2(emul=1/2，使用一个寄存器组成两个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为8 vsetvli t0, a2, e16, mf2 一般情况下，矢量寄存器的长度组乘系数与有效组乘系数是相等的(lmul=emul)，并且sew=eew。但在处理不同位宽的数据（如 8 位与 16 位数据相加）时，EMUL 会大于 LMUL。例如，在将 8 位数据与 16 位数据进行矢量加法操作时，为了保证结果宽度足够，可能需要设置 EMUL = 2 × LMUL，以容纳更宽的运算结果 加载和存储指令 单位步长模式 c //从rs1指向的地址加载8位宽的数据元素，vm为掩码操作数 vle8.v vd (rs1) vm //向rs1指向的地址存储16位宽的数据元素，vm为掩码操作数 vse16.v vd (rs1) vm 掩码操作数：rvv提供可以控制每一个数据的方法，若vm为v0.t，则表述用v0矢量寄存器作为掩码，每位表示一个数据元素的状态，若v0[i]==1，表示第i个元素被激活，被激活的元素参与计算，未被激活的则不参与。若未激活的元素的计算策略除了保持不变外还有可能令其为1，这就被称为未知策略，保持不变的策略被称为不打扰策略。这两种策略可以通过配置vtype寄存器的vta，vma字段实现。当掩码操作数在汇编代码中为空时代表激活所有的元素 .v 被称为修饰符，该符号决定了要操作的寄存器的元素的类型，例子如下： .vv：矢量数据元素与矢量数据元素 .vx：矢量数据元素与整型标量数据元素 .vf：矢量数据元素与浮点标量数据元素 .vi：矢量数据元素与立即数数据元素 .m：掩码元素 任意步长格式加载指令 c //任意步长模式会从内存中以rs1为起始地址，每隔r2为步长，依次将下一个元素加载到vd中，r2的值可以为负数或0 vlse8.v vd (vs1), rs2, vm 存储指令 c vsse8.v vs (vs1), rs2, vm 聚合加载与离散存储聚合加载与离散存储均支持以下两种模式 有序索引：在访问内存时按照索引的顺序有序的访问 无序索引：访问内存时不保证访问的顺序 有序索引的聚合加载指令 c //加载8位宽度数据 vloxei8.v vd, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从内存有序的加载元素到vd中 有序索引的离散存储指令 c vsoxei8.v vs, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从vs2有序的存储元素到内存中 无序索引的聚合加载指令 c vluxei8.v vd, (rs1), vs2, vm 无序索引的离散存储指令 c vsuxei8.v vs, (rs1), vs2, vm 打包数据的加载与存储现实中有一些数据是以一定格式打包的，如rgb24，正常情况下需要将rgb24加载到矢量寄存器中，之后将其解包为r，g，b三个不同的寄存器组，但这个过程很麻烦。为此rvv推出此指令，打包数据的加载存储指令也有单位步长，任意步长，聚合加载与离散存储三种模式 单位步长的打包数据加载存储指令如下： c vlsege.v vd, (rs1), vm vssege.v vs, (rs1), vm 其中，nf是构成打包数据的元素个数，eew是每个元素的位宽，cpu会影响vdvd+nf-1/vsvs+nf-1个向量寄存器 对于rgb24： c //从a1地址开始加载rgb24数据到v4，v5，v6矢量寄存器中 vsseg3e8.v v4, (a1) 加载和存储全部矢量数据 c //从rs地址处开始将n个矢量寄存器大小的数据加载进vd到vd+n-1的寄存器中 vlr.v vd, (rs) //存储指令 vsr.v vs, (rs1) 矢量掩码指令 逻辑操作指令我们可以让两个矢量之间进行逻辑运算 c vmand.mm vd, vs2, vs1 vmxor.mm vd, vs2, vs1 vmor.mm vd, vs2, vs1 与位操作指令不同的是，掩码制控制数据元素的激活与否，而位操作指令是修改元素的值 此外，rvv的指令集还支持如下伪指令 c //将vs中数据全部复制到vd vmmv.m vd, vs //将vd中数据全部清0 vmclr.m vd //将vd中数据全部置","date":"2025-01-01","objectID":"/posts/risc-v/:8:14","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#单位步长模式"},{"categories":["Tech"],"content":" 可伸缩矢量计算与优化SISD(single instruction single data，单指令单数据)，同一时刻只能处理一条数据，大多数rv指令是sisd的 当处理小数据时，需要将一个8位数据对应的加载到一个单独的64位寄存器中，不能有效利用cpu资源 simd对多个数据元素同时执行相同的操作，这些数据元素被打包在更大的寄存器中的独立通道(也被称为元素)，假设矢量寄存器的长度是128位，那么add指令会把4个32位数据元素加在一起，这些值被打包到两对128寄存器(v1，v2)中的通道中，然后让第一个源寄存器的每个通道与第二个源寄存器的对应通道相加，结果存在v0对应通道中 simd非常适合图像处理场景。图像常用rgb565，rgba8888，yuv422等格式的数据，这些格式的特点是一个像素的一个分量用3或4个8位数据表示，处理的时候是能够并行处理 SIMD的历史1999年，Intel推出SSE(streaming SIMD extension， 流式SIMD扩展)指令集，解决浮点数运算问题并把矢量寄存器的宽度升级到128位 2008年，Intel发布AVX(advanced vector extension， 高级矢量扩展)，兼容sse的同时把矢量寄存器的长度从128位提升至256位 2013年，Intel发布AVX512，矢量寄存器长度进一步提高至512位 arm阵营中，armv7a推出NEON指令集，矢量寄存器128位，在v8下为256位 由于上述指令集都属于定长度指令集，64位矢量寄存器无法运行128位的程序，因此arm在armv8.2中引入了可伸缩矢量扩展(SVE，scalable vector extension)指令集，其编程模型被称为可变矢量长度(VLA)模型 rv架构中，rvv也支持可伸缩矢量计算，且支持的矢量长度最大达65536位 矢量运算指令提供3个版本：矢量，标量，立即数 矢量版本：把矢量寄存器1的所有通道与矢量寄存器2的所有通道进行计算 标量版本：通用寄存器的数据与矢量寄存器进行计算 立即数版本：矢量寄存器与矢量寄存器生成的立即数进行计算 rvv寄存器组rvv为矢量计算提供了一个全新的寄存器组，包括 32个矢量寄存器(v0~v31) 7个非特权级寄存器：vtype，vl，vlenb，vstart，vxvm，vxsat，vcsr 参与运算的矢量长度：必须是$2^n$，最大长度为$2^{16}$(65536位) 元素长度：必须是$2^n$，最小长度为8位 mstatus寄存器：内部的vs字段(Bit[10:9])不仅描述矢量上下文状态，还会映射到sstatus寄存器的Bit[10:9]。当vs字段处于初始状态也就是0时，使用rvv指令或访问非特权寄存器都会改变状态触发指令异常 vtype寄存器：用来描述矢量寄存器中数据类型，决定了数据组织方式和如何对多个矢量寄存器进行分组。vlmul字段决定了多少个矢量寄存器可以组成一个矢量寄存器组，这样一条指令就可以同时操作这个寄存器组了，vlmul不仅可以被设置为整数也可以设置为分数，所以支持高位宽rvv指令集对低位宽指令集的兼容 vlmul(lmul的) 取值 表达式 寄存器组大小 使用的 v 寄存器 含义 000 m1 1 个 v0 标准长度 001 m2 2 个 v0, v1 两倍长度 010 m4 4 个 v0–v3 四倍长度 011 m8 8 个 v0–v7 八倍长度 111 mf2 1/2 个 v0 (部分使用) 半长 110 mf4 1/4 个 v0 (部分使用) 1/4 长 101 mf8 1/8 个 v0 (部分使用) 1/8 长 示例代码： c vsetvli t0, a2, e32, m4 # 设置 vtype，使用4个寄存器组成一个逻辑向量组 vadd.vv v0, v4, v8 # 对应的加法 整个指令的行为是 c [v0,v1,v2,v3] = [v4,v5,v6,v7] + [v8,v9,v10,v11] vl寄存器：用来记录在矢量指令中处理元素的数量 vlenb寄存器：指定一个矢量寄存器内有多少字节，该值在硬件设计时就确定了，因此该寄存器是只读的 vstart寄存器：用来指示第一个参与运算数据元素的索引，通常为0，不为0时执行某些运算会触发指令异常 VLA模型VLA(Vector Length Agnostic，可变向量长度编程模型) vla的实现依靠软硬件共同完成，硬件方面由底层提供配置寄存器，vtype以及vl，前者配置要处理数据类型的位宽，后者配置每次处理数据元素的个数 一般使用vsetvli指令设置： c //初始化vl和vtype寄存器，其中有效元素位宽为8(eew=8)，有效组乘系数=1(emul=1，使用一个寄存器组成一个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为16 //并把vl的值存在t0寄存器中，a2表示要处理的字节数 vsetvli t0, a2, e8, m1 //初始化vl和vtype寄存器，其中有效元素位宽为16(eew=16)，有效组乘系数=1/2(emul=1/2，使用一个寄存器组成两个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为8 vsetvli t0, a2, e16, mf2 一般情况下，矢量寄存器的长度组乘系数与有效组乘系数是相等的(lmul=emul)，并且sew=eew。但在处理不同位宽的数据（如 8 位与 16 位数据相加）时，EMUL 会大于 LMUL。例如，在将 8 位数据与 16 位数据进行矢量加法操作时，为了保证结果宽度足够，可能需要设置 EMUL = 2 × LMUL，以容纳更宽的运算结果 加载和存储指令 单位步长模式 c //从rs1指向的地址加载8位宽的数据元素，vm为掩码操作数 vle8.v vd (rs1) vm //向rs1指向的地址存储16位宽的数据元素，vm为掩码操作数 vse16.v vd (rs1) vm 掩码操作数：rvv提供可以控制每一个数据的方法，若vm为v0.t，则表述用v0矢量寄存器作为掩码，每位表示一个数据元素的状态，若v0[i]==1，表示第i个元素被激活，被激活的元素参与计算，未被激活的则不参与。若未激活的元素的计算策略除了保持不变外还有可能令其为1，这就被称为未知策略，保持不变的策略被称为不打扰策略。这两种策略可以通过配置vtype寄存器的vta，vma字段实现。当掩码操作数在汇编代码中为空时代表激活所有的元素 .v 被称为修饰符，该符号决定了要操作的寄存器的元素的类型，例子如下： .vv：矢量数据元素与矢量数据元素 .vx：矢量数据元素与整型标量数据元素 .vf：矢量数据元素与浮点标量数据元素 .vi：矢量数据元素与立即数数据元素 .m：掩码元素 任意步长格式加载指令 c //任意步长模式会从内存中以rs1为起始地址，每隔r2为步长，依次将下一个元素加载到vd中，r2的值可以为负数或0 vlse8.v vd (vs1), rs2, vm 存储指令 c vsse8.v vs (vs1), rs2, vm 聚合加载与离散存储聚合加载与离散存储均支持以下两种模式 有序索引：在访问内存时按照索引的顺序有序的访问 无序索引：访问内存时不保证访问的顺序 有序索引的聚合加载指令 c //加载8位宽度数据 vloxei8.v vd, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从内存有序的加载元素到vd中 有序索引的离散存储指令 c vsoxei8.v vs, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从vs2有序的存储元素到内存中 无序索引的聚合加载指令 c vluxei8.v vd, (rs1), vs2, vm 无序索引的离散存储指令 c vsuxei8.v vs, (rs1), vs2, vm 打包数据的加载与存储现实中有一些数据是以一定格式打包的，如rgb24，正常情况下需要将rgb24加载到矢量寄存器中，之后将其解包为r，g，b三个不同的寄存器组，但这个过程很麻烦。为此rvv推出此指令，打包数据的加载存储指令也有单位步长，任意步长，聚合加载与离散存储三种模式 单位步长的打包数据加载存储指令如下： c vlsege.v vd, (rs1), vm vssege.v vs, (rs1), vm 其中，nf是构成打包数据的元素个数，eew是每个元素的位宽，cpu会影响vdvd+nf-1/vsvs+nf-1个向量寄存器 对于rgb24： c //从a1地址开始加载rgb24数据到v4，v5，v6矢量寄存器中 vsseg3e8.v v4, (a1) 加载和存储全部矢量数据 c //从rs地址处开始将n个矢量寄存器大小的数据加载进vd到vd+n-1的寄存器中 vlr.v vd, (rs) //存储指令 vsr.v vs, (rs1) 矢量掩码指令 逻辑操作指令我们可以让两个矢量之间进行逻辑运算 c vmand.mm vd, vs2, vs1 vmxor.mm vd, vs2, vs1 vmor.mm vd, vs2, vs1 与位操作指令不同的是，掩码制控制数据元素的激活与否，而位操作指令是修改元素的值 此外，rvv的指令集还支持如下伪指令 c //将vs中数据全部复制到vd vmmv.m vd, vs //将vd中数据全部清0 vmclr.m vd //将vd中数据全部置","date":"2025-01-01","objectID":"/posts/risc-v/:8:14","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#任意步长格式"},{"categories":["Tech"],"content":" 可伸缩矢量计算与优化SISD(single instruction single data，单指令单数据)，同一时刻只能处理一条数据，大多数rv指令是sisd的 当处理小数据时，需要将一个8位数据对应的加载到一个单独的64位寄存器中，不能有效利用cpu资源 simd对多个数据元素同时执行相同的操作，这些数据元素被打包在更大的寄存器中的独立通道(也被称为元素)，假设矢量寄存器的长度是128位，那么add指令会把4个32位数据元素加在一起，这些值被打包到两对128寄存器(v1，v2)中的通道中，然后让第一个源寄存器的每个通道与第二个源寄存器的对应通道相加，结果存在v0对应通道中 simd非常适合图像处理场景。图像常用rgb565，rgba8888，yuv422等格式的数据，这些格式的特点是一个像素的一个分量用3或4个8位数据表示，处理的时候是能够并行处理 SIMD的历史1999年，Intel推出SSE(streaming SIMD extension， 流式SIMD扩展)指令集，解决浮点数运算问题并把矢量寄存器的宽度升级到128位 2008年，Intel发布AVX(advanced vector extension， 高级矢量扩展)，兼容sse的同时把矢量寄存器的长度从128位提升至256位 2013年，Intel发布AVX512，矢量寄存器长度进一步提高至512位 arm阵营中，armv7a推出NEON指令集，矢量寄存器128位，在v8下为256位 由于上述指令集都属于定长度指令集，64位矢量寄存器无法运行128位的程序，因此arm在armv8.2中引入了可伸缩矢量扩展(SVE，scalable vector extension)指令集，其编程模型被称为可变矢量长度(VLA)模型 rv架构中，rvv也支持可伸缩矢量计算，且支持的矢量长度最大达65536位 矢量运算指令提供3个版本：矢量，标量，立即数 矢量版本：把矢量寄存器1的所有通道与矢量寄存器2的所有通道进行计算 标量版本：通用寄存器的数据与矢量寄存器进行计算 立即数版本：矢量寄存器与矢量寄存器生成的立即数进行计算 rvv寄存器组rvv为矢量计算提供了一个全新的寄存器组，包括 32个矢量寄存器(v0~v31) 7个非特权级寄存器：vtype，vl，vlenb，vstart，vxvm，vxsat，vcsr 参与运算的矢量长度：必须是$2^n$，最大长度为$2^{16}$(65536位) 元素长度：必须是$2^n$，最小长度为8位 mstatus寄存器：内部的vs字段(Bit[10:9])不仅描述矢量上下文状态，还会映射到sstatus寄存器的Bit[10:9]。当vs字段处于初始状态也就是0时，使用rvv指令或访问非特权寄存器都会改变状态触发指令异常 vtype寄存器：用来描述矢量寄存器中数据类型，决定了数据组织方式和如何对多个矢量寄存器进行分组。vlmul字段决定了多少个矢量寄存器可以组成一个矢量寄存器组，这样一条指令就可以同时操作这个寄存器组了，vlmul不仅可以被设置为整数也可以设置为分数，所以支持高位宽rvv指令集对低位宽指令集的兼容 vlmul(lmul的) 取值 表达式 寄存器组大小 使用的 v 寄存器 含义 000 m1 1 个 v0 标准长度 001 m2 2 个 v0, v1 两倍长度 010 m4 4 个 v0–v3 四倍长度 011 m8 8 个 v0–v7 八倍长度 111 mf2 1/2 个 v0 (部分使用) 半长 110 mf4 1/4 个 v0 (部分使用) 1/4 长 101 mf8 1/8 个 v0 (部分使用) 1/8 长 示例代码： c vsetvli t0, a2, e32, m4 # 设置 vtype，使用4个寄存器组成一个逻辑向量组 vadd.vv v0, v4, v8 # 对应的加法 整个指令的行为是 c [v0,v1,v2,v3] = [v4,v5,v6,v7] + [v8,v9,v10,v11] vl寄存器：用来记录在矢量指令中处理元素的数量 vlenb寄存器：指定一个矢量寄存器内有多少字节，该值在硬件设计时就确定了，因此该寄存器是只读的 vstart寄存器：用来指示第一个参与运算数据元素的索引，通常为0，不为0时执行某些运算会触发指令异常 VLA模型VLA(Vector Length Agnostic，可变向量长度编程模型) vla的实现依靠软硬件共同完成，硬件方面由底层提供配置寄存器，vtype以及vl，前者配置要处理数据类型的位宽，后者配置每次处理数据元素的个数 一般使用vsetvli指令设置： c //初始化vl和vtype寄存器，其中有效元素位宽为8(eew=8)，有效组乘系数=1(emul=1，使用一个寄存器组成一个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为16 //并把vl的值存在t0寄存器中，a2表示要处理的字节数 vsetvli t0, a2, e8, m1 //初始化vl和vtype寄存器，其中有效元素位宽为16(eew=16)，有效组乘系数=1/2(emul=1/2，使用一个寄存器组成两个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为8 vsetvli t0, a2, e16, mf2 一般情况下，矢量寄存器的长度组乘系数与有效组乘系数是相等的(lmul=emul)，并且sew=eew。但在处理不同位宽的数据（如 8 位与 16 位数据相加）时，EMUL 会大于 LMUL。例如，在将 8 位数据与 16 位数据进行矢量加法操作时，为了保证结果宽度足够，可能需要设置 EMUL = 2 × LMUL，以容纳更宽的运算结果 加载和存储指令 单位步长模式 c //从rs1指向的地址加载8位宽的数据元素，vm为掩码操作数 vle8.v vd (rs1) vm //向rs1指向的地址存储16位宽的数据元素，vm为掩码操作数 vse16.v vd (rs1) vm 掩码操作数：rvv提供可以控制每一个数据的方法，若vm为v0.t，则表述用v0矢量寄存器作为掩码，每位表示一个数据元素的状态，若v0[i]==1，表示第i个元素被激活，被激活的元素参与计算，未被激活的则不参与。若未激活的元素的计算策略除了保持不变外还有可能令其为1，这就被称为未知策略，保持不变的策略被称为不打扰策略。这两种策略可以通过配置vtype寄存器的vta，vma字段实现。当掩码操作数在汇编代码中为空时代表激活所有的元素 .v 被称为修饰符，该符号决定了要操作的寄存器的元素的类型，例子如下： .vv：矢量数据元素与矢量数据元素 .vx：矢量数据元素与整型标量数据元素 .vf：矢量数据元素与浮点标量数据元素 .vi：矢量数据元素与立即数数据元素 .m：掩码元素 任意步长格式加载指令 c //任意步长模式会从内存中以rs1为起始地址，每隔r2为步长，依次将下一个元素加载到vd中，r2的值可以为负数或0 vlse8.v vd (vs1), rs2, vm 存储指令 c vsse8.v vs (vs1), rs2, vm 聚合加载与离散存储聚合加载与离散存储均支持以下两种模式 有序索引：在访问内存时按照索引的顺序有序的访问 无序索引：访问内存时不保证访问的顺序 有序索引的聚合加载指令 c //加载8位宽度数据 vloxei8.v vd, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从内存有序的加载元素到vd中 有序索引的离散存储指令 c vsoxei8.v vs, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从vs2有序的存储元素到内存中 无序索引的聚合加载指令 c vluxei8.v vd, (rs1), vs2, vm 无序索引的离散存储指令 c vsuxei8.v vs, (rs1), vs2, vm 打包数据的加载与存储现实中有一些数据是以一定格式打包的，如rgb24，正常情况下需要将rgb24加载到矢量寄存器中，之后将其解包为r，g，b三个不同的寄存器组，但这个过程很麻烦。为此rvv推出此指令，打包数据的加载存储指令也有单位步长，任意步长，聚合加载与离散存储三种模式 单位步长的打包数据加载存储指令如下： c vlsege.v vd, (rs1), vm vssege.v vs, (rs1), vm 其中，nf是构成打包数据的元素个数，eew是每个元素的位宽，cpu会影响vdvd+nf-1/vsvs+nf-1个向量寄存器 对于rgb24： c //从a1地址开始加载rgb24数据到v4，v5，v6矢量寄存器中 vsseg3e8.v v4, (a1) 加载和存储全部矢量数据 c //从rs地址处开始将n个矢量寄存器大小的数据加载进vd到vd+n-1的寄存器中 vlr.v vd, (rs) //存储指令 vsr.v vs, (rs1) 矢量掩码指令 逻辑操作指令我们可以让两个矢量之间进行逻辑运算 c vmand.mm vd, vs2, vs1 vmxor.mm vd, vs2, vs1 vmor.mm vd, vs2, vs1 与位操作指令不同的是，掩码制控制数据元素的激活与否，而位操作指令是修改元素的值 此外，rvv的指令集还支持如下伪指令 c //将vs中数据全部复制到vd vmmv.m vd, vs //将vd中数据全部清0 vmclr.m vd //将vd中数据全部置","date":"2025-01-01","objectID":"/posts/risc-v/:8:14","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#聚合加载与离散存储"},{"categories":["Tech"],"content":" 可伸缩矢量计算与优化SISD(single instruction single data，单指令单数据)，同一时刻只能处理一条数据，大多数rv指令是sisd的 当处理小数据时，需要将一个8位数据对应的加载到一个单独的64位寄存器中，不能有效利用cpu资源 simd对多个数据元素同时执行相同的操作，这些数据元素被打包在更大的寄存器中的独立通道(也被称为元素)，假设矢量寄存器的长度是128位，那么add指令会把4个32位数据元素加在一起，这些值被打包到两对128寄存器(v1，v2)中的通道中，然后让第一个源寄存器的每个通道与第二个源寄存器的对应通道相加，结果存在v0对应通道中 simd非常适合图像处理场景。图像常用rgb565，rgba8888，yuv422等格式的数据，这些格式的特点是一个像素的一个分量用3或4个8位数据表示，处理的时候是能够并行处理 SIMD的历史1999年，Intel推出SSE(streaming SIMD extension， 流式SIMD扩展)指令集，解决浮点数运算问题并把矢量寄存器的宽度升级到128位 2008年，Intel发布AVX(advanced vector extension， 高级矢量扩展)，兼容sse的同时把矢量寄存器的长度从128位提升至256位 2013年，Intel发布AVX512，矢量寄存器长度进一步提高至512位 arm阵营中，armv7a推出NEON指令集，矢量寄存器128位，在v8下为256位 由于上述指令集都属于定长度指令集，64位矢量寄存器无法运行128位的程序，因此arm在armv8.2中引入了可伸缩矢量扩展(SVE，scalable vector extension)指令集，其编程模型被称为可变矢量长度(VLA)模型 rv架构中，rvv也支持可伸缩矢量计算，且支持的矢量长度最大达65536位 矢量运算指令提供3个版本：矢量，标量，立即数 矢量版本：把矢量寄存器1的所有通道与矢量寄存器2的所有通道进行计算 标量版本：通用寄存器的数据与矢量寄存器进行计算 立即数版本：矢量寄存器与矢量寄存器生成的立即数进行计算 rvv寄存器组rvv为矢量计算提供了一个全新的寄存器组，包括 32个矢量寄存器(v0~v31) 7个非特权级寄存器：vtype，vl，vlenb，vstart，vxvm，vxsat，vcsr 参与运算的矢量长度：必须是$2^n$，最大长度为$2^{16}$(65536位) 元素长度：必须是$2^n$，最小长度为8位 mstatus寄存器：内部的vs字段(Bit[10:9])不仅描述矢量上下文状态，还会映射到sstatus寄存器的Bit[10:9]。当vs字段处于初始状态也就是0时，使用rvv指令或访问非特权寄存器都会改变状态触发指令异常 vtype寄存器：用来描述矢量寄存器中数据类型，决定了数据组织方式和如何对多个矢量寄存器进行分组。vlmul字段决定了多少个矢量寄存器可以组成一个矢量寄存器组，这样一条指令就可以同时操作这个寄存器组了，vlmul不仅可以被设置为整数也可以设置为分数，所以支持高位宽rvv指令集对低位宽指令集的兼容 vlmul(lmul的) 取值 表达式 寄存器组大小 使用的 v 寄存器 含义 000 m1 1 个 v0 标准长度 001 m2 2 个 v0, v1 两倍长度 010 m4 4 个 v0–v3 四倍长度 011 m8 8 个 v0–v7 八倍长度 111 mf2 1/2 个 v0 (部分使用) 半长 110 mf4 1/4 个 v0 (部分使用) 1/4 长 101 mf8 1/8 个 v0 (部分使用) 1/8 长 示例代码： c vsetvli t0, a2, e32, m4 # 设置 vtype，使用4个寄存器组成一个逻辑向量组 vadd.vv v0, v4, v8 # 对应的加法 整个指令的行为是 c [v0,v1,v2,v3] = [v4,v5,v6,v7] + [v8,v9,v10,v11] vl寄存器：用来记录在矢量指令中处理元素的数量 vlenb寄存器：指定一个矢量寄存器内有多少字节，该值在硬件设计时就确定了，因此该寄存器是只读的 vstart寄存器：用来指示第一个参与运算数据元素的索引，通常为0，不为0时执行某些运算会触发指令异常 VLA模型VLA(Vector Length Agnostic，可变向量长度编程模型) vla的实现依靠软硬件共同完成，硬件方面由底层提供配置寄存器，vtype以及vl，前者配置要处理数据类型的位宽，后者配置每次处理数据元素的个数 一般使用vsetvli指令设置： c //初始化vl和vtype寄存器，其中有效元素位宽为8(eew=8)，有效组乘系数=1(emul=1，使用一个寄存器组成一个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为16 //并把vl的值存在t0寄存器中，a2表示要处理的字节数 vsetvli t0, a2, e8, m1 //初始化vl和vtype寄存器，其中有效元素位宽为16(eew=16)，有效组乘系数=1/2(emul=1/2，使用一个寄存器组成两个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为8 vsetvli t0, a2, e16, mf2 一般情况下，矢量寄存器的长度组乘系数与有效组乘系数是相等的(lmul=emul)，并且sew=eew。但在处理不同位宽的数据（如 8 位与 16 位数据相加）时，EMUL 会大于 LMUL。例如，在将 8 位数据与 16 位数据进行矢量加法操作时，为了保证结果宽度足够，可能需要设置 EMUL = 2 × LMUL，以容纳更宽的运算结果 加载和存储指令 单位步长模式 c //从rs1指向的地址加载8位宽的数据元素，vm为掩码操作数 vle8.v vd (rs1) vm //向rs1指向的地址存储16位宽的数据元素，vm为掩码操作数 vse16.v vd (rs1) vm 掩码操作数：rvv提供可以控制每一个数据的方法，若vm为v0.t，则表述用v0矢量寄存器作为掩码，每位表示一个数据元素的状态，若v0[i]==1，表示第i个元素被激活，被激活的元素参与计算，未被激活的则不参与。若未激活的元素的计算策略除了保持不变外还有可能令其为1，这就被称为未知策略，保持不变的策略被称为不打扰策略。这两种策略可以通过配置vtype寄存器的vta，vma字段实现。当掩码操作数在汇编代码中为空时代表激活所有的元素 .v 被称为修饰符，该符号决定了要操作的寄存器的元素的类型，例子如下： .vv：矢量数据元素与矢量数据元素 .vx：矢量数据元素与整型标量数据元素 .vf：矢量数据元素与浮点标量数据元素 .vi：矢量数据元素与立即数数据元素 .m：掩码元素 任意步长格式加载指令 c //任意步长模式会从内存中以rs1为起始地址，每隔r2为步长，依次将下一个元素加载到vd中，r2的值可以为负数或0 vlse8.v vd (vs1), rs2, vm 存储指令 c vsse8.v vs (vs1), rs2, vm 聚合加载与离散存储聚合加载与离散存储均支持以下两种模式 有序索引：在访问内存时按照索引的顺序有序的访问 无序索引：访问内存时不保证访问的顺序 有序索引的聚合加载指令 c //加载8位宽度数据 vloxei8.v vd, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从内存有序的加载元素到vd中 有序索引的离散存储指令 c vsoxei8.v vs, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从vs2有序的存储元素到内存中 无序索引的聚合加载指令 c vluxei8.v vd, (rs1), vs2, vm 无序索引的离散存储指令 c vsuxei8.v vs, (rs1), vs2, vm 打包数据的加载与存储现实中有一些数据是以一定格式打包的，如rgb24，正常情况下需要将rgb24加载到矢量寄存器中，之后将其解包为r，g，b三个不同的寄存器组，但这个过程很麻烦。为此rvv推出此指令，打包数据的加载存储指令也有单位步长，任意步长，聚合加载与离散存储三种模式 单位步长的打包数据加载存储指令如下： c vlsege.v vd, (rs1), vm vssege.v vs, (rs1), vm 其中，nf是构成打包数据的元素个数，eew是每个元素的位宽，cpu会影响vdvd+nf-1/vsvs+nf-1个向量寄存器 对于rgb24： c //从a1地址开始加载rgb24数据到v4，v5，v6矢量寄存器中 vsseg3e8.v v4, (a1) 加载和存储全部矢量数据 c //从rs地址处开始将n个矢量寄存器大小的数据加载进vd到vd+n-1的寄存器中 vlr.v vd, (rs) //存储指令 vsr.v vs, (rs1) 矢量掩码指令 逻辑操作指令我们可以让两个矢量之间进行逻辑运算 c vmand.mm vd, vs2, vs1 vmxor.mm vd, vs2, vs1 vmor.mm vd, vs2, vs1 与位操作指令不同的是，掩码制控制数据元素的激活与否，而位操作指令是修改元素的值 此外，rvv的指令集还支持如下伪指令 c //将vs中数据全部复制到vd vmmv.m vd, vs //将vd中数据全部清0 vmclr.m vd //将vd中数据全部置","date":"2025-01-01","objectID":"/posts/risc-v/:8:14","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#打包数据的加载与存储"},{"categories":["Tech"],"content":" 可伸缩矢量计算与优化SISD(single instruction single data，单指令单数据)，同一时刻只能处理一条数据，大多数rv指令是sisd的 当处理小数据时，需要将一个8位数据对应的加载到一个单独的64位寄存器中，不能有效利用cpu资源 simd对多个数据元素同时执行相同的操作，这些数据元素被打包在更大的寄存器中的独立通道(也被称为元素)，假设矢量寄存器的长度是128位，那么add指令会把4个32位数据元素加在一起，这些值被打包到两对128寄存器(v1，v2)中的通道中，然后让第一个源寄存器的每个通道与第二个源寄存器的对应通道相加，结果存在v0对应通道中 simd非常适合图像处理场景。图像常用rgb565，rgba8888，yuv422等格式的数据，这些格式的特点是一个像素的一个分量用3或4个8位数据表示，处理的时候是能够并行处理 SIMD的历史1999年，Intel推出SSE(streaming SIMD extension， 流式SIMD扩展)指令集，解决浮点数运算问题并把矢量寄存器的宽度升级到128位 2008年，Intel发布AVX(advanced vector extension， 高级矢量扩展)，兼容sse的同时把矢量寄存器的长度从128位提升至256位 2013年，Intel发布AVX512，矢量寄存器长度进一步提高至512位 arm阵营中，armv7a推出NEON指令集，矢量寄存器128位，在v8下为256位 由于上述指令集都属于定长度指令集，64位矢量寄存器无法运行128位的程序，因此arm在armv8.2中引入了可伸缩矢量扩展(SVE，scalable vector extension)指令集，其编程模型被称为可变矢量长度(VLA)模型 rv架构中，rvv也支持可伸缩矢量计算，且支持的矢量长度最大达65536位 矢量运算指令提供3个版本：矢量，标量，立即数 矢量版本：把矢量寄存器1的所有通道与矢量寄存器2的所有通道进行计算 标量版本：通用寄存器的数据与矢量寄存器进行计算 立即数版本：矢量寄存器与矢量寄存器生成的立即数进行计算 rvv寄存器组rvv为矢量计算提供了一个全新的寄存器组，包括 32个矢量寄存器(v0~v31) 7个非特权级寄存器：vtype，vl，vlenb，vstart，vxvm，vxsat，vcsr 参与运算的矢量长度：必须是$2^n$，最大长度为$2^{16}$(65536位) 元素长度：必须是$2^n$，最小长度为8位 mstatus寄存器：内部的vs字段(Bit[10:9])不仅描述矢量上下文状态，还会映射到sstatus寄存器的Bit[10:9]。当vs字段处于初始状态也就是0时，使用rvv指令或访问非特权寄存器都会改变状态触发指令异常 vtype寄存器：用来描述矢量寄存器中数据类型，决定了数据组织方式和如何对多个矢量寄存器进行分组。vlmul字段决定了多少个矢量寄存器可以组成一个矢量寄存器组，这样一条指令就可以同时操作这个寄存器组了，vlmul不仅可以被设置为整数也可以设置为分数，所以支持高位宽rvv指令集对低位宽指令集的兼容 vlmul(lmul的) 取值 表达式 寄存器组大小 使用的 v 寄存器 含义 000 m1 1 个 v0 标准长度 001 m2 2 个 v0, v1 两倍长度 010 m4 4 个 v0–v3 四倍长度 011 m8 8 个 v0–v7 八倍长度 111 mf2 1/2 个 v0 (部分使用) 半长 110 mf4 1/4 个 v0 (部分使用) 1/4 长 101 mf8 1/8 个 v0 (部分使用) 1/8 长 示例代码： c vsetvli t0, a2, e32, m4 # 设置 vtype，使用4个寄存器组成一个逻辑向量组 vadd.vv v0, v4, v8 # 对应的加法 整个指令的行为是 c [v0,v1,v2,v3] = [v4,v5,v6,v7] + [v8,v9,v10,v11] vl寄存器：用来记录在矢量指令中处理元素的数量 vlenb寄存器：指定一个矢量寄存器内有多少字节，该值在硬件设计时就确定了，因此该寄存器是只读的 vstart寄存器：用来指示第一个参与运算数据元素的索引，通常为0，不为0时执行某些运算会触发指令异常 VLA模型VLA(Vector Length Agnostic，可变向量长度编程模型) vla的实现依靠软硬件共同完成，硬件方面由底层提供配置寄存器，vtype以及vl，前者配置要处理数据类型的位宽，后者配置每次处理数据元素的个数 一般使用vsetvli指令设置： c //初始化vl和vtype寄存器，其中有效元素位宽为8(eew=8)，有效组乘系数=1(emul=1，使用一个寄存器组成一个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为16 //并把vl的值存在t0寄存器中，a2表示要处理的字节数 vsetvli t0, a2, e8, m1 //初始化vl和vtype寄存器，其中有效元素位宽为16(eew=16)，有效组乘系数=1/2(emul=1/2，使用一个寄存器组成两个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为8 vsetvli t0, a2, e16, mf2 一般情况下，矢量寄存器的长度组乘系数与有效组乘系数是相等的(lmul=emul)，并且sew=eew。但在处理不同位宽的数据（如 8 位与 16 位数据相加）时，EMUL 会大于 LMUL。例如，在将 8 位数据与 16 位数据进行矢量加法操作时，为了保证结果宽度足够，可能需要设置 EMUL = 2 × LMUL，以容纳更宽的运算结果 加载和存储指令 单位步长模式 c //从rs1指向的地址加载8位宽的数据元素，vm为掩码操作数 vle8.v vd (rs1) vm //向rs1指向的地址存储16位宽的数据元素，vm为掩码操作数 vse16.v vd (rs1) vm 掩码操作数：rvv提供可以控制每一个数据的方法，若vm为v0.t，则表述用v0矢量寄存器作为掩码，每位表示一个数据元素的状态，若v0[i]==1，表示第i个元素被激活，被激活的元素参与计算，未被激活的则不参与。若未激活的元素的计算策略除了保持不变外还有可能令其为1，这就被称为未知策略，保持不变的策略被称为不打扰策略。这两种策略可以通过配置vtype寄存器的vta，vma字段实现。当掩码操作数在汇编代码中为空时代表激活所有的元素 .v 被称为修饰符，该符号决定了要操作的寄存器的元素的类型，例子如下： .vv：矢量数据元素与矢量数据元素 .vx：矢量数据元素与整型标量数据元素 .vf：矢量数据元素与浮点标量数据元素 .vi：矢量数据元素与立即数数据元素 .m：掩码元素 任意步长格式加载指令 c //任意步长模式会从内存中以rs1为起始地址，每隔r2为步长，依次将下一个元素加载到vd中，r2的值可以为负数或0 vlse8.v vd (vs1), rs2, vm 存储指令 c vsse8.v vs (vs1), rs2, vm 聚合加载与离散存储聚合加载与离散存储均支持以下两种模式 有序索引：在访问内存时按照索引的顺序有序的访问 无序索引：访问内存时不保证访问的顺序 有序索引的聚合加载指令 c //加载8位宽度数据 vloxei8.v vd, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从内存有序的加载元素到vd中 有序索引的离散存储指令 c vsoxei8.v vs, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从vs2有序的存储元素到内存中 无序索引的聚合加载指令 c vluxei8.v vd, (rs1), vs2, vm 无序索引的离散存储指令 c vsuxei8.v vs, (rs1), vs2, vm 打包数据的加载与存储现实中有一些数据是以一定格式打包的，如rgb24，正常情况下需要将rgb24加载到矢量寄存器中，之后将其解包为r，g，b三个不同的寄存器组，但这个过程很麻烦。为此rvv推出此指令，打包数据的加载存储指令也有单位步长，任意步长，聚合加载与离散存储三种模式 单位步长的打包数据加载存储指令如下： c vlsege.v vd, (rs1), vm vssege.v vs, (rs1), vm 其中，nf是构成打包数据的元素个数，eew是每个元素的位宽，cpu会影响vdvd+nf-1/vsvs+nf-1个向量寄存器 对于rgb24： c //从a1地址开始加载rgb24数据到v4，v5，v6矢量寄存器中 vsseg3e8.v v4, (a1) 加载和存储全部矢量数据 c //从rs地址处开始将n个矢量寄存器大小的数据加载进vd到vd+n-1的寄存器中 vlr.v vd, (rs) //存储指令 vsr.v vs, (rs1) 矢量掩码指令 逻辑操作指令我们可以让两个矢量之间进行逻辑运算 c vmand.mm vd, vs2, vs1 vmxor.mm vd, vs2, vs1 vmor.mm vd, vs2, vs1 与位操作指令不同的是，掩码制控制数据元素的激活与否，而位操作指令是修改元素的值 此外，rvv的指令集还支持如下伪指令 c //将vs中数据全部复制到vd vmmv.m vd, vs //将vd中数据全部清0 vmclr.m vd //将vd中数据全部置","date":"2025-01-01","objectID":"/posts/risc-v/:8:14","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#加载和存储全部矢量数据"},{"categories":["Tech"],"content":" 可伸缩矢量计算与优化SISD(single instruction single data，单指令单数据)，同一时刻只能处理一条数据，大多数rv指令是sisd的 当处理小数据时，需要将一个8位数据对应的加载到一个单独的64位寄存器中，不能有效利用cpu资源 simd对多个数据元素同时执行相同的操作，这些数据元素被打包在更大的寄存器中的独立通道(也被称为元素)，假设矢量寄存器的长度是128位，那么add指令会把4个32位数据元素加在一起，这些值被打包到两对128寄存器(v1，v2)中的通道中，然后让第一个源寄存器的每个通道与第二个源寄存器的对应通道相加，结果存在v0对应通道中 simd非常适合图像处理场景。图像常用rgb565，rgba8888，yuv422等格式的数据，这些格式的特点是一个像素的一个分量用3或4个8位数据表示，处理的时候是能够并行处理 SIMD的历史1999年，Intel推出SSE(streaming SIMD extension， 流式SIMD扩展)指令集，解决浮点数运算问题并把矢量寄存器的宽度升级到128位 2008年，Intel发布AVX(advanced vector extension， 高级矢量扩展)，兼容sse的同时把矢量寄存器的长度从128位提升至256位 2013年，Intel发布AVX512，矢量寄存器长度进一步提高至512位 arm阵营中，armv7a推出NEON指令集，矢量寄存器128位，在v8下为256位 由于上述指令集都属于定长度指令集，64位矢量寄存器无法运行128位的程序，因此arm在armv8.2中引入了可伸缩矢量扩展(SVE，scalable vector extension)指令集，其编程模型被称为可变矢量长度(VLA)模型 rv架构中，rvv也支持可伸缩矢量计算，且支持的矢量长度最大达65536位 矢量运算指令提供3个版本：矢量，标量，立即数 矢量版本：把矢量寄存器1的所有通道与矢量寄存器2的所有通道进行计算 标量版本：通用寄存器的数据与矢量寄存器进行计算 立即数版本：矢量寄存器与矢量寄存器生成的立即数进行计算 rvv寄存器组rvv为矢量计算提供了一个全新的寄存器组，包括 32个矢量寄存器(v0~v31) 7个非特权级寄存器：vtype，vl，vlenb，vstart，vxvm，vxsat，vcsr 参与运算的矢量长度：必须是$2^n$，最大长度为$2^{16}$(65536位) 元素长度：必须是$2^n$，最小长度为8位 mstatus寄存器：内部的vs字段(Bit[10:9])不仅描述矢量上下文状态，还会映射到sstatus寄存器的Bit[10:9]。当vs字段处于初始状态也就是0时，使用rvv指令或访问非特权寄存器都会改变状态触发指令异常 vtype寄存器：用来描述矢量寄存器中数据类型，决定了数据组织方式和如何对多个矢量寄存器进行分组。vlmul字段决定了多少个矢量寄存器可以组成一个矢量寄存器组，这样一条指令就可以同时操作这个寄存器组了，vlmul不仅可以被设置为整数也可以设置为分数，所以支持高位宽rvv指令集对低位宽指令集的兼容 vlmul(lmul的) 取值 表达式 寄存器组大小 使用的 v 寄存器 含义 000 m1 1 个 v0 标准长度 001 m2 2 个 v0, v1 两倍长度 010 m4 4 个 v0–v3 四倍长度 011 m8 8 个 v0–v7 八倍长度 111 mf2 1/2 个 v0 (部分使用) 半长 110 mf4 1/4 个 v0 (部分使用) 1/4 长 101 mf8 1/8 个 v0 (部分使用) 1/8 长 示例代码： c vsetvli t0, a2, e32, m4 # 设置 vtype，使用4个寄存器组成一个逻辑向量组 vadd.vv v0, v4, v8 # 对应的加法 整个指令的行为是 c [v0,v1,v2,v3] = [v4,v5,v6,v7] + [v8,v9,v10,v11] vl寄存器：用来记录在矢量指令中处理元素的数量 vlenb寄存器：指定一个矢量寄存器内有多少字节，该值在硬件设计时就确定了，因此该寄存器是只读的 vstart寄存器：用来指示第一个参与运算数据元素的索引，通常为0，不为0时执行某些运算会触发指令异常 VLA模型VLA(Vector Length Agnostic，可变向量长度编程模型) vla的实现依靠软硬件共同完成，硬件方面由底层提供配置寄存器，vtype以及vl，前者配置要处理数据类型的位宽，后者配置每次处理数据元素的个数 一般使用vsetvli指令设置： c //初始化vl和vtype寄存器，其中有效元素位宽为8(eew=8)，有效组乘系数=1(emul=1，使用一个寄存器组成一个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为16 //并把vl的值存在t0寄存器中，a2表示要处理的字节数 vsetvli t0, a2, e8, m1 //初始化vl和vtype寄存器，其中有效元素位宽为16(eew=16)，有效组乘系数=1/2(emul=1/2，使用一个寄存器组成两个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为8 vsetvli t0, a2, e16, mf2 一般情况下，矢量寄存器的长度组乘系数与有效组乘系数是相等的(lmul=emul)，并且sew=eew。但在处理不同位宽的数据（如 8 位与 16 位数据相加）时，EMUL 会大于 LMUL。例如，在将 8 位数据与 16 位数据进行矢量加法操作时，为了保证结果宽度足够，可能需要设置 EMUL = 2 × LMUL，以容纳更宽的运算结果 加载和存储指令 单位步长模式 c //从rs1指向的地址加载8位宽的数据元素，vm为掩码操作数 vle8.v vd (rs1) vm //向rs1指向的地址存储16位宽的数据元素，vm为掩码操作数 vse16.v vd (rs1) vm 掩码操作数：rvv提供可以控制每一个数据的方法，若vm为v0.t，则表述用v0矢量寄存器作为掩码，每位表示一个数据元素的状态，若v0[i]==1，表示第i个元素被激活，被激活的元素参与计算，未被激活的则不参与。若未激活的元素的计算策略除了保持不变外还有可能令其为1，这就被称为未知策略，保持不变的策略被称为不打扰策略。这两种策略可以通过配置vtype寄存器的vta，vma字段实现。当掩码操作数在汇编代码中为空时代表激活所有的元素 .v 被称为修饰符，该符号决定了要操作的寄存器的元素的类型，例子如下： .vv：矢量数据元素与矢量数据元素 .vx：矢量数据元素与整型标量数据元素 .vf：矢量数据元素与浮点标量数据元素 .vi：矢量数据元素与立即数数据元素 .m：掩码元素 任意步长格式加载指令 c //任意步长模式会从内存中以rs1为起始地址，每隔r2为步长，依次将下一个元素加载到vd中，r2的值可以为负数或0 vlse8.v vd (vs1), rs2, vm 存储指令 c vsse8.v vs (vs1), rs2, vm 聚合加载与离散存储聚合加载与离散存储均支持以下两种模式 有序索引：在访问内存时按照索引的顺序有序的访问 无序索引：访问内存时不保证访问的顺序 有序索引的聚合加载指令 c //加载8位宽度数据 vloxei8.v vd, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从内存有序的加载元素到vd中 有序索引的离散存储指令 c vsoxei8.v vs, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从vs2有序的存储元素到内存中 无序索引的聚合加载指令 c vluxei8.v vd, (rs1), vs2, vm 无序索引的离散存储指令 c vsuxei8.v vs, (rs1), vs2, vm 打包数据的加载与存储现实中有一些数据是以一定格式打包的，如rgb24，正常情况下需要将rgb24加载到矢量寄存器中，之后将其解包为r，g，b三个不同的寄存器组，但这个过程很麻烦。为此rvv推出此指令，打包数据的加载存储指令也有单位步长，任意步长，聚合加载与离散存储三种模式 单位步长的打包数据加载存储指令如下： c vlsege.v vd, (rs1), vm vssege.v vs, (rs1), vm 其中，nf是构成打包数据的元素个数，eew是每个元素的位宽，cpu会影响vdvd+nf-1/vsvs+nf-1个向量寄存器 对于rgb24： c //从a1地址开始加载rgb24数据到v4，v5，v6矢量寄存器中 vsseg3e8.v v4, (a1) 加载和存储全部矢量数据 c //从rs地址处开始将n个矢量寄存器大小的数据加载进vd到vd+n-1的寄存器中 vlr.v vd, (rs) //存储指令 vsr.v vs, (rs1) 矢量掩码指令 逻辑操作指令我们可以让两个矢量之间进行逻辑运算 c vmand.mm vd, vs2, vs1 vmxor.mm vd, vs2, vs1 vmor.mm vd, vs2, vs1 与位操作指令不同的是，掩码制控制数据元素的激活与否，而位操作指令是修改元素的值 此外，rvv的指令集还支持如下伪指令 c //将vs中数据全部复制到vd vmmv.m vd, vs //将vd中数据全部清0 vmclr.m vd //将vd中数据全部置","date":"2025-01-01","objectID":"/posts/risc-v/:8:14","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#矢量掩码指令"},{"categories":["Tech"],"content":" 可伸缩矢量计算与优化SISD(single instruction single data，单指令单数据)，同一时刻只能处理一条数据，大多数rv指令是sisd的 当处理小数据时，需要将一个8位数据对应的加载到一个单独的64位寄存器中，不能有效利用cpu资源 simd对多个数据元素同时执行相同的操作，这些数据元素被打包在更大的寄存器中的独立通道(也被称为元素)，假设矢量寄存器的长度是128位，那么add指令会把4个32位数据元素加在一起，这些值被打包到两对128寄存器(v1，v2)中的通道中，然后让第一个源寄存器的每个通道与第二个源寄存器的对应通道相加，结果存在v0对应通道中 simd非常适合图像处理场景。图像常用rgb565，rgba8888，yuv422等格式的数据，这些格式的特点是一个像素的一个分量用3或4个8位数据表示，处理的时候是能够并行处理 SIMD的历史1999年，Intel推出SSE(streaming SIMD extension， 流式SIMD扩展)指令集，解决浮点数运算问题并把矢量寄存器的宽度升级到128位 2008年，Intel发布AVX(advanced vector extension， 高级矢量扩展)，兼容sse的同时把矢量寄存器的长度从128位提升至256位 2013年，Intel发布AVX512，矢量寄存器长度进一步提高至512位 arm阵营中，armv7a推出NEON指令集，矢量寄存器128位，在v8下为256位 由于上述指令集都属于定长度指令集，64位矢量寄存器无法运行128位的程序，因此arm在armv8.2中引入了可伸缩矢量扩展(SVE，scalable vector extension)指令集，其编程模型被称为可变矢量长度(VLA)模型 rv架构中，rvv也支持可伸缩矢量计算，且支持的矢量长度最大达65536位 矢量运算指令提供3个版本：矢量，标量，立即数 矢量版本：把矢量寄存器1的所有通道与矢量寄存器2的所有通道进行计算 标量版本：通用寄存器的数据与矢量寄存器进行计算 立即数版本：矢量寄存器与矢量寄存器生成的立即数进行计算 rvv寄存器组rvv为矢量计算提供了一个全新的寄存器组，包括 32个矢量寄存器(v0~v31) 7个非特权级寄存器：vtype，vl，vlenb，vstart，vxvm，vxsat，vcsr 参与运算的矢量长度：必须是$2^n$，最大长度为$2^{16}$(65536位) 元素长度：必须是$2^n$，最小长度为8位 mstatus寄存器：内部的vs字段(Bit[10:9])不仅描述矢量上下文状态，还会映射到sstatus寄存器的Bit[10:9]。当vs字段处于初始状态也就是0时，使用rvv指令或访问非特权寄存器都会改变状态触发指令异常 vtype寄存器：用来描述矢量寄存器中数据类型，决定了数据组织方式和如何对多个矢量寄存器进行分组。vlmul字段决定了多少个矢量寄存器可以组成一个矢量寄存器组，这样一条指令就可以同时操作这个寄存器组了，vlmul不仅可以被设置为整数也可以设置为分数，所以支持高位宽rvv指令集对低位宽指令集的兼容 vlmul(lmul的) 取值 表达式 寄存器组大小 使用的 v 寄存器 含义 000 m1 1 个 v0 标准长度 001 m2 2 个 v0, v1 两倍长度 010 m4 4 个 v0–v3 四倍长度 011 m8 8 个 v0–v7 八倍长度 111 mf2 1/2 个 v0 (部分使用) 半长 110 mf4 1/4 个 v0 (部分使用) 1/4 长 101 mf8 1/8 个 v0 (部分使用) 1/8 长 示例代码： c vsetvli t0, a2, e32, m4 # 设置 vtype，使用4个寄存器组成一个逻辑向量组 vadd.vv v0, v4, v8 # 对应的加法 整个指令的行为是 c [v0,v1,v2,v3] = [v4,v5,v6,v7] + [v8,v9,v10,v11] vl寄存器：用来记录在矢量指令中处理元素的数量 vlenb寄存器：指定一个矢量寄存器内有多少字节，该值在硬件设计时就确定了，因此该寄存器是只读的 vstart寄存器：用来指示第一个参与运算数据元素的索引，通常为0，不为0时执行某些运算会触发指令异常 VLA模型VLA(Vector Length Agnostic，可变向量长度编程模型) vla的实现依靠软硬件共同完成，硬件方面由底层提供配置寄存器，vtype以及vl，前者配置要处理数据类型的位宽，后者配置每次处理数据元素的个数 一般使用vsetvli指令设置： c //初始化vl和vtype寄存器，其中有效元素位宽为8(eew=8)，有效组乘系数=1(emul=1，使用一个寄存器组成一个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为16 //并把vl的值存在t0寄存器中，a2表示要处理的字节数 vsetvli t0, a2, e8, m1 //初始化vl和vtype寄存器，其中有效元素位宽为16(eew=16)，有效组乘系数=1/2(emul=1/2，使用一个寄存器组成两个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为8 vsetvli t0, a2, e16, mf2 一般情况下，矢量寄存器的长度组乘系数与有效组乘系数是相等的(lmul=emul)，并且sew=eew。但在处理不同位宽的数据（如 8 位与 16 位数据相加）时，EMUL 会大于 LMUL。例如，在将 8 位数据与 16 位数据进行矢量加法操作时，为了保证结果宽度足够，可能需要设置 EMUL = 2 × LMUL，以容纳更宽的运算结果 加载和存储指令 单位步长模式 c //从rs1指向的地址加载8位宽的数据元素，vm为掩码操作数 vle8.v vd (rs1) vm //向rs1指向的地址存储16位宽的数据元素，vm为掩码操作数 vse16.v vd (rs1) vm 掩码操作数：rvv提供可以控制每一个数据的方法，若vm为v0.t，则表述用v0矢量寄存器作为掩码，每位表示一个数据元素的状态，若v0[i]==1，表示第i个元素被激活，被激活的元素参与计算，未被激活的则不参与。若未激活的元素的计算策略除了保持不变外还有可能令其为1，这就被称为未知策略，保持不变的策略被称为不打扰策略。这两种策略可以通过配置vtype寄存器的vta，vma字段实现。当掩码操作数在汇编代码中为空时代表激活所有的元素 .v 被称为修饰符，该符号决定了要操作的寄存器的元素的类型，例子如下： .vv：矢量数据元素与矢量数据元素 .vx：矢量数据元素与整型标量数据元素 .vf：矢量数据元素与浮点标量数据元素 .vi：矢量数据元素与立即数数据元素 .m：掩码元素 任意步长格式加载指令 c //任意步长模式会从内存中以rs1为起始地址，每隔r2为步长，依次将下一个元素加载到vd中，r2的值可以为负数或0 vlse8.v vd (vs1), rs2, vm 存储指令 c vsse8.v vs (vs1), rs2, vm 聚合加载与离散存储聚合加载与离散存储均支持以下两种模式 有序索引：在访问内存时按照索引的顺序有序的访问 无序索引：访问内存时不保证访问的顺序 有序索引的聚合加载指令 c //加载8位宽度数据 vloxei8.v vd, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从内存有序的加载元素到vd中 有序索引的离散存储指令 c vsoxei8.v vs, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从vs2有序的存储元素到内存中 无序索引的聚合加载指令 c vluxei8.v vd, (rs1), vs2, vm 无序索引的离散存储指令 c vsuxei8.v vs, (rs1), vs2, vm 打包数据的加载与存储现实中有一些数据是以一定格式打包的，如rgb24，正常情况下需要将rgb24加载到矢量寄存器中，之后将其解包为r，g，b三个不同的寄存器组，但这个过程很麻烦。为此rvv推出此指令，打包数据的加载存储指令也有单位步长，任意步长，聚合加载与离散存储三种模式 单位步长的打包数据加载存储指令如下： c vlsege.v vd, (rs1), vm vssege.v vs, (rs1), vm 其中，nf是构成打包数据的元素个数，eew是每个元素的位宽，cpu会影响vdvd+nf-1/vsvs+nf-1个向量寄存器 对于rgb24： c //从a1地址开始加载rgb24数据到v4，v5，v6矢量寄存器中 vsseg3e8.v v4, (a1) 加载和存储全部矢量数据 c //从rs地址处开始将n个矢量寄存器大小的数据加载进vd到vd+n-1的寄存器中 vlr.v vd, (rs) //存储指令 vsr.v vs, (rs1) 矢量掩码指令 逻辑操作指令我们可以让两个矢量之间进行逻辑运算 c vmand.mm vd, vs2, vs1 vmxor.mm vd, vs2, vs1 vmor.mm vd, vs2, vs1 与位操作指令不同的是，掩码制控制数据元素的激活与否，而位操作指令是修改元素的值 此外，rvv的指令集还支持如下伪指令 c //将vs中数据全部复制到vd vmmv.m vd, vs //将vd中数据全部清0 vmclr.m vd //将vd中数据全部置","date":"2025-01-01","objectID":"/posts/risc-v/:8:14","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#逻辑操作指令"},{"categories":["Tech"],"content":" 可伸缩矢量计算与优化SISD(single instruction single data，单指令单数据)，同一时刻只能处理一条数据，大多数rv指令是sisd的 当处理小数据时，需要将一个8位数据对应的加载到一个单独的64位寄存器中，不能有效利用cpu资源 simd对多个数据元素同时执行相同的操作，这些数据元素被打包在更大的寄存器中的独立通道(也被称为元素)，假设矢量寄存器的长度是128位，那么add指令会把4个32位数据元素加在一起，这些值被打包到两对128寄存器(v1，v2)中的通道中，然后让第一个源寄存器的每个通道与第二个源寄存器的对应通道相加，结果存在v0对应通道中 simd非常适合图像处理场景。图像常用rgb565，rgba8888，yuv422等格式的数据，这些格式的特点是一个像素的一个分量用3或4个8位数据表示，处理的时候是能够并行处理 SIMD的历史1999年，Intel推出SSE(streaming SIMD extension， 流式SIMD扩展)指令集，解决浮点数运算问题并把矢量寄存器的宽度升级到128位 2008年，Intel发布AVX(advanced vector extension， 高级矢量扩展)，兼容sse的同时把矢量寄存器的长度从128位提升至256位 2013年，Intel发布AVX512，矢量寄存器长度进一步提高至512位 arm阵营中，armv7a推出NEON指令集，矢量寄存器128位，在v8下为256位 由于上述指令集都属于定长度指令集，64位矢量寄存器无法运行128位的程序，因此arm在armv8.2中引入了可伸缩矢量扩展(SVE，scalable vector extension)指令集，其编程模型被称为可变矢量长度(VLA)模型 rv架构中，rvv也支持可伸缩矢量计算，且支持的矢量长度最大达65536位 矢量运算指令提供3个版本：矢量，标量，立即数 矢量版本：把矢量寄存器1的所有通道与矢量寄存器2的所有通道进行计算 标量版本：通用寄存器的数据与矢量寄存器进行计算 立即数版本：矢量寄存器与矢量寄存器生成的立即数进行计算 rvv寄存器组rvv为矢量计算提供了一个全新的寄存器组，包括 32个矢量寄存器(v0~v31) 7个非特权级寄存器：vtype，vl，vlenb，vstart，vxvm，vxsat，vcsr 参与运算的矢量长度：必须是$2^n$，最大长度为$2^{16}$(65536位) 元素长度：必须是$2^n$，最小长度为8位 mstatus寄存器：内部的vs字段(Bit[10:9])不仅描述矢量上下文状态，还会映射到sstatus寄存器的Bit[10:9]。当vs字段处于初始状态也就是0时，使用rvv指令或访问非特权寄存器都会改变状态触发指令异常 vtype寄存器：用来描述矢量寄存器中数据类型，决定了数据组织方式和如何对多个矢量寄存器进行分组。vlmul字段决定了多少个矢量寄存器可以组成一个矢量寄存器组，这样一条指令就可以同时操作这个寄存器组了，vlmul不仅可以被设置为整数也可以设置为分数，所以支持高位宽rvv指令集对低位宽指令集的兼容 vlmul(lmul的) 取值 表达式 寄存器组大小 使用的 v 寄存器 含义 000 m1 1 个 v0 标准长度 001 m2 2 个 v0, v1 两倍长度 010 m4 4 个 v0–v3 四倍长度 011 m8 8 个 v0–v7 八倍长度 111 mf2 1/2 个 v0 (部分使用) 半长 110 mf4 1/4 个 v0 (部分使用) 1/4 长 101 mf8 1/8 个 v0 (部分使用) 1/8 长 示例代码： c vsetvli t0, a2, e32, m4 # 设置 vtype，使用4个寄存器组成一个逻辑向量组 vadd.vv v0, v4, v8 # 对应的加法 整个指令的行为是 c [v0,v1,v2,v3] = [v4,v5,v6,v7] + [v8,v9,v10,v11] vl寄存器：用来记录在矢量指令中处理元素的数量 vlenb寄存器：指定一个矢量寄存器内有多少字节，该值在硬件设计时就确定了，因此该寄存器是只读的 vstart寄存器：用来指示第一个参与运算数据元素的索引，通常为0，不为0时执行某些运算会触发指令异常 VLA模型VLA(Vector Length Agnostic，可变向量长度编程模型) vla的实现依靠软硬件共同完成，硬件方面由底层提供配置寄存器，vtype以及vl，前者配置要处理数据类型的位宽，后者配置每次处理数据元素的个数 一般使用vsetvli指令设置： c //初始化vl和vtype寄存器，其中有效元素位宽为8(eew=8)，有效组乘系数=1(emul=1，使用一个寄存器组成一个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为16 //并把vl的值存在t0寄存器中，a2表示要处理的字节数 vsetvli t0, a2, e8, m1 //初始化vl和vtype寄存器，其中有效元素位宽为16(eew=16)，有效组乘系数=1/2(emul=1/2，使用一个寄存器组成两个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为8 vsetvli t0, a2, e16, mf2 一般情况下，矢量寄存器的长度组乘系数与有效组乘系数是相等的(lmul=emul)，并且sew=eew。但在处理不同位宽的数据（如 8 位与 16 位数据相加）时，EMUL 会大于 LMUL。例如，在将 8 位数据与 16 位数据进行矢量加法操作时，为了保证结果宽度足够，可能需要设置 EMUL = 2 × LMUL，以容纳更宽的运算结果 加载和存储指令 单位步长模式 c //从rs1指向的地址加载8位宽的数据元素，vm为掩码操作数 vle8.v vd (rs1) vm //向rs1指向的地址存储16位宽的数据元素，vm为掩码操作数 vse16.v vd (rs1) vm 掩码操作数：rvv提供可以控制每一个数据的方法，若vm为v0.t，则表述用v0矢量寄存器作为掩码，每位表示一个数据元素的状态，若v0[i]==1，表示第i个元素被激活，被激活的元素参与计算，未被激活的则不参与。若未激活的元素的计算策略除了保持不变外还有可能令其为1，这就被称为未知策略，保持不变的策略被称为不打扰策略。这两种策略可以通过配置vtype寄存器的vta，vma字段实现。当掩码操作数在汇编代码中为空时代表激活所有的元素 .v 被称为修饰符，该符号决定了要操作的寄存器的元素的类型，例子如下： .vv：矢量数据元素与矢量数据元素 .vx：矢量数据元素与整型标量数据元素 .vf：矢量数据元素与浮点标量数据元素 .vi：矢量数据元素与立即数数据元素 .m：掩码元素 任意步长格式加载指令 c //任意步长模式会从内存中以rs1为起始地址，每隔r2为步长，依次将下一个元素加载到vd中，r2的值可以为负数或0 vlse8.v vd (vs1), rs2, vm 存储指令 c vsse8.v vs (vs1), rs2, vm 聚合加载与离散存储聚合加载与离散存储均支持以下两种模式 有序索引：在访问内存时按照索引的顺序有序的访问 无序索引：访问内存时不保证访问的顺序 有序索引的聚合加载指令 c //加载8位宽度数据 vloxei8.v vd, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从内存有序的加载元素到vd中 有序索引的离散存储指令 c vsoxei8.v vs, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从vs2有序的存储元素到内存中 无序索引的聚合加载指令 c vluxei8.v vd, (rs1), vs2, vm 无序索引的离散存储指令 c vsuxei8.v vs, (rs1), vs2, vm 打包数据的加载与存储现实中有一些数据是以一定格式打包的，如rgb24，正常情况下需要将rgb24加载到矢量寄存器中，之后将其解包为r，g，b三个不同的寄存器组，但这个过程很麻烦。为此rvv推出此指令，打包数据的加载存储指令也有单位步长，任意步长，聚合加载与离散存储三种模式 单位步长的打包数据加载存储指令如下： c vlsege.v vd, (rs1), vm vssege.v vs, (rs1), vm 其中，nf是构成打包数据的元素个数，eew是每个元素的位宽，cpu会影响vdvd+nf-1/vsvs+nf-1个向量寄存器 对于rgb24： c //从a1地址开始加载rgb24数据到v4，v5，v6矢量寄存器中 vsseg3e8.v v4, (a1) 加载和存储全部矢量数据 c //从rs地址处开始将n个矢量寄存器大小的数据加载进vd到vd+n-1的寄存器中 vlr.v vd, (rs) //存储指令 vsr.v vs, (rs1) 矢量掩码指令 逻辑操作指令我们可以让两个矢量之间进行逻辑运算 c vmand.mm vd, vs2, vs1 vmxor.mm vd, vs2, vs1 vmor.mm vd, vs2, vs1 与位操作指令不同的是，掩码制控制数据元素的激活与否，而位操作指令是修改元素的值 此外，rvv的指令集还支持如下伪指令 c //将vs中数据全部复制到vd vmmv.m vd, vs //将vd中数据全部清0 vmclr.m vd //将vd中数据全部置","date":"2025-01-01","objectID":"/posts/risc-v/:8:14","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#矢量整型算术指令"},{"categories":["Tech"],"content":" 可伸缩矢量计算与优化SISD(single instruction single data，单指令单数据)，同一时刻只能处理一条数据，大多数rv指令是sisd的 当处理小数据时，需要将一个8位数据对应的加载到一个单独的64位寄存器中，不能有效利用cpu资源 simd对多个数据元素同时执行相同的操作，这些数据元素被打包在更大的寄存器中的独立通道(也被称为元素)，假设矢量寄存器的长度是128位，那么add指令会把4个32位数据元素加在一起，这些值被打包到两对128寄存器(v1，v2)中的通道中，然后让第一个源寄存器的每个通道与第二个源寄存器的对应通道相加，结果存在v0对应通道中 simd非常适合图像处理场景。图像常用rgb565，rgba8888，yuv422等格式的数据，这些格式的特点是一个像素的一个分量用3或4个8位数据表示，处理的时候是能够并行处理 SIMD的历史1999年，Intel推出SSE(streaming SIMD extension， 流式SIMD扩展)指令集，解决浮点数运算问题并把矢量寄存器的宽度升级到128位 2008年，Intel发布AVX(advanced vector extension， 高级矢量扩展)，兼容sse的同时把矢量寄存器的长度从128位提升至256位 2013年，Intel发布AVX512，矢量寄存器长度进一步提高至512位 arm阵营中，armv7a推出NEON指令集，矢量寄存器128位，在v8下为256位 由于上述指令集都属于定长度指令集，64位矢量寄存器无法运行128位的程序，因此arm在armv8.2中引入了可伸缩矢量扩展(SVE，scalable vector extension)指令集，其编程模型被称为可变矢量长度(VLA)模型 rv架构中，rvv也支持可伸缩矢量计算，且支持的矢量长度最大达65536位 矢量运算指令提供3个版本：矢量，标量，立即数 矢量版本：把矢量寄存器1的所有通道与矢量寄存器2的所有通道进行计算 标量版本：通用寄存器的数据与矢量寄存器进行计算 立即数版本：矢量寄存器与矢量寄存器生成的立即数进行计算 rvv寄存器组rvv为矢量计算提供了一个全新的寄存器组，包括 32个矢量寄存器(v0~v31) 7个非特权级寄存器：vtype，vl，vlenb，vstart，vxvm，vxsat，vcsr 参与运算的矢量长度：必须是$2^n$，最大长度为$2^{16}$(65536位) 元素长度：必须是$2^n$，最小长度为8位 mstatus寄存器：内部的vs字段(Bit[10:9])不仅描述矢量上下文状态，还会映射到sstatus寄存器的Bit[10:9]。当vs字段处于初始状态也就是0时，使用rvv指令或访问非特权寄存器都会改变状态触发指令异常 vtype寄存器：用来描述矢量寄存器中数据类型，决定了数据组织方式和如何对多个矢量寄存器进行分组。vlmul字段决定了多少个矢量寄存器可以组成一个矢量寄存器组，这样一条指令就可以同时操作这个寄存器组了，vlmul不仅可以被设置为整数也可以设置为分数，所以支持高位宽rvv指令集对低位宽指令集的兼容 vlmul(lmul的) 取值 表达式 寄存器组大小 使用的 v 寄存器 含义 000 m1 1 个 v0 标准长度 001 m2 2 个 v0, v1 两倍长度 010 m4 4 个 v0–v3 四倍长度 011 m8 8 个 v0–v7 八倍长度 111 mf2 1/2 个 v0 (部分使用) 半长 110 mf4 1/4 个 v0 (部分使用) 1/4 长 101 mf8 1/8 个 v0 (部分使用) 1/8 长 示例代码： c vsetvli t0, a2, e32, m4 # 设置 vtype，使用4个寄存器组成一个逻辑向量组 vadd.vv v0, v4, v8 # 对应的加法 整个指令的行为是 c [v0,v1,v2,v3] = [v4,v5,v6,v7] + [v8,v9,v10,v11] vl寄存器：用来记录在矢量指令中处理元素的数量 vlenb寄存器：指定一个矢量寄存器内有多少字节，该值在硬件设计时就确定了，因此该寄存器是只读的 vstart寄存器：用来指示第一个参与运算数据元素的索引，通常为0，不为0时执行某些运算会触发指令异常 VLA模型VLA(Vector Length Agnostic，可变向量长度编程模型) vla的实现依靠软硬件共同完成，硬件方面由底层提供配置寄存器，vtype以及vl，前者配置要处理数据类型的位宽，后者配置每次处理数据元素的个数 一般使用vsetvli指令设置： c //初始化vl和vtype寄存器，其中有效元素位宽为8(eew=8)，有效组乘系数=1(emul=1，使用一个寄存器组成一个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为16 //并把vl的值存在t0寄存器中，a2表示要处理的字节数 vsetvli t0, a2, e8, m1 //初始化vl和vtype寄存器，其中有效元素位宽为16(eew=16)，有效组乘系数=1/2(emul=1/2，使用一个寄存器组成两个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为8 vsetvli t0, a2, e16, mf2 一般情况下，矢量寄存器的长度组乘系数与有效组乘系数是相等的(lmul=emul)，并且sew=eew。但在处理不同位宽的数据（如 8 位与 16 位数据相加）时，EMUL 会大于 LMUL。例如，在将 8 位数据与 16 位数据进行矢量加法操作时，为了保证结果宽度足够，可能需要设置 EMUL = 2 × LMUL，以容纳更宽的运算结果 加载和存储指令 单位步长模式 c //从rs1指向的地址加载8位宽的数据元素，vm为掩码操作数 vle8.v vd (rs1) vm //向rs1指向的地址存储16位宽的数据元素，vm为掩码操作数 vse16.v vd (rs1) vm 掩码操作数：rvv提供可以控制每一个数据的方法，若vm为v0.t，则表述用v0矢量寄存器作为掩码，每位表示一个数据元素的状态，若v0[i]==1，表示第i个元素被激活，被激活的元素参与计算，未被激活的则不参与。若未激活的元素的计算策略除了保持不变外还有可能令其为1，这就被称为未知策略，保持不变的策略被称为不打扰策略。这两种策略可以通过配置vtype寄存器的vta，vma字段实现。当掩码操作数在汇编代码中为空时代表激活所有的元素 .v 被称为修饰符，该符号决定了要操作的寄存器的元素的类型，例子如下： .vv：矢量数据元素与矢量数据元素 .vx：矢量数据元素与整型标量数据元素 .vf：矢量数据元素与浮点标量数据元素 .vi：矢量数据元素与立即数数据元素 .m：掩码元素 任意步长格式加载指令 c //任意步长模式会从内存中以rs1为起始地址，每隔r2为步长，依次将下一个元素加载到vd中，r2的值可以为负数或0 vlse8.v vd (vs1), rs2, vm 存储指令 c vsse8.v vs (vs1), rs2, vm 聚合加载与离散存储聚合加载与离散存储均支持以下两种模式 有序索引：在访问内存时按照索引的顺序有序的访问 无序索引：访问内存时不保证访问的顺序 有序索引的聚合加载指令 c //加载8位宽度数据 vloxei8.v vd, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从内存有序的加载元素到vd中 有序索引的离散存储指令 c vsoxei8.v vs, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从vs2有序的存储元素到内存中 无序索引的聚合加载指令 c vluxei8.v vd, (rs1), vs2, vm 无序索引的离散存储指令 c vsuxei8.v vs, (rs1), vs2, vm 打包数据的加载与存储现实中有一些数据是以一定格式打包的，如rgb24，正常情况下需要将rgb24加载到矢量寄存器中，之后将其解包为r，g，b三个不同的寄存器组，但这个过程很麻烦。为此rvv推出此指令，打包数据的加载存储指令也有单位步长，任意步长，聚合加载与离散存储三种模式 单位步长的打包数据加载存储指令如下： c vlsege.v vd, (rs1), vm vssege.v vs, (rs1), vm 其中，nf是构成打包数据的元素个数，eew是每个元素的位宽，cpu会影响vdvd+nf-1/vsvs+nf-1个向量寄存器 对于rgb24： c //从a1地址开始加载rgb24数据到v4，v5，v6矢量寄存器中 vsseg3e8.v v4, (a1) 加载和存储全部矢量数据 c //从rs地址处开始将n个矢量寄存器大小的数据加载进vd到vd+n-1的寄存器中 vlr.v vd, (rs) //存储指令 vsr.v vs, (rs1) 矢量掩码指令 逻辑操作指令我们可以让两个矢量之间进行逻辑运算 c vmand.mm vd, vs2, vs1 vmxor.mm vd, vs2, vs1 vmor.mm vd, vs2, vs1 与位操作指令不同的是，掩码制控制数据元素的激活与否，而位操作指令是修改元素的值 此外，rvv的指令集还支持如下伪指令 c //将vs中数据全部复制到vd vmmv.m vd, vs //将vd中数据全部清0 vmclr.m vd //将vd中数据全部置","date":"2025-01-01","objectID":"/posts/risc-v/:8:14","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#加宽和变窄算数指令"},{"categories":["Tech"],"content":" 可伸缩矢量计算与优化SISD(single instruction single data，单指令单数据)，同一时刻只能处理一条数据，大多数rv指令是sisd的 当处理小数据时，需要将一个8位数据对应的加载到一个单独的64位寄存器中，不能有效利用cpu资源 simd对多个数据元素同时执行相同的操作，这些数据元素被打包在更大的寄存器中的独立通道(也被称为元素)，假设矢量寄存器的长度是128位，那么add指令会把4个32位数据元素加在一起，这些值被打包到两对128寄存器(v1，v2)中的通道中，然后让第一个源寄存器的每个通道与第二个源寄存器的对应通道相加，结果存在v0对应通道中 simd非常适合图像处理场景。图像常用rgb565，rgba8888，yuv422等格式的数据，这些格式的特点是一个像素的一个分量用3或4个8位数据表示，处理的时候是能够并行处理 SIMD的历史1999年，Intel推出SSE(streaming SIMD extension， 流式SIMD扩展)指令集，解决浮点数运算问题并把矢量寄存器的宽度升级到128位 2008年，Intel发布AVX(advanced vector extension， 高级矢量扩展)，兼容sse的同时把矢量寄存器的长度从128位提升至256位 2013年，Intel发布AVX512，矢量寄存器长度进一步提高至512位 arm阵营中，armv7a推出NEON指令集，矢量寄存器128位，在v8下为256位 由于上述指令集都属于定长度指令集，64位矢量寄存器无法运行128位的程序，因此arm在armv8.2中引入了可伸缩矢量扩展(SVE，scalable vector extension)指令集，其编程模型被称为可变矢量长度(VLA)模型 rv架构中，rvv也支持可伸缩矢量计算，且支持的矢量长度最大达65536位 矢量运算指令提供3个版本：矢量，标量，立即数 矢量版本：把矢量寄存器1的所有通道与矢量寄存器2的所有通道进行计算 标量版本：通用寄存器的数据与矢量寄存器进行计算 立即数版本：矢量寄存器与矢量寄存器生成的立即数进行计算 rvv寄存器组rvv为矢量计算提供了一个全新的寄存器组，包括 32个矢量寄存器(v0~v31) 7个非特权级寄存器：vtype，vl，vlenb，vstart，vxvm，vxsat，vcsr 参与运算的矢量长度：必须是$2^n$，最大长度为$2^{16}$(65536位) 元素长度：必须是$2^n$，最小长度为8位 mstatus寄存器：内部的vs字段(Bit[10:9])不仅描述矢量上下文状态，还会映射到sstatus寄存器的Bit[10:9]。当vs字段处于初始状态也就是0时，使用rvv指令或访问非特权寄存器都会改变状态触发指令异常 vtype寄存器：用来描述矢量寄存器中数据类型，决定了数据组织方式和如何对多个矢量寄存器进行分组。vlmul字段决定了多少个矢量寄存器可以组成一个矢量寄存器组，这样一条指令就可以同时操作这个寄存器组了，vlmul不仅可以被设置为整数也可以设置为分数，所以支持高位宽rvv指令集对低位宽指令集的兼容 vlmul(lmul的) 取值 表达式 寄存器组大小 使用的 v 寄存器 含义 000 m1 1 个 v0 标准长度 001 m2 2 个 v0, v1 两倍长度 010 m4 4 个 v0–v3 四倍长度 011 m8 8 个 v0–v7 八倍长度 111 mf2 1/2 个 v0 (部分使用) 半长 110 mf4 1/4 个 v0 (部分使用) 1/4 长 101 mf8 1/8 个 v0 (部分使用) 1/8 长 示例代码： c vsetvli t0, a2, e32, m4 # 设置 vtype，使用4个寄存器组成一个逻辑向量组 vadd.vv v0, v4, v8 # 对应的加法 整个指令的行为是 c [v0,v1,v2,v3] = [v4,v5,v6,v7] + [v8,v9,v10,v11] vl寄存器：用来记录在矢量指令中处理元素的数量 vlenb寄存器：指定一个矢量寄存器内有多少字节，该值在硬件设计时就确定了，因此该寄存器是只读的 vstart寄存器：用来指示第一个参与运算数据元素的索引，通常为0，不为0时执行某些运算会触发指令异常 VLA模型VLA(Vector Length Agnostic，可变向量长度编程模型) vla的实现依靠软硬件共同完成，硬件方面由底层提供配置寄存器，vtype以及vl，前者配置要处理数据类型的位宽，后者配置每次处理数据元素的个数 一般使用vsetvli指令设置： c //初始化vl和vtype寄存器，其中有效元素位宽为8(eew=8)，有效组乘系数=1(emul=1，使用一个寄存器组成一个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为16 //并把vl的值存在t0寄存器中，a2表示要处理的字节数 vsetvli t0, a2, e8, m1 //初始化vl和vtype寄存器，其中有效元素位宽为16(eew=16)，有效组乘系数=1/2(emul=1/2，使用一个寄存器组成两个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为8 vsetvli t0, a2, e16, mf2 一般情况下，矢量寄存器的长度组乘系数与有效组乘系数是相等的(lmul=emul)，并且sew=eew。但在处理不同位宽的数据（如 8 位与 16 位数据相加）时，EMUL 会大于 LMUL。例如，在将 8 位数据与 16 位数据进行矢量加法操作时，为了保证结果宽度足够，可能需要设置 EMUL = 2 × LMUL，以容纳更宽的运算结果 加载和存储指令 单位步长模式 c //从rs1指向的地址加载8位宽的数据元素，vm为掩码操作数 vle8.v vd (rs1) vm //向rs1指向的地址存储16位宽的数据元素，vm为掩码操作数 vse16.v vd (rs1) vm 掩码操作数：rvv提供可以控制每一个数据的方法，若vm为v0.t，则表述用v0矢量寄存器作为掩码，每位表示一个数据元素的状态，若v0[i]==1，表示第i个元素被激活，被激活的元素参与计算，未被激活的则不参与。若未激活的元素的计算策略除了保持不变外还有可能令其为1，这就被称为未知策略，保持不变的策略被称为不打扰策略。这两种策略可以通过配置vtype寄存器的vta，vma字段实现。当掩码操作数在汇编代码中为空时代表激活所有的元素 .v 被称为修饰符，该符号决定了要操作的寄存器的元素的类型，例子如下： .vv：矢量数据元素与矢量数据元素 .vx：矢量数据元素与整型标量数据元素 .vf：矢量数据元素与浮点标量数据元素 .vi：矢量数据元素与立即数数据元素 .m：掩码元素 任意步长格式加载指令 c //任意步长模式会从内存中以rs1为起始地址，每隔r2为步长，依次将下一个元素加载到vd中，r2的值可以为负数或0 vlse8.v vd (vs1), rs2, vm 存储指令 c vsse8.v vs (vs1), rs2, vm 聚合加载与离散存储聚合加载与离散存储均支持以下两种模式 有序索引：在访问内存时按照索引的顺序有序的访问 无序索引：访问内存时不保证访问的顺序 有序索引的聚合加载指令 c //加载8位宽度数据 vloxei8.v vd, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从内存有序的加载元素到vd中 有序索引的离散存储指令 c vsoxei8.v vs, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从vs2有序的存储元素到内存中 无序索引的聚合加载指令 c vluxei8.v vd, (rs1), vs2, vm 无序索引的离散存储指令 c vsuxei8.v vs, (rs1), vs2, vm 打包数据的加载与存储现实中有一些数据是以一定格式打包的，如rgb24，正常情况下需要将rgb24加载到矢量寄存器中，之后将其解包为r，g，b三个不同的寄存器组，但这个过程很麻烦。为此rvv推出此指令，打包数据的加载存储指令也有单位步长，任意步长，聚合加载与离散存储三种模式 单位步长的打包数据加载存储指令如下： c vlsege.v vd, (rs1), vm vssege.v vs, (rs1), vm 其中，nf是构成打包数据的元素个数，eew是每个元素的位宽，cpu会影响vdvd+nf-1/vsvs+nf-1个向量寄存器 对于rgb24： c //从a1地址开始加载rgb24数据到v4，v5，v6矢量寄存器中 vsseg3e8.v v4, (a1) 加载和存储全部矢量数据 c //从rs地址处开始将n个矢量寄存器大小的数据加载进vd到vd+n-1的寄存器中 vlr.v vd, (rs) //存储指令 vsr.v vs, (rs1) 矢量掩码指令 逻辑操作指令我们可以让两个矢量之间进行逻辑运算 c vmand.mm vd, vs2, vs1 vmxor.mm vd, vs2, vs1 vmor.mm vd, vs2, vs1 与位操作指令不同的是，掩码制控制数据元素的激活与否，而位操作指令是修改元素的值 此外，rvv的指令集还支持如下伪指令 c //将vs中数据全部复制到vd vmmv.m vd, vs //将vd中数据全部清0 vmclr.m vd //将vd中数据全部置","date":"2025-01-01","objectID":"/posts/risc-v/:8:14","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#加减法指令"},{"categories":["Tech"],"content":" 可伸缩矢量计算与优化SISD(single instruction single data，单指令单数据)，同一时刻只能处理一条数据，大多数rv指令是sisd的 当处理小数据时，需要将一个8位数据对应的加载到一个单独的64位寄存器中，不能有效利用cpu资源 simd对多个数据元素同时执行相同的操作，这些数据元素被打包在更大的寄存器中的独立通道(也被称为元素)，假设矢量寄存器的长度是128位，那么add指令会把4个32位数据元素加在一起，这些值被打包到两对128寄存器(v1，v2)中的通道中，然后让第一个源寄存器的每个通道与第二个源寄存器的对应通道相加，结果存在v0对应通道中 simd非常适合图像处理场景。图像常用rgb565，rgba8888，yuv422等格式的数据，这些格式的特点是一个像素的一个分量用3或4个8位数据表示，处理的时候是能够并行处理 SIMD的历史1999年，Intel推出SSE(streaming SIMD extension， 流式SIMD扩展)指令集，解决浮点数运算问题并把矢量寄存器的宽度升级到128位 2008年，Intel发布AVX(advanced vector extension， 高级矢量扩展)，兼容sse的同时把矢量寄存器的长度从128位提升至256位 2013年，Intel发布AVX512，矢量寄存器长度进一步提高至512位 arm阵营中，armv7a推出NEON指令集，矢量寄存器128位，在v8下为256位 由于上述指令集都属于定长度指令集，64位矢量寄存器无法运行128位的程序，因此arm在armv8.2中引入了可伸缩矢量扩展(SVE，scalable vector extension)指令集，其编程模型被称为可变矢量长度(VLA)模型 rv架构中，rvv也支持可伸缩矢量计算，且支持的矢量长度最大达65536位 矢量运算指令提供3个版本：矢量，标量，立即数 矢量版本：把矢量寄存器1的所有通道与矢量寄存器2的所有通道进行计算 标量版本：通用寄存器的数据与矢量寄存器进行计算 立即数版本：矢量寄存器与矢量寄存器生成的立即数进行计算 rvv寄存器组rvv为矢量计算提供了一个全新的寄存器组，包括 32个矢量寄存器(v0~v31) 7个非特权级寄存器：vtype，vl，vlenb，vstart，vxvm，vxsat，vcsr 参与运算的矢量长度：必须是$2^n$，最大长度为$2^{16}$(65536位) 元素长度：必须是$2^n$，最小长度为8位 mstatus寄存器：内部的vs字段(Bit[10:9])不仅描述矢量上下文状态，还会映射到sstatus寄存器的Bit[10:9]。当vs字段处于初始状态也就是0时，使用rvv指令或访问非特权寄存器都会改变状态触发指令异常 vtype寄存器：用来描述矢量寄存器中数据类型，决定了数据组织方式和如何对多个矢量寄存器进行分组。vlmul字段决定了多少个矢量寄存器可以组成一个矢量寄存器组，这样一条指令就可以同时操作这个寄存器组了，vlmul不仅可以被设置为整数也可以设置为分数，所以支持高位宽rvv指令集对低位宽指令集的兼容 vlmul(lmul的) 取值 表达式 寄存器组大小 使用的 v 寄存器 含义 000 m1 1 个 v0 标准长度 001 m2 2 个 v0, v1 两倍长度 010 m4 4 个 v0–v3 四倍长度 011 m8 8 个 v0–v7 八倍长度 111 mf2 1/2 个 v0 (部分使用) 半长 110 mf4 1/4 个 v0 (部分使用) 1/4 长 101 mf8 1/8 个 v0 (部分使用) 1/8 长 示例代码： c vsetvli t0, a2, e32, m4 # 设置 vtype，使用4个寄存器组成一个逻辑向量组 vadd.vv v0, v4, v8 # 对应的加法 整个指令的行为是 c [v0,v1,v2,v3] = [v4,v5,v6,v7] + [v8,v9,v10,v11] vl寄存器：用来记录在矢量指令中处理元素的数量 vlenb寄存器：指定一个矢量寄存器内有多少字节，该值在硬件设计时就确定了，因此该寄存器是只读的 vstart寄存器：用来指示第一个参与运算数据元素的索引，通常为0，不为0时执行某些运算会触发指令异常 VLA模型VLA(Vector Length Agnostic，可变向量长度编程模型) vla的实现依靠软硬件共同完成，硬件方面由底层提供配置寄存器，vtype以及vl，前者配置要处理数据类型的位宽，后者配置每次处理数据元素的个数 一般使用vsetvli指令设置： c //初始化vl和vtype寄存器，其中有效元素位宽为8(eew=8)，有效组乘系数=1(emul=1，使用一个寄存器组成一个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为16 //并把vl的值存在t0寄存器中，a2表示要处理的字节数 vsetvli t0, a2, e8, m1 //初始化vl和vtype寄存器，其中有效元素位宽为16(eew=16)，有效组乘系数=1/2(emul=1/2，使用一个寄存器组成两个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为8 vsetvli t0, a2, e16, mf2 一般情况下，矢量寄存器的长度组乘系数与有效组乘系数是相等的(lmul=emul)，并且sew=eew。但在处理不同位宽的数据（如 8 位与 16 位数据相加）时，EMUL 会大于 LMUL。例如，在将 8 位数据与 16 位数据进行矢量加法操作时，为了保证结果宽度足够，可能需要设置 EMUL = 2 × LMUL，以容纳更宽的运算结果 加载和存储指令 单位步长模式 c //从rs1指向的地址加载8位宽的数据元素，vm为掩码操作数 vle8.v vd (rs1) vm //向rs1指向的地址存储16位宽的数据元素，vm为掩码操作数 vse16.v vd (rs1) vm 掩码操作数：rvv提供可以控制每一个数据的方法，若vm为v0.t，则表述用v0矢量寄存器作为掩码，每位表示一个数据元素的状态，若v0[i]==1，表示第i个元素被激活，被激活的元素参与计算，未被激活的则不参与。若未激活的元素的计算策略除了保持不变外还有可能令其为1，这就被称为未知策略，保持不变的策略被称为不打扰策略。这两种策略可以通过配置vtype寄存器的vta，vma字段实现。当掩码操作数在汇编代码中为空时代表激活所有的元素 .v 被称为修饰符，该符号决定了要操作的寄存器的元素的类型，例子如下： .vv：矢量数据元素与矢量数据元素 .vx：矢量数据元素与整型标量数据元素 .vf：矢量数据元素与浮点标量数据元素 .vi：矢量数据元素与立即数数据元素 .m：掩码元素 任意步长格式加载指令 c //任意步长模式会从内存中以rs1为起始地址，每隔r2为步长，依次将下一个元素加载到vd中，r2的值可以为负数或0 vlse8.v vd (vs1), rs2, vm 存储指令 c vsse8.v vs (vs1), rs2, vm 聚合加载与离散存储聚合加载与离散存储均支持以下两种模式 有序索引：在访问内存时按照索引的顺序有序的访问 无序索引：访问内存时不保证访问的顺序 有序索引的聚合加载指令 c //加载8位宽度数据 vloxei8.v vd, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从内存有序的加载元素到vd中 有序索引的离散存储指令 c vsoxei8.v vs, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从vs2有序的存储元素到内存中 无序索引的聚合加载指令 c vluxei8.v vd, (rs1), vs2, vm 无序索引的离散存储指令 c vsuxei8.v vs, (rs1), vs2, vm 打包数据的加载与存储现实中有一些数据是以一定格式打包的，如rgb24，正常情况下需要将rgb24加载到矢量寄存器中，之后将其解包为r，g，b三个不同的寄存器组，但这个过程很麻烦。为此rvv推出此指令，打包数据的加载存储指令也有单位步长，任意步长，聚合加载与离散存储三种模式 单位步长的打包数据加载存储指令如下： c vlsege.v vd, (rs1), vm vssege.v vs, (rs1), vm 其中，nf是构成打包数据的元素个数，eew是每个元素的位宽，cpu会影响vdvd+nf-1/vsvs+nf-1个向量寄存器 对于rgb24： c //从a1地址开始加载rgb24数据到v4，v5，v6矢量寄存器中 vsseg3e8.v v4, (a1) 加载和存储全部矢量数据 c //从rs地址处开始将n个矢量寄存器大小的数据加载进vd到vd+n-1的寄存器中 vlr.v vd, (rs) //存储指令 vsr.v vs, (rs1) 矢量掩码指令 逻辑操作指令我们可以让两个矢量之间进行逻辑运算 c vmand.mm vd, vs2, vs1 vmxor.mm vd, vs2, vs1 vmor.mm vd, vs2, vs1 与位操作指令不同的是，掩码制控制数据元素的激活与否，而位操作指令是修改元素的值 此外，rvv的指令集还支持如下伪指令 c //将vs中数据全部复制到vd vmmv.m vd, vs //将vd中数据全部清0 vmclr.m vd //将vd中数据全部置","date":"2025-01-01","objectID":"/posts/risc-v/:8:14","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#加宽模式的加减法指令"},{"categories":["Tech"],"content":" 可伸缩矢量计算与优化SISD(single instruction single data，单指令单数据)，同一时刻只能处理一条数据，大多数rv指令是sisd的 当处理小数据时，需要将一个8位数据对应的加载到一个单独的64位寄存器中，不能有效利用cpu资源 simd对多个数据元素同时执行相同的操作，这些数据元素被打包在更大的寄存器中的独立通道(也被称为元素)，假设矢量寄存器的长度是128位，那么add指令会把4个32位数据元素加在一起，这些值被打包到两对128寄存器(v1，v2)中的通道中，然后让第一个源寄存器的每个通道与第二个源寄存器的对应通道相加，结果存在v0对应通道中 simd非常适合图像处理场景。图像常用rgb565，rgba8888，yuv422等格式的数据，这些格式的特点是一个像素的一个分量用3或4个8位数据表示，处理的时候是能够并行处理 SIMD的历史1999年，Intel推出SSE(streaming SIMD extension， 流式SIMD扩展)指令集，解决浮点数运算问题并把矢量寄存器的宽度升级到128位 2008年，Intel发布AVX(advanced vector extension， 高级矢量扩展)，兼容sse的同时把矢量寄存器的长度从128位提升至256位 2013年，Intel发布AVX512，矢量寄存器长度进一步提高至512位 arm阵营中，armv7a推出NEON指令集，矢量寄存器128位，在v8下为256位 由于上述指令集都属于定长度指令集，64位矢量寄存器无法运行128位的程序，因此arm在armv8.2中引入了可伸缩矢量扩展(SVE，scalable vector extension)指令集，其编程模型被称为可变矢量长度(VLA)模型 rv架构中，rvv也支持可伸缩矢量计算，且支持的矢量长度最大达65536位 矢量运算指令提供3个版本：矢量，标量，立即数 矢量版本：把矢量寄存器1的所有通道与矢量寄存器2的所有通道进行计算 标量版本：通用寄存器的数据与矢量寄存器进行计算 立即数版本：矢量寄存器与矢量寄存器生成的立即数进行计算 rvv寄存器组rvv为矢量计算提供了一个全新的寄存器组，包括 32个矢量寄存器(v0~v31) 7个非特权级寄存器：vtype，vl，vlenb，vstart，vxvm，vxsat，vcsr 参与运算的矢量长度：必须是$2^n$，最大长度为$2^{16}$(65536位) 元素长度：必须是$2^n$，最小长度为8位 mstatus寄存器：内部的vs字段(Bit[10:9])不仅描述矢量上下文状态，还会映射到sstatus寄存器的Bit[10:9]。当vs字段处于初始状态也就是0时，使用rvv指令或访问非特权寄存器都会改变状态触发指令异常 vtype寄存器：用来描述矢量寄存器中数据类型，决定了数据组织方式和如何对多个矢量寄存器进行分组。vlmul字段决定了多少个矢量寄存器可以组成一个矢量寄存器组，这样一条指令就可以同时操作这个寄存器组了，vlmul不仅可以被设置为整数也可以设置为分数，所以支持高位宽rvv指令集对低位宽指令集的兼容 vlmul(lmul的) 取值 表达式 寄存器组大小 使用的 v 寄存器 含义 000 m1 1 个 v0 标准长度 001 m2 2 个 v0, v1 两倍长度 010 m4 4 个 v0–v3 四倍长度 011 m8 8 个 v0–v7 八倍长度 111 mf2 1/2 个 v0 (部分使用) 半长 110 mf4 1/4 个 v0 (部分使用) 1/4 长 101 mf8 1/8 个 v0 (部分使用) 1/8 长 示例代码： c vsetvli t0, a2, e32, m4 # 设置 vtype，使用4个寄存器组成一个逻辑向量组 vadd.vv v0, v4, v8 # 对应的加法 整个指令的行为是 c [v0,v1,v2,v3] = [v4,v5,v6,v7] + [v8,v9,v10,v11] vl寄存器：用来记录在矢量指令中处理元素的数量 vlenb寄存器：指定一个矢量寄存器内有多少字节，该值在硬件设计时就确定了，因此该寄存器是只读的 vstart寄存器：用来指示第一个参与运算数据元素的索引，通常为0，不为0时执行某些运算会触发指令异常 VLA模型VLA(Vector Length Agnostic，可变向量长度编程模型) vla的实现依靠软硬件共同完成，硬件方面由底层提供配置寄存器，vtype以及vl，前者配置要处理数据类型的位宽，后者配置每次处理数据元素的个数 一般使用vsetvli指令设置： c //初始化vl和vtype寄存器，其中有效元素位宽为8(eew=8)，有效组乘系数=1(emul=1，使用一个寄存器组成一个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为16 //并把vl的值存在t0寄存器中，a2表示要处理的字节数 vsetvli t0, a2, e8, m1 //初始化vl和vtype寄存器，其中有效元素位宽为16(eew=16)，有效组乘系数=1/2(emul=1/2，使用一个寄存器组成两个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为8 vsetvli t0, a2, e16, mf2 一般情况下，矢量寄存器的长度组乘系数与有效组乘系数是相等的(lmul=emul)，并且sew=eew。但在处理不同位宽的数据（如 8 位与 16 位数据相加）时，EMUL 会大于 LMUL。例如，在将 8 位数据与 16 位数据进行矢量加法操作时，为了保证结果宽度足够，可能需要设置 EMUL = 2 × LMUL，以容纳更宽的运算结果 加载和存储指令 单位步长模式 c //从rs1指向的地址加载8位宽的数据元素，vm为掩码操作数 vle8.v vd (rs1) vm //向rs1指向的地址存储16位宽的数据元素，vm为掩码操作数 vse16.v vd (rs1) vm 掩码操作数：rvv提供可以控制每一个数据的方法，若vm为v0.t，则表述用v0矢量寄存器作为掩码，每位表示一个数据元素的状态，若v0[i]==1，表示第i个元素被激活，被激活的元素参与计算，未被激活的则不参与。若未激活的元素的计算策略除了保持不变外还有可能令其为1，这就被称为未知策略，保持不变的策略被称为不打扰策略。这两种策略可以通过配置vtype寄存器的vta，vma字段实现。当掩码操作数在汇编代码中为空时代表激活所有的元素 .v 被称为修饰符，该符号决定了要操作的寄存器的元素的类型，例子如下： .vv：矢量数据元素与矢量数据元素 .vx：矢量数据元素与整型标量数据元素 .vf：矢量数据元素与浮点标量数据元素 .vi：矢量数据元素与立即数数据元素 .m：掩码元素 任意步长格式加载指令 c //任意步长模式会从内存中以rs1为起始地址，每隔r2为步长，依次将下一个元素加载到vd中，r2的值可以为负数或0 vlse8.v vd (vs1), rs2, vm 存储指令 c vsse8.v vs (vs1), rs2, vm 聚合加载与离散存储聚合加载与离散存储均支持以下两种模式 有序索引：在访问内存时按照索引的顺序有序的访问 无序索引：访问内存时不保证访问的顺序 有序索引的聚合加载指令 c //加载8位宽度数据 vloxei8.v vd, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从内存有序的加载元素到vd中 有序索引的离散存储指令 c vsoxei8.v vs, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从vs2有序的存储元素到内存中 无序索引的聚合加载指令 c vluxei8.v vd, (rs1), vs2, vm 无序索引的离散存储指令 c vsuxei8.v vs, (rs1), vs2, vm 打包数据的加载与存储现实中有一些数据是以一定格式打包的，如rgb24，正常情况下需要将rgb24加载到矢量寄存器中，之后将其解包为r，g，b三个不同的寄存器组，但这个过程很麻烦。为此rvv推出此指令，打包数据的加载存储指令也有单位步长，任意步长，聚合加载与离散存储三种模式 单位步长的打包数据加载存储指令如下： c vlsege.v vd, (rs1), vm vssege.v vs, (rs1), vm 其中，nf是构成打包数据的元素个数，eew是每个元素的位宽，cpu会影响vdvd+nf-1/vsvs+nf-1个向量寄存器 对于rgb24： c //从a1地址开始加载rgb24数据到v4，v5，v6矢量寄存器中 vsseg3e8.v v4, (a1) 加载和存储全部矢量数据 c //从rs地址处开始将n个矢量寄存器大小的数据加载进vd到vd+n-1的寄存器中 vlr.v vd, (rs) //存储指令 vsr.v vs, (rs1) 矢量掩码指令 逻辑操作指令我们可以让两个矢量之间进行逻辑运算 c vmand.mm vd, vs2, vs1 vmxor.mm vd, vs2, vs1 vmor.mm vd, vs2, vs1 与位操作指令不同的是，掩码制控制数据元素的激活与否，而位操作指令是修改元素的值 此外，rvv的指令集还支持如下伪指令 c //将vs中数据全部复制到vd vmmv.m vd, vs //将vd中数据全部清0 vmclr.m vd //将vd中数据全部置","date":"2025-01-01","objectID":"/posts/risc-v/:8:14","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#位操作指令"},{"categories":["Tech"],"content":" 可伸缩矢量计算与优化SISD(single instruction single data，单指令单数据)，同一时刻只能处理一条数据，大多数rv指令是sisd的 当处理小数据时，需要将一个8位数据对应的加载到一个单独的64位寄存器中，不能有效利用cpu资源 simd对多个数据元素同时执行相同的操作，这些数据元素被打包在更大的寄存器中的独立通道(也被称为元素)，假设矢量寄存器的长度是128位，那么add指令会把4个32位数据元素加在一起，这些值被打包到两对128寄存器(v1，v2)中的通道中，然后让第一个源寄存器的每个通道与第二个源寄存器的对应通道相加，结果存在v0对应通道中 simd非常适合图像处理场景。图像常用rgb565，rgba8888，yuv422等格式的数据，这些格式的特点是一个像素的一个分量用3或4个8位数据表示，处理的时候是能够并行处理 SIMD的历史1999年，Intel推出SSE(streaming SIMD extension， 流式SIMD扩展)指令集，解决浮点数运算问题并把矢量寄存器的宽度升级到128位 2008年，Intel发布AVX(advanced vector extension， 高级矢量扩展)，兼容sse的同时把矢量寄存器的长度从128位提升至256位 2013年，Intel发布AVX512，矢量寄存器长度进一步提高至512位 arm阵营中，armv7a推出NEON指令集，矢量寄存器128位，在v8下为256位 由于上述指令集都属于定长度指令集，64位矢量寄存器无法运行128位的程序，因此arm在armv8.2中引入了可伸缩矢量扩展(SVE，scalable vector extension)指令集，其编程模型被称为可变矢量长度(VLA)模型 rv架构中，rvv也支持可伸缩矢量计算，且支持的矢量长度最大达65536位 矢量运算指令提供3个版本：矢量，标量，立即数 矢量版本：把矢量寄存器1的所有通道与矢量寄存器2的所有通道进行计算 标量版本：通用寄存器的数据与矢量寄存器进行计算 立即数版本：矢量寄存器与矢量寄存器生成的立即数进行计算 rvv寄存器组rvv为矢量计算提供了一个全新的寄存器组，包括 32个矢量寄存器(v0~v31) 7个非特权级寄存器：vtype，vl，vlenb，vstart，vxvm，vxsat，vcsr 参与运算的矢量长度：必须是$2^n$，最大长度为$2^{16}$(65536位) 元素长度：必须是$2^n$，最小长度为8位 mstatus寄存器：内部的vs字段(Bit[10:9])不仅描述矢量上下文状态，还会映射到sstatus寄存器的Bit[10:9]。当vs字段处于初始状态也就是0时，使用rvv指令或访问非特权寄存器都会改变状态触发指令异常 vtype寄存器：用来描述矢量寄存器中数据类型，决定了数据组织方式和如何对多个矢量寄存器进行分组。vlmul字段决定了多少个矢量寄存器可以组成一个矢量寄存器组，这样一条指令就可以同时操作这个寄存器组了，vlmul不仅可以被设置为整数也可以设置为分数，所以支持高位宽rvv指令集对低位宽指令集的兼容 vlmul(lmul的) 取值 表达式 寄存器组大小 使用的 v 寄存器 含义 000 m1 1 个 v0 标准长度 001 m2 2 个 v0, v1 两倍长度 010 m4 4 个 v0–v3 四倍长度 011 m8 8 个 v0–v7 八倍长度 111 mf2 1/2 个 v0 (部分使用) 半长 110 mf4 1/4 个 v0 (部分使用) 1/4 长 101 mf8 1/8 个 v0 (部分使用) 1/8 长 示例代码： c vsetvli t0, a2, e32, m4 # 设置 vtype，使用4个寄存器组成一个逻辑向量组 vadd.vv v0, v4, v8 # 对应的加法 整个指令的行为是 c [v0,v1,v2,v3] = [v4,v5,v6,v7] + [v8,v9,v10,v11] vl寄存器：用来记录在矢量指令中处理元素的数量 vlenb寄存器：指定一个矢量寄存器内有多少字节，该值在硬件设计时就确定了，因此该寄存器是只读的 vstart寄存器：用来指示第一个参与运算数据元素的索引，通常为0，不为0时执行某些运算会触发指令异常 VLA模型VLA(Vector Length Agnostic，可变向量长度编程模型) vla的实现依靠软硬件共同完成，硬件方面由底层提供配置寄存器，vtype以及vl，前者配置要处理数据类型的位宽，后者配置每次处理数据元素的个数 一般使用vsetvli指令设置： c //初始化vl和vtype寄存器，其中有效元素位宽为8(eew=8)，有效组乘系数=1(emul=1，使用一个寄存器组成一个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为16 //并把vl的值存在t0寄存器中，a2表示要处理的字节数 vsetvli t0, a2, e8, m1 //初始化vl和vtype寄存器，其中有效元素位宽为16(eew=16)，有效组乘系数=1/2(emul=1/2，使用一个寄存器组成两个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为8 vsetvli t0, a2, e16, mf2 一般情况下，矢量寄存器的长度组乘系数与有效组乘系数是相等的(lmul=emul)，并且sew=eew。但在处理不同位宽的数据（如 8 位与 16 位数据相加）时，EMUL 会大于 LMUL。例如，在将 8 位数据与 16 位数据进行矢量加法操作时，为了保证结果宽度足够，可能需要设置 EMUL = 2 × LMUL，以容纳更宽的运算结果 加载和存储指令 单位步长模式 c //从rs1指向的地址加载8位宽的数据元素，vm为掩码操作数 vle8.v vd (rs1) vm //向rs1指向的地址存储16位宽的数据元素，vm为掩码操作数 vse16.v vd (rs1) vm 掩码操作数：rvv提供可以控制每一个数据的方法，若vm为v0.t，则表述用v0矢量寄存器作为掩码，每位表示一个数据元素的状态，若v0[i]==1，表示第i个元素被激活，被激活的元素参与计算，未被激活的则不参与。若未激活的元素的计算策略除了保持不变外还有可能令其为1，这就被称为未知策略，保持不变的策略被称为不打扰策略。这两种策略可以通过配置vtype寄存器的vta，vma字段实现。当掩码操作数在汇编代码中为空时代表激活所有的元素 .v 被称为修饰符，该符号决定了要操作的寄存器的元素的类型，例子如下： .vv：矢量数据元素与矢量数据元素 .vx：矢量数据元素与整型标量数据元素 .vf：矢量数据元素与浮点标量数据元素 .vi：矢量数据元素与立即数数据元素 .m：掩码元素 任意步长格式加载指令 c //任意步长模式会从内存中以rs1为起始地址，每隔r2为步长，依次将下一个元素加载到vd中，r2的值可以为负数或0 vlse8.v vd (vs1), rs2, vm 存储指令 c vsse8.v vs (vs1), rs2, vm 聚合加载与离散存储聚合加载与离散存储均支持以下两种模式 有序索引：在访问内存时按照索引的顺序有序的访问 无序索引：访问内存时不保证访问的顺序 有序索引的聚合加载指令 c //加载8位宽度数据 vloxei8.v vd, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从内存有序的加载元素到vd中 有序索引的离散存储指令 c vsoxei8.v vs, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从vs2有序的存储元素到内存中 无序索引的聚合加载指令 c vluxei8.v vd, (rs1), vs2, vm 无序索引的离散存储指令 c vsuxei8.v vs, (rs1), vs2, vm 打包数据的加载与存储现实中有一些数据是以一定格式打包的，如rgb24，正常情况下需要将rgb24加载到矢量寄存器中，之后将其解包为r，g，b三个不同的寄存器组，但这个过程很麻烦。为此rvv推出此指令，打包数据的加载存储指令也有单位步长，任意步长，聚合加载与离散存储三种模式 单位步长的打包数据加载存储指令如下： c vlsege.v vd, (rs1), vm vssege.v vs, (rs1), vm 其中，nf是构成打包数据的元素个数，eew是每个元素的位宽，cpu会影响vdvd+nf-1/vsvs+nf-1个向量寄存器 对于rgb24： c //从a1地址开始加载rgb24数据到v4，v5，v6矢量寄存器中 vsseg3e8.v v4, (a1) 加载和存储全部矢量数据 c //从rs地址处开始将n个矢量寄存器大小的数据加载进vd到vd+n-1的寄存器中 vlr.v vd, (rs) //存储指令 vsr.v vs, (rs1) 矢量掩码指令 逻辑操作指令我们可以让两个矢量之间进行逻辑运算 c vmand.mm vd, vs2, vs1 vmxor.mm vd, vs2, vs1 vmor.mm vd, vs2, vs1 与位操作指令不同的是，掩码制控制数据元素的激活与否，而位操作指令是修改元素的值 此外，rvv的指令集还支持如下伪指令 c //将vs中数据全部复制到vd vmmv.m vd, vs //将vd中数据全部清0 vmclr.m vd //将vd中数据全部置","date":"2025-01-01","objectID":"/posts/risc-v/:8:14","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#比较指令"},{"categories":["Tech"],"content":" 可伸缩矢量计算与优化SISD(single instruction single data，单指令单数据)，同一时刻只能处理一条数据，大多数rv指令是sisd的 当处理小数据时，需要将一个8位数据对应的加载到一个单独的64位寄存器中，不能有效利用cpu资源 simd对多个数据元素同时执行相同的操作，这些数据元素被打包在更大的寄存器中的独立通道(也被称为元素)，假设矢量寄存器的长度是128位，那么add指令会把4个32位数据元素加在一起，这些值被打包到两对128寄存器(v1，v2)中的通道中，然后让第一个源寄存器的每个通道与第二个源寄存器的对应通道相加，结果存在v0对应通道中 simd非常适合图像处理场景。图像常用rgb565，rgba8888，yuv422等格式的数据，这些格式的特点是一个像素的一个分量用3或4个8位数据表示，处理的时候是能够并行处理 SIMD的历史1999年，Intel推出SSE(streaming SIMD extension， 流式SIMD扩展)指令集，解决浮点数运算问题并把矢量寄存器的宽度升级到128位 2008年，Intel发布AVX(advanced vector extension， 高级矢量扩展)，兼容sse的同时把矢量寄存器的长度从128位提升至256位 2013年，Intel发布AVX512，矢量寄存器长度进一步提高至512位 arm阵营中，armv7a推出NEON指令集，矢量寄存器128位，在v8下为256位 由于上述指令集都属于定长度指令集，64位矢量寄存器无法运行128位的程序，因此arm在armv8.2中引入了可伸缩矢量扩展(SVE，scalable vector extension)指令集，其编程模型被称为可变矢量长度(VLA)模型 rv架构中，rvv也支持可伸缩矢量计算，且支持的矢量长度最大达65536位 矢量运算指令提供3个版本：矢量，标量，立即数 矢量版本：把矢量寄存器1的所有通道与矢量寄存器2的所有通道进行计算 标量版本：通用寄存器的数据与矢量寄存器进行计算 立即数版本：矢量寄存器与矢量寄存器生成的立即数进行计算 rvv寄存器组rvv为矢量计算提供了一个全新的寄存器组，包括 32个矢量寄存器(v0~v31) 7个非特权级寄存器：vtype，vl，vlenb，vstart，vxvm，vxsat，vcsr 参与运算的矢量长度：必须是$2^n$，最大长度为$2^{16}$(65536位) 元素长度：必须是$2^n$，最小长度为8位 mstatus寄存器：内部的vs字段(Bit[10:9])不仅描述矢量上下文状态，还会映射到sstatus寄存器的Bit[10:9]。当vs字段处于初始状态也就是0时，使用rvv指令或访问非特权寄存器都会改变状态触发指令异常 vtype寄存器：用来描述矢量寄存器中数据类型，决定了数据组织方式和如何对多个矢量寄存器进行分组。vlmul字段决定了多少个矢量寄存器可以组成一个矢量寄存器组，这样一条指令就可以同时操作这个寄存器组了，vlmul不仅可以被设置为整数也可以设置为分数，所以支持高位宽rvv指令集对低位宽指令集的兼容 vlmul(lmul的) 取值 表达式 寄存器组大小 使用的 v 寄存器 含义 000 m1 1 个 v0 标准长度 001 m2 2 个 v0, v1 两倍长度 010 m4 4 个 v0–v3 四倍长度 011 m8 8 个 v0–v7 八倍长度 111 mf2 1/2 个 v0 (部分使用) 半长 110 mf4 1/4 个 v0 (部分使用) 1/4 长 101 mf8 1/8 个 v0 (部分使用) 1/8 长 示例代码： c vsetvli t0, a2, e32, m4 # 设置 vtype，使用4个寄存器组成一个逻辑向量组 vadd.vv v0, v4, v8 # 对应的加法 整个指令的行为是 c [v0,v1,v2,v3] = [v4,v5,v6,v7] + [v8,v9,v10,v11] vl寄存器：用来记录在矢量指令中处理元素的数量 vlenb寄存器：指定一个矢量寄存器内有多少字节，该值在硬件设计时就确定了，因此该寄存器是只读的 vstart寄存器：用来指示第一个参与运算数据元素的索引，通常为0，不为0时执行某些运算会触发指令异常 VLA模型VLA(Vector Length Agnostic，可变向量长度编程模型) vla的实现依靠软硬件共同完成，硬件方面由底层提供配置寄存器，vtype以及vl，前者配置要处理数据类型的位宽，后者配置每次处理数据元素的个数 一般使用vsetvli指令设置： c //初始化vl和vtype寄存器，其中有效元素位宽为8(eew=8)，有效组乘系数=1(emul=1，使用一个寄存器组成一个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为16 //并把vl的值存在t0寄存器中，a2表示要处理的字节数 vsetvli t0, a2, e8, m1 //初始化vl和vtype寄存器，其中有效元素位宽为16(eew=16)，有效组乘系数=1/2(emul=1/2，使用一个寄存器组成两个寄存器组)。假设矢量寄存器长度为128位，那么一个寄存器组内元素的数量为8 vsetvli t0, a2, e16, mf2 一般情况下，矢量寄存器的长度组乘系数与有效组乘系数是相等的(lmul=emul)，并且sew=eew。但在处理不同位宽的数据（如 8 位与 16 位数据相加）时，EMUL 会大于 LMUL。例如，在将 8 位数据与 16 位数据进行矢量加法操作时，为了保证结果宽度足够，可能需要设置 EMUL = 2 × LMUL，以容纳更宽的运算结果 加载和存储指令 单位步长模式 c //从rs1指向的地址加载8位宽的数据元素，vm为掩码操作数 vle8.v vd (rs1) vm //向rs1指向的地址存储16位宽的数据元素，vm为掩码操作数 vse16.v vd (rs1) vm 掩码操作数：rvv提供可以控制每一个数据的方法，若vm为v0.t，则表述用v0矢量寄存器作为掩码，每位表示一个数据元素的状态，若v0[i]==1，表示第i个元素被激活，被激活的元素参与计算，未被激活的则不参与。若未激活的元素的计算策略除了保持不变外还有可能令其为1，这就被称为未知策略，保持不变的策略被称为不打扰策略。这两种策略可以通过配置vtype寄存器的vta，vma字段实现。当掩码操作数在汇编代码中为空时代表激活所有的元素 .v 被称为修饰符，该符号决定了要操作的寄存器的元素的类型，例子如下： .vv：矢量数据元素与矢量数据元素 .vx：矢量数据元素与整型标量数据元素 .vf：矢量数据元素与浮点标量数据元素 .vi：矢量数据元素与立即数数据元素 .m：掩码元素 任意步长格式加载指令 c //任意步长模式会从内存中以rs1为起始地址，每隔r2为步长，依次将下一个元素加载到vd中，r2的值可以为负数或0 vlse8.v vd (vs1), rs2, vm 存储指令 c vsse8.v vs (vs1), rs2, vm 聚合加载与离散存储聚合加载与离散存储均支持以下两种模式 有序索引：在访问内存时按照索引的顺序有序的访问 无序索引：访问内存时不保证访问的顺序 有序索引的聚合加载指令 c //加载8位宽度数据 vloxei8.v vd, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从内存有序的加载元素到vd中 有序索引的离散存储指令 c vsoxei8.v vs, (rs1), vs2, vm 上述指令以rs1为基地址，vs2中每个通道的数据作为偏移量，而后从vs2有序的存储元素到内存中 无序索引的聚合加载指令 c vluxei8.v vd, (rs1), vs2, vm 无序索引的离散存储指令 c vsuxei8.v vs, (rs1), vs2, vm 打包数据的加载与存储现实中有一些数据是以一定格式打包的，如rgb24，正常情况下需要将rgb24加载到矢量寄存器中，之后将其解包为r，g，b三个不同的寄存器组，但这个过程很麻烦。为此rvv推出此指令，打包数据的加载存储指令也有单位步长，任意步长，聚合加载与离散存储三种模式 单位步长的打包数据加载存储指令如下： c vlsege.v vd, (rs1), vm vssege.v vs, (rs1), vm 其中，nf是构成打包数据的元素个数，eew是每个元素的位宽，cpu会影响vdvd+nf-1/vsvs+nf-1个向量寄存器 对于rgb24： c //从a1地址开始加载rgb24数据到v4，v5，v6矢量寄存器中 vsseg3e8.v v4, (a1) 加载和存储全部矢量数据 c //从rs地址处开始将n个矢量寄存器大小的数据加载进vd到vd+n-1的寄存器中 vlr.v vd, (rs) //存储指令 vsr.v vs, (rs1) 矢量掩码指令 逻辑操作指令我们可以让两个矢量之间进行逻辑运算 c vmand.mm vd, vs2, vs1 vmxor.mm vd, vs2, vs1 vmor.mm vd, vs2, vs1 与位操作指令不同的是，掩码制控制数据元素的激活与否，而位操作指令是修改元素的值 此外，rvv的指令集还支持如下伪指令 c //将vs中数据全部复制到vd vmmv.m vd, vs //将vd中数据全部清0 vmclr.m vd //将vd中数据全部置","date":"2025-01-01","objectID":"/posts/risc-v/:8:14","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#其他"},{"categories":["Tech"],"content":" 压缩指令集由于riscv指令集相比其他risc商业指令集(如armv8)密度低，例如arm有专用的成对加载/存储指令，一条指令可以完成riscv两条指令的工作。因此使用riscv架构就会造成编译后的代码增多，这样就需要更大的存储介质并，同时指令密度低也造成了提指令缓存的命中率过低，也会降低程序效率 因此rv推出压缩指令扩展(C)，压缩指令扩展使用16位宽指令替换32位宽或64位宽指令，由于32/64位指令严格兼容16位指令，因此低位宽指令集不会影响高位宽指令集，实验表明，一个程序中有50%的指令可以使用压缩指令集中的指令来替代 压缩指令集的替代高位宽指令集的策略为 当指令中的立即数或地址偏移量很小时 当指令中有一个寄存器是x0，x1或x2时 当指令中第一个源寄存器和目标寄存器是同一个寄存器时 当指令中所有寄存器都使用C指令集常用的8个寄存器时 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:15","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#压缩指令集"},{"categories":["Tech"],"content":" 虚拟化实现虚拟化三要素 资源控制：vmm(virtual machine manager)必须能够管理所有的系统资源 等价性：虚拟机的运行行为与裸机行为一致 效率性：虚拟机运行的程序不受vmm的干涉 敏感指令：操作某些特权资源的指令，如访问，修改vm模式或机器状态指令 特权指令：具有特殊权限的指令，这类指令只用于操作系统或其他系统软件，一般不直接供用户使用 三要素中第2点的实现较为困难，要实现就必须保证敏感指令是特权指令的子集。也就是说，当执行敏感指令来操作vm时，一定要陷入特权指令。这样vm就不会发现自己处于用户模式还是系统模式(有些恶意软件会请求vm给予更高权限来判别是否处于vm中)，它只会认为自己运行于用户模式。而vmm使用位于系统模式，vm相对于vmm就类似于app相对于os，它会认为没有其他的vm存在而独享所有资源。为了解决第2点，x86采用了二进制翻译的技术，vmm在vm运行中会动态的将所有有问题的指令替换为符合条件的指令，这被称为软件虚拟化 2005年，Intel引入了硬件虚拟化技术(virtualization technology，vt)。vt的基本思想是创建可以运行虚拟机的容器。vt中，cpu有两种模式：根与非根，这两种模式都有ring0~ring3四个特权级 根模式是给vmm用的，这种模式支持vmx指令集。非根模式是给vm用的，该模式不支持vmx。进入与退出根模式可以通过指令进行，类似ecall 内存地址的虚拟化在内存虚拟化中：存在四种地址 GVA(guest virtual address)：虚拟机虚拟地址 GPA(guest physical address)：虚拟机物理地址 HVA(host virtual address)：宿主机虚拟地址 HPA(host physical address)：宿主机物理地址 在访问内存时，由于页表项位于内存，因此当需要修改页表项时仅仅是对非敏感内存的操作，这并不涉及敏感指令。因此vm不会陷入vmm中，为了能捕获vm行为，vmm会创建影子页表供vm修改。vmm提供给vm的影子页表是只读的，一旦vm尝试修改影子页表就会触发缺页异常导致陷入vmm 这样，vm修改pa就需要3步：GVA-\u003eGPA-\u003eHPA，这三步也被称为影子页表。但相比于HVA-\u003eHPA的宿主机的页表查询，影子页表引入的额外缺页异常会产生性能问题，为了解决这个问题，可以使用硬件来加速影子页表的查询速度。Intel就实现了这种被称为EPT的技术 上面修改影子页表的步骤可能会让人迷惑：为什么需要GPA-\u003eHPA？直接使用GPA不行么？这是因为vm相对于vmm就类似于app相对于os，因此即使是vm的GPA，实际上还是va，因此为了能够得到真正的pa，我们需要查询宿主机的页表，所以需要GPA-\u003eHPA这一步 io虚拟化在虚拟化环境中，虚拟机（VM）不仅使用 I/O 设备，还常常依赖 DMA（直接内存访问）进行高速数据传输。但这也带来了安全隐患：如果不加限制，虚拟机中的外设可能通过 DMA 访问甚至篡改宿主机或其他虚拟机的内存 为了解决这一问题，系统引入了 IOMMU（输入输出内存管理单元）。它的作用与 CPU 使用的 MMU 类似，但面向的是设备。IOMMU 能够将设备发出的地址请求（通常是设备虚拟地址，DVA，或直接是GPA）映射为主机的实际物理地址（HPA），这一过程被称为： DMA 重映射（DMA Remapping） 在虚拟化场景下，IOMMU 会根据 VMM（虚拟机管理器）设置的 GPA → HPA 映射，建立一套独立的页表。这使得虚拟机的 DMA 请求只能访问其自身的内存空间（GPA 对应的 HPA），无法越权访问宿主机或其他虚拟机的内存 rv的虚拟化扩展rv的cpu在虚拟化方面有两个改进： 将s模式扩展为hs模式，增加寄存器和指令来同时兼容两类虚拟机(第一类虚拟机指的是vmm作为宿主机的os，第二类虚拟机指的是vmm作为宿主机os管理的一个应用程序)，例如在mstatus寄存器添加了模式(v)字段，v=0表示位于非虚拟化模式，如m，hs或u，v=1表示系统位于vs或vu模式 新增vs和vu模式，给vm内部划分权限 在虚拟化场景下，新增了vmm，它被允许运行在hs模式。而vm的os运行在vs模式，vm的应用程序运行在vu模式 rv内存虚拟化与Intel的ept技术类似，riscv也采用了硬件加速查询影子页表来优化内存虚拟化的性能。为此riscv准备了两个寄存器：vsatp与hgatp。这两个寄存器分别存储v模式和hs模式下的页表基地址，并且hgatp的支持模式包括sv39x4，sv48x4等，相比普通的映射模式，x4代表额外支持2位的页表，如sv39x4支持41位的GPA 虚拟机两阶段的地址映射过程 包括宿主机的映射过程 对于tlb刷新指令来说，sfence.vma与v相关，v=0，也就是位于m或hs模式，此时该指令与普通的sfence指令并无区别，都是刷新宿主机tlb缓存，或根据指定的 ASID 刷新特定地址空间的 TLB。v=1时仅仅作用于vs模式的第一阶段地址转换的tlb刷新，此时也可以通过指定 ASID，仅刷新对应虚拟机地址空间的 TLB 条目 新增指令hfence.gvma：该指令作用于第二阶段地址转换的tlb刷新 riscv虚拟化扩展提供两种模式：虚拟化模式和非虚拟化模式，这类似于Intel vt中的根模式与非根模式 虚拟化模式(v=1)：指cpu运行在vm中，如vs或vu模式 非虚拟化模式(v=0)：指cpu运行在vmm中，如m或hs模式 进入vm：可以配置hstatus的spv以及spvp字段，然后执行sret指令从而进入vm 退出vm：vm在运行中遇到需要vmm处理的事件，如外部中断或缺页异常，cpu可以自动挂起vm，切换到非虚拟化模式(hs或m)从而退出vm 中断虚拟化由于中断虚拟化标准尚未成熟，此处只做简要介绍，rv的中断虚拟化主要采用中断注入和陷入模拟技术。中断注入指的是提供hvip寄存器来将虚拟中断注入虚拟机。hvip支持软件中断，定时器中断和外设中断 陷入与模拟：目前riscv在硬件中断虚拟化中仅支持最基本的中断注入功能，要完成一次中断处理过程需要陷入vmm中模拟 下面以定时器中断触发流程讲解中断注入以及陷入与模拟 vm中的虚拟定时器驱动通过sbi服务接口陷入hs模式的vmm中，从而配置下次定时器的超时事件 vmm中的驱动通过sbi服务接口访问m模式下的mysbi固件来配置定时器 mysbi设置mtimer 等待一段时间后mtimer触发中断 定时器中断由m模式的mysbi固件优先处理，在其内部的中断处理程序中将该中断委托给hs模式下的vmm处理 在vmm中的中断处理程序中通过虚拟中断注入机制设置hvip寄存器 vm收到中断并处理该中断 上述过程为一般的中断注入机制，可见，每次配置定时器都要陷入vmm并且陷入m模式，这会增大开销。为了解决该问题，riscv正在草拟方案，因此本文不做介绍 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:16","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#虚拟化"},{"categories":["Tech"],"content":" 虚拟化实现虚拟化三要素 资源控制：vmm(virtual machine manager)必须能够管理所有的系统资源 等价性：虚拟机的运行行为与裸机行为一致 效率性：虚拟机运行的程序不受vmm的干涉 敏感指令：操作某些特权资源的指令，如访问，修改vm模式或机器状态指令 特权指令：具有特殊权限的指令，这类指令只用于操作系统或其他系统软件，一般不直接供用户使用 三要素中第2点的实现较为困难，要实现就必须保证敏感指令是特权指令的子集。也就是说，当执行敏感指令来操作vm时，一定要陷入特权指令。这样vm就不会发现自己处于用户模式还是系统模式(有些恶意软件会请求vm给予更高权限来判别是否处于vm中)，它只会认为自己运行于用户模式。而vmm使用位于系统模式，vm相对于vmm就类似于app相对于os，它会认为没有其他的vm存在而独享所有资源。为了解决第2点，x86采用了二进制翻译的技术，vmm在vm运行中会动态的将所有有问题的指令替换为符合条件的指令，这被称为软件虚拟化 2005年，Intel引入了硬件虚拟化技术(virtualization technology，vt)。vt的基本思想是创建可以运行虚拟机的容器。vt中，cpu有两种模式：根与非根，这两种模式都有ring0~ring3四个特权级 根模式是给vmm用的，这种模式支持vmx指令集。非根模式是给vm用的，该模式不支持vmx。进入与退出根模式可以通过指令进行，类似ecall 内存地址的虚拟化在内存虚拟化中：存在四种地址 GVA(guest virtual address)：虚拟机虚拟地址 GPA(guest physical address)：虚拟机物理地址 HVA(host virtual address)：宿主机虚拟地址 HPA(host physical address)：宿主机物理地址 在访问内存时，由于页表项位于内存，因此当需要修改页表项时仅仅是对非敏感内存的操作，这并不涉及敏感指令。因此vm不会陷入vmm中，为了能捕获vm行为，vmm会创建影子页表供vm修改。vmm提供给vm的影子页表是只读的，一旦vm尝试修改影子页表就会触发缺页异常导致陷入vmm 这样，vm修改pa就需要3步：GVA-\u003eGPA-\u003eHPA，这三步也被称为影子页表。但相比于HVA-\u003eHPA的宿主机的页表查询，影子页表引入的额外缺页异常会产生性能问题，为了解决这个问题，可以使用硬件来加速影子页表的查询速度。Intel就实现了这种被称为EPT的技术 上面修改影子页表的步骤可能会让人迷惑：为什么需要GPA-\u003eHPA？直接使用GPA不行么？这是因为vm相对于vmm就类似于app相对于os，因此即使是vm的GPA，实际上还是va，因此为了能够得到真正的pa，我们需要查询宿主机的页表，所以需要GPA-\u003eHPA这一步 io虚拟化在虚拟化环境中，虚拟机（VM）不仅使用 I/O 设备，还常常依赖 DMA（直接内存访问）进行高速数据传输。但这也带来了安全隐患：如果不加限制，虚拟机中的外设可能通过 DMA 访问甚至篡改宿主机或其他虚拟机的内存 为了解决这一问题，系统引入了 IOMMU（输入输出内存管理单元）。它的作用与 CPU 使用的 MMU 类似，但面向的是设备。IOMMU 能够将设备发出的地址请求（通常是设备虚拟地址，DVA，或直接是GPA）映射为主机的实际物理地址（HPA），这一过程被称为： DMA 重映射（DMA Remapping） 在虚拟化场景下，IOMMU 会根据 VMM（虚拟机管理器）设置的 GPA → HPA 映射，建立一套独立的页表。这使得虚拟机的 DMA 请求只能访问其自身的内存空间（GPA 对应的 HPA），无法越权访问宿主机或其他虚拟机的内存 rv的虚拟化扩展rv的cpu在虚拟化方面有两个改进： 将s模式扩展为hs模式，增加寄存器和指令来同时兼容两类虚拟机(第一类虚拟机指的是vmm作为宿主机的os，第二类虚拟机指的是vmm作为宿主机os管理的一个应用程序)，例如在mstatus寄存器添加了模式(v)字段，v=0表示位于非虚拟化模式，如m，hs或u，v=1表示系统位于vs或vu模式 新增vs和vu模式，给vm内部划分权限 在虚拟化场景下，新增了vmm，它被允许运行在hs模式。而vm的os运行在vs模式，vm的应用程序运行在vu模式 rv内存虚拟化与Intel的ept技术类似，riscv也采用了硬件加速查询影子页表来优化内存虚拟化的性能。为此riscv准备了两个寄存器：vsatp与hgatp。这两个寄存器分别存储v模式和hs模式下的页表基地址，并且hgatp的支持模式包括sv39x4，sv48x4等，相比普通的映射模式，x4代表额外支持2位的页表，如sv39x4支持41位的GPA 虚拟机两阶段的地址映射过程 包括宿主机的映射过程 对于tlb刷新指令来说，sfence.vma与v相关，v=0，也就是位于m或hs模式，此时该指令与普通的sfence指令并无区别，都是刷新宿主机tlb缓存，或根据指定的 ASID 刷新特定地址空间的 TLB。v=1时仅仅作用于vs模式的第一阶段地址转换的tlb刷新，此时也可以通过指定 ASID，仅刷新对应虚拟机地址空间的 TLB 条目 新增指令hfence.gvma：该指令作用于第二阶段地址转换的tlb刷新 riscv虚拟化扩展提供两种模式：虚拟化模式和非虚拟化模式，这类似于Intel vt中的根模式与非根模式 虚拟化模式(v=1)：指cpu运行在vm中，如vs或vu模式 非虚拟化模式(v=0)：指cpu运行在vmm中，如m或hs模式 进入vm：可以配置hstatus的spv以及spvp字段，然后执行sret指令从而进入vm 退出vm：vm在运行中遇到需要vmm处理的事件，如外部中断或缺页异常，cpu可以自动挂起vm，切换到非虚拟化模式(hs或m)从而退出vm 中断虚拟化由于中断虚拟化标准尚未成熟，此处只做简要介绍，rv的中断虚拟化主要采用中断注入和陷入模拟技术。中断注入指的是提供hvip寄存器来将虚拟中断注入虚拟机。hvip支持软件中断，定时器中断和外设中断 陷入与模拟：目前riscv在硬件中断虚拟化中仅支持最基本的中断注入功能，要完成一次中断处理过程需要陷入vmm中模拟 下面以定时器中断触发流程讲解中断注入以及陷入与模拟 vm中的虚拟定时器驱动通过sbi服务接口陷入hs模式的vmm中，从而配置下次定时器的超时事件 vmm中的驱动通过sbi服务接口访问m模式下的mysbi固件来配置定时器 mysbi设置mtimer 等待一段时间后mtimer触发中断 定时器中断由m模式的mysbi固件优先处理，在其内部的中断处理程序中将该中断委托给hs模式下的vmm处理 在vmm中的中断处理程序中通过虚拟中断注入机制设置hvip寄存器 vm收到中断并处理该中断 上述过程为一般的中断注入机制，可见，每次配置定时器都要陷入vmm并且陷入m模式，这会增大开销。为了解决该问题，riscv正在草拟方案，因此本文不做介绍 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:16","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#内存地址的虚拟化"},{"categories":["Tech"],"content":" 虚拟化实现虚拟化三要素 资源控制：vmm(virtual machine manager)必须能够管理所有的系统资源 等价性：虚拟机的运行行为与裸机行为一致 效率性：虚拟机运行的程序不受vmm的干涉 敏感指令：操作某些特权资源的指令，如访问，修改vm模式或机器状态指令 特权指令：具有特殊权限的指令，这类指令只用于操作系统或其他系统软件，一般不直接供用户使用 三要素中第2点的实现较为困难，要实现就必须保证敏感指令是特权指令的子集。也就是说，当执行敏感指令来操作vm时，一定要陷入特权指令。这样vm就不会发现自己处于用户模式还是系统模式(有些恶意软件会请求vm给予更高权限来判别是否处于vm中)，它只会认为自己运行于用户模式。而vmm使用位于系统模式，vm相对于vmm就类似于app相对于os，它会认为没有其他的vm存在而独享所有资源。为了解决第2点，x86采用了二进制翻译的技术，vmm在vm运行中会动态的将所有有问题的指令替换为符合条件的指令，这被称为软件虚拟化 2005年，Intel引入了硬件虚拟化技术(virtualization technology，vt)。vt的基本思想是创建可以运行虚拟机的容器。vt中，cpu有两种模式：根与非根，这两种模式都有ring0~ring3四个特权级 根模式是给vmm用的，这种模式支持vmx指令集。非根模式是给vm用的，该模式不支持vmx。进入与退出根模式可以通过指令进行，类似ecall 内存地址的虚拟化在内存虚拟化中：存在四种地址 GVA(guest virtual address)：虚拟机虚拟地址 GPA(guest physical address)：虚拟机物理地址 HVA(host virtual address)：宿主机虚拟地址 HPA(host physical address)：宿主机物理地址 在访问内存时，由于页表项位于内存，因此当需要修改页表项时仅仅是对非敏感内存的操作，这并不涉及敏感指令。因此vm不会陷入vmm中，为了能捕获vm行为，vmm会创建影子页表供vm修改。vmm提供给vm的影子页表是只读的，一旦vm尝试修改影子页表就会触发缺页异常导致陷入vmm 这样，vm修改pa就需要3步：GVA-\u003eGPA-\u003eHPA，这三步也被称为影子页表。但相比于HVA-\u003eHPA的宿主机的页表查询，影子页表引入的额外缺页异常会产生性能问题，为了解决这个问题，可以使用硬件来加速影子页表的查询速度。Intel就实现了这种被称为EPT的技术 上面修改影子页表的步骤可能会让人迷惑：为什么需要GPA-\u003eHPA？直接使用GPA不行么？这是因为vm相对于vmm就类似于app相对于os，因此即使是vm的GPA，实际上还是va，因此为了能够得到真正的pa，我们需要查询宿主机的页表，所以需要GPA-\u003eHPA这一步 io虚拟化在虚拟化环境中，虚拟机（VM）不仅使用 I/O 设备，还常常依赖 DMA（直接内存访问）进行高速数据传输。但这也带来了安全隐患：如果不加限制，虚拟机中的外设可能通过 DMA 访问甚至篡改宿主机或其他虚拟机的内存 为了解决这一问题，系统引入了 IOMMU（输入输出内存管理单元）。它的作用与 CPU 使用的 MMU 类似，但面向的是设备。IOMMU 能够将设备发出的地址请求（通常是设备虚拟地址，DVA，或直接是GPA）映射为主机的实际物理地址（HPA），这一过程被称为： DMA 重映射（DMA Remapping） 在虚拟化场景下，IOMMU 会根据 VMM（虚拟机管理器）设置的 GPA → HPA 映射，建立一套独立的页表。这使得虚拟机的 DMA 请求只能访问其自身的内存空间（GPA 对应的 HPA），无法越权访问宿主机或其他虚拟机的内存 rv的虚拟化扩展rv的cpu在虚拟化方面有两个改进： 将s模式扩展为hs模式，增加寄存器和指令来同时兼容两类虚拟机(第一类虚拟机指的是vmm作为宿主机的os，第二类虚拟机指的是vmm作为宿主机os管理的一个应用程序)，例如在mstatus寄存器添加了模式(v)字段，v=0表示位于非虚拟化模式，如m，hs或u，v=1表示系统位于vs或vu模式 新增vs和vu模式，给vm内部划分权限 在虚拟化场景下，新增了vmm，它被允许运行在hs模式。而vm的os运行在vs模式，vm的应用程序运行在vu模式 rv内存虚拟化与Intel的ept技术类似，riscv也采用了硬件加速查询影子页表来优化内存虚拟化的性能。为此riscv准备了两个寄存器：vsatp与hgatp。这两个寄存器分别存储v模式和hs模式下的页表基地址，并且hgatp的支持模式包括sv39x4，sv48x4等，相比普通的映射模式，x4代表额外支持2位的页表，如sv39x4支持41位的GPA 虚拟机两阶段的地址映射过程 包括宿主机的映射过程 对于tlb刷新指令来说，sfence.vma与v相关，v=0，也就是位于m或hs模式，此时该指令与普通的sfence指令并无区别，都是刷新宿主机tlb缓存，或根据指定的 ASID 刷新特定地址空间的 TLB。v=1时仅仅作用于vs模式的第一阶段地址转换的tlb刷新，此时也可以通过指定 ASID，仅刷新对应虚拟机地址空间的 TLB 条目 新增指令hfence.gvma：该指令作用于第二阶段地址转换的tlb刷新 riscv虚拟化扩展提供两种模式：虚拟化模式和非虚拟化模式，这类似于Intel vt中的根模式与非根模式 虚拟化模式(v=1)：指cpu运行在vm中，如vs或vu模式 非虚拟化模式(v=0)：指cpu运行在vmm中，如m或hs模式 进入vm：可以配置hstatus的spv以及spvp字段，然后执行sret指令从而进入vm 退出vm：vm在运行中遇到需要vmm处理的事件，如外部中断或缺页异常，cpu可以自动挂起vm，切换到非虚拟化模式(hs或m)从而退出vm 中断虚拟化由于中断虚拟化标准尚未成熟，此处只做简要介绍，rv的中断虚拟化主要采用中断注入和陷入模拟技术。中断注入指的是提供hvip寄存器来将虚拟中断注入虚拟机。hvip支持软件中断，定时器中断和外设中断 陷入与模拟：目前riscv在硬件中断虚拟化中仅支持最基本的中断注入功能，要完成一次中断处理过程需要陷入vmm中模拟 下面以定时器中断触发流程讲解中断注入以及陷入与模拟 vm中的虚拟定时器驱动通过sbi服务接口陷入hs模式的vmm中，从而配置下次定时器的超时事件 vmm中的驱动通过sbi服务接口访问m模式下的mysbi固件来配置定时器 mysbi设置mtimer 等待一段时间后mtimer触发中断 定时器中断由m模式的mysbi固件优先处理，在其内部的中断处理程序中将该中断委托给hs模式下的vmm处理 在vmm中的中断处理程序中通过虚拟中断注入机制设置hvip寄存器 vm收到中断并处理该中断 上述过程为一般的中断注入机制，可见，每次配置定时器都要陷入vmm并且陷入m模式，这会增大开销。为了解决该问题，riscv正在草拟方案，因此本文不做介绍 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:16","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#io虚拟化"},{"categories":["Tech"],"content":" 虚拟化实现虚拟化三要素 资源控制：vmm(virtual machine manager)必须能够管理所有的系统资源 等价性：虚拟机的运行行为与裸机行为一致 效率性：虚拟机运行的程序不受vmm的干涉 敏感指令：操作某些特权资源的指令，如访问，修改vm模式或机器状态指令 特权指令：具有特殊权限的指令，这类指令只用于操作系统或其他系统软件，一般不直接供用户使用 三要素中第2点的实现较为困难，要实现就必须保证敏感指令是特权指令的子集。也就是说，当执行敏感指令来操作vm时，一定要陷入特权指令。这样vm就不会发现自己处于用户模式还是系统模式(有些恶意软件会请求vm给予更高权限来判别是否处于vm中)，它只会认为自己运行于用户模式。而vmm使用位于系统模式，vm相对于vmm就类似于app相对于os，它会认为没有其他的vm存在而独享所有资源。为了解决第2点，x86采用了二进制翻译的技术，vmm在vm运行中会动态的将所有有问题的指令替换为符合条件的指令，这被称为软件虚拟化 2005年，Intel引入了硬件虚拟化技术(virtualization technology，vt)。vt的基本思想是创建可以运行虚拟机的容器。vt中，cpu有两种模式：根与非根，这两种模式都有ring0~ring3四个特权级 根模式是给vmm用的，这种模式支持vmx指令集。非根模式是给vm用的，该模式不支持vmx。进入与退出根模式可以通过指令进行，类似ecall 内存地址的虚拟化在内存虚拟化中：存在四种地址 GVA(guest virtual address)：虚拟机虚拟地址 GPA(guest physical address)：虚拟机物理地址 HVA(host virtual address)：宿主机虚拟地址 HPA(host physical address)：宿主机物理地址 在访问内存时，由于页表项位于内存，因此当需要修改页表项时仅仅是对非敏感内存的操作，这并不涉及敏感指令。因此vm不会陷入vmm中，为了能捕获vm行为，vmm会创建影子页表供vm修改。vmm提供给vm的影子页表是只读的，一旦vm尝试修改影子页表就会触发缺页异常导致陷入vmm 这样，vm修改pa就需要3步：GVA-\u003eGPA-\u003eHPA，这三步也被称为影子页表。但相比于HVA-\u003eHPA的宿主机的页表查询，影子页表引入的额外缺页异常会产生性能问题，为了解决这个问题，可以使用硬件来加速影子页表的查询速度。Intel就实现了这种被称为EPT的技术 上面修改影子页表的步骤可能会让人迷惑：为什么需要GPA-\u003eHPA？直接使用GPA不行么？这是因为vm相对于vmm就类似于app相对于os，因此即使是vm的GPA，实际上还是va，因此为了能够得到真正的pa，我们需要查询宿主机的页表，所以需要GPA-\u003eHPA这一步 io虚拟化在虚拟化环境中，虚拟机（VM）不仅使用 I/O 设备，还常常依赖 DMA（直接内存访问）进行高速数据传输。但这也带来了安全隐患：如果不加限制，虚拟机中的外设可能通过 DMA 访问甚至篡改宿主机或其他虚拟机的内存 为了解决这一问题，系统引入了 IOMMU（输入输出内存管理单元）。它的作用与 CPU 使用的 MMU 类似，但面向的是设备。IOMMU 能够将设备发出的地址请求（通常是设备虚拟地址，DVA，或直接是GPA）映射为主机的实际物理地址（HPA），这一过程被称为： DMA 重映射（DMA Remapping） 在虚拟化场景下，IOMMU 会根据 VMM（虚拟机管理器）设置的 GPA → HPA 映射，建立一套独立的页表。这使得虚拟机的 DMA 请求只能访问其自身的内存空间（GPA 对应的 HPA），无法越权访问宿主机或其他虚拟机的内存 rv的虚拟化扩展rv的cpu在虚拟化方面有两个改进： 将s模式扩展为hs模式，增加寄存器和指令来同时兼容两类虚拟机(第一类虚拟机指的是vmm作为宿主机的os，第二类虚拟机指的是vmm作为宿主机os管理的一个应用程序)，例如在mstatus寄存器添加了模式(v)字段，v=0表示位于非虚拟化模式，如m，hs或u，v=1表示系统位于vs或vu模式 新增vs和vu模式，给vm内部划分权限 在虚拟化场景下，新增了vmm，它被允许运行在hs模式。而vm的os运行在vs模式，vm的应用程序运行在vu模式 rv内存虚拟化与Intel的ept技术类似，riscv也采用了硬件加速查询影子页表来优化内存虚拟化的性能。为此riscv准备了两个寄存器：vsatp与hgatp。这两个寄存器分别存储v模式和hs模式下的页表基地址，并且hgatp的支持模式包括sv39x4，sv48x4等，相比普通的映射模式，x4代表额外支持2位的页表，如sv39x4支持41位的GPA 虚拟机两阶段的地址映射过程 包括宿主机的映射过程 对于tlb刷新指令来说，sfence.vma与v相关，v=0，也就是位于m或hs模式，此时该指令与普通的sfence指令并无区别，都是刷新宿主机tlb缓存，或根据指定的 ASID 刷新特定地址空间的 TLB。v=1时仅仅作用于vs模式的第一阶段地址转换的tlb刷新，此时也可以通过指定 ASID，仅刷新对应虚拟机地址空间的 TLB 条目 新增指令hfence.gvma：该指令作用于第二阶段地址转换的tlb刷新 riscv虚拟化扩展提供两种模式：虚拟化模式和非虚拟化模式，这类似于Intel vt中的根模式与非根模式 虚拟化模式(v=1)：指cpu运行在vm中，如vs或vu模式 非虚拟化模式(v=0)：指cpu运行在vmm中，如m或hs模式 进入vm：可以配置hstatus的spv以及spvp字段，然后执行sret指令从而进入vm 退出vm：vm在运行中遇到需要vmm处理的事件，如外部中断或缺页异常，cpu可以自动挂起vm，切换到非虚拟化模式(hs或m)从而退出vm 中断虚拟化由于中断虚拟化标准尚未成熟，此处只做简要介绍，rv的中断虚拟化主要采用中断注入和陷入模拟技术。中断注入指的是提供hvip寄存器来将虚拟中断注入虚拟机。hvip支持软件中断，定时器中断和外设中断 陷入与模拟：目前riscv在硬件中断虚拟化中仅支持最基本的中断注入功能，要完成一次中断处理过程需要陷入vmm中模拟 下面以定时器中断触发流程讲解中断注入以及陷入与模拟 vm中的虚拟定时器驱动通过sbi服务接口陷入hs模式的vmm中，从而配置下次定时器的超时事件 vmm中的驱动通过sbi服务接口访问m模式下的mysbi固件来配置定时器 mysbi设置mtimer 等待一段时间后mtimer触发中断 定时器中断由m模式的mysbi固件优先处理，在其内部的中断处理程序中将该中断委托给hs模式下的vmm处理 在vmm中的中断处理程序中通过虚拟中断注入机制设置hvip寄存器 vm收到中断并处理该中断 上述过程为一般的中断注入机制，可见，每次配置定时器都要陷入vmm并且陷入m模式，这会增大开销。为了解决该问题，riscv正在草拟方案，因此本文不做介绍 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:16","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#rv的虚拟化扩展"},{"categories":["Tech"],"content":" 虚拟化实现虚拟化三要素 资源控制：vmm(virtual machine manager)必须能够管理所有的系统资源 等价性：虚拟机的运行行为与裸机行为一致 效率性：虚拟机运行的程序不受vmm的干涉 敏感指令：操作某些特权资源的指令，如访问，修改vm模式或机器状态指令 特权指令：具有特殊权限的指令，这类指令只用于操作系统或其他系统软件，一般不直接供用户使用 三要素中第2点的实现较为困难，要实现就必须保证敏感指令是特权指令的子集。也就是说，当执行敏感指令来操作vm时，一定要陷入特权指令。这样vm就不会发现自己处于用户模式还是系统模式(有些恶意软件会请求vm给予更高权限来判别是否处于vm中)，它只会认为自己运行于用户模式。而vmm使用位于系统模式，vm相对于vmm就类似于app相对于os，它会认为没有其他的vm存在而独享所有资源。为了解决第2点，x86采用了二进制翻译的技术，vmm在vm运行中会动态的将所有有问题的指令替换为符合条件的指令，这被称为软件虚拟化 2005年，Intel引入了硬件虚拟化技术(virtualization technology，vt)。vt的基本思想是创建可以运行虚拟机的容器。vt中，cpu有两种模式：根与非根，这两种模式都有ring0~ring3四个特权级 根模式是给vmm用的，这种模式支持vmx指令集。非根模式是给vm用的，该模式不支持vmx。进入与退出根模式可以通过指令进行，类似ecall 内存地址的虚拟化在内存虚拟化中：存在四种地址 GVA(guest virtual address)：虚拟机虚拟地址 GPA(guest physical address)：虚拟机物理地址 HVA(host virtual address)：宿主机虚拟地址 HPA(host physical address)：宿主机物理地址 在访问内存时，由于页表项位于内存，因此当需要修改页表项时仅仅是对非敏感内存的操作，这并不涉及敏感指令。因此vm不会陷入vmm中，为了能捕获vm行为，vmm会创建影子页表供vm修改。vmm提供给vm的影子页表是只读的，一旦vm尝试修改影子页表就会触发缺页异常导致陷入vmm 这样，vm修改pa就需要3步：GVA-\u003eGPA-\u003eHPA，这三步也被称为影子页表。但相比于HVA-\u003eHPA的宿主机的页表查询，影子页表引入的额外缺页异常会产生性能问题，为了解决这个问题，可以使用硬件来加速影子页表的查询速度。Intel就实现了这种被称为EPT的技术 上面修改影子页表的步骤可能会让人迷惑：为什么需要GPA-\u003eHPA？直接使用GPA不行么？这是因为vm相对于vmm就类似于app相对于os，因此即使是vm的GPA，实际上还是va，因此为了能够得到真正的pa，我们需要查询宿主机的页表，所以需要GPA-\u003eHPA这一步 io虚拟化在虚拟化环境中，虚拟机（VM）不仅使用 I/O 设备，还常常依赖 DMA（直接内存访问）进行高速数据传输。但这也带来了安全隐患：如果不加限制，虚拟机中的外设可能通过 DMA 访问甚至篡改宿主机或其他虚拟机的内存 为了解决这一问题，系统引入了 IOMMU（输入输出内存管理单元）。它的作用与 CPU 使用的 MMU 类似，但面向的是设备。IOMMU 能够将设备发出的地址请求（通常是设备虚拟地址，DVA，或直接是GPA）映射为主机的实际物理地址（HPA），这一过程被称为： DMA 重映射（DMA Remapping） 在虚拟化场景下，IOMMU 会根据 VMM（虚拟机管理器）设置的 GPA → HPA 映射，建立一套独立的页表。这使得虚拟机的 DMA 请求只能访问其自身的内存空间（GPA 对应的 HPA），无法越权访问宿主机或其他虚拟机的内存 rv的虚拟化扩展rv的cpu在虚拟化方面有两个改进： 将s模式扩展为hs模式，增加寄存器和指令来同时兼容两类虚拟机(第一类虚拟机指的是vmm作为宿主机的os，第二类虚拟机指的是vmm作为宿主机os管理的一个应用程序)，例如在mstatus寄存器添加了模式(v)字段，v=0表示位于非虚拟化模式，如m，hs或u，v=1表示系统位于vs或vu模式 新增vs和vu模式，给vm内部划分权限 在虚拟化场景下，新增了vmm，它被允许运行在hs模式。而vm的os运行在vs模式，vm的应用程序运行在vu模式 rv内存虚拟化与Intel的ept技术类似，riscv也采用了硬件加速查询影子页表来优化内存虚拟化的性能。为此riscv准备了两个寄存器：vsatp与hgatp。这两个寄存器分别存储v模式和hs模式下的页表基地址，并且hgatp的支持模式包括sv39x4，sv48x4等，相比普通的映射模式，x4代表额外支持2位的页表，如sv39x4支持41位的GPA 虚拟机两阶段的地址映射过程 包括宿主机的映射过程 对于tlb刷新指令来说，sfence.vma与v相关，v=0，也就是位于m或hs模式，此时该指令与普通的sfence指令并无区别，都是刷新宿主机tlb缓存，或根据指定的 ASID 刷新特定地址空间的 TLB。v=1时仅仅作用于vs模式的第一阶段地址转换的tlb刷新，此时也可以通过指定 ASID，仅刷新对应虚拟机地址空间的 TLB 条目 新增指令hfence.gvma：该指令作用于第二阶段地址转换的tlb刷新 riscv虚拟化扩展提供两种模式：虚拟化模式和非虚拟化模式，这类似于Intel vt中的根模式与非根模式 虚拟化模式(v=1)：指cpu运行在vm中，如vs或vu模式 非虚拟化模式(v=0)：指cpu运行在vmm中，如m或hs模式 进入vm：可以配置hstatus的spv以及spvp字段，然后执行sret指令从而进入vm 退出vm：vm在运行中遇到需要vmm处理的事件，如外部中断或缺页异常，cpu可以自动挂起vm，切换到非虚拟化模式(hs或m)从而退出vm 中断虚拟化由于中断虚拟化标准尚未成熟，此处只做简要介绍，rv的中断虚拟化主要采用中断注入和陷入模拟技术。中断注入指的是提供hvip寄存器来将虚拟中断注入虚拟机。hvip支持软件中断，定时器中断和外设中断 陷入与模拟：目前riscv在硬件中断虚拟化中仅支持最基本的中断注入功能，要完成一次中断处理过程需要陷入vmm中模拟 下面以定时器中断触发流程讲解中断注入以及陷入与模拟 vm中的虚拟定时器驱动通过sbi服务接口陷入hs模式的vmm中，从而配置下次定时器的超时事件 vmm中的驱动通过sbi服务接口访问m模式下的mysbi固件来配置定时器 mysbi设置mtimer 等待一段时间后mtimer触发中断 定时器中断由m模式的mysbi固件优先处理，在其内部的中断处理程序中将该中断委托给hs模式下的vmm处理 在vmm中的中断处理程序中通过虚拟中断注入机制设置hvip寄存器 vm收到中断并处理该中断 上述过程为一般的中断注入机制，可见，每次配置定时器都要陷入vmm并且陷入m模式，这会增大开销。为了解决该问题，riscv正在草拟方案，因此本文不做介绍 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:16","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#rv内存虚拟化"},{"categories":["Tech"],"content":" 虚拟化实现虚拟化三要素 资源控制：vmm(virtual machine manager)必须能够管理所有的系统资源 等价性：虚拟机的运行行为与裸机行为一致 效率性：虚拟机运行的程序不受vmm的干涉 敏感指令：操作某些特权资源的指令，如访问，修改vm模式或机器状态指令 特权指令：具有特殊权限的指令，这类指令只用于操作系统或其他系统软件，一般不直接供用户使用 三要素中第2点的实现较为困难，要实现就必须保证敏感指令是特权指令的子集。也就是说，当执行敏感指令来操作vm时，一定要陷入特权指令。这样vm就不会发现自己处于用户模式还是系统模式(有些恶意软件会请求vm给予更高权限来判别是否处于vm中)，它只会认为自己运行于用户模式。而vmm使用位于系统模式，vm相对于vmm就类似于app相对于os，它会认为没有其他的vm存在而独享所有资源。为了解决第2点，x86采用了二进制翻译的技术，vmm在vm运行中会动态的将所有有问题的指令替换为符合条件的指令，这被称为软件虚拟化 2005年，Intel引入了硬件虚拟化技术(virtualization technology，vt)。vt的基本思想是创建可以运行虚拟机的容器。vt中，cpu有两种模式：根与非根，这两种模式都有ring0~ring3四个特权级 根模式是给vmm用的，这种模式支持vmx指令集。非根模式是给vm用的，该模式不支持vmx。进入与退出根模式可以通过指令进行，类似ecall 内存地址的虚拟化在内存虚拟化中：存在四种地址 GVA(guest virtual address)：虚拟机虚拟地址 GPA(guest physical address)：虚拟机物理地址 HVA(host virtual address)：宿主机虚拟地址 HPA(host physical address)：宿主机物理地址 在访问内存时，由于页表项位于内存，因此当需要修改页表项时仅仅是对非敏感内存的操作，这并不涉及敏感指令。因此vm不会陷入vmm中，为了能捕获vm行为，vmm会创建影子页表供vm修改。vmm提供给vm的影子页表是只读的，一旦vm尝试修改影子页表就会触发缺页异常导致陷入vmm 这样，vm修改pa就需要3步：GVA-\u003eGPA-\u003eHPA，这三步也被称为影子页表。但相比于HVA-\u003eHPA的宿主机的页表查询，影子页表引入的额外缺页异常会产生性能问题，为了解决这个问题，可以使用硬件来加速影子页表的查询速度。Intel就实现了这种被称为EPT的技术 上面修改影子页表的步骤可能会让人迷惑：为什么需要GPA-\u003eHPA？直接使用GPA不行么？这是因为vm相对于vmm就类似于app相对于os，因此即使是vm的GPA，实际上还是va，因此为了能够得到真正的pa，我们需要查询宿主机的页表，所以需要GPA-\u003eHPA这一步 io虚拟化在虚拟化环境中，虚拟机（VM）不仅使用 I/O 设备，还常常依赖 DMA（直接内存访问）进行高速数据传输。但这也带来了安全隐患：如果不加限制，虚拟机中的外设可能通过 DMA 访问甚至篡改宿主机或其他虚拟机的内存 为了解决这一问题，系统引入了 IOMMU（输入输出内存管理单元）。它的作用与 CPU 使用的 MMU 类似，但面向的是设备。IOMMU 能够将设备发出的地址请求（通常是设备虚拟地址，DVA，或直接是GPA）映射为主机的实际物理地址（HPA），这一过程被称为： DMA 重映射（DMA Remapping） 在虚拟化场景下，IOMMU 会根据 VMM（虚拟机管理器）设置的 GPA → HPA 映射，建立一套独立的页表。这使得虚拟机的 DMA 请求只能访问其自身的内存空间（GPA 对应的 HPA），无法越权访问宿主机或其他虚拟机的内存 rv的虚拟化扩展rv的cpu在虚拟化方面有两个改进： 将s模式扩展为hs模式，增加寄存器和指令来同时兼容两类虚拟机(第一类虚拟机指的是vmm作为宿主机的os，第二类虚拟机指的是vmm作为宿主机os管理的一个应用程序)，例如在mstatus寄存器添加了模式(v)字段，v=0表示位于非虚拟化模式，如m，hs或u，v=1表示系统位于vs或vu模式 新增vs和vu模式，给vm内部划分权限 在虚拟化场景下，新增了vmm，它被允许运行在hs模式。而vm的os运行在vs模式，vm的应用程序运行在vu模式 rv内存虚拟化与Intel的ept技术类似，riscv也采用了硬件加速查询影子页表来优化内存虚拟化的性能。为此riscv准备了两个寄存器：vsatp与hgatp。这两个寄存器分别存储v模式和hs模式下的页表基地址，并且hgatp的支持模式包括sv39x4，sv48x4等，相比普通的映射模式，x4代表额外支持2位的页表，如sv39x4支持41位的GPA 虚拟机两阶段的地址映射过程 包括宿主机的映射过程 对于tlb刷新指令来说，sfence.vma与v相关，v=0，也就是位于m或hs模式，此时该指令与普通的sfence指令并无区别，都是刷新宿主机tlb缓存，或根据指定的 ASID 刷新特定地址空间的 TLB。v=1时仅仅作用于vs模式的第一阶段地址转换的tlb刷新，此时也可以通过指定 ASID，仅刷新对应虚拟机地址空间的 TLB 条目 新增指令hfence.gvma：该指令作用于第二阶段地址转换的tlb刷新 riscv虚拟化扩展提供两种模式：虚拟化模式和非虚拟化模式，这类似于Intel vt中的根模式与非根模式 虚拟化模式(v=1)：指cpu运行在vm中，如vs或vu模式 非虚拟化模式(v=0)：指cpu运行在vmm中，如m或hs模式 进入vm：可以配置hstatus的spv以及spvp字段，然后执行sret指令从而进入vm 退出vm：vm在运行中遇到需要vmm处理的事件，如外部中断或缺页异常，cpu可以自动挂起vm，切换到非虚拟化模式(hs或m)从而退出vm 中断虚拟化由于中断虚拟化标准尚未成熟，此处只做简要介绍，rv的中断虚拟化主要采用中断注入和陷入模拟技术。中断注入指的是提供hvip寄存器来将虚拟中断注入虚拟机。hvip支持软件中断，定时器中断和外设中断 陷入与模拟：目前riscv在硬件中断虚拟化中仅支持最基本的中断注入功能，要完成一次中断处理过程需要陷入vmm中模拟 下面以定时器中断触发流程讲解中断注入以及陷入与模拟 vm中的虚拟定时器驱动通过sbi服务接口陷入hs模式的vmm中，从而配置下次定时器的超时事件 vmm中的驱动通过sbi服务接口访问m模式下的mysbi固件来配置定时器 mysbi设置mtimer 等待一段时间后mtimer触发中断 定时器中断由m模式的mysbi固件优先处理，在其内部的中断处理程序中将该中断委托给hs模式下的vmm处理 在vmm中的中断处理程序中通过虚拟中断注入机制设置hvip寄存器 vm收到中断并处理该中断 上述过程为一般的中断注入机制，可见，每次配置定时器都要陷入vmm并且陷入m模式，这会增大开销。为了解决该问题，riscv正在草拟方案，因此本文不做介绍 ","date":"2025-01-01","objectID":"/posts/risc-v/:8:16","series":null,"tags":["Tech","Computer Architecture"],"title":"RISC-V","uri":"/posts/risc-v/#中断虚拟化"},{"categories":["Tech"],"content":"本文是笔者学习Rust时系统总结的笔记，内部详细地介绍了Rust的特点以及语法，较为深入的探讨了Rust语言的语资料包括但不限于b站视频Rust编程语言入门教程，国人出品的开源书籍Rust语言圣经(Rust Course)，Rust语言中文社区，以及rust的官方书籍The Rust Programming Language ","date":"2024-12-15","objectID":"/posts/rust/:0:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#"},{"categories":["Tech"],"content":" Rust","date":"2024-12-15","objectID":"/posts/rust/:0:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#rust"},{"categories":["Tech"],"content":" 前期准备","date":"2024-12-15","objectID":"/posts/rust/:1:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#前期准备"},{"categories":["Tech"],"content":" 环境搭建可选ide/插件式编辑器: rustrover(jet brains)/rust-analyzer(rust foundation)+vscode 访问rust官网来获取下载链接，windows采用msvc编译链，在使用msvc之前需要先下载Visual Studio C++ Build tools。浏览器会自动识别平台并提供下载方式 ","date":"2024-12-15","objectID":"/posts/rust/:1:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#环境搭建"},{"categories":["Tech"],"content":" 创建项目 shell cd path cargo new project ","date":"2024-12-15","objectID":"/posts/rust/:1:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#创建项目"},{"categories":["Tech"],"content":" 编译运行可使用rustc编译 rust rustc filename.rs 大型项目推荐使用cargo进行编译 rust cd project cargo build 使用cargo build命令会在project/target/debug下生成可执行文件，默认编译方式是调试编译 同时也可以使用cargo run编译并运行代码 ","date":"2024-12-15","objectID":"/posts/rust/:1:3","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#编译运行"},{"categories":["Tech"],"content":" 添加外部库添加外部库有两种方法 修改cargo.toml文件的[dependencies]部分，添加格式为lib = \"\u003cversion\u003e\" 在终端执行cargo add lib\u003c@version\u003e，不添加@version字段为添加最新版库 ","date":"2024-12-15","objectID":"/posts/rust/:1:4","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#添加外部库"},{"categories":["Tech"],"content":" 强弱类型与动静态强类型: 编译器对类型有强约束，例如rust，java，python 弱类型: 编译器对类型无强约束，例如C，C++（有争议） 动态语言: 类型在运行时才确定，例如python 静态语言: 类型在编译完成时即可确定，编译时进行类型检查，例如rust ","date":"2024-12-15","objectID":"/posts/rust/:1:5","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#强弱类型与动静态"},{"categories":["Tech"],"content":" 基本语法","date":"2024-12-15","objectID":"/posts/rust/:2:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#基本语法"},{"categories":["Tech"],"content":" 变量与常量定义变量 rust let var; //默认定义的变量是不可变的 let mut var;//定义可变变量 定义常量 rust const cst:i32; //定义时必须指定类型 变量遮蔽(shadowing): 在同一作用域内可定义相同名称变量，但重新定义后只能使用新值 rust let num = 1; let num = 2; //num使用这个值 ","date":"2024-12-15","objectID":"/posts/rust/:2:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#变量与常量"},{"categories":["Tech"],"content":" 数据类型我们可以使用as关键字来强制指定数字类型 rust let thing1: u8 = 89.0 as u8; assert_eq!('B' as u32, 66); assert_eq!(thing1 as char, 'Y'); let thing2: f32 = thing1 as f32 + 10.5; assert_eq!(true as u8 + thing2 as u8, 100); 第一行代码等价于 rust let thing1 = 89.0 as u8; let thing1: u8 = 89.0; 此外，as关键字还可以给导入的模块起别名 标量类型包括整数类型，浮点类型，布尔类型和字符类型 字符类型是32位的，用以表示unicode字符 复合类型原始复合类型有两种: 元组(tuple)，数组(array) 元组不同类型数据的集合 数组相同数据的集合 ","date":"2024-12-15","objectID":"/posts/rust/:2:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#数据类型"},{"categories":["Tech"],"content":" 数据类型我们可以使用as关键字来强制指定数字类型 rust let thing1: u8 = 89.0 as u8; assert_eq!('B' as u32, 66); assert_eq!(thing1 as char, 'Y'); let thing2: f32 = thing1 as f32 + 10.5; assert_eq!(true as u8 + thing2 as u8, 100); 第一行代码等价于 rust let thing1 = 89.0 as u8; let thing1: u8 = 89.0; 此外，as关键字还可以给导入的模块起别名 标量类型包括整数类型，浮点类型，布尔类型和字符类型 字符类型是32位的，用以表示unicode字符 复合类型原始复合类型有两种: 元组(tuple)，数组(array) 元组不同类型数据的集合 数组相同数据的集合 ","date":"2024-12-15","objectID":"/posts/rust/:2:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#标量类型"},{"categories":["Tech"],"content":" 数据类型我们可以使用as关键字来强制指定数字类型 rust let thing1: u8 = 89.0 as u8; assert_eq!('B' as u32, 66); assert_eq!(thing1 as char, 'Y'); let thing2: f32 = thing1 as f32 + 10.5; assert_eq!(true as u8 + thing2 as u8, 100); 第一行代码等价于 rust let thing1 = 89.0 as u8; let thing1: u8 = 89.0; 此外，as关键字还可以给导入的模块起别名 标量类型包括整数类型，浮点类型，布尔类型和字符类型 字符类型是32位的，用以表示unicode字符 复合类型原始复合类型有两种: 元组(tuple)，数组(array) 元组不同类型数据的集合 数组相同数据的集合 ","date":"2024-12-15","objectID":"/posts/rust/:2:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#复合类型"},{"categories":["Tech"],"content":" 数据类型我们可以使用as关键字来强制指定数字类型 rust let thing1: u8 = 89.0 as u8; assert_eq!('B' as u32, 66); assert_eq!(thing1 as char, 'Y'); let thing2: f32 = thing1 as f32 + 10.5; assert_eq!(true as u8 + thing2 as u8, 100); 第一行代码等价于 rust let thing1 = 89.0 as u8; let thing1: u8 = 89.0; 此外，as关键字还可以给导入的模块起别名 标量类型包括整数类型，浮点类型，布尔类型和字符类型 字符类型是32位的，用以表示unicode字符 复合类型原始复合类型有两种: 元组(tuple)，数组(array) 元组不同类型数据的集合 数组相同数据的集合 ","date":"2024-12-15","objectID":"/posts/rust/:2:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#元组"},{"categories":["Tech"],"content":" 数据类型我们可以使用as关键字来强制指定数字类型 rust let thing1: u8 = 89.0 as u8; assert_eq!('B' as u32, 66); assert_eq!(thing1 as char, 'Y'); let thing2: f32 = thing1 as f32 + 10.5; assert_eq!(true as u8 + thing2 as u8, 100); 第一行代码等价于 rust let thing1 = 89.0 as u8; let thing1: u8 = 89.0; 此外，as关键字还可以给导入的模块起别名 标量类型包括整数类型，浮点类型，布尔类型和字符类型 字符类型是32位的，用以表示unicode字符 复合类型原始复合类型有两种: 元组(tuple)，数组(array) 元组不同类型数据的集合 数组相同数据的集合 ","date":"2024-12-15","objectID":"/posts/rust/:2:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#数组"},{"categories":["Tech"],"content":" 函数定义函数及参数时必须指明参数类型，并可以指定函数返回值类型(可以返回多个值) rust fn fun(a:i32, b:char) -\u003e i32 { return a; } fn fun1(a:i32, b:char) -\u003e (i32，i32) { (a,a+1) } 与其它语言不同的是，rust的语句没有返回值，例如在C中，语句的返回值是未定义行为，但是可以视为bool或整型变量。但在rust中则会报错。因此有关下列语句中，x+1的结尾是没有分号的 rust fn main() { let y = { let x = 3; x + 1 //表达式无分号 }; //y的定义语句才有分号 println!(\"y = {}\",y)； } ","date":"2024-12-15","objectID":"/posts/rust/:2:3","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#函数"},{"categories":["Tech"],"content":" 控制流（逻辑表达式） if表达式使用if表达式无论是否使用else if的多重分支都需要将分支语句用花括号括上，并且判断条件不应使用()包括起来 rust fn main() { let num = 3; if num \u003c 4 { //不可省略花括号 println!(\"num\u003c4\"); } else { println!(\"num\u003e4\"); } } 注意: if表达式的condition必须为bool变量，否则报错 rust fn main() { let x = 1; //x不是bool变量，会报错 let y = if x {0} else {1}; println!(\"{y}\"); } 循环语句 looploop是一个死循环，只能从break处跳出循环 break 表达式就返回值 rust fn main() { let mut counter = 0; let result = loop { counter += 1; if counter==10{ break counter * 2; } } println!(\"{result}\"); } 使用break还可以跳转到标签处，标签写法: ’label: loop rust fn main() { let mut count = 0; 'count_up: loop{ println!(\"{count}\"); let mut remaining = 10; loop{ if remaining==9 { break; } if count==2 { break 'count_up; } remaining -= 1; println!(\"{remaining}\"); } count += 1; } } for与python的for写法一样 rust fn main(){ let a = [10,20,30,40,50,60]; for element in a{ println!(\"{element}\"); } } 想要指定循环次数或者其它有关循环的高级功能可以使用rust的range库 while与C的while相同，但是判断条件同样不应使用()括起来 ","date":"2024-12-15","objectID":"/posts/rust/:2:4","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#控制流逻辑表达式"},{"categories":["Tech"],"content":" 控制流（逻辑表达式） if表达式使用if表达式无论是否使用else if的多重分支都需要将分支语句用花括号括上，并且判断条件不应使用()包括起来 rust fn main() { let num = 3; if num \u003c 4 { //不可省略花括号 println!(\"num\u003c4\"); } else { println!(\"num\u003e4\"); } } 注意: if表达式的condition必须为bool变量，否则报错 rust fn main() { let x = 1; //x不是bool变量，会报错 let y = if x {0} else {1}; println!(\"{y}\"); } 循环语句 looploop是一个死循环，只能从break处跳出循环 break 表达式就返回值 rust fn main() { let mut counter = 0; let result = loop { counter += 1; if counter==10{ break counter * 2; } } println!(\"{result}\"); } 使用break还可以跳转到标签处，标签写法: ’label: loop rust fn main() { let mut count = 0; 'count_up: loop{ println!(\"{count}\"); let mut remaining = 10; loop{ if remaining==9 { break; } if count==2 { break 'count_up; } remaining -= 1; println!(\"{remaining}\"); } count += 1; } } for与python的for写法一样 rust fn main(){ let a = [10,20,30,40,50,60]; for element in a{ println!(\"{element}\"); } } 想要指定循环次数或者其它有关循环的高级功能可以使用rust的range库 while与C的while相同，但是判断条件同样不应使用()括起来 ","date":"2024-12-15","objectID":"/posts/rust/:2:4","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#if表达式"},{"categories":["Tech"],"content":" 控制流（逻辑表达式） if表达式使用if表达式无论是否使用else if的多重分支都需要将分支语句用花括号括上，并且判断条件不应使用()包括起来 rust fn main() { let num = 3; if num \u003c 4 { //不可省略花括号 println!(\"num\u003c4\"); } else { println!(\"num\u003e4\"); } } 注意: if表达式的condition必须为bool变量，否则报错 rust fn main() { let x = 1; //x不是bool变量，会报错 let y = if x {0} else {1}; println!(\"{y}\"); } 循环语句 looploop是一个死循环，只能从break处跳出循环 break 表达式就返回值 rust fn main() { let mut counter = 0; let result = loop { counter += 1; if counter==10{ break counter * 2; } } println!(\"{result}\"); } 使用break还可以跳转到标签处，标签写法: ’label: loop rust fn main() { let mut count = 0; 'count_up: loop{ println!(\"{count}\"); let mut remaining = 10; loop{ if remaining==9 { break; } if count==2 { break 'count_up; } remaining -= 1; println!(\"{remaining}\"); } count += 1; } } for与python的for写法一样 rust fn main(){ let a = [10,20,30,40,50,60]; for element in a{ println!(\"{element}\"); } } 想要指定循环次数或者其它有关循环的高级功能可以使用rust的range库 while与C的while相同，但是判断条件同样不应使用()括起来 ","date":"2024-12-15","objectID":"/posts/rust/:2:4","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#循环语句"},{"categories":["Tech"],"content":" 控制流（逻辑表达式） if表达式使用if表达式无论是否使用else if的多重分支都需要将分支语句用花括号括上，并且判断条件不应使用()包括起来 rust fn main() { let num = 3; if num \u003c 4 { //不可省略花括号 println!(\"num\u003c4\"); } else { println!(\"num\u003e4\"); } } 注意: if表达式的condition必须为bool变量，否则报错 rust fn main() { let x = 1; //x不是bool变量，会报错 let y = if x {0} else {1}; println!(\"{y}\"); } 循环语句 looploop是一个死循环，只能从break处跳出循环 break 表达式就返回值 rust fn main() { let mut counter = 0; let result = loop { counter += 1; if counter==10{ break counter * 2; } } println!(\"{result}\"); } 使用break还可以跳转到标签处，标签写法: ’label: loop rust fn main() { let mut count = 0; 'count_up: loop{ println!(\"{count}\"); let mut remaining = 10; loop{ if remaining==9 { break; } if count==2 { break 'count_up; } remaining -= 1; println!(\"{remaining}\"); } count += 1; } } for与python的for写法一样 rust fn main(){ let a = [10,20,30,40,50,60]; for element in a{ println!(\"{element}\"); } } 想要指定循环次数或者其它有关循环的高级功能可以使用rust的range库 while与C的while相同，但是判断条件同样不应使用()括起来 ","date":"2024-12-15","objectID":"/posts/rust/:2:4","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#loop"},{"categories":["Tech"],"content":" 控制流（逻辑表达式） if表达式使用if表达式无论是否使用else if的多重分支都需要将分支语句用花括号括上，并且判断条件不应使用()包括起来 rust fn main() { let num = 3; if num \u003c 4 { //不可省略花括号 println!(\"num\u003c4\"); } else { println!(\"num\u003e4\"); } } 注意: if表达式的condition必须为bool变量，否则报错 rust fn main() { let x = 1; //x不是bool变量，会报错 let y = if x {0} else {1}; println!(\"{y}\"); } 循环语句 looploop是一个死循环，只能从break处跳出循环 break 表达式就返回值 rust fn main() { let mut counter = 0; let result = loop { counter += 1; if counter==10{ break counter * 2; } } println!(\"{result}\"); } 使用break还可以跳转到标签处，标签写法: ’label: loop rust fn main() { let mut count = 0; 'count_up: loop{ println!(\"{count}\"); let mut remaining = 10; loop{ if remaining==9 { break; } if count==2 { break 'count_up; } remaining -= 1; println!(\"{remaining}\"); } count += 1; } } for与python的for写法一样 rust fn main(){ let a = [10,20,30,40,50,60]; for element in a{ println!(\"{element}\"); } } 想要指定循环次数或者其它有关循环的高级功能可以使用rust的range库 while与C的while相同，但是判断条件同样不应使用()括起来 ","date":"2024-12-15","objectID":"/posts/rust/:2:4","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#for"},{"categories":["Tech"],"content":" 控制流（逻辑表达式） if表达式使用if表达式无论是否使用else if的多重分支都需要将分支语句用花括号括上，并且判断条件不应使用()包括起来 rust fn main() { let num = 3; if num \u003c 4 { //不可省略花括号 println!(\"num\u003c4\"); } else { println!(\"num\u003e4\"); } } 注意: if表达式的condition必须为bool变量，否则报错 rust fn main() { let x = 1; //x不是bool变量，会报错 let y = if x {0} else {1}; println!(\"{y}\"); } 循环语句 looploop是一个死循环，只能从break处跳出循环 break 表达式就返回值 rust fn main() { let mut counter = 0; let result = loop { counter += 1; if counter==10{ break counter * 2; } } println!(\"{result}\"); } 使用break还可以跳转到标签处，标签写法: ’label: loop rust fn main() { let mut count = 0; 'count_up: loop{ println!(\"{count}\"); let mut remaining = 10; loop{ if remaining==9 { break; } if count==2 { break 'count_up; } remaining -= 1; println!(\"{remaining}\"); } count += 1; } } for与python的for写法一样 rust fn main(){ let a = [10,20,30,40,50,60]; for element in a{ println!(\"{element}\"); } } 想要指定循环次数或者其它有关循环的高级功能可以使用rust的range库 while与C的while相同，但是判断条件同样不应使用()括起来 ","date":"2024-12-15","objectID":"/posts/rust/:2:4","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#while"},{"categories":["Tech"],"content":" 所有权为了能够更好的理解所有权的概念，这里现介绍一下字符串的类型，因为字符串在某些情况下是存储在堆上的，而这就会导致各种各样的bug(参考C++的string) ","date":"2024-12-15","objectID":"/posts/rust/:3:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#所有权"},{"categories":["Tech"],"content":" 字符串类型中文社区的图片清晰的指出了字符串和切片类型的区别 字符串类型远比其它类型要复杂，它首先要处理两种情况: 不可修改的字面量类型 可修改的String类型 两种需求决定了不同的处理方式: 字面量类型由于其不可修改，因此被硬编码到可执行文件里并充分发挥其速度快的优势 当需要用户手动输入字符串时，这就需要在堆上开辟一段内存，因此需要使用String::from来将不可变的字面量转换为可变的堆上的对象 为了能够综合利用两种方式的优点，rust规定str类型既可以存储在堆上也可以硬编码到文件里，而前者为了兼容后者，str必须是动态类型的(DST)，而想要使用动态类型就必须使用指针(在字符串中为引用)，这样，即使是硬编码的字符串也必须使用引用来获取。对于String类型则单指存储在堆上的字符串，它也使用引用的方式来获取来避免字符串移动后丢失对象，这样我们常见的字符串都是引用类型的，而最初的字符串str类型则不常见 当使用String后，拥有GC的语言会自动执行清理。而rust通过编译器执行这一切 一个String由三部分组成: 指向内容的指针 长度(当前长度) 容量(最大可获取长度) 而一个\u0026str则由两部分组成: 指向内容的指针 长度(当前长度) 因为切片不管理内存，而String还要管理内存的申请和释放(DST类型的特点) ","date":"2024-12-15","objectID":"/posts/rust/:3:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#字符串类型"},{"categories":["Tech"],"content":" 所有权的基本概念所有权是一组规则，用于控制rust程序如何管理内存 rust的基本目标: 消除程序中所有的未定义行为 rust的次要目标: 在编译时而不是运行时消除程序中所有的未定义行为 rust提供了类似heap的东西，被称为box，其原理类似C++的移动语义或移动构造函数: 仅仅掌握这块内存地址的指针，而不掌握这块内存地址，这在拷贝数据时会节省开销 rust不允许手动管理(释放)box上的堆内存数据，而是由rust本身进行管理，这样就保证了程序的正确性，但是可以通过所有权系统制造例外 这个例外的发生与C++析构函数发生的错误很类似: 一个变量绑定到box上，当这个变量的栈帧被销毁时同时也会将这个box销毁，但我们并不清楚在下文是否有程序会读取写入这个box，或者再次释放这个box，这就引出了所有权的概念 当一个heap数据的所有权从x转移到y时，原来的x就不能被使用了(防止double free或访问非法内存)，因此当所有权发生移动时访问原变量会导致编译错误 下面的代码尽管不会进入if分支，但是编译器会进行更严格的检查，因此编译不会通过 rust fn main() { let s = String::from(\"hello world\"); let s2; let b = false; if b { s2 = s; } println!(\"{}\", s); } 引用是没有获取所有权的指针 下面的代码在进行函数调用时会产生所有权移动(box作为函数参数会复制一份，返回时所有权会转移到full) rust fn main() { let first = String::from(\"Ferris\"); let full = add_suffix(first); println!(\"{full}\"); } fn add_suffix(mut name: String) { name.push_str(\"Jr.\"); name } 实现了copy trait的类型在函数调用时会传入副本，函数在返回时也会发生所有权的转移 引用的规则(借用规则)： 只能满足下列条件之一 一个可变的引用 任意多个不可变的引用 引用必须一直有效 引用时不会发生所有权的转移，我们把引用作为函数参数的情况称为借用 尽管变量是以指针的形式传过来的，但是在子函数中能够直接获取原值，而非二次解引用 rust fn main() { let m1 = String::from(\"hello\"); let m2 = String::from(\"world\"); println!(\"m1:{m1}\"); println!(\"m1 addr:{:p}\",\u0026m1); greet(\u0026m1,\u0026m2); } fn greet(g1:\u0026String, g2:\u0026String) { println!(\"{},{}\",g1,g2); let addr_in_g1 = g1 as *const String; println!(\"{g1}\"); println!(\"g1 content:{:p}\",addr_in_g1); println!(\"g1 addr:{:p}\",\u0026g1); } println!宏内部会自动实现解引用，因此即使我们传入的是指针或指针的指针，只要不明确打印的格式为指针类型，我们在屏幕上看到的结果就是指针最终指向的值 rust经常会自动进行隐式解引用，以至于我们不会经常看到* len(\u0026s)写为s.len()是一种语法糖，因为s变量无需其它操作就可以获取自身地址 别名和可变性不可同时存在: 也就是借用规则，C++为了解决这个问题使用了智能指针来解决问题 别名: 通过不同变量访问同一块内存 box就是受别名和可变性不可同时存在这种规则影响的产物，box规定了每片内存区域只能被一个box占用，因为box内存实现类似于\u0026mut T，因此其它任何变量都不能通过别名访问，只能通过box这一媒介来访问原内存，并且box这种权限是独占的，只能被转移到其它box上。这样: box不能别名，只能移动所有权 rust编译器通过借用检查器确保类型安全 变量对内存中的数据有三种权限: 读(R): 数据可以被复制到另一个位置 写(W): 数据可以被修改 拥有(O): 数据可以被移动或释放 上述权限不在内存中存在，仅存在于编译器中 默认情况下，变量对内存的数据有RO权限，加上mut后还具有W权限 ，但引用可以临时移除这些权限 为了类型安全，rust在引用方面也做了特殊设置: rust let x = 0; let mut x_ref = \u0026x; //此时，x_ref有写的权限，但是*x_ref没有写的权限，也就是说，x_ref的指向可以被改变，但是指向的值也就是x不可被改变 通过上面的学习发现: 权限与变量强绑定，或者更确切地说，权限与左值强绑定 还需要值得注意的是，当一块内存区域被别名了，此时连最初的box或者其它有写权限的变量也会失去写权限，但是我们可以通过可变引用来实现对原数据的修改，但修改变量时，最初的变量或box都失去了全部权限(包括R权限) 引用会使数据失去WO权限，可变引用会使数据失去RWO权限 在函数输入输出时会产生另外一种权限: 流动权限(F)，这种权限只在函数接受参数以及返回值返回时才产生，并且在函数体内不会发生变化 随着所有权的到来紧接着就会引入生命周期的问题，在比较复杂的情况中，所有权的并不是很容易被编译器推断出来，因此我们需要使用生命周期参数来指明左值的生命周期 尽管第八行的引用是不可变的，在执行完第八行后会发生两件事: 将name的写权限去除 将name.0的写权限去除并转移给first 做完上述两件事后name.1的写权限是保留的，也就是说我们无法对name整个数据进行写操作，但是我们可以对name.1进行写操作 但是上面的代码就不对了，因为在调用函数时，rust会检查函数签名，它发现name.0和name.1都被作为参数调用了，那么在调用后它就会去除作为函数参数的name.0，name.1的写权限，直至first被使用完毕，因此在first未被使用时再对name进行其它操作会出现权限问题。当然，这个问题的根本原因是rust编译器不够聪明，它只能通过函数签名来猜测函数中到底借用了谁，而不能实际检测出参数是否真的被借用了，例如这个例子中只有name.0被借用，因此在未来随着编译器的发展，这行代码可能不会报错 第5行代码发生了可变的引用，因此在第5行执行完毕后，a会失去全部权限，因此假如将第9，10行代码取消注释就会报错 ","date":"2024-12-15","objectID":"/posts/rust/:3:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#所有权的基本概念"},{"categories":["Tech"],"content":" 深浅拷贝上述情况都是在浅拷贝的背景下产生的种种问题与对应的解决方案，而关于深拷贝，rust并没有实现这点(rust认为浅拷贝是非常符合效率的做法)。如果真的需要深拷贝，我们需要自行实现对应数据类型的clone方法(copy负责浅拷贝) copy内部实现的是按位复制，行为类似于c的memcpy。因此在复制的过程中复制的指针会指向原对象指向的内存，且不会将原对象指向的内存一起拷贝，所以copy是浅拷贝。而实现深拷贝需要修改复制出来的的指针，并同时将指针指向的对象也一同拷贝 注意: 如果类型实现了copy trait，那么就不能实现drop trait，因为copy发生时操作是隐式的而drop是自动调用的，因此有了深拷贝后编译器就不知道该何时执行drop 拥有copy trait的类型: 所有基础类型 元组内所有类型均可copy trait，那么该元组就实现了copy trait (i32,i32) 实现 (i32,String) 未实现(String未实现copy trait) ","date":"2024-12-15","objectID":"/posts/rust/:3:3","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#深浅拷贝"},{"categories":["Tech"],"content":" 切片在rust中，任何切片类型的大小都是动态的，因而只能通过引用来使用切片 切片的类型常见的有字符串切片和数组切片两种 字符串切片: str 数组切片: [i32] 数组切片没有指定数组长度，因此是动态类型大小的，而字符串也没有包含类型大小的信息(你无法知道这个字符串(str)储存的是\"abc\"(String)还是\"hello\"(String))，所以我们需要一个胖指针来储存地址信息和长度信息，这就是切片的引用。实际上，我们更常使用切片的引用，于是我们常把切片的引用简称为切片 综上所述，下面的代码编译会有问题，因为我们指定的类型柄不包含长度信息 rust let s3:\u0026str= \"banana\"; let arr:[i32] = [1, 2, 3, 4, 5]; 而下面的代码就没有问题，因为\"banana\"会被编译器推断为\u0026str类型，该胖指针包含长度信息，[1, 2, 3, 4, 5]会被编译器推断为[i32; 5]类型，显式包含了长度信息，因此该程序没有问题 rust let s3 = \"banana\"; let arr = [1, 2, 3, 4, 5]; 还有一种包含长度的切片写法如下 rust let arr = [1, 2, 3, 4, 5]; let slice: \u0026[i32] = \u0026arr[1..4]; // slice 包含值 [2, 3, 4] 切片不仅仅用于字符串，还可以用于数组，元组等数据类型 切片有多种表示方法(range语法): \u0026s[..]代表全部字符串的切片 \u0026s[..4]代表从s[0]到s[3]的切片 \u0026s[2..]代表从s[2]到字符串末尾的切片 对字符串进行切片是非常危险的操作，必须严格控制切片到字符边界上 字符串的字面值是切片，例如let s = “hello world”; 但是此时s的类型是\u0026str，它是指向二进制文件特定位置的切片，因此字符串字面量是不可变的 ","date":"2024-12-15","objectID":"/posts/rust/:4:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#切片"},{"categories":["Tech"],"content":" self与Self rust trait Draw { fn draw(\u0026self) -\u003e Self; } #[derive(Clone)] struct Button; impl Draw for Button { fn draw(\u0026self) -\u003e Self { return self.clone() } } fn main() { let button = Button; let newb = button.draw(); } 上述代码中，self指代的就是当前的实例对象，也就是button.draw()中的button实例，Self则指代的是Button类型 通过上面的例子我们可以知道：self调用实例方法，而Self只能调用关联函数 rust let v= Vec::new(); //Self调用关联函数 v.pop(); //调用实例方法 Self不仅指代类型，还可以指代trait或方法 ","date":"2024-12-15","objectID":"/posts/rust/:5:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#self与self"},{"categories":["Tech"],"content":" 结构体结构体的定义方式: rust struct UserStruct{ active:bool, username:String, num:u64, } 上面的username存储了字符串的原数据，例如胖指针，容量等内容，而字符串保存在堆上面。对于String类型，即使原始文本来自于硬编码的只读文本，该文本也会被拷贝到堆中 我们再思考一个更深入地问题：为什么这里的username是String类型而不是\u0026str类型？这是因为String类型更适合于长度动态变化的，运行期难以确定的字符串，而\u0026str适合于硬编码进文件的，长度固定的字符串。因此这里选择了String类型作为切片 struct赋值的简便写法: rust let mut user = User{ email:String::from(\"@email.com\"), username:String::from(\"name\"), active:true, num:3, }; let mut user2 = User{ num:4, ..user }; ..user代表除了显式赋值的字段(num:4)，其他结构体成员的值都与user相同 还有一种struct被称为tuple struct: 它没有像struct那样的字段，定义的形式类似truple rust struct Color(i32,i32,i32) 无字段的struct可以实现trait: rust struct AlwaysEqual; fn main() { let subject = AlwaysEqual; } 上面代码的含义是：定一个零大小类型AlwaysEqual，该类型在编译后不会占用内存，多用于标记类型标记或占位符(如常见标记泛型的_marker: PhantomData\u003cT\u003e)，trait类型等情况。而let subject = AlwaysEqual;代表创立一个AlwaysEqual实例，将其绑定到subject 与元组一样，当借用了结构体的某一元素时会影响结构体整体的权限，但不会影响结构体其它元素的权限 rust struct Point{x:i32,y:i32}; fn prt(p: \u0026Point) { println!(\"{}\",p.x); } fn main() { let mut p = Point{x:0, y:0}; let px = \u0026mut p.x; p.y += 1; //这里是有权限的 *px+=1; } 作为著名的类型体操专家，rust采用了将方法绑定到类型上面的方案，我们使用impl来实现struct的方法 rust struct Rectangle{ width:u32, height:u32, } impl Rectangle{ fn new() -\u003e Rectangle{ Rectangle{width:0,height:0} } fn area(\u0026self) -\u003e u32{ //这里返回值类型不能省略，编译器不能自行推断 self.height*self.width } fn can_hold(\u0026self,other:\u0026Rectangle) -\u003ebool{ self.height\u003eother.height \u0026\u0026 self.width\u003eother.width } fn square(size:u32) -\u003e Self{ //参数不是self的方法被称为关联方法 Self{ width:size, height:size, } } } fn main() { let rect1 = Rectangle{ width:1, height:3, }; let rect2 = Rectangle{ width:2, height:4, }; println!(\"{}\",rect1.can_hold(\u0026rect2)); println!(\"{}\",Rectangle::can_hold(\u0026rect1, \u0026rect2)); //是上一行的语法糖 } 注意: 方法第一个参数永远是self/\u0026self，而函数则没有要求，对于那些没有参数的函数或参数不包含\u0026self或self的函数，例如上面的new和square函数，我们不能使用\".“调用，只能使用”::“调用，因此不能称之为方法。我们将这种没有参数的函数称为关联函数(与结构体关系密切) 对于这些关联函数(即不需要实例化对象就可以调用的方法，如Vec::new())，我们需要使用::来调用 同时我们还应该注意所有权的问题: rust struct Rectangle { width: u32, height: u32, } impl Rectangle { fn area(\u0026self) -\u003e u32 { self.width * self.height } fn set_width(\u0026mut self, width: u32) { self.width = width; } fn max(self, other: Self) -\u003e Self { let w = self.width.max(other.width); //调用u32的max方法 let h = self.height.max(other.height); Rectangle { width: w, height: h } } fn set_to_max(\u0026mut self, other: Rectangle) { *self = self.max(other); //注意这里 } } *self = self.max(other);在执行max方法时发生了所有权的移动，因此在赋值给*self时就会缺失写权限导致编译错误 ","date":"2024-12-15","objectID":"/posts/rust/:6:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#结构体"},{"categories":["Tech"],"content":" 枚举rust中的枚举会按照占用内存的最大那个成员对齐，且同一时间只能存储一个变体，类似C的union 枚举内有不同的变体，每个变体绑定了不同的数据类型: rust enum IpAddrKind{ V4(u8,u8,u8,u8), V6(String), } fn main() { let home = IpAddrKind::V4(127,0,0,1); let loopback = IpAddrKind::V6(String::from(\"::1\")); } impl IpAddrKind{ fn call(\u0026self){ } } 上述写法等同于下面的 rust enum IpAddrKind{ V4, V6, } fn main() { struct IpAddr{ kind:IpAddrKind, adress:String, } //为了实现IpAddr结构体，必须根据IpAddrKind内部变体的类型分别实现 let home = IpAddr{ kind:IpAddrKind::V4, //V4变体 address:String::from(\"127.0.0.1\"), } let loopback = IpAddr{ address:IpAddrKind::V6, //V6变体 address:String::from(\"::1\"), } } impl IpAddrKind{ fn call(\u0026self){ } } 前者写法的优势在于当每个枚举都需要若干方法时，不必给每个变体都写一份，因为V4，V6变体是类似的，仅仅是类型不同，如果给每个变体实现一份方法就会增加重复代码。并且后者不仅仅在方法的实现上冗余，就连结构体的实现上也会冗余 ","date":"2024-12-15","objectID":"/posts/rust/:7:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#枚举"},{"categories":["Tech"],"content":" 特殊的枚举在rust中，使用None代表空指针 rust enum Option\u003cT\u003e{ None, Some\u003cT\u003e, } 使用Option\u003cT\u003e类型时需要强制实现T为None情况的异常处理(在C语言中就是空指针判断和处理)，只有实现了异常处理，Option\u003cT\u003e才会退化为Some\u003cT\u003e也就是T类型 ","date":"2024-12-15","objectID":"/posts/rust/:7:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#特殊的枚举"},{"categories":["Tech"],"content":" 模式匹配与绑定模式是rust的一种特殊语法，用于匹配各种结构 将模式与匹配表达式和其它构造结合使用，可以更好的控制程序流 最简单的模式匹配就是let a = 1;类似这种的模式匹配就是无可辩驳的，这种操作不会产生其它情况。但如果是let Some(x) = Some(5);就是可辩驳的，因为 Some(x) 只能匹配 Some 类型的值，对于 None 就无法匹配，可能导致运行时出错。如果将一个不可辩驳的模式匹配到可辩驳的模式，编译器就会发出警告，因为它认为这是不必要的 下面的代码会令人迷惑： rust fn main() { let x = Some(10); let y = 20; match x { Some(5)=\u003eprintln!(\"5\"), Some(y)=\u003eprintln!(\"y = {}\",y), _=\u003eprintln!(\"0\"), } } 输出结果为y = 10。为什么会出现这样的结果？原因在于match会遮蔽外部变量，这里match表达式的作用是绑定，因此Some(y)会跟传入的Some(10)进行绑定。rust这样设计的原因在于防止外部值隐式的对match内部造成影响，为了能够获取并比较外部值，我们必须显式的指出比较的对象 rust let y = 10; match x { Some(n) if n == y =\u003e println!(\"Equal to y\"), Some(n) =\u003e println!(\"Not equal: n = {}\", n), None =\u003e println!(\"None\"), } match中可以使用”|“符号代表逻辑或进行模式匹配，还可以使用”..=“来匹配范围(闭区间)或者”..\"(开区间)，而\"_“代表任意值 注意，使用_name可以让编译器忽略name没有被使用的警告，例子如下 rust fn main() { let _unused_value = 42; } 该代码不会出现未使用变量的警告，但是下面的就会有警告 rust fn main() { let unused_value = 42; } 模式匹配还可以使用数据结构来获取值 rust struct Point{ x:i32, y:i32, } fn main() { let p = Point{x:3,y:5}; let Point{x,y} = p; } ","date":"2024-12-15","objectID":"/posts/rust/:8:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#模式匹配与绑定"},{"categories":["Tech"],"content":" match表达式match表达式必须将所有情况都考虑在内，即必须穷尽所有情况，并且每个分支的返回值必须相同 match可以使用变量来表示其它情况 rust let var:u8 = 3; match var{ 1=\u003edo_something(), 4=\u003edo_anything(), other=\u003edo_the_one_thing(), //也可以换成其它变量 } fn do_something(){ } fn do_anything(){ } fn do_the_one_thing(){ } 上面的代码没有用到other变量，因此编译器会提出警报，为了避免这种情况发生，可将代码改成如下形式: rust match var{ 1=\u003edo_something(), 4=\u003edo_anything(), _=\u003edo_the_one_thing(), //也可以换成其它变量 } 如需要other作为参数也可改成: rust other=\u003edo_the_one_thing(other), 当与所有权发生联系时: rust let opt:Option\u003cString\u003e = Some(String::from(\"hello world\")); match opt { Some(s) =\u003e println!(\"{}\",s), None =\u003e println!(\"None\"), } println!(\"{:?}\",opt); 上述代码会报错，因为s在打印完成后其本身就被移动了，再次打印opt就会产生错误 造成所有权发生移动的原因是，match的核心作用是绑定，因此执行Some分支语句后opt指向的资源就被s移动/复制了，但由于String位于堆上，本身没有实现copy trait，因此只能执行移动语义，这样opt就丧失RWO所有权限。为了避免这种情况，我们可以让s以只读的方式进行绑定，若想改正，只需在opt前加入\u0026 rust let opt:Option\u003cString\u003e = Some(String::from(\"hello world\")); match \u0026opt { Some(s) =\u003e println!(\"{}\",s); None =\u003e println!(\"None\"); } println!(\"{:?}\",opt); 如果想进行更复杂的匹配可以使用match guard进行约束 rust let opt:Option\u003cString\u003e = Some(String::from(\"hello world\")); match \u0026opt { Some(s) if s.len() \u003c 5 =\u003e println!(\"{}\",s); //match guard _ =\u003e println!(\"_\"); //这里汇集了len\u003e5和opt为None的情况，因此只能使用_ } println!(\"{:?}\",opt); ","date":"2024-12-15","objectID":"/posts/rust/:8:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#match表达式"},{"categories":["Tech"],"content":" if let相比match表达式，if let只能匹配一种情况 rust let max:u8; let config = Some(3u8); if let Some(max) = config { //不是==号 println!(\"{}\",max); } else{ println!(\"None\"); } ","date":"2024-12-15","objectID":"/posts/rust/:8:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#if-let"},{"categories":["Tech"],"content":" 项目代码组织crate是组织和共享代码的基本构建块，也是rust编译时的基本单元 binary crate: 可执行的，需要main函数 library crate: 不可执行的，没有main函数。是为了定义一些功能以共享使用 crate root: 编译crate的入口点 binary crate: src/main.rs library crate: src/lib.rs package: 由一个或多个crates组成，包含cargo.toml文件 package规则: 可有多个binary crates 最多只能有一个library crate 最少由一个crate组成 module: 将代码组织成更小更易管理的单元的办法 也就是说一个crate包含若干个文件，内部接口以module方式提供，例如math algorithm crate包含add module，sub module。而一个package可以包含多个crate，例如math package包括math algorithm crate和math cli crate等等 导入模块: rust mod mod_name; 通常rust会在以下路径寻找模块 rust // 内联模块：在当前文件中使用 `mod` 关键字定义模块体 mod mod_name { // 模块内容 } // 独立模块文件：Rust 会在 `src/mod_name.rs` 中查找 `mod mod_name;` // 模块子目录：Rust 也会在 `src/mod_name/mod.rs` 中查找 `mod mod_name;` 子模块的创建方法: 在src下新建文件夹(一般命名为models)，之后在这个文件夹下新建文件，文件名为子模块的模块名。之后在父模块中导入模块即可(类似上文的第三种建立模块的方式) 新建模块默认权限为私有，想要调用其子模块的函数，需要将子模块，子模块的函数变为公有权限，对于枚举而言，定义时在enum前加pub就可以访问枚举内所有变体。但是在struct内，我们不仅需要在struct前加pub，还需要在内部成员前加pub才能访问到其成员，这样做的原因是保证只暴露接口，不暴露数据 rust src/main.rs fn main() { crate::m1::m2::fun1(); //绝对路径访问方式 } src/models.rs mod m1{ pub mod m2{ pub fn fun1(){ } } } mod x1{ mod x2{ fn fun2(){ super::super::m1 //相对路径访问方式，想要返回上一级应该使用super } } } main能够访问到m1的原因是main与m1同级 在 binary crate 中访问 library crate 中的内容，路径的格式通常如下： rust 包名::模块路径::项名 //例如 my_crate::submodule::some_function(); 其中： my_crate 是 library crate 的包名（即 Cargo.toml 中的 name 字段） submodule 是 library crate 中的模块路径（可以是文件或文件夹） some_function 是你想要访问的函数、结构体或常量等项 所有的东西(function methods structs enum modules)默认对父模块都是私有的 为了避免模块命名空间重复，可以使用as给引用起别名 rust use std::fmt::Result; use std::io::Result as IoResult; 在cargo.toml中，package(项目)是项目本身的信息，包含name，version，authors，edition(rust版本)等字段。而dependencies是项目依赖的信息，包含外部包(crate)，外部crate等信息。下面是例子 toml [package] name = \"my_project\" # 项目名称，对应 crate 名 version = \"0.1.0\" # 项目版本 edition = \"2021\" # Rust 语言版本（edition） authors = [\"Your Name \u003cyou@example.com\u003e\"] [dependencies] rand = \"0.8\" # 添加外部 crate 'rand'，版本号为 0.8 serde = { version = \"1.0\", features = [\"derive\"] } # 启用特性的依赖项 单纯的使用mod关键字引入模块只能以绝对路径/相对路径的路径全名的方式使用模块，但是使用use关键字后就不必输入路径全名引入模块了，这与C++的use和Python的import很相似 rust mod tools; // ❌ 不使用 use，每次调用都要写完整路径： fn main() { tools::helper::echo(); } //使用use简化 mod tools; use tools::helper::echo; fn main() { echo(); // 简洁 } ","date":"2024-12-15","objectID":"/posts/rust/:9:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#项目代码组织"},{"categories":["Tech"],"content":" 常见的集合","date":"2024-12-15","objectID":"/posts/rust/:10:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#常见的集合"},{"categories":["Tech"],"content":" vectors创建vector: rust let v:Vec\u003ci32\u003e = Vec::new(); //使用方法创建 let v:Vec\u003ci32\u003e = vec![1,2,3]; //使用宏创建 获取vector rust fn main() { let mut v = Vec::new(); v.push(1); v.push(2); v.push(3); v.push(4); //let v1 = \u0026v[2]; let v2 = v.get(2); match v2 { Some(v2)=\u003eprintln!(\"{:?}\",v2), None=\u003eprintln!(\"None\"), } } 使用get方法获取vec时，返回值为Option\u003cT\u003e类型，我们还需要match一下，这是为了保证安全性 更进一步，如果这里访问的是v.[100]，此时如果使用地址访问会导致程序panic，使用get方法会返回None，这就是两种方法的最大的不同 访问修改vec通常有两种方法: 迭代器和range方法 rust //iterator let mut v: Vec\u003ci32\u003e = vec![1,2]; let mut iter: std::slice::Iter\u003c'_, i32\u003e = v.iter(); let n1: \u0026i32 = iter.next().unwrap(); let n2: \u0026i32 = iter.next().unwrap(); let end: Option\u003c\u0026i32\u003e = iter.next(); //range let mut range: Range\u003cusize\u003e = 0..v.len(); //这里获取的是数组的下标的范围 let i1: usize = range.next().unwrap(); let n1: \u0026i32 = \u0026v[i1]; next方法返回的是Option\u003c\u0026i32\u003e类型，unwrap方法会自动帮我们进行match，去除None的结果，最后返回的就是vec元素的引用 len方法返回的Range\u003cusize\u003e类型，unwarp后获得的是索引 vector与所有权当新push的元素大于vector容量时内存就会重新分配，这时原vector所有权就被移动到新vector上，这一点和DTL的vector也很相似 ","date":"2024-12-15","objectID":"/posts/rust/:10:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#vectors"},{"categories":["Tech"],"content":" vectors创建vector: rust let v:Vec = Vec::new(); //使用方法创建 let v:Vec = vec![1,2,3]; //使用宏创建 获取vector rust fn main() { let mut v = Vec::new(); v.push(1); v.push(2); v.push(3); v.push(4); //let v1 = \u0026v[2]; let v2 = v.get(2); match v2 { Some(v2)=\u003eprintln!(\"{:?}\",v2), None=\u003eprintln!(\"None\"), } } 使用get方法获取vec时，返回值为Option类型，我们还需要match一下，这是为了保证安全性 更进一步，如果这里访问的是v.[100]，此时如果使用地址访问会导致程序panic，使用get方法会返回None，这就是两种方法的最大的不同 访问修改vec通常有两种方法: 迭代器和range方法 rust //iterator let mut v: Vec = vec![1,2]; let mut iter: std::slice::Iter\u003c'_, i32\u003e = v.iter(); let n1: \u0026i32 = iter.next().unwrap(); let n2: \u0026i32 = iter.next().unwrap(); let end: Option\u003c\u0026i32\u003e = iter.next(); //range let mut range: Range = 0..v.len(); //这里获取的是数组的下标的范围 let i1: usize = range.next().unwrap(); let n1: \u0026i32 = \u0026v[i1]; next方法返回的是Option\u003c\u0026i32\u003e类型，unwrap方法会自动帮我们进行match，去除None的结果，最后返回的就是vec元素的引用 len方法返回的Range类型，unwarp后获得的是索引 vector与所有权当新push的元素大于vector容量时内存就会重新分配，这时原vector所有权就被移动到新vector上，这一点和DTL的vector也很相似 ","date":"2024-12-15","objectID":"/posts/rust/:10:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#vector与所有权"},{"categories":["Tech"],"content":" string创建string rust let mut s = String::new(); let data = \"hello\"; let s2 = data.to_string(); let s3 = \"hello\".to_string(); let s4 = String::from(\"hello\"); to_string方法会将字面量转为字符串变量 相比String::from，to_string语义不是很明确(因为String::from有类似的Vec::from、Box::from)，并且to_string底层也调用了String::from，因此to_string效率没有String::from高 连接string rust let mut s = String::from(\"hello\"); s.push_str(\"world\"); println!(\"{s}\"); s.push('!'); println!(\"{s}\"); push_str可以连接字符串，push只能连接字符 还可以使用”+“连接字符串 rust let s1 = String::from(\"hello\"); let s2 = String::from(\"world\"); let s3 = s1 + \u0026s2; println!(\"{s3}\"); 使用”+“会使s1丧失所有权，之后s1就不能使用了。链接字符串语法不设计成let s3 = s1 + s2;的原因是未使用\u0026修饰的字符串的所有权会被移动，这样能够避免复制带来的性能损耗，使用\u0026修饰的字符串会保留所有权，防止所有权被移动。这样在连接后的字符串的所有权就可以转移到使用\u0026修饰的字符串了。如果语法被设计为let s3 = s1 + s2;就无法保证字符串的所有权。还需要注意的是，我们也不能写为let s3 = \u0026s1 + s2;，因为标准库中没有实现 如果想要保留所有权的话可以使用clone rust let s1 = String::from(\"hello\"); let s2 = String::from(\"world\"); let s3 = s1.clone() + \u0026s2; // 显式克隆 s1 println!(\"{s3}\"); rust不允许使用下标的方式去索引string内部的元素。由于string是使用vec\u003cu8\u003e将unicode编码包装而成的，而各国文字编码的长度不完全一致。例如应对字母使用单字节编码，汉字使用2或3个字节编码，这样如果允许使用下标的方式去索引string内部的元素就会导致访问元素会返回不同的u8的值，而这并不是我们想看到的 获取字节或字符 rust //单个unicode标量值 for c in \"你好\".chars(){ println!(\"{c}\"); } //存储在计算机中的字节 for b in \"你好\".bytes(){ println!(\"{b}\"); } string与所有权与vector类似，当新push的元素大于string容量时会发生内存重新分配，这时原string所有权就被移动到新string上 string的内部结构 rust pub struct String { vec: Vec\u003cu8\u003e, } ","date":"2024-12-15","objectID":"/posts/rust/:10:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#string"},{"categories":["Tech"],"content":" string创建string rust let mut s = String::new(); let data = \"hello\"; let s2 = data.to_string(); let s3 = \"hello\".to_string(); let s4 = String::from(\"hello\"); to_string方法会将字面量转为字符串变量 相比String::from，to_string语义不是很明确(因为String::from有类似的Vec::from、Box::from)，并且to_string底层也调用了String::from，因此to_string效率没有String::from高 连接string rust let mut s = String::from(\"hello\"); s.push_str(\"world\"); println!(\"{s}\"); s.push('!'); println!(\"{s}\"); push_str可以连接字符串，push只能连接字符 还可以使用”+“连接字符串 rust let s1 = String::from(\"hello\"); let s2 = String::from(\"world\"); let s3 = s1 + \u0026s2; println!(\"{s3}\"); 使用”+“会使s1丧失所有权，之后s1就不能使用了。链接字符串语法不设计成let s3 = s1 + s2;的原因是未使用\u0026修饰的字符串的所有权会被移动，这样能够避免复制带来的性能损耗，使用\u0026修饰的字符串会保留所有权，防止所有权被移动。这样在连接后的字符串的所有权就可以转移到使用\u0026修饰的字符串了。如果语法被设计为let s3 = s1 + s2;就无法保证字符串的所有权。还需要注意的是，我们也不能写为let s3 = \u0026s1 + s2;，因为标准库中没有实现 如果想要保留所有权的话可以使用clone rust let s1 = String::from(\"hello\"); let s2 = String::from(\"world\"); let s3 = s1.clone() + \u0026s2; // 显式克隆 s1 println!(\"{s3}\"); rust不允许使用下标的方式去索引string内部的元素。由于string是使用vec将unicode编码包装而成的，而各国文字编码的长度不完全一致。例如应对字母使用单字节编码，汉字使用2或3个字节编码，这样如果允许使用下标的方式去索引string内部的元素就会导致访问元素会返回不同的u8的值，而这并不是我们想看到的 获取字节或字符 rust //单个unicode标量值 for c in \"你好\".chars(){ println!(\"{c}\"); } //存储在计算机中的字节 for b in \"你好\".bytes(){ println!(\"{b}\"); } string与所有权与vector类似，当新push的元素大于string容量时会发生内存重新分配，这时原string所有权就被移动到新string上 string的内部结构 rust pub struct String { vec: Vec, } ","date":"2024-12-15","objectID":"/posts/rust/:10:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#string与所有权"},{"categories":["Tech"],"content":" hashmap创建hashmap rust let mut scores = HashMap::new(); scores.insert(String::from(\"blue\"), 10); scores.insert(String::from(\"red\"), 50); let vec = vec![(\"hello\",\"10\"),(\"world\",\"50\")]; let map:HashMap\u003c_, _\u003e = vec.into_iter().collect(); 访问hashmap rust let mut scores = HashMap::new(); scores.insert(String::from(\"blue\"), 10); let teamname = String::from(\"blue\"); let scores = scores.get(\u0026teamname).copied().unwrap_or(0); get方法返回Option\u003c\u0026v\u003e，copied方法会将\u0026v转换为v变成Option\u003cv\u003e，unwrap_or方法提取 Option\u003cT\u003e 或 Result\u003cT, E\u003e 中的值，如果值是 None 或 Err(e)，返回指定的默认值（不会 panic），而unwrap则会panic 遍历hashmap rust let mut scores = HashMap::new(); scores.insert(String::from(\"blue\"), 10); for (key,value) in \u0026scores { println!(\"{}:{}\",key,value); } hashmap与所有权对于实现copy trait的类型，hashmap会将数据拷贝到map里，对于没有实现的，会移动到map里 ","date":"2024-12-15","objectID":"/posts/rust/:10:3","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#hashmap"},{"categories":["Tech"],"content":" hashmap创建hashmap rust let mut scores = HashMap::new(); scores.insert(String::from(\"blue\"), 10); scores.insert(String::from(\"red\"), 50); let vec = vec![(\"hello\",\"10\"),(\"world\",\"50\")]; let map:HashMap\u003c_, _\u003e = vec.into_iter().collect(); 访问hashmap rust let mut scores = HashMap::new(); scores.insert(String::from(\"blue\"), 10); let teamname = String::from(\"blue\"); let scores = scores.get(\u0026teamname).copied().unwrap_or(0); get方法返回Option\u003c\u0026v\u003e，copied方法会将\u0026v转换为v变成Option，unwrap_or方法提取 Option 或 Result 中的值，如果值是 None 或 Err(e)，返回指定的默认值（不会 panic），而unwrap则会panic 遍历hashmap rust let mut scores = HashMap::new(); scores.insert(String::from(\"blue\"), 10); for (key,value) in \u0026scores { println!(\"{}:{}\",key,value); } hashmap与所有权对于实现copy trait的类型，hashmap会将数据拷贝到map里，对于没有实现的，会移动到map里 ","date":"2024-12-15","objectID":"/posts/rust/:10:3","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#hashmap与所有权"},{"categories":["Tech"],"content":" 错误处理我们把rust中产生的错误分成两类: 可恢复的和不可恢复的，同时rust没有异常这一概念 ","date":"2024-12-15","objectID":"/posts/rust/:11:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#错误处理"},{"categories":["Tech"],"content":" 不可恢复的错误panic!()宏就是不可恢复的错误 两种导致panic的方法: 显式调用panic 代码中某些行为导致panic panic之后会打印信息，unwind(展开stack，清理stack)/立即终止(让os来做清理工作) 究竟采用unwind还是立即终止取决于cargo.toml的配置 我们还可以在编译时指定环境变量RUST_BACKTRACE=full来指定backtrace也就是unwind的内容详细程度 ","date":"2024-12-15","objectID":"/posts/rust/:11:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#不可恢复的错误"},{"categories":["Tech"],"content":" 可恢复的错误我们常用Result来处理可恢复的错误 rust enum Result\u003cT,E\u003e { Ok(T), Err(E), } Ok的类型在不同情况下是不同的，对于文件访问而言，返回的是std::fs::File对应的handle，Err返回的是std::io::Error，其内部包含了具体的信息 ","date":"2024-12-15","objectID":"/posts/rust/:11:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#可恢复的错误"},{"categories":["Tech"],"content":" 出现错误时让程序panic的快捷方式unwarp: 用于将Option和Result的值提取出来，如果返回的值是Err或None的话就调用panic!，如果返回的值是Ok或Some的话，就会将返回该值 expect: 允许开发者提供自定义的信息(生产级别代码常用，因为便于调试) rust use std::fs::File; fn main() { let file = File::open(\"config.toml\") .expect(\"Failed to open config file. Make sure 'config.toml' exists.\"); println!(\"File opened successfully: {:?}\", file); } 由于unwarp不包含错误信息，很不利于调试，测试以及运维，因此官方书籍指明: 只有在十分确定某个函数不会panic时才可以调用unwarp ","date":"2024-12-15","objectID":"/posts/rust/:11:3","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#出现错误时让程序panic的快捷方式"},{"categories":["Tech"],"content":" 传播错误传播错误可以将错误返回给函数调用者来处理 rust use std::{fs::File, io::{self, Read}}; fn read_username_from_file() -\u003e Result\u003cString,io::Error\u003e{ let username_file_result: Result\u003cFile, io::Error\u003e = File::open(\"hello.txt\"); let mut username_file: File = match username_file_result { Ok(file)=\u003efile, Err(err)=\u003ereturn Err(err), //也可能从这返回 }; let mut username_str: String = String::new(); match username_file.read_to_string(\u0026mut username_str) { Ok(_)=\u003eOk(username_str), //_可以让编译器自动推断类型 Err(err)=\u003eErr(err), } //没有分号，match表达式的结果就是函数返回的结果 } 上述操作也可以使用?运算符来简化 rust fn read_username_from_file() -\u003eResult\u003cString,io::Error\u003e{ let mut username_file_result = File::open(\"hello.txt\")?; let mut username_str: String = String::new(); username_file_result.read_to_string(\u0026mut username_str)?; Ok(username_str) } ? 的工作原理几乎与match相同，如果调用的函数返回Ok的话就会解包Ok的值(对于本例就是文件操作符)，之后程序继续执行。如果返回的值是Err的话就会立即从本函数内返回，并将错误传播给上层调用者。因此使用?可以使代码避免大量的match语句从而变的更简洁 ? 与match仍有一些细微差别，当?遇到Err的返回值就会调用from函数，from函数会将下层函数返回的错误类型转换为本层函数的返回值的错误类型。也就是说，使用?后，错误类型会自动进行转换，但前提是必须有这种转换的过程: 通常情况下这个from定义在std的from trait上，但是我们也可以实现自己的from trait 上述例子还可以进一步简化 rust let mut username_str: String = String::new(); let mut username_file_result = File::open(\"hello.txt\")?.read_to_string(\u0026mut username_str)?; Ok(username_str) 虽然有些离题了，但是还可以进一步简化，这就是标准库提供的函数 rust fs::read_to_string(\"hello.txt\") 使用?运算符的条件: 由于? 作用的表达式返回一个 Result 或 Option 类型。因此当前函数的返回类型必须与该表达式的返回类型一致，或当前函数能通过 From / Into 特性将错误类型转换成自己的返回类型。如果返回值类型对应不上，则需要自行实现对应的返回类型 rust use std::fs::File; use std::io::{self, Read}; fn read_config() -\u003e Result\u003cString, io::Error\u003e { let mut file = File::open(\"config.toml\")?; // 如果失败，自动返回 Err let mut content = String::new(); file.read_to_string(\u0026mut content)?; // 同上 Ok(content) } 上述代码中，File::open 和 read_to_string 返回的是 Result\u003cT, io::Error\u003e，两者为同一类型，且与read_config返回值类型一致，因此可以使用? 若想要让下面代码编译通过 rust fn first(myarr: \u0026[i32]) -\u003e Result\u003cString, io::Error\u003e { myarr.myget(0)? } 必须保证myget方法的返回值为Result\u003cString, io::Error\u003e类型，如果myget的返回值为Option\u003c\u0026i32\u003e，就需要使用ok_or将Option\u003c\u0026i32\u003e显式转换为Result\u003cString, io::Error\u003e类型 rust use std::io; fn first(arr: \u0026[i32]) -\u003e Result\u003cString, io::Error\u003e { let value = arr.get(0).ok_or(io::Error::new(io::ErrorKind::Other, \"index out of bounds\"))?; Ok(format!(\"Value: {}\", value)) } ","date":"2024-12-15","objectID":"/posts/rust/:11:4","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#传播错误"},{"categories":["Tech"],"content":" 错误处理方法 map方法map 是一种容器上的变换的操作，它并不改变 Option 或 Result 的结构，而是在结构内的值存在时对其做变换，否则就保持原样。map支持按函数指针和闭包两种方式传参 与迭代器适配器类似，Option或Result使用map方法会产生一个新的Option或Result类型，并且这个类型会按照闭包的指示生成 rust fn main() { let s1 = Some(\"abcde\"); let s2 = Some(5); let n1: Option\u003c\u0026str\u003e = None; let n2: Option\u003cusize\u003e = None; let o1: Result\u003c\u0026str, \u0026str\u003e = Ok(\"abcde\"); let o2: Result\u003cusize, \u0026str\u003e = Ok(5); let e1: Result\u003c\u0026str, \u0026str\u003e = Err(\"abcde\"); let e2: Result\u003cusize, \u0026str\u003e = Err(\"abcde\"); let fn_character_count = |s: \u0026str| s.chars().count(); assert_eq!(s1.map(fn_character_count), s2); // Some(\u0026str) 映射后变为 Some(usize) assert_eq!(n1.map(fn_character_count), n2); // None 映射后仍是 None，不执行闭包 assert_eq!(o1.map(fn_character_count), o2); // Ok(\u0026str) 映射后变为 Ok(usize) assert_eq!(e1.map(fn_character_count), e2); // Err 跳过映射，保持不变 } 当 n1 是 Some 类型的值时，map 会调用闭包，并将 Some 中的值作为参数传入闭包，返回一个新的 Option 类型（Some 中的值被替换为闭包的返回值） 如果 n1 是 None，则不会调用闭包，直接返回 None，即保留原结构 当 o1 是 Ok 类型的值时，map 会调用闭包，并将 Ok 中的值作为参数传入闭包，生成一个新的 Result 类型（Ok 中的值被闭包的返回值替换） 如果 o1 是 Err，则不会调用闭包，直接返回原封不动的 Err map_or_else和map_or方法两者都在map基础上提供了默认值，但是前者通过闭包提供，后者通过变量提供 我们在使用两者闭包时的参数传递都是隐式的，闭包参数来源于Some(T)，Ok(T)中的T，最终在标准库中map_or_else和map_or都会显式调用参数T，该过程由内部实现，此处不过多介绍 下面是map_or_else方法 rust fn main() { let s = Some(10); let n: Option\u003ci8\u003e = None; let fn_closure = |v: i8| v + 2; let fn_default = || 1; assert_eq!(s.map_or_else(fn_default, fn_closure), 12); // 如果是 Some，应用 `fn_closure`（10 + 2 = 12） assert_eq!(n.map_or_else(fn_default, fn_closure), 1); // 如果是 None，调用 `fn_default`（返回 1） let o = Ok(10); let e = Err(5); let fn_default_for_result = |v: i8| v + 1; // 闭包可以对 Err 中的值进行处理，并返回一个新值 assert_eq!(o.map_or_else(fn_default_for_result, fn_closure), 12); assert_eq!(e.map_or_else(fn_default_for_result, fn_closure), 6); } 下面是map_or方法 rust fn main() { const V_DEFAULT: u32 = 1; let s: Result\u003cu32, ()\u003e = Ok(10); let n: Option\u003cu32\u003e = None; let fn_closure = |v: u32| v + 2; assert_eq!(s.map_or(V_DEFAULT, fn_closure), 12); assert_eq!(n.map_or(V_DEFAULT, fn_closure), V_DEFAULT); } ","date":"2024-12-15","objectID":"/posts/rust/:11:5","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#错误处理方法"},{"categories":["Tech"],"content":" 错误处理方法 map方法map 是一种容器上的变换的操作，它并不改变 Option 或 Result 的结构，而是在结构内的值存在时对其做变换，否则就保持原样。map支持按函数指针和闭包两种方式传参 与迭代器适配器类似，Option或Result使用map方法会产生一个新的Option或Result类型，并且这个类型会按照闭包的指示生成 rust fn main() { let s1 = Some(\"abcde\"); let s2 = Some(5); let n1: Option\u003c\u0026str\u003e = None; let n2: Option = None; let o1: Result\u003c\u0026str, \u0026str\u003e = Ok(\"abcde\"); let o2: Result = Ok(5); let e1: Result\u003c\u0026str, \u0026str\u003e = Err(\"abcde\"); let e2: Result = Err(\"abcde\"); let fn_character_count = |s: \u0026str| s.chars().count(); assert_eq!(s1.map(fn_character_count), s2); // Some(\u0026str) 映射后变为 Some(usize) assert_eq!(n1.map(fn_character_count), n2); // None 映射后仍是 None，不执行闭包 assert_eq!(o1.map(fn_character_count), o2); // Ok(\u0026str) 映射后变为 Ok(usize) assert_eq!(e1.map(fn_character_count), e2); // Err 跳过映射，保持不变 } 当 n1 是 Some 类型的值时，map 会调用闭包，并将 Some 中的值作为参数传入闭包，返回一个新的 Option 类型（Some 中的值被替换为闭包的返回值） 如果 n1 是 None，则不会调用闭包，直接返回 None，即保留原结构 当 o1 是 Ok 类型的值时，map 会调用闭包，并将 Ok 中的值作为参数传入闭包，生成一个新的 Result 类型（Ok 中的值被闭包的返回值替换） 如果 o1 是 Err，则不会调用闭包，直接返回原封不动的 Err map_or_else和map_or方法两者都在map基础上提供了默认值，但是前者通过闭包提供，后者通过变量提供 我们在使用两者闭包时的参数传递都是隐式的，闭包参数来源于Some(T)，Ok(T)中的T，最终在标准库中map_or_else和map_or都会显式调用参数T，该过程由内部实现，此处不过多介绍 下面是map_or_else方法 rust fn main() { let s = Some(10); let n: Option = None; let fn_closure = |v: i8| v + 2; let fn_default = || 1; assert_eq!(s.map_or_else(fn_default, fn_closure), 12); // 如果是 Some，应用 `fn_closure`（10 + 2 = 12） assert_eq!(n.map_or_else(fn_default, fn_closure), 1); // 如果是 None，调用 `fn_default`（返回 1） let o = Ok(10); let e = Err(5); let fn_default_for_result = |v: i8| v + 1; // 闭包可以对 Err 中的值进行处理，并返回一个新值 assert_eq!(o.map_or_else(fn_default_for_result, fn_closure), 12); assert_eq!(e.map_or_else(fn_default_for_result, fn_closure), 6); } 下面是map_or方法 rust fn main() { const V_DEFAULT: u32 = 1; let s: Result = Ok(10); let n: Option = None; let fn_closure = |v: u32| v + 2; assert_eq!(s.map_or(V_DEFAULT, fn_closure), 12); assert_eq!(n.map_or(V_DEFAULT, fn_closure), V_DEFAULT); } ","date":"2024-12-15","objectID":"/posts/rust/:11:5","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#map方法"},{"categories":["Tech"],"content":" 错误处理方法 map方法map 是一种容器上的变换的操作，它并不改变 Option 或 Result 的结构，而是在结构内的值存在时对其做变换，否则就保持原样。map支持按函数指针和闭包两种方式传参 与迭代器适配器类似，Option或Result使用map方法会产生一个新的Option或Result类型，并且这个类型会按照闭包的指示生成 rust fn main() { let s1 = Some(\"abcde\"); let s2 = Some(5); let n1: Option\u003c\u0026str\u003e = None; let n2: Option = None; let o1: Result\u003c\u0026str, \u0026str\u003e = Ok(\"abcde\"); let o2: Result = Ok(5); let e1: Result\u003c\u0026str, \u0026str\u003e = Err(\"abcde\"); let e2: Result = Err(\"abcde\"); let fn_character_count = |s: \u0026str| s.chars().count(); assert_eq!(s1.map(fn_character_count), s2); // Some(\u0026str) 映射后变为 Some(usize) assert_eq!(n1.map(fn_character_count), n2); // None 映射后仍是 None，不执行闭包 assert_eq!(o1.map(fn_character_count), o2); // Ok(\u0026str) 映射后变为 Ok(usize) assert_eq!(e1.map(fn_character_count), e2); // Err 跳过映射，保持不变 } 当 n1 是 Some 类型的值时，map 会调用闭包，并将 Some 中的值作为参数传入闭包，返回一个新的 Option 类型（Some 中的值被替换为闭包的返回值） 如果 n1 是 None，则不会调用闭包，直接返回 None，即保留原结构 当 o1 是 Ok 类型的值时，map 会调用闭包，并将 Ok 中的值作为参数传入闭包，生成一个新的 Result 类型（Ok 中的值被闭包的返回值替换） 如果 o1 是 Err，则不会调用闭包，直接返回原封不动的 Err map_or_else和map_or方法两者都在map基础上提供了默认值，但是前者通过闭包提供，后者通过变量提供 我们在使用两者闭包时的参数传递都是隐式的，闭包参数来源于Some(T)，Ok(T)中的T，最终在标准库中map_or_else和map_or都会显式调用参数T，该过程由内部实现，此处不过多介绍 下面是map_or_else方法 rust fn main() { let s = Some(10); let n: Option = None; let fn_closure = |v: i8| v + 2; let fn_default = || 1; assert_eq!(s.map_or_else(fn_default, fn_closure), 12); // 如果是 Some，应用 `fn_closure`（10 + 2 = 12） assert_eq!(n.map_or_else(fn_default, fn_closure), 1); // 如果是 None，调用 `fn_default`（返回 1） let o = Ok(10); let e = Err(5); let fn_default_for_result = |v: i8| v + 1; // 闭包可以对 Err 中的值进行处理，并返回一个新值 assert_eq!(o.map_or_else(fn_default_for_result, fn_closure), 12); assert_eq!(e.map_or_else(fn_default_for_result, fn_closure), 6); } 下面是map_or方法 rust fn main() { const V_DEFAULT: u32 = 1; let s: Result = Ok(10); let n: Option = None; let fn_closure = |v: u32| v + 2; assert_eq!(s.map_or(V_DEFAULT, fn_closure), 12); assert_eq!(n.map_or(V_DEFAULT, fn_closure), V_DEFAULT); } ","date":"2024-12-15","objectID":"/posts/rust/:11:5","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#map_or_else和map_or方法"},{"categories":["Tech"],"content":" 自定义错误类型虽然标准库为我们提供了多种错误处理方法，但是自定义错误还需要我们自行实现。我们只需要实现Debug trait和Display trait即可，并且由于Debug trait可以由宏自动实现，因此实际上我们只需要实现Display trait rust use std::fmt; // AppError 是自定义错误类型，它可以是当前包中定义的任何类型，在这里为了简化，我们使用了单元结构体作为例子。 // 为 AppError 自动派生 Debug 特征 #[derive(Debug)] struct AppError; // 为 AppError 实现 std::fmt::Display 特征 impl fmt::Display for AppError { fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result { write!(f, \"An Error Occurred, Please Try Again!\") // user-facing output } } // 一个示例函数用于产生 AppError 错误 fn produce_error() -\u003e Result\u003c(), AppError\u003e { Err(AppError) } fn main(){ match produce_error() { Err(e) =\u003e eprintln!(\"{}\", e), // eprintln!是个宏，用于将错误输出到标准错误流 _ =\u003e println!(\"No error\"), } eprintln!(\"{:?}\", produce_error()); // Err({ file: src/main.rs, line: 17 }) } 我们还可以实现from trait(就是String::from的那个from，该trait负责类型转换)来实现错误类型转换。使用from trait主要是为了防止自定义错误，标准库错误，第三方库错误混淆，实现该trait后可以将这三种类型错误全部自定义化 rust use std::fs::File; use std::io::{self, Read}; use std::num; #[derive(Debug)] struct AppError { kind: String, message: String, } impl From\u003cio::Error\u003e for AppError { fn from(error: io::Error) -\u003e Self { AppError { kind: String::from(\"io\"), message: error.to_string(), } } } impl From\u003cnum::ParseIntError\u003e for AppError { fn from(error: num::ParseIntError) -\u003e Self { AppError { kind: String::from(\"parse\"), message: error.to_string(), } } } fn main() -\u003e Result\u003c(), AppError\u003e { let mut file = File::open(\"hello_world.txt\")?; let mut content = String::new(); file.read_to_string(\u0026mut content)?; let _number: usize; _number = content.parse()?; Ok(()) } // --------------- 上述代码运行后的可能输出 --------------- // 01. 若 hello_world.txt 文件不存在 Error: AppError { kind: \"io\", message: \"No such file or directory (os error 2)\" } // 02. 若用户没有相关的权限访问 hello_world.txt Error: AppError { kind: \"io\", message: \"Permission denied (os error 13)\" } // 03. 若 hello_world.txt 包含有非数字的内容，例如 Hello, world! Error: AppError { kind: \"parse\", message: \"invalid digit found in string\" } 如果想要一个函数可能返回多种类型的错误，那么上面的方案就不够用了。这时我们可以使用trait对象来将多种错误归一化 rust use std::fs::read_to_string; use std::error::Error; fn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e { let html = render()?; println!(\"{}\", html); Ok(()) } fn render() -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e { //将多种错误归一化到Box\u003cdyn Error\u003e let file = std::env::var(\"MARKDOWN\")?; //获取名为 MARKDOWN 的环境变量的值 let source = read_to_string(file)?; Ok(source) } 虽然这种方案满足了我们的需求并且实现起来非常简单，但是还有一点瑕疵：Box\u003cdyn Error\u003e参数并没有强制要求实现Error trait，也就是说即使一个类型没有实现Error trait，它也可以从render中被返回！ 我们还有一种解决方案就是使用万能的枚举 rust use std::fs::read_to_string; fn main() -\u003e Result\u003c(), MyError\u003e { let html = render()?; println!(\"{}\", html); Ok(()) } fn render() -\u003e Result\u003cString, MyError\u003e { let file = std::env::var(\"MARKDOWN\")?; let source = read_to_string(file)?; Ok(source) } #[derive(Debug)] enum MyError { EnvironmentVariableNotFound, IOError(std::io::Error), } impl From\u003cstd::env::VarError\u003e for MyError { fn from(_: std::env::VarError) -\u003e Self { Self::EnvironmentVariableNotFound } } impl From\u003cstd::io::Error\u003e for MyError { fn from(value: std::io::Error) -\u003e Self { Self::IOError(value) } } impl std::error::Error for MyError {} //要求MyError强制实现Error trait，防止其它类型返回 impl std::fmt::Display for MyError { fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result { match self { MyError::EnvironmentVariableNotFound =\u003e write!(f, \"Environment variable not found\"), MyError::IOError(err) =\u003e write!(f, \"IO Error: {}\", err.to_string()), } } } 当然，这里也有丰富的第三方错误库来简化上述操作，最著名的是thiserror以及anyhow ","date":"2024-12-15","objectID":"/posts/rust/:11:6","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#自定义错误类型"},{"categories":["Tech"],"content":" 泛型rust可以定义泛型，方法的泛型以及泛型的特化。使用泛型时需要先进行声明，声明的位置位于impl与结构体名之间 rust struct Point\u003cT\u003e{ x:T, y:T, } impl\u003cT\u003e Point\u003cT\u003e{ //为结构体自身实现某个方法不必加for，但为结构体实现某个trait则必须加for fn x(\u0026self)-\u003e\u0026T{ \u0026self.x } } impl Point\u003ci32\u003e{ fn x1(\u0026self)-\u003e\u0026i32{ \u0026self.x } } strcut里的泛型模板参数和方法的泛型模板参数可能不同 rust struct Point\u003cT,U\u003e{ x:T, y:U, } impl \u003cT,U\u003e Point\u003cT,U\u003e{ fn mixup\u003cV,W\u003e(self,other:Point\u003cV,W\u003e)-\u003ePoint\u003cT,W\u003e{ Point{ x:self.x, y:other.y, } } } fn main() { let p1 = Point{x:5, y:4}; let p2 = Point{x:\"hello\",y:'c'}; let p3 = p1.mixup(p2); println!(\"{} {}\",p3.x,p3.y); } 与C++一样，rust的泛型在编译期就可确定，并通过修改函数/方法签名的技术生成对象，这样就可以保证与普通函数有相同的性能 ","date":"2024-12-15","objectID":"/posts/rust/:12:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#泛型"},{"categories":["Tech"],"content":" const泛型 常量泛型参数常量泛型参数类似于C++的constexpr，用于编译期计算常量值 当我们给display_array传递不同的值时，编译器会生成不同长度的arr数组 rust fn display_array\u003cT: std::fmt::Debug, const N: usize\u003e(arr: [T; N]) { //要求T实现std::fmt::Debug trait，否则无法打印 println!(\"{:?}\", arr); } fn main() { let arr: [i32; 3] = [1, 2, 3]; display_array(arr); let arr: [i32; 2] = [1, 2]; display_array(arr); } 常量泛型参数除了可以被作为值传递，还可以作为表达式的结果传递 rust // 目前只能在nightly版本下使用 #![allow(incomplete_features)] #![feature(generic_const_exprs)] fn something\u003cT\u003e(val: T) where Assert\u003c{ core::mem::size_of::\u003cT\u003e() \u003c 768 }\u003e: IsTrue, //这里在编译期计算表达式结果 // ^-----------------------------^ 这里是一个 const 表达式，换成其它的 const 表达式也可以 { // } fn main() { something([0u8; 0]); // ok something([0u8; 512]); // ok something([0u8; 1024]); // 编译错误，数组长度是1024字节，超过了768字节的参数长度限制 } // --- pub enum Assert\u003cconst CHECK: bool\u003e { //这里声明CHECK常量表达式 // } pub trait IsTrue { // } impl IsTrue for Assert\u003ctrue\u003e { // } 还可以与常量函数搭配使用 rust const fn add(a: usize, b: usize) -\u003e usize { a + b } const RESULT: usize = add(5, 10); fn main() { println!(\"The result is: {}\", RESULT); } 上面的代码可能会令人疑惑，我们只需要返回值是常量就可以了，为什么还要把函数变成常量？这是因为如果我们想要获得函数返回值就必须要求函数在编译期就可以计算，而普通函数是在运行期进行计算的，因此我们需要将整个函数定义为常量函数，这样才能将函数使用在常量上下文中也就是告知编译器在编译期间提前计算函数结果，这样我们就只能将函数写为常函数，这个过程与C++是一样的，C++也需要将constexpr放在函数定义前 ","date":"2024-12-15","objectID":"/posts/rust/:12:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#const泛型"},{"categories":["Tech"],"content":" const泛型 常量泛型参数常量泛型参数类似于C++的constexpr，用于编译期计算常量值 当我们给display_array传递不同的值时，编译器会生成不同长度的arr数组 rust fn display_array(arr: [T; N]) { //要求T实现std::fmt::Debug trait，否则无法打印 println!(\"{:?}\", arr); } fn main() { let arr: [i32; 3] = [1, 2, 3]; display_array(arr); let arr: [i32; 2] = [1, 2]; display_array(arr); } 常量泛型参数除了可以被作为值传递，还可以作为表达式的结果传递 rust // 目前只能在nightly版本下使用 #![allow(incomplete_features)] #![feature(generic_const_exprs)] fn something(val: T) where Assert\u003c{ core::mem::size_of::() \u003c 768 }\u003e: IsTrue, //这里在编译期计算表达式结果 // ^-----------------------------^ 这里是一个 const 表达式，换成其它的 const 表达式也可以 { // } fn main() { something([0u8; 0]); // ok something([0u8; 512]); // ok something([0u8; 1024]); // 编译错误，数组长度是1024字节，超过了768字节的参数长度限制 } // --- pub enum Assert { //这里声明CHECK常量表达式 // } pub trait IsTrue { // } impl IsTrue for Assert { // } 还可以与常量函数搭配使用 rust const fn add(a: usize, b: usize) -\u003e usize { a + b } const RESULT: usize = add(5, 10); fn main() { println!(\"The result is: {}\", RESULT); } 上面的代码可能会令人疑惑，我们只需要返回值是常量就可以了，为什么还要把函数变成常量？这是因为如果我们想要获得函数返回值就必须要求函数在编译期就可以计算，而普通函数是在运行期进行计算的，因此我们需要将整个函数定义为常量函数，这样才能将函数使用在常量上下文中也就是告知编译器在编译期间提前计算函数结果，这样我们就只能将函数写为常函数，这个过程与C++是一样的，C++也需要将constexpr放在函数定义前 ","date":"2024-12-15","objectID":"/posts/rust/:12:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#常量泛型参数"},{"categories":["Tech"],"content":" traittrait: 特质，特征 trait是对于具有相似行为的结构体抽象出来的统一接口，因此尽管相似行为在实现细节上可能不同，但是逻辑上，功能上是雷同的，因此我们可以将其抽象出来作为trait。为了能够支持重载和默认实现等特性，我们可以在trait中实现方法细节，这样该方法可以作为实现trait类型的默认方法，并且类型内部可以对其进行重载 对于一些不同类型的方法，它们在逻辑上是类似甚至是相同的，因此我们可以将这些方法签名放在一起来定义一组行为 rust //lib.rs pub trait Summary { fn summarize(\u0026self); //在这里可以只写方法签名，如果写方法实现则为默认方法 } pub struct NewsArticle{ pub headline:String, pub location:String, pub author:String, pub content:String, } impl Summary for NewsArticle { //注意for关键字 fn summarize(\u0026self) { println!(\"The summary of NewsArticle is {}\",self.content); } //在这里写实现 } pub struct Tweet{ pub username:String, pub content:String, pub replay:bool, pub retweet:bool, } impl Summary for Tweet { fn summarize(\u0026self) { println!(\"The summary of Tweet is {}\",self.content); } } //main.rs use first_proj::{Summary, Tweet}; fn main() { let tweet = Tweet{ username: \"name\".to_string(), content: \"content\".to_string(), replay:true, retweet:false, }; tweet.summarize(); } 在某个类型上实现trait的前提是: 这个类型或这个trait是在本地定义的。如果两者均不在本地定义，则无法实现trait。比如: 我们不能实现标准库中vector的copy trait，这个规则可以防止我们破坏上游的代码，同时也可防止下游破坏我们的代码，这被称为孤儿原则。如果没有这个原则，不仅可能造成代码的破坏，还可能在上下游为同一类型实现两个trait，编译器就不知道调用哪个了 我们还可以采用trait的默认实现 rust //lib.rs pub trait Summary { fn summarize(\u0026self) { println!(\"The summary of NewsArticle is {}\",self.content); } //这里改为实现trait } pub struct NewsArticle{ pub headline:String, pub location:String, pub author:String, pub content:String, } impl Summary for NewsArticle { //注意for关键字 //fn summarize(\u0026self) { // println!(\"The summary of NewsArticle is {}\",self.content); //} //这里可以省略 } //下文同样可以省略 还可以重写默认实现 rust //lib.rs pub trait Summary { fn summarize_author(\u0026self)-\u003eString; fn summarize(\u0026self) { println!(\"The summary of NewsArticle is {}\",self.summarize_author()); } } pub struct NewsArticle{ pub headline:String, pub location:String, pub author:String, pub content:String, } impl Summary for NewsArticle { //注意for关键字 fn summarize_author(\u0026self) { //重写summarize_author println!(\"The summary of NewsArticle is {}\",self.content); } } ","date":"2024-12-15","objectID":"/posts/rust/:13:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#trait"},{"categories":["Tech"],"content":" 静态trait对象静态trait对象指的是在编译期就可确定类型的trait实现 典型的静态trait对象的语法如下 rust item:impl Trait1 实际上impl trait语法声明静态tait对象是trait bound的语法糖，因此上面的代码等价于 rust \u003cT:Trait1\u003e item:T 我们还可以item施加多种trait约束 rust item:impl Trait1 + Trait2 \u003cT:Trait1 + Trait2\u003e item:T 我们还可以使用where子句优化函数签名 rust pub fn notify\u003cT:Summary+Display,U:Debug+Clone\u003e(item:T,b:U) pub fn notify\u003cT,U\u003e(item:T,b:U) where T:Summary+Display, U:Debug+Clone, 静态trait对象作为函数参数考虑一个情况: 我需要一个notify函数，它的参数不仅可以接受NewsArticle类型还可以接受Tweet类型，也就是说，它可以接受Summary trait类型的参数 我们使用impl语法 rust pub fn notify(item:impl Summary) { println!(\"notify {:?}\",item.summarize()); } impl实际上是trait bound的语法糖 rust pub fn notify\u003cT:Summary\u003e(item:T) { println!(\"notify {:?}\",item.summarize()); } 对于一个参数需要多种trait进行约束，rust提供了”+“运算符 rust use std::fmt::Display; pub fn notify(item:impl Summary+Display) { println!(\"notify {:?}\",item.summarize()); } //也可以写为下面的形式 pub fn notify\u003cT:Summary+Display\u003e(item:T) { println!(\"notify {:?}\",item.summarize()); } 对于较复杂的trait bound，rust还提供了where子句优化函数签名 rust pub fn notify\u003cT,U\u003e(item:T,b:U) where T:Summary+Display, U:Debug+Clone, { println!(\"notify {:?}\",item.summarize()); } 只要使用impl Trait可以让用户不用考虑结构体的特性，只需要考虑trait的共性，当然缺点是失去了结构体特有的方法。下民的代码中用户就会失去调用Weibo这个结构体内部方法的能力，只能使用Summary这个trait的公有方法 rust fn returns_summarizable() -\u003e impl Summary { Weibo { username: String::from(\"sunface\"), content: String::from( \"m1 max太厉害了，电脑再也不会卡\", ) } } 如果想要返回多种类型就需要使用到动态trait对象了 我们甚至可以给已经实现了的trait的某个类型再次实现其它trait，也就是trait的覆盖实现 rust /// # Panics /// /// In this implementation, the `to_string` method panics /// if the `Display` implementation returns an error. /// This indicates an incorrect `Display` implementation /// since `fmt::Write for String` never returns an error itself. #[cfg(not(no_global_oom_handling))] #[stable(feature = \"rust1\", since = \"1.0.0\")] impl\u003cT: fmt::Display\u003e ToString for T { // A common guideline is to not inline generic functions. However, // removing `#[inline]` from this method causes non-negligible regressions. // See \u003chttps://github.com/rust-lang/rust/pull/74852\u003e, the last attempt // to try to remove it. #[inline] default fn to_string(\u0026self) -\u003e String { let mut buf = String::new(); let mut formatter = core::fmt::Formatter::new(\u0026mut buf); // Bypass format_args!() to avoid write_str with zero-length strs fmt::Display::fmt(self, \u0026mut formatter) .expect(\"a Display implementation returned an error unexpectedly\"); buf } } 上面的代码表示了: 对于满足实现Display这个trait的T，就实现ToString这个trait 下面的代码展示了trait对于参数约束的用法: rust trait Trait {} fn foo\u003cX: Trait\u003e(t: X) {} //参数X必须满足Trait，即使Trait是空实现 impl\u003c'a\u003e Trait for \u0026'a i32 {} //让i32实现Trait fn main() { let t: \u0026mut i32 = \u0026mut 0; //报错，类型不匹配 let t: \u0026 i32 = \u0026 0; //这个是对的 foo(t); } 通过空trait实现和trait约束来让foo函数只接受i32的参数，这对于限制参数类型很有用 ","date":"2024-12-15","objectID":"/posts/rust/:13:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#静态trait对象"},{"categories":["Tech"],"content":" 静态trait对象静态trait对象指的是在编译期就可确定类型的trait实现 典型的静态trait对象的语法如下 rust item:impl Trait1 实际上impl trait语法声明静态tait对象是trait bound的语法糖，因此上面的代码等价于 rust item:T 我们还可以item施加多种trait约束 rust item:impl Trait1 + Trait2 item:T 我们还可以使用where子句优化函数签名 rust pub fn notify(item:T,b:U) pub fn notify(item:T,b:U) where T:Summary+Display, U:Debug+Clone, 静态trait对象作为函数参数考虑一个情况: 我需要一个notify函数，它的参数不仅可以接受NewsArticle类型还可以接受Tweet类型，也就是说，它可以接受Summary trait类型的参数 我们使用impl语法 rust pub fn notify(item:impl Summary) { println!(\"notify {:?}\",item.summarize()); } impl实际上是trait bound的语法糖 rust pub fn notify(item:T) { println!(\"notify {:?}\",item.summarize()); } 对于一个参数需要多种trait进行约束，rust提供了”+“运算符 rust use std::fmt::Display; pub fn notify(item:impl Summary+Display) { println!(\"notify {:?}\",item.summarize()); } //也可以写为下面的形式 pub fn notify(item:T) { println!(\"notify {:?}\",item.summarize()); } 对于较复杂的trait bound，rust还提供了where子句优化函数签名 rust pub fn notify(item:T,b:U) where T:Summary+Display, U:Debug+Clone, { println!(\"notify {:?}\",item.summarize()); } 只要使用impl Trait可以让用户不用考虑结构体的特性，只需要考虑trait的共性，当然缺点是失去了结构体特有的方法。下民的代码中用户就会失去调用Weibo这个结构体内部方法的能力，只能使用Summary这个trait的公有方法 rust fn returns_summarizable() -\u003e impl Summary { Weibo { username: String::from(\"sunface\"), content: String::from( \"m1 max太厉害了，电脑再也不会卡\", ) } } 如果想要返回多种类型就需要使用到动态trait对象了 我们甚至可以给已经实现了的trait的某个类型再次实现其它trait，也就是trait的覆盖实现 rust /// # Panics /// /// In this implementation, the `to_string` method panics /// if the `Display` implementation returns an error. /// This indicates an incorrect `Display` implementation /// since `fmt::Write for String` never returns an error itself. #[cfg(not(no_global_oom_handling))] #[stable(feature = \"rust1\", since = \"1.0.0\")] impl ToString for T { // A common guideline is to not inline generic functions. However, // removing `#[inline]` from this method causes non-negligible regressions. // See , the last attempt // to try to remove it. #[inline] default fn to_string(\u0026self) -\u003e String { let mut buf = String::new(); let mut formatter = core::fmt::Formatter::new(\u0026mut buf); // Bypass format_args!() to avoid write_str with zero-length strs fmt::Display::fmt(self, \u0026mut formatter) .expect(\"a Display implementation returned an error unexpectedly\"); buf } } 上面的代码表示了: 对于满足实现Display这个trait的T，就实现ToString这个trait 下面的代码展示了trait对于参数约束的用法: rust trait Trait {} fn foo(t: X) {} //参数X必须满足Trait，即使Trait是空实现 impl\u003c'a\u003e Trait for \u0026'a i32 {} //让i32实现Trait fn main() { let t: \u0026mut i32 = \u0026mut 0; //报错，类型不匹配 let t: \u0026 i32 = \u0026 0; //这个是对的 foo(t); } 通过空trait实现和trait约束来让foo函数只接受i32的参数，这对于限制参数类型很有用 ","date":"2024-12-15","objectID":"/posts/rust/:13:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#静态trait对象作为函数参数"},{"categories":["Tech"],"content":" 动态trait对象为了能够支持动态trait实现的多态，产生了trait对象这一概念。类似oop语言的动态多态，rust也采用虚表结构实现多态，为此，实现动态trait要使用dyn关键字声明一个动态trait的指针，这个指针就是trait对象 简要但精确的trait对象和胖指针原理可以看中文社区 下面的代码来自于Rust语言圣经 rust trait Draw { fn draw(\u0026self) -\u003e String; } impl Draw for u8 { fn draw(\u0026self) -\u003e String { format!(\"u8: {}\", *self) } } impl Draw for f64 { fn draw(\u0026self) -\u003e String { format!(\"f64: {}\", *self) } } // 若 T 实现了 Draw 特征， 则调用该函数时传入的 Box\u003cT\u003e 可以被隐式转换成函数参数签名中的 Box\u003cdyn Draw\u003e fn draw1(x: Box\u003cdyn Draw\u003e) { // 由于实现了 Deref 特征，Box 智能指针会自动解引用为它所包裹的值，然后调用该值对应的类型上定义的 `draw` 方法 x.draw(); } fn draw2(x: \u0026dyn Draw) { x.draw(); } fn main() { let x = 1.1f64; // do_something(\u0026x); let y = 8u8; // x 和 y 的类型 T 都实现了 `Draw` 特征，因为 Box\u003cT\u003e 可以在函数调用时隐式地被转换为特征对象 Box\u003cdyn Draw\u003e // 基于 x 的值创建一个 Box\u003cf64\u003e 类型的智能指针，指针指向的数据被放置在了堆上 draw1(Box::new(x)); // 基于 y 的值创建一个 Box\u003cu8\u003e 类型的智能指针 draw1(Box::new(y)); draw2(\u0026x); draw2(\u0026y); } 我们可以看到，dyn指针只在draw1和draw2定义时使用，在使用时不必强调指针是否为动态trait对象 正如前面所言，dyn指针维护了指向当前trait的\"父trait\"的实例，其内部存放了\"父trait\"的数据，还维护了指向虚表vtable的行为指针，此时vtable只包含实现自特征的方法，不能调用\"父trait\"或者其它衍生trait的方法，也就是说，btn是哪个trait对象的实例，它的vtable中就包含了该trait的方法 ","date":"2024-12-15","objectID":"/posts/rust/:13:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#动态trait对象"},{"categories":["Tech"],"content":" 对象安全在 Rust 中，对象安全（Object Safety）是指一个 trait 能否被用作动态 Trait 对象（dyn Trait）的条件。如果一个 trait 是对象安全的，那么它可以用于 dyn Trait，否则编译器会报错 并不是所有trait都能拥有trait对象，只有满足以下两点条件才符合对象安全 方法的返回类型不能是Self且参数也不能包含Self 方法没有任何泛型参数 原因如下： 对象安全对于特征对象是必须的，因为一旦有了特征对象，就不再需要知道实现该特征的具体类型是什么了。如果特征方法返回了具体的 Self 类型，但是特征对象忘记了其真正的类型，那这个 Self 就非常尴尬，因为没人知道它是谁了。而对于泛型类型参数来说，泛型的单态化是编译期确定的，但是动态特征对象要求其参数(也就是T)需要在运行期确定，这样动态特征对象的参数要求旧雨泛型要求冲突了 标准库中的Clone方法就不是对象安全的 rust pub trait Clone { fn clone(\u0026self) -\u003e Self; } 从常识上也可以推断出来为什么Clone不是对象安全的: 当我们使用Clone时，我们只想要获得对应的对象，而最方便获得对象的方法就是memcpy，对于内存的操作来说，它无需考虑传入的类型是什么，也无需对操作实现动态trait以满足其它要求，它只是忠实的进行内存复制罢了。如果Clone支持动态trait对象，那么它也无能为力，它只进行内存复制，对象是什么样子它也不知道，最多维护个编译器交给它的胖指针，但是胖指针也只是个指针而已，要想生成完整的Self类型也是不太可能的 ","date":"2024-12-15","objectID":"/posts/rust/:13:3","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#对象安全"},{"categories":["Tech"],"content":" 生命周期The Rust Programming Language如此解释生命周期: Lifetimes are another kind of generic that we’ve already been using. 生命周期可以被视为rust与其它语言最与众不同的特征 rust的借用检查器原理如下代码所示 rust fn main() { let r; { let x = 5; r = \u0026x; } println!(\"{}\",\u0026r); } 借用检查器会检查r及赋予它的值的变量x的生命周期，它发现x的生命周期并没有完全覆盖r的生命周期，因此编译这段代码时借用检查器会报error ","date":"2024-12-15","objectID":"/posts/rust/:14:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#生命周期"},{"categories":["Tech"],"content":" NLL (Non-Lexical Lifetime)在1.31版本后，引用的生命周期从借用处开始，一直持续到最后一次使用的地方。这与之前版本的持续到作用域结束会更智能 rust let mut u = 0i32; let mut v = 1i32; let mut w = 2i32; // lifetime of `a` = α ∪ β ∪ γ let mut a = \u0026mut u; // --+ α. lifetime of `\u0026mut u` --+ lexical \"lifetime\" of `\u0026mut u`,`\u0026mut u`, `\u0026mut w` and `a` use(a); // | | *a = 3; // \u003c-----------------+ | ... // | a = \u0026mut v; // --+ β. lifetime of `\u0026mut v` | use(a); // | | *a = 4; // \u003c-----------------+ | ... // | a = \u0026mut w; // --+ γ. lifetime of `\u0026mut w` | use(a); // | | *a = 5; // \u003c-----------------+ \u003c--------------------------+ 这段代码一目了然，a有三段生命周期：α，β，γ，每一段生命周期都随着当前值的最后一次使用而结束 ","date":"2024-12-15","objectID":"/posts/rust/:14:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#nll-non-lexical-lifetime"},{"categories":["Tech"],"content":" Reborrow 再借用对NLL了解后就可以对借用进行再借用 再借用（Reborrowing） 是 Rust 借用检查器（Borrow Checker）中的一种机制，它允许在不违反借用规则的前提下，对已经借用的变量再次创建一个新的借用，并让原借用暂时失效，直到新借用结束 有时候我们需要临时让一个可变引用“降级”为不可变引用，或者让一个可变引用传递给另一个函数，而不会导致冲突。这时就需要再借用 rust #[derive(Debug)] struct Point { x: i32, y: i32, } impl Point { fn move_to(\u0026mut self, x: i32, y: i32) { self.x = x; self.y = y; } } fn main() { let mut p = Point { x: 0, y: 0 }; let r = \u0026mut p; let rr: \u0026Point = \u0026*r; //合法，r暂时失效 println!(\"{:?}\", rr); r.move_to(10, 10); println!(\"{:?}\", r); } 上述代码并不会报错，其中let rr: \u0026Point = \u0026*r;并不是对p的不可变引用，而是对r的借用，只要在println!(”{:?}\", rr);这行代码之前不对r进行任何操作，那么就不会报错 再借用的核心规则： 新借用必须基于原借用（如 \u0026*r1 或直接传递 r1） 新借用期间，原借用暂时失效（不能同时使用） 新借用结束后，原借用恢复可用 ","date":"2024-12-15","objectID":"/posts/rust/:14:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#reborrow-再借用"},{"categories":["Tech"],"content":" 生命周期的标注语法生命周期是类型的一部分，因此在声明需要生命周期的类型时，必须将生命周期带上 由于生命周期是为了解决悬垂引用的问题，因此非引用类型的变量不需要标注生命周期，我们只需要标注\u0026，\u0026mut两种类型的生命周期参数即可 生命周期参数名: 以’开头 通常以小写字母开头且非常短 很多人使用’a rust \u0026i32 \u0026'a i32 \u0026'a mut i32 函数签名中的生命周期标注: 生命周期在标注时需要先声明，声明位置也与泛型类似，也就是说生命周期参数要标注在函数名和参数列表间的\u003c\u003e 对于以下函数，生命周期参数’a代表的是生存时间较短的那个参数，这是因为只有将生存时间按最短考虑，才可能发生生命周期不足的错误 rust fn main() { let string1 = String::from(\"abcd\"); let string2 = \"xyz\"; let result = longest(\u0026string1, \u0026string2); println!(\"{result}\"); } fn longest\u003c'a\u003e (x:\u0026'a str, y:\u0026'a str) -\u003e \u0026'a str{ if x.len() \u003e y.len(){ x } else { y } } 在早期的rust中，每个引用都需要标注生命周期，但随着rust发展，rust团队发现很大一部分的生命周期标注都是重复性的，可预测的情况，所以rust团队将这些代码写进了编译器内部，从而让编译器自动推导生命周期。这样，我们现在看到的rust很多时候不必进行手动标注生命周期 生命周期省略的三个规则: 每个引用类型的参数都有自己的生命周期 如果只有一个输入生命周期参数，那么该生命周期参数就会赋值给所有的输出生命周期参数 如果有多个输入生命周期参数，但其中一个是\u0026self或\u0026mut self，那么self的生命周期会被赋值给所有的输出生命周期参数 这三条规则适用于fn和impl块，如果在执行完这三条规则后仍有无法确定的生命周期，那么编译器就会报错 注意第三条规则，该规则只是说输出生命周期参数会被确定，但假如有多个输入生命周期参数，我们还需要将除了\u0026self和\u0026mut self的其他输入生命周期参数标注出来。例如如下代码 rust impl\u003c'a\u003e Tweet\u003c'a\u003e{ fn func(\u0026mut self,content:\u0026'a str) -\u003e\u0026str { } } 对于结构体而言，由于没有像函数那样的生命周期省略规则，所以应该为所有引用的成员添加生命周期标注。由于要保证结构体的引用成员所引用的内容必须比结构体本身要活的长，也就是要保证结构体的引用成员活的比结构体本身要长，这只有使用生命周期参数才能做到 下面的生命周期参数标注说明part要比s1活的时间长 rust struct s1\u003c'a\u003e{ part:\u0026'a str, } 而对于结构体的方法，impl块中的生命周期不能省略 rust struct s1\u003c'a\u003e{ part:\u0026'a str, } impl\u003c'a\u003e s1\u003c'a\u003e{ //这里不能省略生命周期标注 fn do_something(self) -\u003e { //由于方法的第一个参数固定为self，因此可以在方法处省略生命周期参数 //do_something } } 下面的例子同时使用了泛型参数类型，trait bound和生命周期 rust fn longgest_with_an_announcement\u003c'a,T\u003e(x:\u0026'a str, y:\u0026'a str, ann:T) -\u003e \u0026'a str where T:Display, { println!(\"Announcement {}\",ann); if x.len() \u003e y.len(){ x } else { y } } ","date":"2024-12-15","objectID":"/posts/rust/:14:3","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#生命周期的标注语法"},{"categories":["Tech"],"content":" 生命周期标注的原理 rust fn main(){ let a = 1; let my_num = complex_func(\u0026a); println!(\"{my_num}\"); } fn complex_func(a:\u0026i32)-\u003e\u0026i32{ let b = 2; max_ref(a, \u0026b) } fn max_ref\u003c'a\u003e(a:\u0026'a i32,b:\u0026'a i32)-\u003e\u0026'a i32{ if *a \u003e *b{ a }else { b } } 在为上述代码添加生命周期标注时，编译器会分析 max_ref 函数两个参数的生命周期。它发现参数 a 的生命周期贯穿整个程序，而参数 b 仅在 complex_func 函数内部有效。因此，编译器会推断出 max_ref 的返回值的生命周期应为两者中较短的那个，也就是 b 的生命周期 然而，在 complex_func 中，这个返回值又被直接返回给外部调用者，此时 b 已经被销毁(标记引用的生命周期不能实际延长其生命周期)，返回的是一个悬垂引用（dangling reference），于是编译器报错以防止潜在的内存不安全 rust error[E0515]: cannot return value referencing local variable `b` --\u003e src/main.rs:92:5 | | max_ref(a, \u0026b) | ^^^^^^^^^^^--^ | | | | | `b` is borrowed here | returns a value referencing data owned by the current function 至于max_ref函数内部，编译器不会涉及生命周期的检查，只会进行函数内部的借用检查，因此如果返回值只依赖一个函数参数，那么另一个函数参数就不必标注生命周期 下面的代码是正确的，但可惜已经和原函数的行为不同了，修改之后的代码由于要求返回值的生命周期为’a，所以只会返回a而不会返回任意生命周期’_的b rust fn max_ref\u003c'a\u003e(a:\u0026'a i32,b:\u0026i32)-\u003e\u0026'a i32{ a } 下面是道找错练习题 rust fn main(){ let x; { let input = String::from(\"aaa\"); x = foo(\u0026input); } println!(\"{x}\"); } fn foo\u003c'a\u003e(_input:\u0026'a str)-\u003e\u0026'a str { let s = \"abc\"; s } 我们应该从两方面分析该题，在主函数内根据调用的函数签名分析生命周期，通过函数签名可以确定foo的输入参数与返回值的生命周期相同或返回值的生命周期不长于输入参数的生命周期。而输入参数input的生命周期截止于println!之前，因此返回值x也应该在这行之前就被系统回收，但是在println!中使用了x，这就造成了悬垂引用。而foo内部我们只进行返回值的检查，尽管s是一个字面量，理论上的生命周期是’static，但是我们将其生命周期缩短是可行的，因此将s的生命周期与输入参数绑定并无错误，该函数没有错误 具体改正方法如下 rust fn foo\u003c'a\u003e(_input:\u0026'a str)-\u003e\u0026'static str 我们只需要适当延长返回值的生命周期就可以了 上面的叙述只说明了编译器是如何检查生命周期的，但是如何标注呢？这个要依靠生命周期的省略原则和函数内部具体实现，前者决定我们是否需要标注生命周期参数以及需要标注多少个生命周期参数，后者决定我们选择应该选择哪个生命周期参数标注返回值 ","date":"2024-12-15","objectID":"/posts/rust/:14:4","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#生命周期标注的原理"},{"categories":["Tech"],"content":" 生命周期约束 HRTB我们还可以对生命周期进行约束 rust impl\u003c'a: 'b, 'b\u003e ImportantExcerpt\u003c'a\u003e { fn announce_and_return_part(\u0026'a self, announcement: \u0026'b str) -\u003e \u0026'b str { println!(\"Attention please: {}\", announcement); self.part } } 在定义ImportantExcerpt方法时，使用了\u003c‘a: ‘b,‘b\u003e的约束方法，其具体含义是：该方法有两个生命周期’a和’b，并且a的生命周期必须比b的久 我们还可以使用where来约束 rust impl\u003c'a\u003e ImportantExcerpt\u003c'a\u003e { fn announce_and_return_part\u003c'b\u003e(\u0026'a self, announcement: \u0026'b str) -\u003e \u0026'b str where 'a: 'b, { println!(\"Attention please: {}\", announcement); self.part } } 上面两个例子中必须添加约束’a: ‘b，因为如果self.part的生命周期与self的生命周期一致，将\u0026‘a类型的生命周期强行转换为\u0026‘b类型会报错，编译器是不知道b的生命周期是什么样子的，因此必须规定’a与’b的生命周期关系 多生命周期参数约束的意义大部分情况下我们不必使用多生命周期参数约束，因为这会使生命周期理解难度加大，但是当某个函数需要的返回值依赖多个入参并且无法确定依赖哪一个，那么这时使用生命周期就在所难免了，并且由于这种不确定性，我们必须给出这些生命周期参数的大小关系，这样才能帮助编译器确定函数内部是否符合调用规则 rust //由于涉及到结构体本身的生命周期参数a，因此还需要引入第二个生命周期参数来标注方法参数 impl\u003c'a: 'b, 'b\u003e ImportantExcerpt\u003c'a\u003e { fn announce_and_return_part(\u0026'a self, announcement: \u0026'b str) -\u003e \u0026'b str { println!(\"Attention please: {}\", announcement); self.part } } ","date":"2024-12-15","objectID":"/posts/rust/:14:5","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#生命周期约束-hrtb"},{"categories":["Tech"],"content":" 生命周期约束 HRTB我们还可以对生命周期进行约束 rust impl\u003c'a: 'b, 'b\u003e ImportantExcerpt\u003c'a\u003e { fn announce_and_return_part(\u0026'a self, announcement: \u0026'b str) -\u003e \u0026'b str { println!(\"Attention please: {}\", announcement); self.part } } 在定义ImportantExcerpt方法时，使用了\u003c‘a: ‘b,‘b\u003e的约束方法，其具体含义是：该方法有两个生命周期’a和’b，并且a的生命周期必须比b的久 我们还可以使用where来约束 rust impl\u003c'a\u003e ImportantExcerpt\u003c'a\u003e { fn announce_and_return_part\u003c'b\u003e(\u0026'a self, announcement: \u0026'b str) -\u003e \u0026'b str where 'a: 'b, { println!(\"Attention please: {}\", announcement); self.part } } 上面两个例子中必须添加约束’a: ‘b，因为如果self.part的生命周期与self的生命周期一致，将\u0026‘a类型的生命周期强行转换为\u0026‘b类型会报错，编译器是不知道b的生命周期是什么样子的，因此必须规定’a与’b的生命周期关系 多生命周期参数约束的意义大部分情况下我们不必使用多生命周期参数约束，因为这会使生命周期理解难度加大，但是当某个函数需要的返回值依赖多个入参并且无法确定依赖哪一个，那么这时使用生命周期就在所难免了，并且由于这种不确定性，我们必须给出这些生命周期参数的大小关系，这样才能帮助编译器确定函数内部是否符合调用规则 rust //由于涉及到结构体本身的生命周期参数a，因此还需要引入第二个生命周期参数来标注方法参数 impl\u003c'a: 'b, 'b\u003e ImportantExcerpt\u003c'a\u003e { fn announce_and_return_part(\u0026'a self, announcement: \u0026'b str) -\u003e \u0026'b str { println!(\"Attention please: {}\", announcement); self.part } } ","date":"2024-12-15","objectID":"/posts/rust/:14:5","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#多生命周期参数约束的意义"},{"categories":["Tech"],"content":" 静态生命周期我们可以使用'static来标注静态生命周期，所有字符串字面量都有'static生命周期 ","date":"2024-12-15","objectID":"/posts/rust/:14:6","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#静态生命周期"},{"categories":["Tech"],"content":" 生命周期详解练习参考lifetimekata项目以及b站视频 ","date":"2024-12-15","objectID":"/posts/rust/:15:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#生命周期详解"},{"categories":["Tech"],"content":" 可变引用和容器给下面的代码找找错： rust fn insert_value\u003c'b\u003e(my_vec: \u0026'b mut Vec\u003c\u0026'b i32\u003e, value: \u0026'b i32) { my_vec.push(value) } fn main(){ let mut my_vec = vec![]; let val1 = 1; let val2 = 2; insert_value(\u0026mut my_vec, \u0026val1); insert_value(\u0026mut my_vec, \u0026val2); println!(\"{my_vec:?}\"); } 正常情况下在执行完insert_value(\u0026mut my_vec, \u0026val1);可变引用my_vec会被释放，所以我们能够再次执行insert_value(\u0026mut my_vec, \u0026val2);，但是这里却并不能如我们所愿。原因在于我们第一次执行insert_value时my_vec获得了一个持续到函数结束的可变借用（生命周期 ‘b1），第二次执行insert_value时my_vec又获得了一个持续到函数结束的可变借用，而这这违反了 Rust 的借用规则：不能同时存在多个可变借用 下面是正确的代码 rust fn insert_value\u003c'a,'b:'a\u003e(my_vec: \u0026'a mut Vec\u003c\u0026'b i32\u003e, value: \u0026'b i32) { my_vec.push(value) } 由于value与Vec内部元素有依赖，因此统一设为’b的生命周期，并且要求b的生命周期一定长于a的，否则产生悬垂引用。通过\u0026‘a mut Vec\u003c\u0026‘b i32\u003e这行代码也能看出依赖关系 ","date":"2024-12-15","objectID":"/posts/rust/:15:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#可变引用和容器"},{"categories":["Tech"],"content":" 结构体的生命周期 rust struct SplitStr\u003c'str_lifetime\u003e { start: \u0026'str_lifetime str, end: \u0026'str_lifetime str } fn split\u003c'text, 'delim\u003e(text: \u0026'text str, delimiter: \u0026'delim str) -\u003e Option\u003cSplitStr\u003c'text\u003e\u003e { let (start, end) = text.split_once(delimiter)?; Some(SplitStr { start, end }) } 上面的标注是正确的，但是为什么呢？我们在标注时会遇到两个问题： 结构体成员的生命周期是否彼此依赖 split函数的生命周期如何标注 解决这两个问题需要查看split内部的具体实现，尤其是split_once函数 rust #[stable(feature = \"str_split_once\", since = \"1.52.0\")] #[inline] pub fn split_once\u003cP: Pattern\u003e(\u0026self, delimiter: P) -\u003e Option\u003c(\u0026'_ str, \u0026'_ str)\u003e { let (start, end) = delimiter.into_searcher(self).next_match()?; // SAFETY: `Searcher` is known to return valid indices. unsafe { Some((self.get_unchecked(..start), self.get_unchecked(end..))) } } 我们发现split_once函数返回值的两个生命周期参数相同，这也就意味着let (start, end) = text.split_once(delimiter)?;中的start和end生命周期也相同，也就是说结构体成员的生命周期参数是相同的。对于split_once而言，返回值生命周期只跟self有关，在我们代码中self指的就是text，因此最后确定函数返回值的生命周期与text参数的生命周期相同 下面来看个比较复杂的例子作为练习 rust use std::collections::HashSet; #[derive(Debug, Default)] pub struct Difference { first_only: Vec\u003c\u0026str\u003e, second_only: Vec\u003c\u0026str\u003e, } pub fn find_difference(sentence1: \u0026str, sentence2: \u0026str) -\u003e Difference { let sentence_1_words: HashSet\u003c\u0026str\u003e = sentence1.split(\" \").collect(); let sentence_2_words: HashSet\u003c\u0026str\u003e = sentence2.split(\" \").collect(); let mut diff = Difference::default(); for word in \u0026sentence_1_words { if !sentence_2_words.contains(word) { diff.first_only.push(word) } } for word in \u0026sentence_2_words { if !sentence_1_words.contains(word) { diff.second_only.push(word) } } diff.first_only.sort(); diff.second_only.sort(); diff } #[cfg(test)] mod tests { use super::*; #[test] fn main() { let first_sentence = String::from(\"I hate the surf and the sand.\"); let second_sentence = String::from(\"I love the surf and the sand.\"); let first_only = { let third_sentence = String::from(\"I love the snow and the sand.\"); let diff = find_difference(\u0026first_sentence, \u0026third_sentence); diff.first_only }; assert_eq!(first_only, vec![\"hate\", \"surf\"]); let second_only = { let third_sentence = String::from(\"I love the snow and the sand.\"); let diff = find_difference(\u0026third_sentence, \u0026second_sentence); diff.second_only }; assert_eq!(second_only, vec![\"surf\"]); } } 下面是答案 rust pub struct Difference\u003c'a,'b\u003e { first_only: Vec\u003c\u0026'a str\u003e, second_only: Vec\u003c\u0026'b str\u003e, } pub fn find_difference\u003c'a,'b\u003e(sentence1: \u0026'a str, sentence2: \u0026'b str) -\u003e Difference\u003c'a,'b\u003e ai更推荐下面的标注 rust pub struct Difference\u003c'a\u003e { first_only: Vec\u003c\u0026'a str\u003e, second_only: Vec\u003c\u0026'a str\u003e, } pub fn find_difference\u003c'a\u003e(sentence1: \u0026'a str, sentence2: \u0026'a str) -\u003e Difference\u003c'a\u003e ","date":"2024-12-15","objectID":"/posts/rust/:15:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#结构体的生命周期"},{"categories":["Tech"],"content":" \u0026‘static T与T: ‘static\u0026‘static T与T: ‘static代表的意义如下： \u0026‘static T: 必须是一个指向 ‘static 生命周期的引用 T: ‘static: 不要求T包含引用类型，但如果包含引用类型，则其包含的所有引用都必须是 ‘static 生命周期 下面是道找错练习 rust fn main(){ let input = String::from(\"aaa\"); foo(\u0026input); bar(\u0026input); } fn foo\u003cT\u003e(_input:\u0026'static T) { println!(\"foo works\"); } fn bar\u003cT:'static\u003e(_input:\u0026T) { println!(\"bar works\"); } \u0026‘static T 表示一个引用，要求该引用指向的数据拥有 ‘static 生命周期，即在程序整个运行期内都有效 T: ‘static 是一个更宽松的约束，它要求类型 T 本身不包含任何非 ‘static 生命周期的引用。如果** T 是拥有所有权的类型（如 String、Vec\u003c_\u003e 等），那么它天然满足 T: ‘static** 在上面代码中，foo(\u0026input) 无法通过编译，因为 \u0026input 的生命周期不是 ‘static；而 bar(\u0026input) 是合法的，因为 T = \u0026String，此类型本身不包含内部引用，因此满足 T: ‘static。后者不是很好理解，因为这是rust的一个语义陷阱。Rust 中 T: ‘static 并不意味着值的生命周期是 ‘static，而是：只要 类型 T 本身 没有嵌套任何非 ‘static 的引用，就满足 T: ‘static。代码中的\u0026String尽管不是’static的，但是它不包含非’static的引用，因此可以通过编译 ","date":"2024-12-15","objectID":"/posts/rust/:15:3","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#static-t与t-static"},{"categories":["Tech"],"content":" 动态trait对象的生命周期trait对象的生命周期遵循以下规则： 如果trait对象被作为容器的参数(如box，refcell，这对于动态trait对象是必须的)并有唯一的生命周期约束，那就将其设置为默认生命周期约束 如果trait对象有多个生命周期约束则必须指定一个 不符合上面的规则时会进行下面规则的判定 如果trait有了一个生命周期约束，那么trait对象就应该使用这个生命周期约束 如果trait没有任何生命周期约束，那么默认约束为’static 但是当我们指定生命周期省略规则时(也就是使用’_时)，编译器会优先使用省略规则标注生命周期而不是使用默认规则 下面是trait对象的生命周期标注以及对应的规则 rust //对应第1条规则 type T5\u003c'a\u003e = std::cell::Ref\u003c'a, Box\u003cdyn Foo\u003e\u003e; //Ref要求必须传入生命周期和trait对象，而根据第1条规则，传入的trait对象会与生命周期进行绑定，因此等同于下面的代码 type T6\u003c'a\u003e = std::cell::Ref\u003c'a, Box\u003cdyn Foo\u003e + 'a\u003e; rust //对应第2条规则 struct TwoBounds\u003c'a, 'b, T: ?Sized + 'a + 'b\u003e { f1: \u0026'a i32, f2: \u0026'b i32, f3: T, } type T7\u003c'a, 'b\u003e = TwoBounds\u003c'a, 'b, Box\u003cdyn Foo\u003e\u003e; //由于dyn Foo动态对象只能使用一种生命周期约束，因此dyn Foo并不知道应该使用a还是b // ^^^^^^^ // Error: the lifetime bound for this object type cannot be deduced from context rust //对应第3条规则 trait Bar\u003c'a\u003e: 'a { } //对trait进行生命周期参数的定义和标注 type T1\u003c'b\u003e = Box\u003cdyn Bar\u003c'b\u003e\u003e; //T1与T2相同 type T2\u003c'b\u003e = Box\u003cdyn Bar\u003c'b\u003e + 'a\u003e; //实际上，由于Box在标准库中的定义为Box\u003cT\u003e，因此dyn Bar\u003c'b\u003e与dyn Bar\u003c'b\u003e + 'a均可被视作泛型，进而有 T: dyn Bar\u003c'b\u003e //代表传入的T要求是Bar的动态trait对象，并且至少比'b活得长 T: dyn Bar\u003c'b\u003e + 'a //不仅代表传入的T要求是Bar的动态trait对象，并且至少比'b活得长，并且还要比'a活的长 //静态trait对象也一样，因此下面两行是相同的 impl\u003c'a\u003e dyn Bar\u003c'a\u003e {} impl\u003c'a\u003e dyn Bar\u003c'a\u003e + 'a {} rust //对应第4条规则 trait Foo { } //由于Box内没有指定dyn Foo的生命周期，并且Foo的trait也没有指定生命周期，因此dyn Foo的生命周期被设置为默认的'static type T1 = Box\u003cdyn Foo\u003e; type T2 = Box\u003cdyn Foo + 'static\u003e; //由于\u0026'a T 是 T:\u0026'a 的子集，因此也就有下面两行 type T3\u003c'a\u003e = \u0026'a dyn Foo; //等同于下面那一行 type T4\u003c'a\u003e = \u0026'a (dyn Foo + 'a); //静态trait对象也是如此 struct MyType; impl\u003c'a\u003e Foo\u003c'a\u003e for MyType { /* ... */ } 下面是练习 rust fn fetch(trace_id:\u0026str,span_id:\u0026str)-\u003eBox\u003cdyn Future\u003cOutput = ()\u003e\u003e{ Box::new(async move{ println!(\"{}\",trace_id); println!(\"{}\",span_id); }) } 上述代码在编译器眼中是这样的 rust fn fetch\u003c'a,'b\u003e(trace_id:\u0026'a str,span_id:\u0026'b str)-\u003eBox\u003cdyn Future\u003cOutput = ()\u003e + 'static\u003e 这会导致trace_id与span_id活的没有static长，编译器也会这么提示，因此我们有两种解决办法: 延长函数参数的生命周期或缩短Future对象的生命周期，前者指定trace_id与span_id的生命周期为’static并要求传入的参数生命周期为static。这里着重讲后者 最简单的一种解决办法如下 rust fn fetch\u003c'a,'b:'a\u003e(trace_id:\u0026'a str,span_id:\u0026'b str)-\u003eBox\u003cdyn Future\u003cOutput = ()\u003e + 'a\u003e 我们还可以使用下面的解决办法 rust fn fetch\u003c'a,'b,'c\u003e(trace_id:\u0026'a str,span_id:\u0026'b str)-\u003eBox\u003cdyn Future\u003cOutput = ()\u003e + 'c\u003e where: 'a:'c, 'b:'c 这种解决办法也是编译器解决trait中不能使用async块的办法，当我们使用#[async_trait]宏修饰某个trait时，该宏会将代码改为上面代码的形式以使编译检查通过 trait对象的生命周期练习题放在下一节 ","date":"2024-12-15","objectID":"/posts/rust/:15:4","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#动态trait对象的生命周期"},{"categories":["Tech"],"content":" 静态trait对象的生命周期由于impl trait是T: trait的语法糖，据可指代静态对象，因此我们impl trait的生命周期也就是静态生命对象的生命周期 impl trait的生命周期规则如下 impl生命周期只捕获泛型参数T的生命周期，而不捕获普通类型的生命周期 当没有指定生命周期的泛型参数或根本没有泛型参数但是返回值为impl trait的情况，默认impl trait没有生命周期并需要手动指定 当使用impl Trait + ‘a标注时，范围内的trait的生命周期会被设置为a的生命周期 当使用impl Trait + ‘_标注时，范围内的trait的生命周期会被自动推导 下面是trait对象的生命周期与impl trait的生命周期找错练习题 rust trait Foo {} impl Foo for \u0026'_ str {} fn f1\u003cT:Foo\u003e(t:T)-\u003eBox\u003cimpl Foo\u003e{ Box::new(t) } fn f2\u003cT:Foo\u003e(t:T)-\u003eBox\u003cdyn Foo\u003e{ Box::new(t) } fn f3(s:\u0026str)-\u003eBox\u003cimpl Foo\u003e{ Box::new(s) } fn f4(s:\u0026str)-\u003eBox\u003cdyn Foo\u003e{ Box::new(s) } 只有f1是正确的，接下来让我们逐条分析 对于f1而言，impl Foo只会捕捉泛型T的生命周期，因此在调用f1并给实例化T时，f1会捕捉impl Foo for \u0026’_ str中str的生命周期，此时在编译器的眼里来看是这样的fn f1\u003cSomeT:Foo + ‘_\u003e(t:SomeT + ‘_)-\u003eBox\u003cimpl Foo + ‘_\u003e，因此f1生命周期约束完全，编译无问题 对于f2而言，由于我们没有指定dyn Foo的生命周期，因此编译器会根据trait对象的生命周期规则生成’static的生命周期，但是f2内部Box返回的并不是一份具有’static生命周期的变量，因此编译报错 对于f3而言，impl不会捕捉s的生命周期而只会捕捉泛型T的生命周期，因此f3在编译器的眼里来看是这样的fn f3\u003c’_\u003e(s:\u0026’_ str)-\u003eBox\u003cimpl Foo\u003e，而返回值并没有标注生命周期，生命周期约束不完全，编译器会提示error[E0700]: hidden type for impl Foo captures lifetime that does not appear in bounds 对于f4而言，它发生错误的原因类似f2，也就是dyn Foo没有指定生命周期从而被编译器推导为’static的生命周期 那么我们应该怎样才能修改正确呢？ 对于f2，我们可以指定参数s的生命周期为’static来应对默认生成的dyn Foo的生命周期，我们也可以指定dyn Foo的生命周期来放宽传入参数的约束 rust fn f2\u003cT:Foo\u003e(t:T)-\u003eBox\u003cdyn Foo + 'static\u003e fn f2\u003c'a,T:Foo + 'a\u003e(t:T)-\u003eBox\u003cdyn Foo + 'a\u003e 对于f3，我们应该约束s参数的生命周期为’static，或者补充impl Foo的生命周期 rust fn f3(s:\u0026'static str)-\u003eBox\u003cimpl Foo\u003e fn f3\u003c'a\u003e(s:\u0026'a str)-\u003eBox\u003cimpl Foo + 'a\u003e fn f3(s:\u0026str)-\u003eBox\u003cimpl Foo + '_\u003e//也可以让编译器实现 对于f4，解决方法有多种，我们既可以约束传入的生命周期参数也可以为返回类型指定生命周期参数 rust fn f4(s:\u0026'static str)-\u003eBox\u003cdyn Foo\u003e fn f4\u003c'a\u003e(s:\u0026'a str)-\u003eBox\u003cdyn Foo + 'a\u003e fn f4(s:\u0026str)-\u003eBox\u003cdyn Foo + '_\u003e ","date":"2024-12-15","objectID":"/posts/rust/:15:5","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#静态trait对象的生命周期"},{"categories":["Tech"],"content":" 闭包闭包的定义 rust let closure = |param|{ //function body }; 闭包不像函数那样要求标注参数和返回值类型，这是因为闭包不必暴露接口，它只是在本地临时使用。而函数有时需要暴露给用户或下游，这就需要在接口方面取得一致性。另一方面，闭包比较小，上下文的工作环境比较明确，编译器可以自动推断类型，当然rust也支持手动给闭包标注类型 一个闭包不支持多次不同参数的计算 rust fn main() { let closure = |x|{x}; let y = closure(String::from(\"value\")); let z = closure(5); } 上述代码在定义z时会报错，因为闭包类型已经被推断为String类型的了，再将i32类型的值传入就会报错 闭包可以捕获上下文环境。此时需要使用move关键字 rust fn main() { let x = vec![1,2,3]; let closure = move |z|{ z == x}; let y = vec![2,3,4]; println!(\"{}\",closure(y)); } 在创建闭包后可能会发生所有权的问题(C++的闭包是惰性加载的，rust不是)，我们可以使用trait(Fn,FnMut,FnOnce)来约束所有权，但如果让编译器自行推断的话就会产生错误 rust fn main() { let x = vec![1,2,3]; let closure = move |z|{ z == x}; println!(\"{}\",x[0]); //注意这里，没有实现copy trait的类型的所有权在上一行代码中已经发生了移动，这里想再次获得所有权就会失败 let y = vec![2,3,4]; println!(\"{}\",closure(y)); } 获取所有权的情况多发生在多线程的数据转移或共享的环境 在rust中，闭包的一大用处就是用于缓存计算结果 rust struct Cacher\u003cT\u003e where T: Fn(u32) -\u003e u32, { query: T, value: Option\u003cu32\u003e, } impl\u003cT\u003e Cacher\u003cT\u003e where T: Fn(u32) -\u003e u32, { fn new(query: T) -\u003e Cacher\u003cT\u003e { Cacher { query, value: None, } } // 先查询缓存值 `self.value`，若不存在，则调用 `query` 加载，并把加载后的值存入value fn value(\u0026mut self, arg: u32) -\u003e u32 { match self.value { Some(v) =\u003e v, None =\u003e { let v = (self.query)(arg); self.value = Some(v); v } } } } 上面的例子中，我们可以给cacher传入不同逻辑的闭包来缓存各种计算结果。但只能缓存一次结果，并且没有实现cacher内部元素的泛型 ","date":"2024-12-15","objectID":"/posts/rust/:16:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#闭包"},{"categories":["Tech"],"content":" 闭包的trait所有的闭包都实现了以下trait之一，且函数指针实现了全部3种闭包trait: Fn: 从环境中不可变借用值 FnMut: 从环境中可变借用值 FnOnce: 从环境中取得值的所有权 这三种方式规定了闭包从环境中捕获变量的方式 仅实现FnOnce特征的闭包在调用后会失去所有权，所以不能对已失去所有权的闭包变量进行二次调用： rust fn fn_once\u003cF\u003e(func: F) where F: FnOnce(usize) -\u003e bool, { println!(\"{}\", func(3)); //println!(\"{}\", func(4)); //不能进行二次调用 } fn main() { let x = vec![1, 2, 3]; fn_once(move |z|{z == x.len()}) } 下面是FnMut的情况，闭包中获取并修改s的值导致update_string必须使用mut进行修饰 rust fn main() { let mut s = String::new(); let mut update_string = |str| s.push_str(str); update_string(\"hello\"); println!(\"{:?}\",s); } 我们也可以指明闭包内部使用可变借用FnMut，这样就不必指明update_string为mut类型了 rust fn main() { let mut s = String::new(); let mut update_string = |str| s.push_str(str); exec(update_string); println!(\"{:?}\",s); } fn exec\u003c'a, F: FnMut(\u0026'a str)\u003e(mut f: F) { f(\"hello\") } 如果一个地方需要使用Fn特征，我们使用了FnMut特征也无妨 rust fn main() { let s = \"hello, \".to_string(); let update_string = |str| println!(\"{},{}\",s,str); exec(update_string); println!(\"{:?}\",s); } fn exec\u003c'a, F: FnMut(String) -\u003e ()\u003e(mut f: F) { //使用FnMut也可以，但换为Fn更准确 f(\"world\".to_string()) } 闭包实现了哪种Fn特征取决于它如何使用捕获的变量，而不是如何捕获变量。后者通过move关键字修饰，前者依靠编译器推导，因此当我们使用move的时候只是将变量所有权移动到闭包内部，至于闭包对这些变量进行只读(Fn)，写(FnMut)还是消耗(FnOnce)这些变量，move无法确定 ","date":"2024-12-15","objectID":"/posts/rust/:16:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#闭包的trait"},{"categories":["Tech"],"content":" 闭包作为返回值首先我们需要知道impl trait语法: 该语法用于说明函数返回一个类型，该类型实现了某个trait，该语法常用于返回的具体类型十分复杂或该函数返回了多种类型以至于我们不想将这个/这些类型暴露为函数接口时，唯一的替代方法就是返回这个类型的trait。这样，我们就可以告诉调用者: “你不必关注类型，只关注trait就可以了”。下面的代码就是一个很好的例子 rust fn returns_summarizable() -\u003e impl Summary { //Weibo实现了Summary trait Weibo { username: String::from(\"sunface\"), content: String::from( \"m1 max太厉害了，电脑再也不会卡\", ) } } 但是当返回值是多种类型时，该方法就失效了 rust fn returns_summarizable(switch: bool) -\u003e impl Summary { //Post与Weibo都实现了Summary trait if switch { Post { title: String::from( \"Penguins win the Stanley Cup Championship!\", ), author: String::from(\"Iceburgh\"), content: String::from( \"The Pittsburgh Penguins once again are the best \\ hockey team in the NHL.\", ), } } else { Weibo { username: String::from(\"horse_ebooks\"), content: String::from( \"of course, as you probably already know, people\", ), } } } 报错如下 rust `if` and `else` have incompatible types expected struct `Post`, found struct `Weibo` 我们就需要使用特征对象来指定，这一过程类似与C++的多态 rust fn returns_summarizable(switch: bool) -\u003e Box\u003cdyn Summary\u003e { //Post与Weibo都实现了Summary trait if switch { Post { title: String::from( \"Penguins win the Stanley Cup Championship!\", ), author: String::from(\"Iceburgh\"), content: String::from( \"The Pittsburgh Penguins once again are the best \\ hockey team in the NHL.\", ), } } else { Weibo { username: String::from(\"horse_ebooks\"), content: String::from( \"of course, as you probably already know, people\", ), } } } 对于闭包，我们需要函数返回值是闭包类型 rust fn factory() -\u003e impl Fn(i32) -\u003e i32 { let num = 5; |x| x + num } let f = factory(); let answer = f(1); assert_eq!(6, answer); 这同样只能支持一种返回类型，对于下面的使用方式impl就无能为力了 rust fn factory(x:i32) -\u003e Box\u003cdyn Fn(i32) -\u003e i32\u003e { let num = 5; if x \u003e 1{ Box::new(move |x| x + num) } else { Box::new(move |x| x - num) } } 这令人奇怪，两条分支的类型不是一样的么？这是由于就算签名一样的闭包，类型也是不同的，因此会产生如下错误 rust error[E0308]: `if` and `else` have incompatible types --\u003e src/main.rs:15:9 | 12 | / if x \u003e 1{ 13 | | move |x| x + num | | ---------------- expected because of this 14 | | } else { 15 | | move |x| x - num | | ^^^^^^^^^^^^^^^^ expected closure, found a different closure 16 | | } | |_____- `if` and `else` have incompatible types | 究其根本在 Rust 中，闭包是匿名结构体，每个闭包的类型是唯一的，即使签名一样，下面是rust编译器眼中的闭包 rust //源代码 let a = |x| x + 5; let b = |x| x + 5; //编译器眼中的 type A = impl Fn(i32) -\u003e i32; type B = impl Fn(i32) -\u003e i32; // A != B 所以我们只能使用特征对象来实现 rust fn factory(x:i32) -\u003e Box\u003cdyn Fn(i32) -\u003e i32\u003e { let num = 5; if x \u003e 1{ Box::new(move |x| x + num) } else { Box::new(move |x| x - num) } } ","date":"2024-12-15","objectID":"/posts/rust/:16:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#闭包作为返回值"},{"categories":["Tech"],"content":" 迭代器rust中的迭代器是惰性加载的，只有当执行next方法或者调用了next的其它方法(这被称为消耗型适配器)时才会执行代码。正如在vector小节提到的，只有执行了next方法迭代器才会向前一步，返回的值是向前一步之前的位置的值 所有迭代器均实现了Iterator trait 常用的迭代方法 rust iter: 在不可变引用上创建迭代器 into_iter: 创建的迭代器会获得所有权 iter_mut: 迭代可变的引用 sum，collect方法是消费者型适配器，collect会将一个迭代器转换为其它集合类型的结构，如Vec、HashMap等，sum会对迭代器中所有元素求和 使用消费型迭代器后原迭代器的所有权就丢失了，因为 Iterator 没有实现 Copy，也通常没有实现 Clone ","date":"2024-12-15","objectID":"/posts/rust/:17:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#迭代器"},{"categories":["Tech"],"content":" 迭代器适配器迭代器适配器会返回一个新的迭代器，常用的生成迭代器适配器的方法是map方法，我们可以使用闭包来指定返回的新的迭代器的值 rust let v1: Vec\u003ci32\u003e = vec![1, 2, 3]; v1.iter().map(|x| x + 1); 由于消费者型适配器会消耗掉原始迭代器，因此如果希望对数据执行多个操作，可以使用迭代器适配器来返回一个新的迭代器，进行链式调用。这种方式不会立即执行操作，而是等到调用消费者适配器时才真正开始计算 rust fn main() { let numbers = vec![1, 2, 3, 4, 5]; // 使用迭代器适配器 map 和 filter，返回新的迭代器 let processed = numbers .iter() .map(|x| x * 2) // 每个元素乘以2 .filter(|x| x \u003e \u00265); // 只保留大于5的元素 // 最终调用 collect（消费者）来收集结果 let result: Vec\u003c_\u003e = processed.collect(); println!(\"{:?}\", result); // 输出: [6, 8, 10] } ","date":"2024-12-15","objectID":"/posts/rust/:17:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#迭代器适配器"},{"categories":["Tech"],"content":" fliter方法fliter方法要求的参数与C++的谓词类似，但是谓词是返回值为bool的仿函数，而fliter方法要求的参数是一个闭包，并且这个闭包的返回值是bool类型，符合闭包的值将会包含在fliter保存的迭代器中 rust struct Shoe{ size:u32, color:String, } fn shoes_fit_my_size(mysize:u32, shoes:Vec\u003cShoe\u003e)-\u003eVec\u003cShoe\u003e{ shoes.into_iter().filter(|x| -\u003ebool{x.size == mysize}).collect() //into_iter获得所有权，filter从符合要求的迭代器中生成新的迭代器，collect将新的迭代器转化为集合(也就是Vec\u003cShoe\u003e) } fn main() { let shoes = vec![ Shoe{ size:10, color:String::from(\"black\"), }, Shoe{ size:30, color:String::from(\"red\"), }, Shoe{ size:10, color:String::from(\"green\"), } ]; let new_shoes = shoes_fit_my_size(10, shoes); for iter in new_shoes{ println!(\"color:{},size:{}\",iter.color,iter.size); } } 通过上文介绍可知，iterator最为关键的是next方法(在iterator trait规定的唯一方法就是next)，因此如果我们想要自定义迭代器，只需实现对应的next方法即可 rust struct Counter{ count:u32, } impl Counter { fn new()-\u003eCounter{ Counter{ count:0, } } } impl Iterator for Counter { type Item = u32; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e{ if self.count \u003c 5{ self.count += 1; Some(self.count) }else { None } } } 实际上，自行实现的Iterator trait来自于标准库 rust pub trait Iterator { ... type Item; ... fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e; ... } 相比手写循环并维护mut变量，迭代器的速度会更快！这是因为迭代器虽然是高级抽象概念，但编译后的产物与手写的底层代码几乎相同。这被称为零开销抽象(抽象实例化后不会引入额外的运行时开销) 我们再详细的解释一下为什么迭代器会更快一些: 在使用迭代器时，编译器不会直接使用循环替代迭带操作，由于大部分情况迭代器的元素数量是已知的，因此编译器会进行循环展开的操作。相比之下，传统的 for 或 while 循环在每次迭代时都需要进行边界判断或条件比较，而这恰恰是循环中主要的性能开销之一。Rust 的迭代器通过消除这些重复判断、内联函数调用以及展开循环等方式，减少了运行时的开销，提高了性能 这也是为什么在 Rust 中推荐使用迭代器风格编程：不仅代码更简洁表达力更强，而且经过优化后，运行效率往往比手写循环还要高 下面的例子很好的说明了filter，map和迭代器的工作模式 rust let v = vec![1u64, 3, 3, 2, 5, 6]; let val = v.iter() .enumerate() // 每两个元素剔除一个 // [1, 3, 5] .filter(|\u0026(idx, _)| idx % 2 == 0) .map(|(_, val)| val) // 累加 1+3+5 = 9 .fold(0u64, |sum, acm| sum + acm); println!(\"{}\", val); 首先v调用iter()方法产生一个迭代器并使用enumerate()方法将迭代器转为枚举迭代器，此时迭代器的序列如下所示 rust (0, \u00261), (1, \u00263), (2, \u00263), (3, \u00262), (4, \u00265), (5, \u00266) 第一个元素为枚举迭代器的索引，第二个元素为原迭代器元素的引用。之后使用filter方法将迭代器的元素进行过滤，过滤方式使用闭包描述，闭包的第一个参数是元素索引，第二个参数本应该是value但由于过滤规则不涉及value因此留空。过滤完成后的迭代器如下所示 rust (0, \u00261), (2, \u00263), (4, \u00265) 而后使用map产生一个新的迭代器，迭代器的具体值是filter过滤完成后枚举迭代器的元素的值，此时迭代器如下所示 rust \u00261, \u00263, \u00265 最后调用fold方法将迭代器的值按总和输出 ","date":"2024-12-15","objectID":"/posts/rust/:17:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#fliter方法"},{"categories":["Tech"],"content":" crate","date":"2024-12-15","objectID":"/posts/rust/:18:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#crate"},{"categories":["Tech"],"content":" 注释与文档crates.io是官方维护的crate源，但lib.rs包更丰富 对于代码注释，我们使用//来标注，对于生成文档的注释，我们使用///来标注，并且在文档注释中rust还支持markdown语法 文档注释编写后需要生成 shell cargo doc 生成并浏览 shell cargo doc --open ","date":"2024-12-15","objectID":"/posts/rust/:18:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#注释与文档"},{"categories":["Tech"],"content":" 模块导入使用mod对模块进行定义，注意函数体的写法 rust // 模块定义（无分号） pub mod front_of_house { // 子模块（无分号） pub mod hosting { pub fn add_to_waitlist() {} //没有分号 pub fn seat_at_table() {} } //没有分号 pub mod serving { pub fn take_order() {} pub fn serve_order() {} pub fn take_payment() {} } } 模块的声明 rust mod front_of_house::hosting; pub use 用于将内部结构的接口重新导出为外部结构的接口。如下代码所示，在不使用pub use时必须在main.rs中提前指定use的路径，如果要导入的方法和crate很多，那么这对于要使用接口的下游开发者很不友好，它们必须在层级文件夹中找到对应的crate和方法 rust //lib.rs pub mod kinds{ pub enum PrimaryColor { Red, Yellow, Blue, } pub enum SecondaryColor { Orange, Purple, Green, } } pub mod utils{ use crate::kinds::*; pub fn mix(c1:PrimaryColor,c2:SecondaryColor)-\u003eSecondaryColor{ SecondaryColor::Green } } //main.rs use first_proj::kinds::PrimaryColor; use first_proj::utils; fn main() { //do someting } 使用pub use后在main.rs导入crate和方法会方便很多，这里的self指的是模块内可见(想要包内可见需使用crate) rust //lib.rs pub use self::kinds::PrimaryColor; pub use self::kinds::SecondaryColor; pub use self::utils::mix; pub mod kinds{ pub enum PrimaryColor { Red, Yellow, Blue, } pub enum SecondaryColor { Orange, Purple, Green, } } pub mod utils{ use crate::kinds::*; pub fn mix(c1:PrimaryColor,c2:SecondaryColor)-\u003eSecondaryColor{ SecondaryColor::Green } } //main.rs use first_proj::PrimaryColor; //这里等价于use first_proj::kinds::PrimaryColor;; use first_proj::utils; fn main() { //do someting directly with PrimaryColor and utils } 这样实际的源代码无论有多少层级，在下游开发者看来只有一个层级 由于src/main.rs与src/lib.rs构成了包根(crate root)，而包根可以作为该包的树形结构的根部，因此我们可以用包根的绝对路径来引用到其它模块 rust crate └── front_of_house ├── hosting │ ├── add_to_waitlist │ └── seat_at_table └── serving ├── take_order ├── serve_order └── take_payment 模块默认属性是私有的，所以其他模块调用本模块时需要加pub，并且尽管父模块使用pub修饰但仍不影响子模块私有的属模块中的项（如函数、结构体、常量等）默认是私有的（private），因此其他模块在访问这些项时，必须使用 pub 关键字显式地将其设为公有。同时需要注意的是，即使父模块被声明为 pub，这并不会自动让其子模块中的项变为公有。要使外部模块能够访问某个子模块中的项，必须在从顶层模块到目标项的每一级路径上都使用 pub 修饰符进行公开 rust mod front_of_house { mod hosting { fn add_to_waitlist() {} } } pub fn eat_at_restaurant() { // 绝对路径 crate::front_of_house::hosting::add_to_waitlist(); } 上面代码会报错 rust error[E0603]: module `hosting` is private --\u003e src/lib.rs:9:28 | 9 | crate::front_of_house::hosting::add_to_waitlist(); | ^^^^^^^ private module 当一个项目比较大，同时需要多个crate才能构建时。rust提供了cargo.lock文件以维护版本依赖。例如，当一个crate依赖0.8.0版本的rand crate，而另一个crate依赖0.8.1的rand crate时。如果我们执行cargo build命令，那么cargo就会去crate.io寻找符合两个crate的rand crate，其最终结果是0.8.1版本。而后cargo在cargo.lock文件中指明两个crate所需rand crate的版本为0.8.1，尽管它们在各自的cargo.toml中指定了不同的版本号。但假如两个crate所需依赖的版本相差太大，那么cargo也不会去寻找它们的公共依赖(因为这时可能有冲突)，这时cargo会为两个crate准备不同版本的依赖，比如rand 0.8.0和rand 0.7.0。详情参考The Rust Programming Language 可以看到，cargo.lock与cargo.toml作用上很相似，但cargo.lock提供了更精确的版本号(如0.8.0-20250215)，而cargo.toml提供了更精确的元数据，指明了该包的仓库地址，作者等信息。所以我们cargo.lock常用于开发二进制程序时的提交文件，而cargo.toml用于库项目，软件项目等程序时的提交文件 ","date":"2024-12-15","objectID":"/posts/rust/:18:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#模块导入"},{"categories":["Tech"],"content":" mod声明与use导入mod声明要求 被声明的模块在src文件夹下有对应的文件名及其实现 如果不能满足这个要求就需要在src文件夹下有对应的文件夹，并且这个文件夹与被声明模块同名，且该文件夹下要求有模块实现的文件 第一种的文件树如下 rust src ├── mod1.rs ├── mod2.rs └── lib.rs 第二种是更被推荐的 rust src ├── mymod | ├── mod1.rs │ └── mod2.rs │── mymod.rs └── lib.rs 第二种会将所有模块放在一个文件夹内，管理更方便 如果使用第二种方式进行项目管理，mymod.rs应添加如下代码 rust //mymod.rs mod mod1; mod mod2; 并在lib.rs中 rust //lib.rs pub mod mymod; 实现则需要放在mod1.rs和mod2.rs文件内进行 rust //mod1.rs pub mod mod1{ pub mod1_func(){} } //mod2.rs pub mod mod2{ pub mod2_func(){} } 使用方法如下 rust //main.rs use project_name::mod::mod1; use project_name::mod::mod2; 可以看出，与模块文件夹同名的 .rs 文件（如 foo.rs 或 foo/mod.rs） 负责该模块目录下的子模块引入、私有/公开接口控制和再组织。这类文件通常充当模块的根模块（module root），管理其子模块结构和对外暴露的符号 而 lib.rs 则作为整个 crate 的主入口文件，在模块根文件的基础上进一步组织整个项目的公共 API。它不仅可以引入顶层模块，还负责将整个库需要向外暴露的接口进行统一的 pub use 重导出，从而隐藏内部实现细节，形成清晰且简洁的对外 API 层 pub use放在lib.rs内 rust // lib.rs pub mod mymod; pub use mymod::*; // 可选：将 mymod 中公开的内容再公开一层 ","date":"2024-12-15","objectID":"/posts/rust/:18:3","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#mod声明与use导入"},{"categories":["Tech"],"content":" 安装二进制crate我们使用cargo install来安装二进制crate，存放目录位于$HOME/.cargo/bin 注意: 我们只能安装binary crate ","date":"2024-12-15","objectID":"/posts/rust/:19:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#安装二进制crate"},{"categories":["Tech"],"content":" 智能指针引用与智能指针的不同: 引用大部分情况下只借用数据 智能指针拥有数据 智能指针的例子: String Vec\u003cT\u003e 智能指针的实现: 通常使用struct实现，并且实现了Deref trait和Drop trait Deref trait允许智能指针像引用一样使用 Drop trait定义了智能指针走出作用域时执行的代码 常见的智能指针: Box\u003cT\u003e: 在堆内存上分配 Rc\u003cT\u003e: 多重所有权的引用计数类型 Ref\u003cT\u003e和RefMut\u003cT\u003e: 通过RefCell\u003cT\u003e访问，在运行时而不是编译时检查借用规则的类型 ","date":"2024-12-15","objectID":"/posts/rust/:20:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#智能指针"},{"categories":["Tech"],"content":" Box\u003cT\u003eBox\u003cT\u003e是最简单的智能指针，功能类似C的malloc或者C++的new，因此Box相比其它智能指针也就没有额外的性能开销 Box\u003cT\u003e只会将T类型封装并放在堆上，想要获取指针需要同时使用new的关联方法 rust let p = Box::new(5); //将5放在堆上并获取不可变引用 // *p += 1； //不能更改不可变引用的值 let mut p = Box::new(10); *p += 1; //这样就可以更改堆上的数据 链表用rust写链表简直折磨，这里我写了个示例。具体实现使用头插法，并且在数据插入链表中间时会丧失链表头的所有权(显然clone能够解决，但是我不想实现trait) rust #[derive(PartialEq)] #[derive(Clone)] struct List{ data:i32, node:Option\u003cBox\u003cList\u003e\u003e, } impl List { fn new()-\u003eList{ List{ data: 0, node: None, } } fn insert_benhind(from:\u0026mut List,mut to:List)-\u003eList{ //from 插到 to后 from.node = to.node; let from_inlist = from.clone(); to.node = Some(Box::new(from_inlist)); to } fn add_to_head(mut head:List,prv:List)-\u003eList{ head.node = Some(Box::new(prv)); head } fn insert_benhind_self(\u0026mut self, to:List) -\u003e List{ let rt = List::insert_benhind( self, to); rt } fn add_to_head_self(self, head:List)-\u003eList{ let rt = List::add_to_head(head, self); rt } fn print_list(\u0026self)-\u003e(){ let mut cur = self; println!(\"{}\",cur.data); while let Some(ref header) = cur.node { println!(\"{}\",header.data); cur = header; } } } fn main(){ let mut l1 = List::new(); l1.data = 1; let mut l2=List::new(); l2.data = 2; let mut l3=List::new(); l3.data = 3; let mut l4=List::new(); l4.data = 4; let l1 = l2.add_to_head_self(l1); let l1 = l3.insert_benhind_self(l1); // let l2 = l4.insert_benhind_self(*l1.node.unwrap()); l1.print_list(); } 标准库中的链表实现也是unsafe的，因此不必过于纠结 ","date":"2024-12-15","objectID":"/posts/rust/:20:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#boxt"},{"categories":["Tech"],"content":" BoxBox是最简单的智能指针，功能类似C的malloc或者C++的new，因此Box相比其它智能指针也就没有额外的性能开销 Box只会将T类型封装并放在堆上，想要获取指针需要同时使用new的关联方法 rust let p = Box::new(5); //将5放在堆上并获取不可变引用 // *p += 1； //不能更改不可变引用的值 let mut p = Box::new(10); *p += 1; //这样就可以更改堆上的数据 链表用rust写链表简直折磨，这里我写了个示例。具体实现使用头插法，并且在数据插入链表中间时会丧失链表头的所有权(显然clone能够解决，但是我不想实现trait) rust #[derive(PartialEq)] #[derive(Clone)] struct List{ data:i32, node:Option","date":"2024-12-15","objectID":"/posts/rust/:20:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#链表"},{"categories":["Tech"],"content":" Deref trait自行实现Deref trait可以自定义解引用符号*的行为，这可以像常规引用一样处理智能指针 在std中，Box\u003cT\u003e被定义为拥有一个元素的tuple struct rust use std::ops::Deref; struct MyBox\u003cT\u003e(T); impl\u003cT\u003e MyBox\u003cT\u003e { fn new(x:T)-\u003eMyBox\u003cT\u003e{ MyBox(x) } } impl\u003cT\u003e Deref for MyBox\u003cT\u003e { type Target = T; fn deref(\u0026self) -\u003e \u0026Self::Target { \u0026self.0 } } Deref trait的实现有一些令人困惑的地方 rust impl\u003cT: ?Sized\u003e Deref for \u0026T { type Target = T; fn deref(\u0026self) -\u003e \u0026Target { *self } } //当调用deref trait时，rust会在底层调用如下代码 *(y.deref()) fn deref(\u0026self) -\u003e \u0026T这行代码正确地理解是\u0026T作为self，但参数是\u0026self，因此这行代码的效果是将\u0026T类型传入，之后获取\u0026\u0026T类型并返回为\u0026T类型。这里可能有疑问：传入\u0026T，返回的还是\u0026T，这函数有什么用？而且这个函数名字是解引用，但是实际上并没有任何解引用的操作 让我们一条一条来解答，首先为什么输入输出类型相同？实际上输入输出类型可以不相同，这取决于我们的需求。例如对于某个struct，我想要通过deref获得第一个元素的值，那么代码应该换成这样 rust fn deref(\u0026self) -\u003e \u0026Target { \u0026self.0 } 通过这样我们可以换成第一个元素的不可变借用(.0操作导致Deref Coercion)。那么我们为什么非得返回引用，直接返回值不好么？ 这是由于借用规则，当我们想要返回值的时候，原值的所有权会被调用deref trait的那个类型的对象持有，也就是y那里，这之后想再次使用原值时就会违反借用规则。而返回引用则不涉及所有权移动，这只是在栈上创建了\u0026T的副本，我们将这个副本解引用来获得T或转移副本，都不会违反借用规则 ","date":"2024-12-15","objectID":"/posts/rust/:20:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#deref-trait"},{"categories":["Tech"],"content":" 函数和方法的隐式解引用转化(Deref Coercion)对于实现了Deref trait的类型，编译器会根据上下文自动判断并调用Deref trait以使编译通过 产生条件: 把某类型的引用作为函数或方法的参数但与函数或方法要求的参数不匹配时，Deref Coercion就会自动发生 rust fn hello(name:\u0026str){ println!(\"hello {}\",name); } fn main() { let m = MyBox::new(String::from(\"rust\")); //\u0026m \u0026MyBox\u003cString\u003e //deref \u0026String //deref \u0026str hello(\u0026m); //上下两个函数结果相同 hello(\"rust\"); } 上述代码在执行hello(\u0026m);时就会产生Deref Coercion，编译器会检查MyBox\u003cString\u003e是否实现了deref trait，而后自动进行deref将\u0026MyBox\u003cString\u003e转化为\u0026String，之后编译器还会继续判断String是否实现了deref trait，并继续调用对应的deref trait将\u0026String转为\u0026str。这就是我们在println!填入\u0026String和str都可以正常打印的原因 ","date":"2024-12-15","objectID":"/posts/rust/:20:3","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#函数和方法的隐式解引用转化deref-coercion"},{"categories":["Tech"],"content":" Drop traitDrop trait 可以被理解为 Rust 中的析构函数。当一个值离开作用域时，编译器会自动调用其实现的 Drop::drop 方法，以执行清理逻辑（如关闭文件、释放堆内存等） 需要注意的是，Rust 禁止手动调用 Drop::drop 方法。这是因为 Drop::drop 可能会释放该值拥有的内部资源（例如堆内存、文件句柄等），但不会标记该值本身为“已被销毁”。这样一来，当该值离开作用域时，编译器仍会再次自动调用 drop，导致**双重释放（double free）或使用已释放资源（use-after-free）**等未定义行为。也就是说，Rust接管了堆内存的管理，我们只有在Rust不清楚如何管理堆内存时才会实现Drop trait，例如实现某些自定义结构体时 为了安全地提前释放一个值，可以使用标准库提供的 std::mem::drop 函数。它会转移值的所有权并立刻销毁它，确保该值之后不会再被使用，也不会再被自动 drop，从而避免 double free 等问题 Drop trait与std::mem::drop的区别在于，前者可能会关闭堆内存，如fd，mpsc::channel等，这就意味着Drop是个trait，也就是允许我们自定义清理逻辑，这常见于自定义结构体或其他数据类型的情况。但是真正提前清理栈内存则需要std::mem::drop出手 stm::mem::drop位于预导入模块(prelude)，直接使用即可 ","date":"2024-12-15","objectID":"/posts/rust/:20:4","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#drop-trait"},{"categories":["Tech"],"content":" Rc\u003cT\u003eRc\u003cT\u003e: reference counting，类似shared_pointer的引用计数，只能使用在单线程环境 Rc::clone(): 只进行指针的拷贝操作，不进行数据的拷贝操作 类型的clone: 进行数据的拷贝操作 Rc\u003cT\u003e: 是不可变引用，可以在内存中共享只读数据。不支持可变引用的原因是这会破坏借用规则 下面是Rc\u003cT\u003e的使用示例 rust use std::rc::Rc; fn print_data(data: Rc\u003ci32\u003e) { println!(\"Data inside function: {}\", data); println!(\"Reference count in function: {}\", Rc::strong_count(\u0026data)); // 3 } fn main() { let data = Rc::new(42); let cloned1 = Rc::clone(\u0026data); let cloned2 = Rc::clone(\u0026data); print_data(cloned1); println!(\"Reference count after function: {}\", Rc::strong_count(\u0026data)); // 2 } Rc::clone(\u0026a): 增加引用计数 Rc::strong_count(\u0026a): 获得当前强引用计数值 Rc::weak_count(\u0026a): 获得当前弱引用计数值 下面是Rc\u003cT\u003e的使用例子 rust use std::rc::Rc; fn main() { let data = Rc::new(42); println!(\"Initial count: {}\", Rc::strong_count(\u0026data)); // 1 { let _cloned = Rc::clone(\u0026data); println!(\"Count inside scope: {}\", Rc::strong_count(\u0026data)); // 2 } // _cloned 离开作用域，计数减 1 println!(\"Count after scope: {}\", Rc::strong_count(\u0026data)); // 1 } ","date":"2024-12-15","objectID":"/posts/rust/:20:5","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#rct"},{"categories":["Tech"],"content":" RefCell\u003cT\u003e与内部可变性RefCell\u003cT\u003e 是 Rust 提供的运行时借用检查的智能指针，允许在不可变引用下修改内部数据（内部可变性） RefCell\u003cT\u003e运行时检查并抛panic的原理: 每次调用borrow时，不可变借用计数会+1，每次调用borrow_mut时，可变借用计数就会+1。当Ref\u003cT\u003e的值或RefMut\u003cT\u003e的值离开作用域被释放时，对应的计数器就会-1。这样我们对引用计数进行检查就可以判定运行时是否违反借用规则了 要访问 RefCell\u003cT\u003e 中的值，必须通过 .borrow() 获取不可变引用（类型为 Ref\u003cT\u003e），或通过 .borrow_mut() 获取可变引用（类型为 RefMut\u003cT\u003e） .borrow() 返回一个 Ref\u003cT\u003e，用于只读访问数据 .borrow_mut() 返回一个 RefMut\u003cT\u003e，用于修改数据 内部可变性是Rust的设计模式之一，这允许我们持有不可变引用时对数据进行修改，这违反了编译期借用规则是因为对应的数据结构中使用了unsafe代码来绕过Rust的借用规则，请注意，这只是绕过了编译时的借用规则检查，在运行时的借用规则检查仍不可避免，违反了就会导致panic Rc\u003cT\u003e RefCell\u003cT\u003e 编译阶段强制代码遵守借用规则 只在运行时检查借用规则 否则出现错误 否则触发panic 出现RefCell\u003cT\u003e的原因是: rust编译器是保守的，它会对所有不符合所有权和借用规则的代码抛出错误。但是对于一些正确的代码rust编译器可能分析不出来，这就有可能造成编译错误。尽管借用规则对于维护rust的安全性无疑是必须的，这保证了rust能始终受到开发者的信任，但同时也会造成不必要的错误。这样，为了满足这些“正确的”代码的需要，RefCell\u003cT\u003e就诞生了 与Rc\u003cT\u003e类似，RefCell\u003cT\u003e只能用于单线程场景 选择Box\u003cT\u003e，Rc\u003cT\u003e和RefCell\u003cT\u003e的依据 Box\u003cT\u003e Rc\u003cT\u003e RefCell\u003cT\u003e 同一个数据的所有者 一个 多个 一个 可变性，借用性检查 可变，不可变借用(编译时检查) 不可变借用(编译时检查) 可变，不可变借用(运行时检查) 如果上面的解释还是有点抽象，那么想象一个现实问题: 我们是中间件开发者，需要将下游应用开发者传进来的String类型的数据压入对应的Vector(这个Vec由下游开发者定义并传入)，但是为了保证接口的安全和一致性，我们暴露的接口允许接受的参数是\u0026self类型的，但是由于\"数据压入\"这一操作需要\u0026mut self类型的数据，这就违反了借用规则，此时比较好的解决办法就是使用RefCell\u003cT\u003e 以下是 RefCell\u003cT\u003e 的详细使用示例： rust use std::cell::RefCell; use std::rc::Rc; struct Button { // 按钮点击回调列表（可以在不可变引用下添加） callbacks: RefCell\u003cVec\u003cBox\u003cdyn Fn()\u003e\u003e\u003e, } impl Button { fn new() -\u003e Self { Button { callbacks: RefCell::new(Vec::new()), } } // 添加点击回调，注意这里是 \u0026self，不是 \u0026mut self！ fn add_callback\u003cF: Fn() + 'static\u003e(\u0026self, f: F) { self.callbacks.borrow_mut().push(Box::new(f)); } // 触发点击事件 fn click(\u0026self) { for cb in self.callbacks.borrow().iter() { cb(); } } } fn main() { let button = Button::new(); button.add_callback(|| println!(\"按钮被点击！\")); button.add_callback(|| println!(\"另一个回调触发！\")); button.click(); } 为什么只能用 RefCell\u003cT\u003e add_callback 的签名是 \u0026self，不是 \u0026mut self，因为我们希望允许多个地方共享这个按钮并添加回调 但是 Vec::push 需要可变引用，怎么办？这就是内部可变性的经典场景 RefCell\u003cT\u003e 可以让你在只持有 \u0026self 时内部修改内容 换成 Box\u003cVec\u003c_\u003e\u003e 是不行的，因为那就必须要 \u0026mut self 才能 push，而这就与该方法的本意相违背 我们可以将Rc\u003cT\u003e与RefCell\u003cT\u003e组合起来，这样我们就可以获得多个可变借用。但是我们要注意不能随意的使用Rc\u003cT\u003e和RefCell\u003cT\u003e组合类型，因为有可能造成循环引用，这会导致内存泄漏 ","date":"2024-12-15","objectID":"/posts/rust/:20:6","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#refcellt与内部可变性"},{"categories":["Tech"],"content":" 何时使用Rc\u003cT\u003e与RefCell\u003cT\u003eRc\u003cT\u003e与普通指针都实现了drop trait，但当一个程序中很多地方用到了普通指针，并且我们不知道哪个地方的指针时最后用到时，我们应该使用Rc\u003cT\u003e而不是普通指针，因为这可能在生命周期的管理上给普通指针造成巨大的困难。在使用方面，Rc\u003cT\u003e并没有违反借用规则，它只是简化了我们对借用规则的运用，它实际上是创建了一个新的指针并返回，同时内部维护了一个计数器 RefCell\u003cT\u003e适合用来处理可变的引用。与Rc\u003cT\u003e不同，RefCell\u003cT\u003e违反了编译时的借用规则，将其延后至运行时，这样我们就可以进行方便的但不\"安全\"的操作 ","date":"2024-12-15","objectID":"/posts/rust/:20:7","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#何时使用rct与refcellt"},{"categories":["Tech"],"content":" 循环引用与weak\u003cT\u003e与C++类似，rust并没有解决循环引用的问题，因此也只能采用weak指针的方法 Rc\u003cT\u003e可以通过Rc::downgrade方法创建弱引用，其返回类型是weak\u003cT\u003e 在使用weak\u003cT\u003e前，需要保证它指向的值仍然存在，我们可以使用upgrade方法，返回值为Option\u003cRc\u003cT\u003e\u003e，如果资源已经被释放，返回值为None rust use std::rc::Rc; fn main() { // 创建Rc，持有一个值5 let five = Rc::new(5); // 通过Rc，创建一个Weak指针 let weak_five = Rc::downgrade(\u0026five); // Weak引用的资源依然存在，取到值5 let strong_five: Option\u003cRc\u003c_\u003e\u003e = weak_five.upgrade(); assert_eq!(*strong_five.unwrap(), 5); // 手动释放资源`five` drop(five); // Weak引用的资源已不存在，因此返回None let strong_five: Option\u003cRc\u003c_\u003e\u003e = weak_five.upgrade(); assert_eq!(strong_five, None); } ","date":"2024-12-15","objectID":"/posts/rust/:20:8","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#循环引用与weakt"},{"categories":["Tech"],"content":" 无畏并发实现线程的方式: 通过调用os的api来创建线程 一个os线程对应一个语言线程(1:1模型) 需要较小的运行时 通过编程语言api创建线程 m个os线程对应n个语言线程(m:n模型) 需要较大的运行时 rust为了保持较高的效率，它采用了1:1模型，但是社区也提供了m:n模型的包 我们可以通过thread::spawn并传入闭包来创建线程 rust use std::{thread, time::Duration}; fn main() { thread::spawn(||{ for i in 1..10{ println!(\"thread1 {}\",i); thread::sleep(Duration::from_millis(1)); } }); for i in 1..5{ println!(\"thread2 {}\",i); thread::sleep(Duration::from_millis(1)); } } 虽然上述程序是交替执行的，但是在主线程执行完毕后，不管子线程是否执行完毕都会进行退出，这就可能导致主线程退出时子线程还没有结束，所以我们可以使用join来让主线程等待子线程 rust use std::{thread, time::Duration}; fn main() { let handle = thread::spawn(||{ for i in 1..10{ println!(\"thread1 {}\",i); thread::sleep(Duration::from_millis(1)); } }); for i in 1..5{ println!(\"thread2 {}\",i); thread::sleep(Duration::from_millis(1)); } handle.join().unwrap(); } 我们也可以让子线程全部执行完毕后再执行主线程 rust use std::{thread, time::Duration}; fn main() { let handle = thread::spawn(||{ for i in 1..10{ println!(\"thread1 {}\",i); thread::sleep(Duration::from_millis(1)); } }); handle.join().unwrap(); for i in 1..5{ println!(\"thread2 {}\",i); thread::sleep(Duration::from_millis(1)); } } 我们可以使用move来将其它线程变量的所有权转移到当前线程 rust use std::{thread, time::Duration}; fn main() { let v= vec![1,2,3]; let handle = thread::spawn(move ||{ for i in 1..10{ println!(\"v {:?}\",v); thread::sleep(Duration::from_millis(1)); } }); //drop(v); //会报错 } 如果在主线程获得v的所有权的话就会报v已经被借用的错误 线程数并不是越多越好，创建线程本身也有开销，每创建一个线程就需要耗费微秒甚至毫秒级时间，每个线程也需要空间开销。上面这一切都是不可忽略的，只有当多线程收益超过多线程开销时使用多线程才是必要的 有时创建的多线程数量等于cpu核数时甚至也不是最优的，详见Rust语言圣经，简单来说有以下几点原因 虽然是rust基本数据结构采用无锁(CAS)实现，但是即使是 CAS ，大量线程的同时访问也会让 CAS 重试次数大幅增加从而增大开销 线程过多时，CPU 缓存的命中率会显著下降，同时多个线程竞争一个 CPU Cache-line 的情况也会经常发生 大量读写可能会让内存带宽也成为瓶颈 读和写不一样，无锁数据结构的读操作开销往往可以伴随线程数线性增长，但是写操作会指数级增长，因为写竞争太大 ","date":"2024-12-15","objectID":"/posts/rust/:21:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#无畏并发"},{"categories":["Tech"],"content":" 线程间消息传递 channel使用mpsc::channel来创建channel，mpsc代表muti producer,single consumer(多生产者，单消费者) rust use std::{sync::mpsc, thread, time::Duration}; fn main() { let (tx,rx) = mpsc::channel(); let handle = thread::spawn(move ||{ //tx是在主线程内定义的，所以应使用move获取tx let v1= vec![1,2,3]; tx.send(v1).unwrap(); //此时v1的所有权已经移动到主线程身上了 }); let v2 = rx.recv().unwrap(); println!(\"v {:?}\",v2); } 注意，recv只能接受单条消息，想要接受多条消息可使用迭代器 rust use std::{sync::mpsc, thread::{self, JoinHandle}, time::Duration}; fn main() { let (tx,rx) = mpsc::channel(); let tx1 = mpsc::Sender::clone(\u0026tx); let handle = thread::spawn(move ||{ let v1= vec![1,2,3]; tx.send(v1).unwrap(); }); let handle1 = thread::spawn(move ||{ let v3= vec![4,5,6]; tx1.send(v3).unwrap(); }); for recv in rx{ println!(\"{:?}\",recv); } } 输出为 shell [1, 2, 3] // 线程1先发送 [4, 5, 6] // 线程2后发送 或 shell [4, 5, 6] // 线程2先发送 [1, 2, 3] // 线程1后发送 但不可能是 shell [1, 2, 4] [3, 5, 6] 因为rust的mpsc::channel的send方法保证消息的原子性，也就是说一次send只能完整的发送一条信息，该过程是原子的 如果不使用迭代器就需要两次打印操作才能将两个子线程的信息接受完毕 rust println!(\"{:?}\",recv); println!(\"{:?}\",recv); 使用迭代器的好处还包括： 自动维护通道，当发送通道关闭时(也就是drop掉所有sender)，迭代器也会自动退出 无需手动管理阻塞 我们也可以使用try_recv非阻塞的获取消息。下面的程序貌似没有问题，但是由于子线程的创建需要时间，因此channel内部是空的，这就会导致使用recv收到错误，而try_recv则可以避免这个问题 rust use std::sync::mpsc; use std::thread; fn main() { let (tx, rx) = mpsc::channel(); thread::spawn(move || { tx.send(1).unwrap(); }); println!(\"receive {:?}\", rx.try_recv()); } channel收发消息是异步的，但是我们也可以创建同步通道 rust use std::sync::mpsc; use std::thread; use std::time::Duration; fn main() { let (tx, rx)= mpsc::sync_channel(0); let handle = thread::spawn(move || { println!(\"发送之前\"); tx.send(1).unwrap(); println!(\"发送之后\"); }); println!(\"睡眠之前\"); thread::sleep(Duration::from_secs(3)); println!(\"睡眠之后\"); println!(\"receive {}\", rx.recv().unwrap()); handle.join().unwrap(); } sync_channel的参数是消息的缓冲区大小，消息没有超出缓冲区时，发哦宋喆进行同步发送，接收者拿到数据后立即返回，超出缓冲区时进行阻塞当前线程直到缓冲区有空间存放数据/有数据放入缓冲区 对于channel，所有发送者被drop或者所有接收者被drop后，通道会自动关闭。对于新手这点可能会是一个坑 rust use std::sync::mpsc; fn main() { use std::thread; let (send, recv) = mpsc::channel(); let num_threads = 3; for i in 0..num_threads { let thread_send = send.clone(); //多个 Sender（通过 clone() 创建）可以发送数据 thread::spawn(move || { thread_send.send(i).unwrap(); println!(\"thread {:?} finished\", i); }); } // 在这里drop send才对 for x in recv { //这里只有一个Receiver\u003cT\u003e println!(\"Got: {}\", x); } println!(\"finished iterating\"); } 输出为 shell thread 0 finished thread 1 finished thread 2 finished Got: 0 Got: 1 Got: 2 finished iterating 上述代码会导致主线程一直被阻塞不能退出，这是由于通道不能关闭导致的。尽管子线程持有的发送者thread_send在线程退出时就已经被drop了，但是最初的send并没有被释放，这就导致通道不能正常关闭。解决办法也很简单，在子线程结束后将send drop即可 主线程还留有send的原因是主线程的send通过clone方法复制3个，并move到子线程，但主线程原始的send并没有被move。这样在子线程内，当所有数据被发送完毕后系统会自动drop子线程内的所有send，但是主线程的send不会drop ","date":"2024-12-15","objectID":"/posts/rust/:21:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#线程间消息传递"},{"categories":["Tech"],"content":" 线程间消息传递 channel使用mpsc::channel来创建channel，mpsc代表muti producer,single consumer(多生产者，单消费者) rust use std::{sync::mpsc, thread, time::Duration}; fn main() { let (tx,rx) = mpsc::channel(); let handle = thread::spawn(move ||{ //tx是在主线程内定义的，所以应使用move获取tx let v1= vec![1,2,3]; tx.send(v1).unwrap(); //此时v1的所有权已经移动到主线程身上了 }); let v2 = rx.recv().unwrap(); println!(\"v {:?}\",v2); } 注意，recv只能接受单条消息，想要接受多条消息可使用迭代器 rust use std::{sync::mpsc, thread::{self, JoinHandle}, time::Duration}; fn main() { let (tx,rx) = mpsc::channel(); let tx1 = mpsc::Sender::clone(\u0026tx); let handle = thread::spawn(move ||{ let v1= vec![1,2,3]; tx.send(v1).unwrap(); }); let handle1 = thread::spawn(move ||{ let v3= vec![4,5,6]; tx1.send(v3).unwrap(); }); for recv in rx{ println!(\"{:?}\",recv); } } 输出为 shell [1, 2, 3] // 线程1先发送 [4, 5, 6] // 线程2后发送 或 shell [4, 5, 6] // 线程2先发送 [1, 2, 3] // 线程1后发送 但不可能是 shell [1, 2, 4] [3, 5, 6] 因为rust的mpsc::channel的send方法保证消息的原子性，也就是说一次send只能完整的发送一条信息，该过程是原子的 如果不使用迭代器就需要两次打印操作才能将两个子线程的信息接受完毕 rust println!(\"{:?}\",recv); println!(\"{:?}\",recv); 使用迭代器的好处还包括： 自动维护通道，当发送通道关闭时(也就是drop掉所有sender)，迭代器也会自动退出 无需手动管理阻塞 我们也可以使用try_recv非阻塞的获取消息。下面的程序貌似没有问题，但是由于子线程的创建需要时间，因此channel内部是空的，这就会导致使用recv收到错误，而try_recv则可以避免这个问题 rust use std::sync::mpsc; use std::thread; fn main() { let (tx, rx) = mpsc::channel(); thread::spawn(move || { tx.send(1).unwrap(); }); println!(\"receive {:?}\", rx.try_recv()); } channel收发消息是异步的，但是我们也可以创建同步通道 rust use std::sync::mpsc; use std::thread; use std::time::Duration; fn main() { let (tx, rx)= mpsc::sync_channel(0); let handle = thread::spawn(move || { println!(\"发送之前\"); tx.send(1).unwrap(); println!(\"发送之后\"); }); println!(\"睡眠之前\"); thread::sleep(Duration::from_secs(3)); println!(\"睡眠之后\"); println!(\"receive {}\", rx.recv().unwrap()); handle.join().unwrap(); } sync_channel的参数是消息的缓冲区大小，消息没有超出缓冲区时，发哦宋喆进行同步发送，接收者拿到数据后立即返回，超出缓冲区时进行阻塞当前线程直到缓冲区有空间存放数据/有数据放入缓冲区 对于channel，所有发送者被drop或者所有接收者被drop后，通道会自动关闭。对于新手这点可能会是一个坑 rust use std::sync::mpsc; fn main() { use std::thread; let (send, recv) = mpsc::channel(); let num_threads = 3; for i in 0..num_threads { let thread_send = send.clone(); //多个 Sender（通过 clone() 创建）可以发送数据 thread::spawn(move || { thread_send.send(i).unwrap(); println!(\"thread {:?} finished\", i); }); } // 在这里drop send才对 for x in recv { //这里只有一个Receiver println!(\"Got: {}\", x); } println!(\"finished iterating\"); } 输出为 shell thread 0 finished thread 1 finished thread 2 finished Got: 0 Got: 1 Got: 2 finished iterating 上述代码会导致主线程一直被阻塞不能退出，这是由于通道不能关闭导致的。尽管子线程持有的发送者thread_send在线程退出时就已经被drop了，但是最初的send并没有被释放，这就导致通道不能正常关闭。解决办法也很简单，在子线程结束后将send drop即可 主线程还留有send的原因是主线程的send通过clone方法复制3个，并move到子线程，但主线程原始的send并没有被move。这样在子线程内，当所有数据被发送完毕后系统会自动drop子线程内的所有send，但是主线程的send不会drop ","date":"2024-12-15","objectID":"/posts/rust/:21:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#channel"},{"categories":["Tech"],"content":" 自定义并发我们只需实现send trait(std::maker::Send)和sync trait(std::maker::Sync)就可以实现并发 send trait可以在线程间转移所有权，sync trait可以在多线程环境下访问，并且只要实现了sync trait，编译器就会自动帮我们实现send trait 只要 T: Sync，那么 \u0026T: Send 成立 —— 即 不可变引用可以在线程之间安全传递，是因为 T 支持并发读访问。更进一步说，实现了Sync trait的类型，在多线程间传递信息的是Box\u003c\u0026T\u003e或者Arc\u003c\u0026T\u003e类型 ","date":"2024-12-15","objectID":"/posts/rust/:21:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#自定义并发"},{"categories":["Tech"],"content":" 线程屏障(Barrier)注意：这是线程屏障而不是内存屏障 rust支持线程屏障 rust use std::sync::{Arc, Barrier}; use std::thread; fn main() { let mut handles = Vec::with_capacity(6); //预先创建容量为6的动态数组 let barrier = Arc::new(Barrier::new(6)); //Arc是线程安全的Rc\u003cT\u003e，这里创建了一个屏障，它会让6个线程在屏障点同步 for _ in 0..6 { let b = barrier.clone(); handles.push(thread::spawn(move|| { println!(\"before wait\"); b.wait(); println!(\"after wait\"); })); } for handle in handles { handle.join().unwrap(); } } 输出结果如下 rust before wait before wait before wait before wait before wait before wait after wait after wait after wait after wait after wait after wait ","date":"2024-12-15","objectID":"/posts/rust/:21:3","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#线程屏障barrier"},{"categories":["Tech"],"content":" 共享内存 互斥锁共享内存会有数据竞争的问题，因此我们使用互斥锁进行访问 rust use std::sync::Mutex; fn main() { let mut n = 5; // 使用`Mutex`结构体的关联函数创建新的互斥锁实例来报数数据n let m = Mutex::new(n); { // 获取锁，然后deref为`m`的引用 // lock返回的是Result let mut num = m.lock().unwrap(); *num += 1; // 锁自动被drop } println!(\"m = {:?}\", m); } 我们可以通过Mutex::new(T)来创建Mutex\u003cT\u003e，Mutex\u003cT\u003e是一个共享指针 在访问数据前通过lock的方式获取锁，这会阻塞当前线程 下面的程序有错误，尝试找出原因 rust use std::rc::Rc; use std::sync::Mutex; use std::thread; fn main() { // 通过`Rc`实现`Mutex`的多所有权 let counter = Rc::new(Mutex::new(0)); let mut handles = vec![]; for _ in 0..10 { let counter = Rc::clone(\u0026counter); // 创建子线程，并将`Mutex`的所有权拷贝传入到子线程中 let handle = thread::spawn(move || { let mut num = counter.lock().unwrap(); *num += 1; }); handles.push(handle); } // 等待所有子线程完成 for handle in handles { handle.join().unwrap(); } // 输出最终的计数结果 println!(\"Result: {}\", *counter.lock().unwrap()); } 当某个数据被多个线程使用时，由于我们在定义线程handle时会使用move方法，这会产生所有权的问题。因此我们需要使用多使用权的智能指针来解决，但由于Rc\u003cT\u003e不能在多线程中使用(它没有实现send trait)，因此我们需要使用Arc\u003cT\u003e(A代表atomic) RefCell\u003cT\u003e对应的就是Mutex\u003cT\u003e，但是使用Mutex\u003cT\u003e有死锁风险 下面是一段很容易就看出来错误的代码 rust use std::{sync::{Mutex, MutexGuard}, thread}; use std::thread::sleep; use std::time::Duration; use lazy_static::lazy_static; lazy_static! { static ref MUTEX1: Mutex\u003ci64\u003e = Mutex::new(0); static ref MUTEX2: Mutex\u003ci64\u003e = Mutex::new(0); } fn main() { // 存放子线程的句柄 let mut children = vec![]; for i_thread in 0..2 { children.push(thread::spawn(move || { for _ in 0..1 { // 线程1 if i_thread % 2 == 0 { // 锁住MUTEX1 let guard: MutexGuard\u003ci64\u003e = MUTEX1.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX1，接着准备去锁MUTEX2 !\", i_thread); // 当前线程睡眠一小会儿，等待线程2锁住MUTEX2 sleep(Duration::from_millis(10)); // 去锁MUTEX2 let guard = MUTEX2.lock().unwrap(); // 线程2 } else { // 锁住MUTEX2 let _guard = MUTEX2.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX2, 准备去锁MUTEX1\", i_thread); let _guard = MUTEX1.lock().unwrap(); } } })); } // 等子线程完成 for child in children { let _ = child.join(); } println!(\"死锁没有发生\"); } 两线程在锁住自己的同时去获取对方线程的资源，这会导致死锁 但当我们使用try_lock时情况就不同了 rust use std::{sync::{Mutex, MutexGuard}, thread}; use std::thread::sleep; use std::time::Duration; use lazy_static::lazy_static; lazy_static! { static ref MUTEX1: Mutex\u003ci64\u003e = Mutex::new(0); static ref MUTEX2: Mutex\u003ci64\u003e = Mutex::new(0); } fn main() { // 存放子线程的句柄 let mut children = vec![]; for i_thread in 0..2 { children.push(thread::spawn(move || { for _ in 0..1 { // 线程1 if i_thread % 2 == 0 { // 锁住MUTEX1 let guard: MutexGuard\u003ci64\u003e = MUTEX1.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX1，接着准备去锁MUTEX2 !\", i_thread); // 当前线程睡眠一小会儿，等待线程2锁住MUTEX2 sleep(Duration::from_millis(10)); // 去锁MUTEX2 let guard = MUTEX2.try_lock(); println!(\"线程 {} 获取 MUTEX2 锁的结果: {:?}\", i_thread, guard); // 线程2 } else { // 锁住MUTEX2 let _guard = MUTEX2.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX2, 准备去锁MUTEX1\", i_thread); sleep(Duration::from_millis(10)); let guard = MUTEX1.try_lock(); println!(\"线程 {} 获取 MUTEX1 锁的结果: {:?}\", i_thread, guard); } } })); } // 等子线程完成 for child in children { let _ = child.join(); } println!(\"死锁没有发生\"); } try_lock会尝试获取锁，如果获取不到就返回一个错误，之后代码继续在子线程中执行，因此不会导致死锁 读写锁rust中的读写锁类似linux中的读写锁，要么同时允许多个读，要么同时允许一个写 rust use std::sync::RwLock; fn main() { let lock = RwLock::new(5); // 同一时间允许多个读 { let r1 = lock.read().unwrap(); let r2 = lock.read().unwrap(); assert_eq!(*r1, 5); assert_eq!(*r2, 5); } // 读锁在此处被drop // 同一时间只允许一个写 { let mut w = lock.write().unwrap(); *w += 1; assert_eq!(*w, 6); // 以下代码会阻塞发生死锁，因为读和写不允许同时存在 // 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于`w`的作用域中 // let r1 = lock.read(); // println!(\"{:?}\",r1); }// 写锁在此处被drop } 条件变量下面是使用条件变量来进行线程的同步以控制顺序 rust use std::sync::{Arc,Mutex,Condvar}; use std::thread::{spawn,sleep}; use std::time::Duration; fn main() { let flag = Arc::new(Mutex::new(false)); let cond = Arc::new(Condvar::new()); let cflag = flag.clone(); let ccond = cond.clone(); let hdl = spawn(move || { let mut lock = cflag.lock().unwrap(); let mut counter = 0; while counter \u003c 3 { while !*lock { // wait方法会接收一个MutexGuard\u003c'a, T\u003e，且它会自动地暂时释放这个锁，使其它线程可以拿到锁并进行数据更新。 // 同时当前线程在此处会被阻塞，直到被其它地方notify后，它会将原本的MutexGuard\u003c'a, T\u003e还给我们","date":"2024-12-15","objectID":"/posts/rust/:21:4","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#共享内存"},{"categories":["Tech"],"content":" 共享内存 互斥锁共享内存会有数据竞争的问题，因此我们使用互斥锁进行访问 rust use std::sync::Mutex; fn main() { let mut n = 5; // 使用`Mutex`结构体的关联函数创建新的互斥锁实例来报数数据n let m = Mutex::new(n); { // 获取锁，然后deref为`m`的引用 // lock返回的是Result let mut num = m.lock().unwrap(); *num += 1; // 锁自动被drop } println!(\"m = {:?}\", m); } 我们可以通过Mutex::new(T)来创建Mutex，Mutex是一个共享指针 在访问数据前通过lock的方式获取锁，这会阻塞当前线程 下面的程序有错误，尝试找出原因 rust use std::rc::Rc; use std::sync::Mutex; use std::thread; fn main() { // 通过`Rc`实现`Mutex`的多所有权 let counter = Rc::new(Mutex::new(0)); let mut handles = vec![]; for _ in 0..10 { let counter = Rc::clone(\u0026counter); // 创建子线程，并将`Mutex`的所有权拷贝传入到子线程中 let handle = thread::spawn(move || { let mut num = counter.lock().unwrap(); *num += 1; }); handles.push(handle); } // 等待所有子线程完成 for handle in handles { handle.join().unwrap(); } // 输出最终的计数结果 println!(\"Result: {}\", *counter.lock().unwrap()); } 当某个数据被多个线程使用时，由于我们在定义线程handle时会使用move方法，这会产生所有权的问题。因此我们需要使用多使用权的智能指针来解决，但由于Rc不能在多线程中使用(它没有实现send trait)，因此我们需要使用Arc(A代表atomic) RefCell对应的就是Mutex，但是使用Mutex有死锁风险 下面是一段很容易就看出来错误的代码 rust use std::{sync::{Mutex, MutexGuard}, thread}; use std::thread::sleep; use std::time::Duration; use lazy_static::lazy_static; lazy_static! { static ref MUTEX1: Mutex = Mutex::new(0); static ref MUTEX2: Mutex = Mutex::new(0); } fn main() { // 存放子线程的句柄 let mut children = vec![]; for i_thread in 0..2 { children.push(thread::spawn(move || { for _ in 0..1 { // 线程1 if i_thread % 2 == 0 { // 锁住MUTEX1 let guard: MutexGuard = MUTEX1.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX1，接着准备去锁MUTEX2 !\", i_thread); // 当前线程睡眠一小会儿，等待线程2锁住MUTEX2 sleep(Duration::from_millis(10)); // 去锁MUTEX2 let guard = MUTEX2.lock().unwrap(); // 线程2 } else { // 锁住MUTEX2 let _guard = MUTEX2.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX2, 准备去锁MUTEX1\", i_thread); let _guard = MUTEX1.lock().unwrap(); } } })); } // 等子线程完成 for child in children { let _ = child.join(); } println!(\"死锁没有发生\"); } 两线程在锁住自己的同时去获取对方线程的资源，这会导致死锁 但当我们使用try_lock时情况就不同了 rust use std::{sync::{Mutex, MutexGuard}, thread}; use std::thread::sleep; use std::time::Duration; use lazy_static::lazy_static; lazy_static! { static ref MUTEX1: Mutex = Mutex::new(0); static ref MUTEX2: Mutex = Mutex::new(0); } fn main() { // 存放子线程的句柄 let mut children = vec![]; for i_thread in 0..2 { children.push(thread::spawn(move || { for _ in 0..1 { // 线程1 if i_thread % 2 == 0 { // 锁住MUTEX1 let guard: MutexGuard = MUTEX1.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX1，接着准备去锁MUTEX2 !\", i_thread); // 当前线程睡眠一小会儿，等待线程2锁住MUTEX2 sleep(Duration::from_millis(10)); // 去锁MUTEX2 let guard = MUTEX2.try_lock(); println!(\"线程 {} 获取 MUTEX2 锁的结果: {:?}\", i_thread, guard); // 线程2 } else { // 锁住MUTEX2 let _guard = MUTEX2.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX2, 准备去锁MUTEX1\", i_thread); sleep(Duration::from_millis(10)); let guard = MUTEX1.try_lock(); println!(\"线程 {} 获取 MUTEX1 锁的结果: {:?}\", i_thread, guard); } } })); } // 等子线程完成 for child in children { let _ = child.join(); } println!(\"死锁没有发生\"); } try_lock会尝试获取锁，如果获取不到就返回一个错误，之后代码继续在子线程中执行，因此不会导致死锁 读写锁rust中的读写锁类似linux中的读写锁，要么同时允许多个读，要么同时允许一个写 rust use std::sync::RwLock; fn main() { let lock = RwLock::new(5); // 同一时间允许多个读 { let r1 = lock.read().unwrap(); let r2 = lock.read().unwrap(); assert_eq!(*r1, 5); assert_eq!(*r2, 5); } // 读锁在此处被drop // 同一时间只允许一个写 { let mut w = lock.write().unwrap(); *w += 1; assert_eq!(*w, 6); // 以下代码会阻塞发生死锁，因为读和写不允许同时存在 // 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于`w`的作用域中 // let r1 = lock.read(); // println!(\"{:?}\",r1); }// 写锁在此处被drop } 条件变量下面是使用条件变量来进行线程的同步以控制顺序 rust use std::sync::{Arc,Mutex,Condvar}; use std::thread::{spawn,sleep}; use std::time::Duration; fn main() { let flag = Arc::new(Mutex::new(false)); let cond = Arc::new(Condvar::new()); let cflag = flag.clone(); let ccond = cond.clone(); let hdl = spawn(move || { let mut lock = cflag.lock().unwrap(); let mut counter = 0; while counter \u003c 3 { while !*lock { // wait方法会接收一个MutexGuard\u003c'a, T\u003e，且它会自动地暂时释放这个锁，使其它线程可以拿到锁并进行数据更新。 // 同时当前线程在此处会被阻塞，直到被其它地方notify后，它会将原本的MutexGuard\u003c'a, T\u003e还给我们","date":"2024-12-15","objectID":"/posts/rust/:21:4","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#互斥锁"},{"categories":["Tech"],"content":" 共享内存 互斥锁共享内存会有数据竞争的问题，因此我们使用互斥锁进行访问 rust use std::sync::Mutex; fn main() { let mut n = 5; // 使用`Mutex`结构体的关联函数创建新的互斥锁实例来报数数据n let m = Mutex::new(n); { // 获取锁，然后deref为`m`的引用 // lock返回的是Result let mut num = m.lock().unwrap(); *num += 1; // 锁自动被drop } println!(\"m = {:?}\", m); } 我们可以通过Mutex::new(T)来创建Mutex，Mutex是一个共享指针 在访问数据前通过lock的方式获取锁，这会阻塞当前线程 下面的程序有错误，尝试找出原因 rust use std::rc::Rc; use std::sync::Mutex; use std::thread; fn main() { // 通过`Rc`实现`Mutex`的多所有权 let counter = Rc::new(Mutex::new(0)); let mut handles = vec![]; for _ in 0..10 { let counter = Rc::clone(\u0026counter); // 创建子线程，并将`Mutex`的所有权拷贝传入到子线程中 let handle = thread::spawn(move || { let mut num = counter.lock().unwrap(); *num += 1; }); handles.push(handle); } // 等待所有子线程完成 for handle in handles { handle.join().unwrap(); } // 输出最终的计数结果 println!(\"Result: {}\", *counter.lock().unwrap()); } 当某个数据被多个线程使用时，由于我们在定义线程handle时会使用move方法，这会产生所有权的问题。因此我们需要使用多使用权的智能指针来解决，但由于Rc不能在多线程中使用(它没有实现send trait)，因此我们需要使用Arc(A代表atomic) RefCell对应的就是Mutex，但是使用Mutex有死锁风险 下面是一段很容易就看出来错误的代码 rust use std::{sync::{Mutex, MutexGuard}, thread}; use std::thread::sleep; use std::time::Duration; use lazy_static::lazy_static; lazy_static! { static ref MUTEX1: Mutex = Mutex::new(0); static ref MUTEX2: Mutex = Mutex::new(0); } fn main() { // 存放子线程的句柄 let mut children = vec![]; for i_thread in 0..2 { children.push(thread::spawn(move || { for _ in 0..1 { // 线程1 if i_thread % 2 == 0 { // 锁住MUTEX1 let guard: MutexGuard = MUTEX1.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX1，接着准备去锁MUTEX2 !\", i_thread); // 当前线程睡眠一小会儿，等待线程2锁住MUTEX2 sleep(Duration::from_millis(10)); // 去锁MUTEX2 let guard = MUTEX2.lock().unwrap(); // 线程2 } else { // 锁住MUTEX2 let _guard = MUTEX2.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX2, 准备去锁MUTEX1\", i_thread); let _guard = MUTEX1.lock().unwrap(); } } })); } // 等子线程完成 for child in children { let _ = child.join(); } println!(\"死锁没有发生\"); } 两线程在锁住自己的同时去获取对方线程的资源，这会导致死锁 但当我们使用try_lock时情况就不同了 rust use std::{sync::{Mutex, MutexGuard}, thread}; use std::thread::sleep; use std::time::Duration; use lazy_static::lazy_static; lazy_static! { static ref MUTEX1: Mutex = Mutex::new(0); static ref MUTEX2: Mutex = Mutex::new(0); } fn main() { // 存放子线程的句柄 let mut children = vec![]; for i_thread in 0..2 { children.push(thread::spawn(move || { for _ in 0..1 { // 线程1 if i_thread % 2 == 0 { // 锁住MUTEX1 let guard: MutexGuard = MUTEX1.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX1，接着准备去锁MUTEX2 !\", i_thread); // 当前线程睡眠一小会儿，等待线程2锁住MUTEX2 sleep(Duration::from_millis(10)); // 去锁MUTEX2 let guard = MUTEX2.try_lock(); println!(\"线程 {} 获取 MUTEX2 锁的结果: {:?}\", i_thread, guard); // 线程2 } else { // 锁住MUTEX2 let _guard = MUTEX2.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX2, 准备去锁MUTEX1\", i_thread); sleep(Duration::from_millis(10)); let guard = MUTEX1.try_lock(); println!(\"线程 {} 获取 MUTEX1 锁的结果: {:?}\", i_thread, guard); } } })); } // 等子线程完成 for child in children { let _ = child.join(); } println!(\"死锁没有发生\"); } try_lock会尝试获取锁，如果获取不到就返回一个错误，之后代码继续在子线程中执行，因此不会导致死锁 读写锁rust中的读写锁类似linux中的读写锁，要么同时允许多个读，要么同时允许一个写 rust use std::sync::RwLock; fn main() { let lock = RwLock::new(5); // 同一时间允许多个读 { let r1 = lock.read().unwrap(); let r2 = lock.read().unwrap(); assert_eq!(*r1, 5); assert_eq!(*r2, 5); } // 读锁在此处被drop // 同一时间只允许一个写 { let mut w = lock.write().unwrap(); *w += 1; assert_eq!(*w, 6); // 以下代码会阻塞发生死锁，因为读和写不允许同时存在 // 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于`w`的作用域中 // let r1 = lock.read(); // println!(\"{:?}\",r1); }// 写锁在此处被drop } 条件变量下面是使用条件变量来进行线程的同步以控制顺序 rust use std::sync::{Arc,Mutex,Condvar}; use std::thread::{spawn,sleep}; use std::time::Duration; fn main() { let flag = Arc::new(Mutex::new(false)); let cond = Arc::new(Condvar::new()); let cflag = flag.clone(); let ccond = cond.clone(); let hdl = spawn(move || { let mut lock = cflag.lock().unwrap(); let mut counter = 0; while counter \u003c 3 { while !*lock { // wait方法会接收一个MutexGuard\u003c'a, T\u003e，且它会自动地暂时释放这个锁，使其它线程可以拿到锁并进行数据更新。 // 同时当前线程在此处会被阻塞，直到被其它地方notify后，它会将原本的MutexGuard\u003c'a, T\u003e还给我们","date":"2024-12-15","objectID":"/posts/rust/:21:4","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#读写锁"},{"categories":["Tech"],"content":" 共享内存 互斥锁共享内存会有数据竞争的问题，因此我们使用互斥锁进行访问 rust use std::sync::Mutex; fn main() { let mut n = 5; // 使用`Mutex`结构体的关联函数创建新的互斥锁实例来报数数据n let m = Mutex::new(n); { // 获取锁，然后deref为`m`的引用 // lock返回的是Result let mut num = m.lock().unwrap(); *num += 1; // 锁自动被drop } println!(\"m = {:?}\", m); } 我们可以通过Mutex::new(T)来创建Mutex，Mutex是一个共享指针 在访问数据前通过lock的方式获取锁，这会阻塞当前线程 下面的程序有错误，尝试找出原因 rust use std::rc::Rc; use std::sync::Mutex; use std::thread; fn main() { // 通过`Rc`实现`Mutex`的多所有权 let counter = Rc::new(Mutex::new(0)); let mut handles = vec![]; for _ in 0..10 { let counter = Rc::clone(\u0026counter); // 创建子线程，并将`Mutex`的所有权拷贝传入到子线程中 let handle = thread::spawn(move || { let mut num = counter.lock().unwrap(); *num += 1; }); handles.push(handle); } // 等待所有子线程完成 for handle in handles { handle.join().unwrap(); } // 输出最终的计数结果 println!(\"Result: {}\", *counter.lock().unwrap()); } 当某个数据被多个线程使用时，由于我们在定义线程handle时会使用move方法，这会产生所有权的问题。因此我们需要使用多使用权的智能指针来解决，但由于Rc不能在多线程中使用(它没有实现send trait)，因此我们需要使用Arc(A代表atomic) RefCell对应的就是Mutex，但是使用Mutex有死锁风险 下面是一段很容易就看出来错误的代码 rust use std::{sync::{Mutex, MutexGuard}, thread}; use std::thread::sleep; use std::time::Duration; use lazy_static::lazy_static; lazy_static! { static ref MUTEX1: Mutex = Mutex::new(0); static ref MUTEX2: Mutex = Mutex::new(0); } fn main() { // 存放子线程的句柄 let mut children = vec![]; for i_thread in 0..2 { children.push(thread::spawn(move || { for _ in 0..1 { // 线程1 if i_thread % 2 == 0 { // 锁住MUTEX1 let guard: MutexGuard = MUTEX1.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX1，接着准备去锁MUTEX2 !\", i_thread); // 当前线程睡眠一小会儿，等待线程2锁住MUTEX2 sleep(Duration::from_millis(10)); // 去锁MUTEX2 let guard = MUTEX2.lock().unwrap(); // 线程2 } else { // 锁住MUTEX2 let _guard = MUTEX2.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX2, 准备去锁MUTEX1\", i_thread); let _guard = MUTEX1.lock().unwrap(); } } })); } // 等子线程完成 for child in children { let _ = child.join(); } println!(\"死锁没有发生\"); } 两线程在锁住自己的同时去获取对方线程的资源，这会导致死锁 但当我们使用try_lock时情况就不同了 rust use std::{sync::{Mutex, MutexGuard}, thread}; use std::thread::sleep; use std::time::Duration; use lazy_static::lazy_static; lazy_static! { static ref MUTEX1: Mutex = Mutex::new(0); static ref MUTEX2: Mutex = Mutex::new(0); } fn main() { // 存放子线程的句柄 let mut children = vec![]; for i_thread in 0..2 { children.push(thread::spawn(move || { for _ in 0..1 { // 线程1 if i_thread % 2 == 0 { // 锁住MUTEX1 let guard: MutexGuard = MUTEX1.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX1，接着准备去锁MUTEX2 !\", i_thread); // 当前线程睡眠一小会儿，等待线程2锁住MUTEX2 sleep(Duration::from_millis(10)); // 去锁MUTEX2 let guard = MUTEX2.try_lock(); println!(\"线程 {} 获取 MUTEX2 锁的结果: {:?}\", i_thread, guard); // 线程2 } else { // 锁住MUTEX2 let _guard = MUTEX2.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX2, 准备去锁MUTEX1\", i_thread); sleep(Duration::from_millis(10)); let guard = MUTEX1.try_lock(); println!(\"线程 {} 获取 MUTEX1 锁的结果: {:?}\", i_thread, guard); } } })); } // 等子线程完成 for child in children { let _ = child.join(); } println!(\"死锁没有发生\"); } try_lock会尝试获取锁，如果获取不到就返回一个错误，之后代码继续在子线程中执行，因此不会导致死锁 读写锁rust中的读写锁类似linux中的读写锁，要么同时允许多个读，要么同时允许一个写 rust use std::sync::RwLock; fn main() { let lock = RwLock::new(5); // 同一时间允许多个读 { let r1 = lock.read().unwrap(); let r2 = lock.read().unwrap(); assert_eq!(*r1, 5); assert_eq!(*r2, 5); } // 读锁在此处被drop // 同一时间只允许一个写 { let mut w = lock.write().unwrap(); *w += 1; assert_eq!(*w, 6); // 以下代码会阻塞发生死锁，因为读和写不允许同时存在 // 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于`w`的作用域中 // let r1 = lock.read(); // println!(\"{:?}\",r1); }// 写锁在此处被drop } 条件变量下面是使用条件变量来进行线程的同步以控制顺序 rust use std::sync::{Arc,Mutex,Condvar}; use std::thread::{spawn,sleep}; use std::time::Duration; fn main() { let flag = Arc::new(Mutex::new(false)); let cond = Arc::new(Condvar::new()); let cflag = flag.clone(); let ccond = cond.clone(); let hdl = spawn(move || { let mut lock = cflag.lock().unwrap(); let mut counter = 0; while counter \u003c 3 { while !*lock { // wait方法会接收一个MutexGuard\u003c'a, T\u003e，且它会自动地暂时释放这个锁，使其它线程可以拿到锁并进行数据更新。 // 同时当前线程在此处会被阻塞，直到被其它地方notify后，它会将原本的MutexGuard\u003c'a, T\u003e还给我们","date":"2024-12-15","objectID":"/posts/rust/:21:4","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#条件变量"},{"categories":["Tech"],"content":" 共享内存 互斥锁共享内存会有数据竞争的问题，因此我们使用互斥锁进行访问 rust use std::sync::Mutex; fn main() { let mut n = 5; // 使用`Mutex`结构体的关联函数创建新的互斥锁实例来报数数据n let m = Mutex::new(n); { // 获取锁，然后deref为`m`的引用 // lock返回的是Result let mut num = m.lock().unwrap(); *num += 1; // 锁自动被drop } println!(\"m = {:?}\", m); } 我们可以通过Mutex::new(T)来创建Mutex，Mutex是一个共享指针 在访问数据前通过lock的方式获取锁，这会阻塞当前线程 下面的程序有错误，尝试找出原因 rust use std::rc::Rc; use std::sync::Mutex; use std::thread; fn main() { // 通过`Rc`实现`Mutex`的多所有权 let counter = Rc::new(Mutex::new(0)); let mut handles = vec![]; for _ in 0..10 { let counter = Rc::clone(\u0026counter); // 创建子线程，并将`Mutex`的所有权拷贝传入到子线程中 let handle = thread::spawn(move || { let mut num = counter.lock().unwrap(); *num += 1; }); handles.push(handle); } // 等待所有子线程完成 for handle in handles { handle.join().unwrap(); } // 输出最终的计数结果 println!(\"Result: {}\", *counter.lock().unwrap()); } 当某个数据被多个线程使用时，由于我们在定义线程handle时会使用move方法，这会产生所有权的问题。因此我们需要使用多使用权的智能指针来解决，但由于Rc不能在多线程中使用(它没有实现send trait)，因此我们需要使用Arc(A代表atomic) RefCell对应的就是Mutex，但是使用Mutex有死锁风险 下面是一段很容易就看出来错误的代码 rust use std::{sync::{Mutex, MutexGuard}, thread}; use std::thread::sleep; use std::time::Duration; use lazy_static::lazy_static; lazy_static! { static ref MUTEX1: Mutex = Mutex::new(0); static ref MUTEX2: Mutex = Mutex::new(0); } fn main() { // 存放子线程的句柄 let mut children = vec![]; for i_thread in 0..2 { children.push(thread::spawn(move || { for _ in 0..1 { // 线程1 if i_thread % 2 == 0 { // 锁住MUTEX1 let guard: MutexGuard = MUTEX1.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX1，接着准备去锁MUTEX2 !\", i_thread); // 当前线程睡眠一小会儿，等待线程2锁住MUTEX2 sleep(Duration::from_millis(10)); // 去锁MUTEX2 let guard = MUTEX2.lock().unwrap(); // 线程2 } else { // 锁住MUTEX2 let _guard = MUTEX2.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX2, 准备去锁MUTEX1\", i_thread); let _guard = MUTEX1.lock().unwrap(); } } })); } // 等子线程完成 for child in children { let _ = child.join(); } println!(\"死锁没有发生\"); } 两线程在锁住自己的同时去获取对方线程的资源，这会导致死锁 但当我们使用try_lock时情况就不同了 rust use std::{sync::{Mutex, MutexGuard}, thread}; use std::thread::sleep; use std::time::Duration; use lazy_static::lazy_static; lazy_static! { static ref MUTEX1: Mutex = Mutex::new(0); static ref MUTEX2: Mutex = Mutex::new(0); } fn main() { // 存放子线程的句柄 let mut children = vec![]; for i_thread in 0..2 { children.push(thread::spawn(move || { for _ in 0..1 { // 线程1 if i_thread % 2 == 0 { // 锁住MUTEX1 let guard: MutexGuard = MUTEX1.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX1，接着准备去锁MUTEX2 !\", i_thread); // 当前线程睡眠一小会儿，等待线程2锁住MUTEX2 sleep(Duration::from_millis(10)); // 去锁MUTEX2 let guard = MUTEX2.try_lock(); println!(\"线程 {} 获取 MUTEX2 锁的结果: {:?}\", i_thread, guard); // 线程2 } else { // 锁住MUTEX2 let _guard = MUTEX2.lock().unwrap(); println!(\"线程 {} 锁住了MUTEX2, 准备去锁MUTEX1\", i_thread); sleep(Duration::from_millis(10)); let guard = MUTEX1.try_lock(); println!(\"线程 {} 获取 MUTEX1 锁的结果: {:?}\", i_thread, guard); } } })); } // 等子线程完成 for child in children { let _ = child.join(); } println!(\"死锁没有发生\"); } try_lock会尝试获取锁，如果获取不到就返回一个错误，之后代码继续在子线程中执行，因此不会导致死锁 读写锁rust中的读写锁类似linux中的读写锁，要么同时允许多个读，要么同时允许一个写 rust use std::sync::RwLock; fn main() { let lock = RwLock::new(5); // 同一时间允许多个读 { let r1 = lock.read().unwrap(); let r2 = lock.read().unwrap(); assert_eq!(*r1, 5); assert_eq!(*r2, 5); } // 读锁在此处被drop // 同一时间只允许一个写 { let mut w = lock.write().unwrap(); *w += 1; assert_eq!(*w, 6); // 以下代码会阻塞发生死锁，因为读和写不允许同时存在 // 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于`w`的作用域中 // let r1 = lock.read(); // println!(\"{:?}\",r1); }// 写锁在此处被drop } 条件变量下面是使用条件变量来进行线程的同步以控制顺序 rust use std::sync::{Arc,Mutex,Condvar}; use std::thread::{spawn,sleep}; use std::time::Duration; fn main() { let flag = Arc::new(Mutex::new(false)); let cond = Arc::new(Condvar::new()); let cflag = flag.clone(); let ccond = cond.clone(); let hdl = spawn(move || { let mut lock = cflag.lock().unwrap(); let mut counter = 0; while counter \u003c 3 { while !*lock { // wait方法会接收一个MutexGuard\u003c'a, T\u003e，且它会自动地暂时释放这个锁，使其它线程可以拿到锁并进行数据更新。 // 同时当前线程在此处会被阻塞，直到被其它地方notify后，它会将原本的MutexGuard\u003c'a, T\u003e还给我们","date":"2024-12-15","objectID":"/posts/rust/:21:4","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#信号量"},{"categories":["Tech"],"content":" Atomic原子类型与内存顺序对于高性能库、基本库而言，原子类型十分重要，但是对于下游用户而言就没那么重要了 下面是原子变量的使用 rust use std::ops::Sub; use std::sync::atomic::{AtomicU64, Ordering}; use std::thread::{self, JoinHandle}; use std::time::Instant; const N_TIMES: u64 = 10000000; const N_THREADS: usize = 10; static R: AtomicU64 = AtomicU64::new(0); fn add_n_times(n: u64) -\u003e JoinHandle\u003c()\u003e { thread::spawn(move || { for _ in 0..n { R.fetch_add(1, Ordering::Relaxed); //Ordering::Relaxed代表原子变量不要求顺序，只保证原子性，这样便于编译优化从而有最高的效率 } }) } fn main() { let s = Instant::now(); let mut threads = Vec::with_capacity(N_THREADS); for _ in 0..N_THREADS { threads.push(add_n_times(N_TIMES)); } for thread in threads { thread.join().unwrap(); } assert_eq!(N_TIMES * N_THREADS as u64, R.load(Ordering::Relaxed)); println!(\"{:?}\",Instant::now().sub(s)); } 上面的代码可以看到，原子变量有内部可变性，可以对原子变量保护的值进行修改，同时由于原子变量是并发原语，因此不必进行加解锁操作，也就是说原子变量是无锁类型 由于mutex内部使用了原子变量，因此上述代码完全可以使用mutex来实现 使用原子变量时还需要考虑内存屏障的问题，也就是R.fetch_add(1, Ordering::Relaxed);这行代码。内存顺序有五种选项 Relaxed 这是最宽松的规则，它对编译器和 CPU 不做任何限制，可以乱序 Release 释放，设定内存屏障(Memory barrier)，保证它之前的操作永远在它之前，但是它后面的操作可能被重排到它前面 Acquire 获取，设定内存屏障，保证在它之后的访问永远在它之后，但是它之前的操作却有可能被重排到它后面，往往和Release在不同线程中联合使用 AcqRel是 Acquire 和 Release 的结合，同时拥有它们两个的保证。比如你要对一个 atomic 自增 1，同时希望该操作之前和之后的读取或写入操作不会被重新排序 SeqCst 顺序一致性， SeqCst就像是AcqRel的加强版，它不管原子操作是属于读取还是写入的操作，只要某个线程有用到SeqCst的原子操作，线程中SeqCst操作前的数据操作绝对不会被重新排在该SeqCst操作之后，且该SeqCst操作后的数据操作也绝对不会被重新排在SeqCst操作前 由于这些规则是系统提供的，因此也与其它语言提供的规则大同小异 ","date":"2024-12-15","objectID":"/posts/rust/:21:5","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#atomic原子类型与内存顺序"},{"categories":["Tech"],"content":" 面向对象特性rust有面向对象的特性，但并不是完全的面向对象的语言。首先，rust的确有封装的特性，但对于继承来说则并没有很大支持，只有trait这种“方法”的继承才可能称的上是继承，作为代替，rust使用的思想更近于组合。至于多态也是在trait和泛型才会涉及到的东西，例如某个类型可以重写默认trait trait实现的是动态派发，这与泛型实现的静态派发不同，动态派发无法在编译阶段确定我们调用的是哪一种方法，它只能从运行时推断我们希望调用的方法。这种技术的代价是编译器无法进行内联，使得部分优化操作无法进行 ","date":"2024-12-15","objectID":"/posts/rust/:22:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#面向对象特性"},{"categories":["Tech"],"content":" 高级特性","date":"2024-12-15","objectID":"/posts/rust/:23:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#高级特性"},{"categories":["Tech"],"content":" unsafe rust可以使用unsafe关键字来切换到unsafe rust，这在实现必须功能时是一种妥协，但是通过显式标记unsafe可以在出现问题时快速定位，这样就把不安全代码的影响降到了最低 unsafe rust里可执行的四个动作: 解引用原始指针 调用unsafe的函数或方法 访问可修改的静态变量 实现unsafe trait 注意 unsafe并没有关闭借用安全检查或其它安全检查 任何内存安全相关的错误必须留在unsafe块里 应该隔离unsafe代码，最好将其封装在安全的抽象里，对外提供安全的api 接下来详细解释需要注意的第三点: rust use std::slice; fn split_at_mut(values: \u0026mut [i32], mid: usize) -\u003e (\u0026mut [i32], \u0026mut [i32]) { let len = values.len(); let ptr = values.as_mut_ptr(); //ptr为*mut i32类型的指针 assert!(mid \u003c= len); unsafe { ( slice::from_raw_parts_mut(ptr, mid), //创建原始指针 slice::from_raw_parts_mut(ptr.add(mid), len - mid), ) } } fn main() { let mut v = vec![1, 2, 3, 4, 5, 6]; let r = \u0026mut v[..]; let (a, b) = r.split_at_mut(3); assert_eq!(a, \u0026mut [1, 2, 3]); assert_eq!(b, \u0026mut [4, 5, 6]); } 上述代码在调用from_raw_parts_mut时是不安全的，但是可以只限定在split_at_mut函数内部，因此这个函数是安全的，这就是不安全代码的安全抽象 原始指针(裸指针，raw pointer): 使用方法与C语言相同 可变指针: *mut T 不可变指针: *const T，这意味着在解引用之后不能对其赋值 下面是原始指针的性质: 允许违反借用规则(指针不是引用) 允许值为null 不实现任何自动清理 原始指针仅有*const与*mut两种类型，不允许出现let a:*i32这种形式，同时原始指针只允许在unsafe块里进行解引用，但是可以在块之外定义 使用extern调用外部代码extern关键字: 简化创建和使用外部函数接口(FFI)的过程，由于代码来自外部函数因此它也是不安全的 FFI: 它允许一种编程语言定义函数，并让其它编程语言调用这些函数 在其它语言使用rust的函数时，还需加上#[no_mangle]注解，防止rust在编译时改变函数的名称 使用extern关键字调用其它语言函数 rust #[link(name = \"adder\", kind = \"static\")] //从adder.c文件中加载c的函数，并以静态库的方式加载 extern \"C\" { fn abs(input: i32) -\u003e i32; } fn main() { unsafe { println!(\"Absolute value of -3 according to C: {}\", abs(-3)); } } 假设adder.c已经被编译为libadder.a，我们只需要指定链接库的位置即可(假设链接库被放在./c_lib/adder文件夹中) shell RUSTFLAGS='-L ./c_lib/adder' 使用extern关键字从其它语言调用rust函数 rust #[no_mangle] pub extern \"C\" fn call_from_c() { println!(\"Just called a Rust function from C!\"); } static变量变量使用static修饰意味着该变量存储于程序的静态内存区，生命周期贯穿整个程序且可以全局访问。由于rust默认变量是不可变的，因此static不支持修改而static mut支持修改 由于static是不可变(只读)的，所以我们可以安全的跨线程访问static变量，而static mut可写且没有实现内置的锁或者原子机制，因此是线程不安全的 rust static mut COUNTER: u32 = 0; fn add_to_count(inc: u32) { unsafe { COUNTER += inc; } } fn main() { add_to_count(3); unsafe { println!(\"COUNTER: {COUNTER}\"); } } 不安全trait如果一个trait的实现是unsafe的，那么它的方法也需要使用unsafe修饰 rust unsafe trait Foo { // methods go here } unsafe impl Foo for i32 { //方法的实现需要使用unsafe修饰 // method implementations go here } fn main() {} 内联汇编rust最新版本已经支持内联汇编了，但同样的，内联汇编不能享受到rust编译器的严格检查，因此需要使用unsafe声明(目前内联汇编支持的架构包括RISCV) rust use std::arch::asm; let i: u64 = 3; let o: u64; unsafe { asm!( \"mov {0}, {1}\", \"add {0}, 5\", out(reg) o, in(reg) i, ); } assert_eq!(o, 8); 上面代码的大意如下： 定义两个变量o和i，把o作为输出寄存器的值，i作为输入寄存器的值，之后将i和o放在两个占位符中。因此程序变为： rust use std::arch::asm; let i: u64 = 3; let o: u64; unsafe { asm!( \"mov {o}, {i}\", \"add {o}, 5\", out(reg) o, in(reg) i, ); } assert_eq!(o, 8); 这样就可以计算出o的值了 ","date":"2024-12-15","objectID":"/posts/rust/:23:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#unsafe-rust"},{"categories":["Tech"],"content":" unsafe rust可以使用unsafe关键字来切换到unsafe rust，这在实现必须功能时是一种妥协，但是通过显式标记unsafe可以在出现问题时快速定位，这样就把不安全代码的影响降到了最低 unsafe rust里可执行的四个动作: 解引用原始指针 调用unsafe的函数或方法 访问可修改的静态变量 实现unsafe trait 注意 unsafe并没有关闭借用安全检查或其它安全检查 任何内存安全相关的错误必须留在unsafe块里 应该隔离unsafe代码，最好将其封装在安全的抽象里，对外提供安全的api 接下来详细解释需要注意的第三点: rust use std::slice; fn split_at_mut(values: \u0026mut [i32], mid: usize) -\u003e (\u0026mut [i32], \u0026mut [i32]) { let len = values.len(); let ptr = values.as_mut_ptr(); //ptr为*mut i32类型的指针 assert!(mid \u003c= len); unsafe { ( slice::from_raw_parts_mut(ptr, mid), //创建原始指针 slice::from_raw_parts_mut(ptr.add(mid), len - mid), ) } } fn main() { let mut v = vec![1, 2, 3, 4, 5, 6]; let r = \u0026mut v[..]; let (a, b) = r.split_at_mut(3); assert_eq!(a, \u0026mut [1, 2, 3]); assert_eq!(b, \u0026mut [4, 5, 6]); } 上述代码在调用from_raw_parts_mut时是不安全的，但是可以只限定在split_at_mut函数内部，因此这个函数是安全的，这就是不安全代码的安全抽象 原始指针(裸指针，raw pointer): 使用方法与C语言相同 可变指针: *mut T 不可变指针: *const T，这意味着在解引用之后不能对其赋值 下面是原始指针的性质: 允许违反借用规则(指针不是引用) 允许值为null 不实现任何自动清理 原始指针仅有*const与*mut两种类型，不允许出现let a:*i32这种形式，同时原始指针只允许在unsafe块里进行解引用，但是可以在块之外定义 使用extern调用外部代码extern关键字: 简化创建和使用外部函数接口(FFI)的过程，由于代码来自外部函数因此它也是不安全的 FFI: 它允许一种编程语言定义函数，并让其它编程语言调用这些函数 在其它语言使用rust的函数时，还需加上#[no_mangle]注解，防止rust在编译时改变函数的名称 使用extern关键字调用其它语言函数 rust #[link(name = \"adder\", kind = \"static\")] //从adder.c文件中加载c的函数，并以静态库的方式加载 extern \"C\" { fn abs(input: i32) -\u003e i32; } fn main() { unsafe { println!(\"Absolute value of -3 according to C: {}\", abs(-3)); } } 假设adder.c已经被编译为libadder.a，我们只需要指定链接库的位置即可(假设链接库被放在./c_lib/adder文件夹中) shell RUSTFLAGS='-L ./c_lib/adder' 使用extern关键字从其它语言调用rust函数 rust #[no_mangle] pub extern \"C\" fn call_from_c() { println!(\"Just called a Rust function from C!\"); } static变量变量使用static修饰意味着该变量存储于程序的静态内存区，生命周期贯穿整个程序且可以全局访问。由于rust默认变量是不可变的，因此static不支持修改而static mut支持修改 由于static是不可变(只读)的，所以我们可以安全的跨线程访问static变量，而static mut可写且没有实现内置的锁或者原子机制，因此是线程不安全的 rust static mut COUNTER: u32 = 0; fn add_to_count(inc: u32) { unsafe { COUNTER += inc; } } fn main() { add_to_count(3); unsafe { println!(\"COUNTER: {COUNTER}\"); } } 不安全trait如果一个trait的实现是unsafe的，那么它的方法也需要使用unsafe修饰 rust unsafe trait Foo { // methods go here } unsafe impl Foo for i32 { //方法的实现需要使用unsafe修饰 // method implementations go here } fn main() {} 内联汇编rust最新版本已经支持内联汇编了，但同样的，内联汇编不能享受到rust编译器的严格检查，因此需要使用unsafe声明(目前内联汇编支持的架构包括RISCV) rust use std::arch::asm; let i: u64 = 3; let o: u64; unsafe { asm!( \"mov {0}, {1}\", \"add {0}, 5\", out(reg) o, in(reg) i, ); } assert_eq!(o, 8); 上面代码的大意如下： 定义两个变量o和i，把o作为输出寄存器的值，i作为输入寄存器的值，之后将i和o放在两个占位符中。因此程序变为： rust use std::arch::asm; let i: u64 = 3; let o: u64; unsafe { asm!( \"mov {o}, {i}\", \"add {o}, 5\", out(reg) o, in(reg) i, ); } assert_eq!(o, 8); 这样就可以计算出o的值了 ","date":"2024-12-15","objectID":"/posts/rust/:23:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#使用extern调用外部代码"},{"categories":["Tech"],"content":" unsafe rust可以使用unsafe关键字来切换到unsafe rust，这在实现必须功能时是一种妥协，但是通过显式标记unsafe可以在出现问题时快速定位，这样就把不安全代码的影响降到了最低 unsafe rust里可执行的四个动作: 解引用原始指针 调用unsafe的函数或方法 访问可修改的静态变量 实现unsafe trait 注意 unsafe并没有关闭借用安全检查或其它安全检查 任何内存安全相关的错误必须留在unsafe块里 应该隔离unsafe代码，最好将其封装在安全的抽象里，对外提供安全的api 接下来详细解释需要注意的第三点: rust use std::slice; fn split_at_mut(values: \u0026mut [i32], mid: usize) -\u003e (\u0026mut [i32], \u0026mut [i32]) { let len = values.len(); let ptr = values.as_mut_ptr(); //ptr为*mut i32类型的指针 assert!(mid \u003c= len); unsafe { ( slice::from_raw_parts_mut(ptr, mid), //创建原始指针 slice::from_raw_parts_mut(ptr.add(mid), len - mid), ) } } fn main() { let mut v = vec![1, 2, 3, 4, 5, 6]; let r = \u0026mut v[..]; let (a, b) = r.split_at_mut(3); assert_eq!(a, \u0026mut [1, 2, 3]); assert_eq!(b, \u0026mut [4, 5, 6]); } 上述代码在调用from_raw_parts_mut时是不安全的，但是可以只限定在split_at_mut函数内部，因此这个函数是安全的，这就是不安全代码的安全抽象 原始指针(裸指针，raw pointer): 使用方法与C语言相同 可变指针: *mut T 不可变指针: *const T，这意味着在解引用之后不能对其赋值 下面是原始指针的性质: 允许违反借用规则(指针不是引用) 允许值为null 不实现任何自动清理 原始指针仅有*const与*mut两种类型，不允许出现let a:*i32这种形式，同时原始指针只允许在unsafe块里进行解引用，但是可以在块之外定义 使用extern调用外部代码extern关键字: 简化创建和使用外部函数接口(FFI)的过程，由于代码来自外部函数因此它也是不安全的 FFI: 它允许一种编程语言定义函数，并让其它编程语言调用这些函数 在其它语言使用rust的函数时，还需加上#[no_mangle]注解，防止rust在编译时改变函数的名称 使用extern关键字调用其它语言函数 rust #[link(name = \"adder\", kind = \"static\")] //从adder.c文件中加载c的函数，并以静态库的方式加载 extern \"C\" { fn abs(input: i32) -\u003e i32; } fn main() { unsafe { println!(\"Absolute value of -3 according to C: {}\", abs(-3)); } } 假设adder.c已经被编译为libadder.a，我们只需要指定链接库的位置即可(假设链接库被放在./c_lib/adder文件夹中) shell RUSTFLAGS='-L ./c_lib/adder' 使用extern关键字从其它语言调用rust函数 rust #[no_mangle] pub extern \"C\" fn call_from_c() { println!(\"Just called a Rust function from C!\"); } static变量变量使用static修饰意味着该变量存储于程序的静态内存区，生命周期贯穿整个程序且可以全局访问。由于rust默认变量是不可变的，因此static不支持修改而static mut支持修改 由于static是不可变(只读)的，所以我们可以安全的跨线程访问static变量，而static mut可写且没有实现内置的锁或者原子机制，因此是线程不安全的 rust static mut COUNTER: u32 = 0; fn add_to_count(inc: u32) { unsafe { COUNTER += inc; } } fn main() { add_to_count(3); unsafe { println!(\"COUNTER: {COUNTER}\"); } } 不安全trait如果一个trait的实现是unsafe的，那么它的方法也需要使用unsafe修饰 rust unsafe trait Foo { // methods go here } unsafe impl Foo for i32 { //方法的实现需要使用unsafe修饰 // method implementations go here } fn main() {} 内联汇编rust最新版本已经支持内联汇编了，但同样的，内联汇编不能享受到rust编译器的严格检查，因此需要使用unsafe声明(目前内联汇编支持的架构包括RISCV) rust use std::arch::asm; let i: u64 = 3; let o: u64; unsafe { asm!( \"mov {0}, {1}\", \"add {0}, 5\", out(reg) o, in(reg) i, ); } assert_eq!(o, 8); 上面代码的大意如下： 定义两个变量o和i，把o作为输出寄存器的值，i作为输入寄存器的值，之后将i和o放在两个占位符中。因此程序变为： rust use std::arch::asm; let i: u64 = 3; let o: u64; unsafe { asm!( \"mov {o}, {i}\", \"add {o}, 5\", out(reg) o, in(reg) i, ); } assert_eq!(o, 8); 这样就可以计算出o的值了 ","date":"2024-12-15","objectID":"/posts/rust/:23:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#static变量"},{"categories":["Tech"],"content":" unsafe rust可以使用unsafe关键字来切换到unsafe rust，这在实现必须功能时是一种妥协，但是通过显式标记unsafe可以在出现问题时快速定位，这样就把不安全代码的影响降到了最低 unsafe rust里可执行的四个动作: 解引用原始指针 调用unsafe的函数或方法 访问可修改的静态变量 实现unsafe trait 注意 unsafe并没有关闭借用安全检查或其它安全检查 任何内存安全相关的错误必须留在unsafe块里 应该隔离unsafe代码，最好将其封装在安全的抽象里，对外提供安全的api 接下来详细解释需要注意的第三点: rust use std::slice; fn split_at_mut(values: \u0026mut [i32], mid: usize) -\u003e (\u0026mut [i32], \u0026mut [i32]) { let len = values.len(); let ptr = values.as_mut_ptr(); //ptr为*mut i32类型的指针 assert!(mid \u003c= len); unsafe { ( slice::from_raw_parts_mut(ptr, mid), //创建原始指针 slice::from_raw_parts_mut(ptr.add(mid), len - mid), ) } } fn main() { let mut v = vec![1, 2, 3, 4, 5, 6]; let r = \u0026mut v[..]; let (a, b) = r.split_at_mut(3); assert_eq!(a, \u0026mut [1, 2, 3]); assert_eq!(b, \u0026mut [4, 5, 6]); } 上述代码在调用from_raw_parts_mut时是不安全的，但是可以只限定在split_at_mut函数内部，因此这个函数是安全的，这就是不安全代码的安全抽象 原始指针(裸指针，raw pointer): 使用方法与C语言相同 可变指针: *mut T 不可变指针: *const T，这意味着在解引用之后不能对其赋值 下面是原始指针的性质: 允许违反借用规则(指针不是引用) 允许值为null 不实现任何自动清理 原始指针仅有*const与*mut两种类型，不允许出现let a:*i32这种形式，同时原始指针只允许在unsafe块里进行解引用，但是可以在块之外定义 使用extern调用外部代码extern关键字: 简化创建和使用外部函数接口(FFI)的过程，由于代码来自外部函数因此它也是不安全的 FFI: 它允许一种编程语言定义函数，并让其它编程语言调用这些函数 在其它语言使用rust的函数时，还需加上#[no_mangle]注解，防止rust在编译时改变函数的名称 使用extern关键字调用其它语言函数 rust #[link(name = \"adder\", kind = \"static\")] //从adder.c文件中加载c的函数，并以静态库的方式加载 extern \"C\" { fn abs(input: i32) -\u003e i32; } fn main() { unsafe { println!(\"Absolute value of -3 according to C: {}\", abs(-3)); } } 假设adder.c已经被编译为libadder.a，我们只需要指定链接库的位置即可(假设链接库被放在./c_lib/adder文件夹中) shell RUSTFLAGS='-L ./c_lib/adder' 使用extern关键字从其它语言调用rust函数 rust #[no_mangle] pub extern \"C\" fn call_from_c() { println!(\"Just called a Rust function from C!\"); } static变量变量使用static修饰意味着该变量存储于程序的静态内存区，生命周期贯穿整个程序且可以全局访问。由于rust默认变量是不可变的，因此static不支持修改而static mut支持修改 由于static是不可变(只读)的，所以我们可以安全的跨线程访问static变量，而static mut可写且没有实现内置的锁或者原子机制，因此是线程不安全的 rust static mut COUNTER: u32 = 0; fn add_to_count(inc: u32) { unsafe { COUNTER += inc; } } fn main() { add_to_count(3); unsafe { println!(\"COUNTER: {COUNTER}\"); } } 不安全trait如果一个trait的实现是unsafe的，那么它的方法也需要使用unsafe修饰 rust unsafe trait Foo { // methods go here } unsafe impl Foo for i32 { //方法的实现需要使用unsafe修饰 // method implementations go here } fn main() {} 内联汇编rust最新版本已经支持内联汇编了，但同样的，内联汇编不能享受到rust编译器的严格检查，因此需要使用unsafe声明(目前内联汇编支持的架构包括RISCV) rust use std::arch::asm; let i: u64 = 3; let o: u64; unsafe { asm!( \"mov {0}, {1}\", \"add {0}, 5\", out(reg) o, in(reg) i, ); } assert_eq!(o, 8); 上面代码的大意如下： 定义两个变量o和i，把o作为输出寄存器的值，i作为输入寄存器的值，之后将i和o放在两个占位符中。因此程序变为： rust use std::arch::asm; let i: u64 = 3; let o: u64; unsafe { asm!( \"mov {o}, {i}\", \"add {o}, 5\", out(reg) o, in(reg) i, ); } assert_eq!(o, 8); 这样就可以计算出o的值了 ","date":"2024-12-15","objectID":"/posts/rust/:23:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#不安全trait"},{"categories":["Tech"],"content":" unsafe rust可以使用unsafe关键字来切换到unsafe rust，这在实现必须功能时是一种妥协，但是通过显式标记unsafe可以在出现问题时快速定位，这样就把不安全代码的影响降到了最低 unsafe rust里可执行的四个动作: 解引用原始指针 调用unsafe的函数或方法 访问可修改的静态变量 实现unsafe trait 注意 unsafe并没有关闭借用安全检查或其它安全检查 任何内存安全相关的错误必须留在unsafe块里 应该隔离unsafe代码，最好将其封装在安全的抽象里，对外提供安全的api 接下来详细解释需要注意的第三点: rust use std::slice; fn split_at_mut(values: \u0026mut [i32], mid: usize) -\u003e (\u0026mut [i32], \u0026mut [i32]) { let len = values.len(); let ptr = values.as_mut_ptr(); //ptr为*mut i32类型的指针 assert!(mid \u003c= len); unsafe { ( slice::from_raw_parts_mut(ptr, mid), //创建原始指针 slice::from_raw_parts_mut(ptr.add(mid), len - mid), ) } } fn main() { let mut v = vec![1, 2, 3, 4, 5, 6]; let r = \u0026mut v[..]; let (a, b) = r.split_at_mut(3); assert_eq!(a, \u0026mut [1, 2, 3]); assert_eq!(b, \u0026mut [4, 5, 6]); } 上述代码在调用from_raw_parts_mut时是不安全的，但是可以只限定在split_at_mut函数内部，因此这个函数是安全的，这就是不安全代码的安全抽象 原始指针(裸指针，raw pointer): 使用方法与C语言相同 可变指针: *mut T 不可变指针: *const T，这意味着在解引用之后不能对其赋值 下面是原始指针的性质: 允许违反借用规则(指针不是引用) 允许值为null 不实现任何自动清理 原始指针仅有*const与*mut两种类型，不允许出现let a:*i32这种形式，同时原始指针只允许在unsafe块里进行解引用，但是可以在块之外定义 使用extern调用外部代码extern关键字: 简化创建和使用外部函数接口(FFI)的过程，由于代码来自外部函数因此它也是不安全的 FFI: 它允许一种编程语言定义函数，并让其它编程语言调用这些函数 在其它语言使用rust的函数时，还需加上#[no_mangle]注解，防止rust在编译时改变函数的名称 使用extern关键字调用其它语言函数 rust #[link(name = \"adder\", kind = \"static\")] //从adder.c文件中加载c的函数，并以静态库的方式加载 extern \"C\" { fn abs(input: i32) -\u003e i32; } fn main() { unsafe { println!(\"Absolute value of -3 according to C: {}\", abs(-3)); } } 假设adder.c已经被编译为libadder.a，我们只需要指定链接库的位置即可(假设链接库被放在./c_lib/adder文件夹中) shell RUSTFLAGS='-L ./c_lib/adder' 使用extern关键字从其它语言调用rust函数 rust #[no_mangle] pub extern \"C\" fn call_from_c() { println!(\"Just called a Rust function from C!\"); } static变量变量使用static修饰意味着该变量存储于程序的静态内存区，生命周期贯穿整个程序且可以全局访问。由于rust默认变量是不可变的，因此static不支持修改而static mut支持修改 由于static是不可变(只读)的，所以我们可以安全的跨线程访问static变量，而static mut可写且没有实现内置的锁或者原子机制，因此是线程不安全的 rust static mut COUNTER: u32 = 0; fn add_to_count(inc: u32) { unsafe { COUNTER += inc; } } fn main() { add_to_count(3); unsafe { println!(\"COUNTER: {COUNTER}\"); } } 不安全trait如果一个trait的实现是unsafe的，那么它的方法也需要使用unsafe修饰 rust unsafe trait Foo { // methods go here } unsafe impl Foo for i32 { //方法的实现需要使用unsafe修饰 // method implementations go here } fn main() {} 内联汇编rust最新版本已经支持内联汇编了，但同样的，内联汇编不能享受到rust编译器的严格检查，因此需要使用unsafe声明(目前内联汇编支持的架构包括RISCV) rust use std::arch::asm; let i: u64 = 3; let o: u64; unsafe { asm!( \"mov {0}, {1}\", \"add {0}, 5\", out(reg) o, in(reg) i, ); } assert_eq!(o, 8); 上面代码的大意如下： 定义两个变量o和i，把o作为输出寄存器的值，i作为输入寄存器的值，之后将i和o放在两个占位符中。因此程序变为： rust use std::arch::asm; let i: u64 = 3; let o: u64; unsafe { asm!( \"mov {o}, {i}\", \"add {o}, 5\", out(reg) o, in(reg) i, ); } assert_eq!(o, 8); 这样就可以计算出o的值了 ","date":"2024-12-15","objectID":"/posts/rust/:23:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#内联汇编"},{"categories":["Tech"],"content":" 高级traittrait是rust中唯一的接口抽象方式，并且这种为类型实现接口的思维方式增加了代码可读性(只需要关注函数名，参数和返回类型就可以知道函数的意图)。trait的使用充分贯彻了组合优于继承和面向接口的编程思想 关联类型在trait定义中可以使用关联类型来指定占位类型，虽然这与泛型十分相似，但是泛型支持对不同类型特化具体trait，而关联类型不允许，并且关联类型对于某个类型只能实现一次 rust库中，迭代器就是一个使用关联类型的例子 rust pub trait Iterator { type Item; //关联类型 fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e; } type Item; 是 Iterator trait 中定义的 关联类型（Associated Type），它表示： 实现 Iterator 的类型需要指定一个具体的不依赖调用者的 Item 类型 这个 Item 类型代表迭代器每次调用 next() 时返回的元素的类型 对于具体的迭代器，我们需要实现这个关联类型才能让程序完整，所以我们只需要补充Item的类型 rust impl Iterator for Counter { //给自定义的类型实现Iterator trait时需要将Item补充完整 type Item = u32; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e { //这样返回值也就清楚了 // --snip-- } } fn main() { let c = Counter{..} c.next() } 关联类型还可以保证代码的可读性，在阅读代码的过程中我们只需要把关联类型视为类型就可以了 完全限定语法完全限定语法适用于trait很多以至于重名的情况 rust trait Animal { fn baby_name() -\u003e String; } struct Dog; impl Dog { fn baby_name() -\u003e String { String::from(\"Spot\") } } impl Animal for Dog { fn baby_name() -\u003e String { String::from(\"puppy\") } } fn main() { println!(\"A baby dog is called a {}\", Dog::baby_name()); println!(\"A baby dog is called a {}\", \u003cDog as Animal\u003e::baby_name()); //完全限定语法 } 输出为 shell A baby dog is called a Spot A baby dog is called a puppy 这很类似于C++子类继承父类实现多态的情况，其传入的子类指针可以被编译器识别为父类的形式 supertrait在 Rust 中，Supertrait 是指一个 trait 依赖另一个 trait，即某个 trait 要求实现它的类型必须先实现另一个 trait 语法与C++的继承类似 rust use std::fmt; struct Point { x: i32, y: i32, } trait OutlinePrint: fmt::Display { //supertrait，OutlinePrint trait依赖于Display trait fn outline_print(\u0026self) { let output = self.to_string(); let len = output.len(); println!(\"{}\", \"*\".repeat(len + 4)); println!(\"*{}*\", \" \".repeat(len + 2)); println!(\"* {output} *\"); println!(\"*{}*\", \" \".repeat(len + 2)); println!(\"{}\", \"*\".repeat(len + 4)); } } impl fmt::Display for Point { //首先实现Dispaly trait fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result { write!(f, \"({}, {})\", self.x, self.y) } } impl OutlinePrint for Point {} //而后实现Dispaly trait newtype模式前文曾提到，对于第三方库和官方库，我们都没有权限对其内置类型实现额外的trait，这就是孤儿原则。但是使用newtype模式可以做到这一点，其具体原理与适配器模式类似: rust use std::fmt; struct Wrapper(Vec\u003cString\u003e); impl fmt::Display for Wrapper { fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result { write!(f, \"[{}]\", self.0.join(\", \")) } } fn main() { let w = Wrapper(vec![String::from(\"hello\"),String::from(\"world\")]); println!(\"w = {w}\"); } 这里使用了Wrapper这样一个struct tuple作为适配器，从而将我们想要实现的trait(在这里就是String的Display trait)放入这个适配器中，这里注意的是使用时需要使用self.0的形式从vec提取string 默认泛型参数和运算符重载rust并不支持对所有的运算符进行重载，目前来说，只有定义在std::ops中的运算符才能进行重载 默认泛型参数的语法与C++的默认函数参数类似 rust trait Add\u003cRHS=Self\u003e { type Output; fn add(self, rhs: RHS) -\u003e Self::Output; } 上述代码将RHS默认为Self，也就是传入的类型，因此我们不必指定Add trait的类型 rust use std::ops::Add; #[derive(Debug, PartialEq)] struct Point { x: i32, y: i32, } impl Add for Point { //不必指定，只需实现即可 type Output = Point; fn add(self, other: Point) -\u003e Point { Point { x: self.x + other.x, y: self.y + other.y, } } } fn main() { assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 }, Point { x: 3, y: 3 }); } 但是如果我们想传入不同的类型并且能够相加，返回值与泛型参数也不同，那么就必须指定泛型的参数类型 rust use std::ops::Add; struct Millimeters(u32); struct Meters(u32); impl Add\u003cMeters\u003e for Millimeters { //指定传入的参数类型 type Output = Millimeters; fn add(self, other: Meters) -\u003e Millimeters { Millimeters(self.0 + (other.0 * 1000)) } } ","date":"2024-12-15","objectID":"/posts/rust/:23:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#高级trait"},{"categories":["Tech"],"content":" 高级traittrait是rust中唯一的接口抽象方式，并且这种为类型实现接口的思维方式增加了代码可读性(只需要关注函数名，参数和返回类型就可以知道函数的意图)。trait的使用充分贯彻了组合优于继承和面向接口的编程思想 关联类型在trait定义中可以使用关联类型来指定占位类型，虽然这与泛型十分相似，但是泛型支持对不同类型特化具体trait，而关联类型不允许，并且关联类型对于某个类型只能实现一次 rust库中，迭代器就是一个使用关联类型的例子 rust pub trait Iterator { type Item; //关联类型 fn next(\u0026mut self) -\u003e Option; } type Item; 是 Iterator trait 中定义的 关联类型（Associated Type），它表示： 实现 Iterator 的类型需要指定一个具体的不依赖调用者的 Item 类型 这个 Item 类型代表迭代器每次调用 next() 时返回的元素的类型 对于具体的迭代器，我们需要实现这个关联类型才能让程序完整，所以我们只需要补充Item的类型 rust impl Iterator for Counter { //给自定义的类型实现Iterator trait时需要将Item补充完整 type Item = u32; fn next(\u0026mut self) -\u003e Option { //这样返回值也就清楚了 // --snip-- } } fn main() { let c = Counter{..} c.next() } 关联类型还可以保证代码的可读性，在阅读代码的过程中我们只需要把关联类型视为类型就可以了 完全限定语法完全限定语法适用于trait很多以至于重名的情况 rust trait Animal { fn baby_name() -\u003e String; } struct Dog; impl Dog { fn baby_name() -\u003e String { String::from(\"Spot\") } } impl Animal for Dog { fn baby_name() -\u003e String { String::from(\"puppy\") } } fn main() { println!(\"A baby dog is called a {}\", Dog::baby_name()); println!(\"A baby dog is called a {}\", ::baby_name()); //完全限定语法 } 输出为 shell A baby dog is called a Spot A baby dog is called a puppy 这很类似于C++子类继承父类实现多态的情况，其传入的子类指针可以被编译器识别为父类的形式 supertrait在 Rust 中，Supertrait 是指一个 trait 依赖另一个 trait，即某个 trait 要求实现它的类型必须先实现另一个 trait 语法与C++的继承类似 rust use std::fmt; struct Point { x: i32, y: i32, } trait OutlinePrint: fmt::Display { //supertrait，OutlinePrint trait依赖于Display trait fn outline_print(\u0026self) { let output = self.to_string(); let len = output.len(); println!(\"{}\", \"*\".repeat(len + 4)); println!(\"*{}*\", \" \".repeat(len + 2)); println!(\"* {output} *\"); println!(\"*{}*\", \" \".repeat(len + 2)); println!(\"{}\", \"*\".repeat(len + 4)); } } impl fmt::Display for Point { //首先实现Dispaly trait fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result { write!(f, \"({}, {})\", self.x, self.y) } } impl OutlinePrint for Point {} //而后实现Dispaly trait newtype模式前文曾提到，对于第三方库和官方库，我们都没有权限对其内置类型实现额外的trait，这就是孤儿原则。但是使用newtype模式可以做到这一点，其具体原理与适配器模式类似: rust use std::fmt; struct Wrapper(Vec); impl fmt::Display for Wrapper { fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result { write!(f, \"[{}]\", self.0.join(\", \")) } } fn main() { let w = Wrapper(vec![String::from(\"hello\"),String::from(\"world\")]); println!(\"w = {w}\"); } 这里使用了Wrapper这样一个struct tuple作为适配器，从而将我们想要实现的trait(在这里就是String的Display trait)放入这个适配器中，这里注意的是使用时需要使用self.0的形式从vec提取string 默认泛型参数和运算符重载rust并不支持对所有的运算符进行重载，目前来说，只有定义在std::ops中的运算符才能进行重载 默认泛型参数的语法与C++的默认函数参数类似 rust trait Add","date":"2024-12-15","objectID":"/posts/rust/:23:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#关联类型"},{"categories":["Tech"],"content":" 高级traittrait是rust中唯一的接口抽象方式，并且这种为类型实现接口的思维方式增加了代码可读性(只需要关注函数名，参数和返回类型就可以知道函数的意图)。trait的使用充分贯彻了组合优于继承和面向接口的编程思想 关联类型在trait定义中可以使用关联类型来指定占位类型，虽然这与泛型十分相似，但是泛型支持对不同类型特化具体trait，而关联类型不允许，并且关联类型对于某个类型只能实现一次 rust库中，迭代器就是一个使用关联类型的例子 rust pub trait Iterator { type Item; //关联类型 fn next(\u0026mut self) -\u003e Option; } type Item; 是 Iterator trait 中定义的 关联类型（Associated Type），它表示： 实现 Iterator 的类型需要指定一个具体的不依赖调用者的 Item 类型 这个 Item 类型代表迭代器每次调用 next() 时返回的元素的类型 对于具体的迭代器，我们需要实现这个关联类型才能让程序完整，所以我们只需要补充Item的类型 rust impl Iterator for Counter { //给自定义的类型实现Iterator trait时需要将Item补充完整 type Item = u32; fn next(\u0026mut self) -\u003e Option { //这样返回值也就清楚了 // --snip-- } } fn main() { let c = Counter{..} c.next() } 关联类型还可以保证代码的可读性，在阅读代码的过程中我们只需要把关联类型视为类型就可以了 完全限定语法完全限定语法适用于trait很多以至于重名的情况 rust trait Animal { fn baby_name() -\u003e String; } struct Dog; impl Dog { fn baby_name() -\u003e String { String::from(\"Spot\") } } impl Animal for Dog { fn baby_name() -\u003e String { String::from(\"puppy\") } } fn main() { println!(\"A baby dog is called a {}\", Dog::baby_name()); println!(\"A baby dog is called a {}\", ::baby_name()); //完全限定语法 } 输出为 shell A baby dog is called a Spot A baby dog is called a puppy 这很类似于C++子类继承父类实现多态的情况，其传入的子类指针可以被编译器识别为父类的形式 supertrait在 Rust 中，Supertrait 是指一个 trait 依赖另一个 trait，即某个 trait 要求实现它的类型必须先实现另一个 trait 语法与C++的继承类似 rust use std::fmt; struct Point { x: i32, y: i32, } trait OutlinePrint: fmt::Display { //supertrait，OutlinePrint trait依赖于Display trait fn outline_print(\u0026self) { let output = self.to_string(); let len = output.len(); println!(\"{}\", \"*\".repeat(len + 4)); println!(\"*{}*\", \" \".repeat(len + 2)); println!(\"* {output} *\"); println!(\"*{}*\", \" \".repeat(len + 2)); println!(\"{}\", \"*\".repeat(len + 4)); } } impl fmt::Display for Point { //首先实现Dispaly trait fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result { write!(f, \"({}, {})\", self.x, self.y) } } impl OutlinePrint for Point {} //而后实现Dispaly trait newtype模式前文曾提到，对于第三方库和官方库，我们都没有权限对其内置类型实现额外的trait，这就是孤儿原则。但是使用newtype模式可以做到这一点，其具体原理与适配器模式类似: rust use std::fmt; struct Wrapper(Vec); impl fmt::Display for Wrapper { fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result { write!(f, \"[{}]\", self.0.join(\", \")) } } fn main() { let w = Wrapper(vec![String::from(\"hello\"),String::from(\"world\")]); println!(\"w = {w}\"); } 这里使用了Wrapper这样一个struct tuple作为适配器，从而将我们想要实现的trait(在这里就是String的Display trait)放入这个适配器中，这里注意的是使用时需要使用self.0的形式从vec提取string 默认泛型参数和运算符重载rust并不支持对所有的运算符进行重载，目前来说，只有定义在std::ops中的运算符才能进行重载 默认泛型参数的语法与C++的默认函数参数类似 rust trait Add","date":"2024-12-15","objectID":"/posts/rust/:23:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#完全限定语法"},{"categories":["Tech"],"content":" 高级traittrait是rust中唯一的接口抽象方式，并且这种为类型实现接口的思维方式增加了代码可读性(只需要关注函数名，参数和返回类型就可以知道函数的意图)。trait的使用充分贯彻了组合优于继承和面向接口的编程思想 关联类型在trait定义中可以使用关联类型来指定占位类型，虽然这与泛型十分相似，但是泛型支持对不同类型特化具体trait，而关联类型不允许，并且关联类型对于某个类型只能实现一次 rust库中，迭代器就是一个使用关联类型的例子 rust pub trait Iterator { type Item; //关联类型 fn next(\u0026mut self) -\u003e Option; } type Item; 是 Iterator trait 中定义的 关联类型（Associated Type），它表示： 实现 Iterator 的类型需要指定一个具体的不依赖调用者的 Item 类型 这个 Item 类型代表迭代器每次调用 next() 时返回的元素的类型 对于具体的迭代器，我们需要实现这个关联类型才能让程序完整，所以我们只需要补充Item的类型 rust impl Iterator for Counter { //给自定义的类型实现Iterator trait时需要将Item补充完整 type Item = u32; fn next(\u0026mut self) -\u003e Option { //这样返回值也就清楚了 // --snip-- } } fn main() { let c = Counter{..} c.next() } 关联类型还可以保证代码的可读性，在阅读代码的过程中我们只需要把关联类型视为类型就可以了 完全限定语法完全限定语法适用于trait很多以至于重名的情况 rust trait Animal { fn baby_name() -\u003e String; } struct Dog; impl Dog { fn baby_name() -\u003e String { String::from(\"Spot\") } } impl Animal for Dog { fn baby_name() -\u003e String { String::from(\"puppy\") } } fn main() { println!(\"A baby dog is called a {}\", Dog::baby_name()); println!(\"A baby dog is called a {}\", ::baby_name()); //完全限定语法 } 输出为 shell A baby dog is called a Spot A baby dog is called a puppy 这很类似于C++子类继承父类实现多态的情况，其传入的子类指针可以被编译器识别为父类的形式 supertrait在 Rust 中，Supertrait 是指一个 trait 依赖另一个 trait，即某个 trait 要求实现它的类型必须先实现另一个 trait 语法与C++的继承类似 rust use std::fmt; struct Point { x: i32, y: i32, } trait OutlinePrint: fmt::Display { //supertrait，OutlinePrint trait依赖于Display trait fn outline_print(\u0026self) { let output = self.to_string(); let len = output.len(); println!(\"{}\", \"*\".repeat(len + 4)); println!(\"*{}*\", \" \".repeat(len + 2)); println!(\"* {output} *\"); println!(\"*{}*\", \" \".repeat(len + 2)); println!(\"{}\", \"*\".repeat(len + 4)); } } impl fmt::Display for Point { //首先实现Dispaly trait fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result { write!(f, \"({}, {})\", self.x, self.y) } } impl OutlinePrint for Point {} //而后实现Dispaly trait newtype模式前文曾提到，对于第三方库和官方库，我们都没有权限对其内置类型实现额外的trait，这就是孤儿原则。但是使用newtype模式可以做到这一点，其具体原理与适配器模式类似: rust use std::fmt; struct Wrapper(Vec); impl fmt::Display for Wrapper { fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result { write!(f, \"[{}]\", self.0.join(\", \")) } } fn main() { let w = Wrapper(vec![String::from(\"hello\"),String::from(\"world\")]); println!(\"w = {w}\"); } 这里使用了Wrapper这样一个struct tuple作为适配器，从而将我们想要实现的trait(在这里就是String的Display trait)放入这个适配器中，这里注意的是使用时需要使用self.0的形式从vec提取string 默认泛型参数和运算符重载rust并不支持对所有的运算符进行重载，目前来说，只有定义在std::ops中的运算符才能进行重载 默认泛型参数的语法与C++的默认函数参数类似 rust trait Add","date":"2024-12-15","objectID":"/posts/rust/:23:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#supertrait"},{"categories":["Tech"],"content":" 高级traittrait是rust中唯一的接口抽象方式，并且这种为类型实现接口的思维方式增加了代码可读性(只需要关注函数名，参数和返回类型就可以知道函数的意图)。trait的使用充分贯彻了组合优于继承和面向接口的编程思想 关联类型在trait定义中可以使用关联类型来指定占位类型，虽然这与泛型十分相似，但是泛型支持对不同类型特化具体trait，而关联类型不允许，并且关联类型对于某个类型只能实现一次 rust库中，迭代器就是一个使用关联类型的例子 rust pub trait Iterator { type Item; //关联类型 fn next(\u0026mut self) -\u003e Option; } type Item; 是 Iterator trait 中定义的 关联类型（Associated Type），它表示： 实现 Iterator 的类型需要指定一个具体的不依赖调用者的 Item 类型 这个 Item 类型代表迭代器每次调用 next() 时返回的元素的类型 对于具体的迭代器，我们需要实现这个关联类型才能让程序完整，所以我们只需要补充Item的类型 rust impl Iterator for Counter { //给自定义的类型实现Iterator trait时需要将Item补充完整 type Item = u32; fn next(\u0026mut self) -\u003e Option { //这样返回值也就清楚了 // --snip-- } } fn main() { let c = Counter{..} c.next() } 关联类型还可以保证代码的可读性，在阅读代码的过程中我们只需要把关联类型视为类型就可以了 完全限定语法完全限定语法适用于trait很多以至于重名的情况 rust trait Animal { fn baby_name() -\u003e String; } struct Dog; impl Dog { fn baby_name() -\u003e String { String::from(\"Spot\") } } impl Animal for Dog { fn baby_name() -\u003e String { String::from(\"puppy\") } } fn main() { println!(\"A baby dog is called a {}\", Dog::baby_name()); println!(\"A baby dog is called a {}\", ::baby_name()); //完全限定语法 } 输出为 shell A baby dog is called a Spot A baby dog is called a puppy 这很类似于C++子类继承父类实现多态的情况，其传入的子类指针可以被编译器识别为父类的形式 supertrait在 Rust 中，Supertrait 是指一个 trait 依赖另一个 trait，即某个 trait 要求实现它的类型必须先实现另一个 trait 语法与C++的继承类似 rust use std::fmt; struct Point { x: i32, y: i32, } trait OutlinePrint: fmt::Display { //supertrait，OutlinePrint trait依赖于Display trait fn outline_print(\u0026self) { let output = self.to_string(); let len = output.len(); println!(\"{}\", \"*\".repeat(len + 4)); println!(\"*{}*\", \" \".repeat(len + 2)); println!(\"* {output} *\"); println!(\"*{}*\", \" \".repeat(len + 2)); println!(\"{}\", \"*\".repeat(len + 4)); } } impl fmt::Display for Point { //首先实现Dispaly trait fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result { write!(f, \"({}, {})\", self.x, self.y) } } impl OutlinePrint for Point {} //而后实现Dispaly trait newtype模式前文曾提到，对于第三方库和官方库，我们都没有权限对其内置类型实现额外的trait，这就是孤儿原则。但是使用newtype模式可以做到这一点，其具体原理与适配器模式类似: rust use std::fmt; struct Wrapper(Vec); impl fmt::Display for Wrapper { fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result { write!(f, \"[{}]\", self.0.join(\", \")) } } fn main() { let w = Wrapper(vec![String::from(\"hello\"),String::from(\"world\")]); println!(\"w = {w}\"); } 这里使用了Wrapper这样一个struct tuple作为适配器，从而将我们想要实现的trait(在这里就是String的Display trait)放入这个适配器中，这里注意的是使用时需要使用self.0的形式从vec提取string 默认泛型参数和运算符重载rust并不支持对所有的运算符进行重载，目前来说，只有定义在std::ops中的运算符才能进行重载 默认泛型参数的语法与C++的默认函数参数类似 rust trait Add","date":"2024-12-15","objectID":"/posts/rust/:23:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#newtype模式"},{"categories":["Tech"],"content":" 高级traittrait是rust中唯一的接口抽象方式，并且这种为类型实现接口的思维方式增加了代码可读性(只需要关注函数名，参数和返回类型就可以知道函数的意图)。trait的使用充分贯彻了组合优于继承和面向接口的编程思想 关联类型在trait定义中可以使用关联类型来指定占位类型，虽然这与泛型十分相似，但是泛型支持对不同类型特化具体trait，而关联类型不允许，并且关联类型对于某个类型只能实现一次 rust库中，迭代器就是一个使用关联类型的例子 rust pub trait Iterator { type Item; //关联类型 fn next(\u0026mut self) -\u003e Option; } type Item; 是 Iterator trait 中定义的 关联类型（Associated Type），它表示： 实现 Iterator 的类型需要指定一个具体的不依赖调用者的 Item 类型 这个 Item 类型代表迭代器每次调用 next() 时返回的元素的类型 对于具体的迭代器，我们需要实现这个关联类型才能让程序完整，所以我们只需要补充Item的类型 rust impl Iterator for Counter { //给自定义的类型实现Iterator trait时需要将Item补充完整 type Item = u32; fn next(\u0026mut self) -\u003e Option { //这样返回值也就清楚了 // --snip-- } } fn main() { let c = Counter{..} c.next() } 关联类型还可以保证代码的可读性，在阅读代码的过程中我们只需要把关联类型视为类型就可以了 完全限定语法完全限定语法适用于trait很多以至于重名的情况 rust trait Animal { fn baby_name() -\u003e String; } struct Dog; impl Dog { fn baby_name() -\u003e String { String::from(\"Spot\") } } impl Animal for Dog { fn baby_name() -\u003e String { String::from(\"puppy\") } } fn main() { println!(\"A baby dog is called a {}\", Dog::baby_name()); println!(\"A baby dog is called a {}\", ::baby_name()); //完全限定语法 } 输出为 shell A baby dog is called a Spot A baby dog is called a puppy 这很类似于C++子类继承父类实现多态的情况，其传入的子类指针可以被编译器识别为父类的形式 supertrait在 Rust 中，Supertrait 是指一个 trait 依赖另一个 trait，即某个 trait 要求实现它的类型必须先实现另一个 trait 语法与C++的继承类似 rust use std::fmt; struct Point { x: i32, y: i32, } trait OutlinePrint: fmt::Display { //supertrait，OutlinePrint trait依赖于Display trait fn outline_print(\u0026self) { let output = self.to_string(); let len = output.len(); println!(\"{}\", \"*\".repeat(len + 4)); println!(\"*{}*\", \" \".repeat(len + 2)); println!(\"* {output} *\"); println!(\"*{}*\", \" \".repeat(len + 2)); println!(\"{}\", \"*\".repeat(len + 4)); } } impl fmt::Display for Point { //首先实现Dispaly trait fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result { write!(f, \"({}, {})\", self.x, self.y) } } impl OutlinePrint for Point {} //而后实现Dispaly trait newtype模式前文曾提到，对于第三方库和官方库，我们都没有权限对其内置类型实现额外的trait，这就是孤儿原则。但是使用newtype模式可以做到这一点，其具体原理与适配器模式类似: rust use std::fmt; struct Wrapper(Vec); impl fmt::Display for Wrapper { fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result { write!(f, \"[{}]\", self.0.join(\", \")) } } fn main() { let w = Wrapper(vec![String::from(\"hello\"),String::from(\"world\")]); println!(\"w = {w}\"); } 这里使用了Wrapper这样一个struct tuple作为适配器，从而将我们想要实现的trait(在这里就是String的Display trait)放入这个适配器中，这里注意的是使用时需要使用self.0的形式从vec提取string 默认泛型参数和运算符重载rust并不支持对所有的运算符进行重载，目前来说，只有定义在std::ops中的运算符才能进行重载 默认泛型参数的语法与C++的默认函数参数类似 rust trait Add","date":"2024-12-15","objectID":"/posts/rust/:23:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#默认泛型参数和运算符重载"},{"categories":["Tech"],"content":" 高级类型 type别名我们可以通过type关键字为现有类型提供别名 下面是比较简单的用法 rust type Kilometers = i32; let x: i32 = 5; let y: Kilometers = 5; println!(\"x + y = {}\", x + y); 例如标准库中的Result就使用了type简化Result类型 rust type Result\u003cT\u003e = std::result::Result\u003cT, std::io::Error\u003e; type关键字更常用于关联类型中 rust pub trait Iterator { type Item; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e; } impl Iterator for Counter { type Item = u32; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e { // --snip-- } } never类型 (!)函数返回的空类型是()，什么也不返回的类型是\"!\"，我们通常称这种类型为never类型 例如下例 rust impl\u003cT\u003e Option\u003cT\u003e { pub fn unwrap(self) -\u003e T { match self { Some(val) =\u003e val, None =\u003e panic!(\"called `Option::unwrap()` on a `None` value\"), } } } 当触发panic时返回类型就是! 下面的函数如果陷入loop的话返回类型就是! rust print!(\"forever \"); loop { print!(\"and ever \"); } 在使用match时必须要求分支返回类型相同，因此下面的程序会报错 rust fn main() { let i = 2; let v = match i { 0..=3 =\u003e i, //返回类型i32 _ =\u003e println!(\"不合规定的值:{}\", i) //返回类型() }; } 这时我们如果将第二个返回值改为!就可以编译通过，因为没有任何返回值，那就可以与所有类型匹配 rust fn main() { let i = 2; let v = match i { 0..=3 =\u003e i, _ =\u003e panic!(\"不合规定的值:{}\", i) }; } ","date":"2024-12-15","objectID":"/posts/rust/:23:3","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#高级类型"},{"categories":["Tech"],"content":" 高级类型 type别名我们可以通过type关键字为现有类型提供别名 下面是比较简单的用法 rust type Kilometers = i32; let x: i32 = 5; let y: Kilometers = 5; println!(\"x + y = {}\", x + y); 例如标准库中的Result就使用了type简化Result类型 rust type Result = std::result::Result; type关键字更常用于关联类型中 rust pub trait Iterator { type Item; fn next(\u0026mut self) -\u003e Option; } impl Iterator for Counter { type Item = u32; fn next(\u0026mut self) -\u003e Option { // --snip-- } } never类型 (!)函数返回的空类型是()，什么也不返回的类型是\"!\"，我们通常称这种类型为never类型 例如下例 rust impl Option { pub fn unwrap(self) -\u003e T { match self { Some(val) =\u003e val, None =\u003e panic!(\"called `Option::unwrap()` on a `None` value\"), } } } 当触发panic时返回类型就是! 下面的函数如果陷入loop的话返回类型就是! rust print!(\"forever \"); loop { print!(\"and ever \"); } 在使用match时必须要求分支返回类型相同，因此下面的程序会报错 rust fn main() { let i = 2; let v = match i { 0..=3 =\u003e i, //返回类型i32 _ =\u003e println!(\"不合规定的值:{}\", i) //返回类型() }; } 这时我们如果将第二个返回值改为!就可以编译通过，因为没有任何返回值，那就可以与所有类型匹配 rust fn main() { let i = 2; let v = match i { 0..=3 =\u003e i, _ =\u003e panic!(\"不合规定的值:{}\", i) }; } ","date":"2024-12-15","objectID":"/posts/rust/:23:3","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#type别名"},{"categories":["Tech"],"content":" 高级类型 type别名我们可以通过type关键字为现有类型提供别名 下面是比较简单的用法 rust type Kilometers = i32; let x: i32 = 5; let y: Kilometers = 5; println!(\"x + y = {}\", x + y); 例如标准库中的Result就使用了type简化Result类型 rust type Result = std::result::Result; type关键字更常用于关联类型中 rust pub trait Iterator { type Item; fn next(\u0026mut self) -\u003e Option; } impl Iterator for Counter { type Item = u32; fn next(\u0026mut self) -\u003e Option { // --snip-- } } never类型 (!)函数返回的空类型是()，什么也不返回的类型是\"!\"，我们通常称这种类型为never类型 例如下例 rust impl Option { pub fn unwrap(self) -\u003e T { match self { Some(val) =\u003e val, None =\u003e panic!(\"called `Option::unwrap()` on a `None` value\"), } } } 当触发panic时返回类型就是! 下面的函数如果陷入loop的话返回类型就是! rust print!(\"forever \"); loop { print!(\"and ever \"); } 在使用match时必须要求分支返回类型相同，因此下面的程序会报错 rust fn main() { let i = 2; let v = match i { 0..=3 =\u003e i, //返回类型i32 _ =\u003e println!(\"不合规定的值:{}\", i) //返回类型() }; } 这时我们如果将第二个返回值改为!就可以编译通过，因为没有任何返回值，那就可以与所有类型匹配 rust fn main() { let i = 2; let v = match i { 0..=3 =\u003e i, _ =\u003e panic!(\"不合规定的值:{}\", i) }; } ","date":"2024-12-15","objectID":"/posts/rust/:23:3","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#never类型-"},{"categories":["Tech"],"content":" 动态大小的类型(DST)rust在编译时需要指定给每个类型分配多少内存空间，但有些类型是在运行时才确定下来的，这时我们就需要使用指针来代替对应类型 每一个trait都是动态大小的类型，可以通过名称对其引用 rust中常见的DST类型有str、[T]、dyn Trait，它们均无法直接使用，需要使用引用或Box间接使用，在引用时，DST类型的指针被称为胖指针，内部存储了长度和指针两种信息，64位机上所占空间为8字节，非DST类型的指针为普通指针，由于长度已知或可被推断，因此只存储指针，大小为8字节 为了处理动态大小的类型，rust提供了一个sized trait来确定一个类型的大小在编译时是否已知，对于泛型函数，rust会隐式的添加这个约束 rust fn generic\u003cT: Sized\u003e(t: T) { // --snip-- } 这样，使用Sized trait约束代表传入generic函数的泛型T应当具有固定大小，也就是说str、[T]、dyn Trait必须使用String，Box或Rc将对象包装 对于一些不确定是否sized的函数可以使用?sized放宽约束，该trait表示无论T是否有固定大小，都可以作为generic函数的泛型参数(即支持Sized类型和?Sized类型) rust fn generic\u003cT: ?Sized\u003e(t: \u0026T) { // --snip-- } 由于trait是DST大小的，因此在将trait作为函数参数传递时，需要将其换为固定大小的类型，这也就是前文提到过的trait对象，使用时需要使用Box\u003cdyn trait\u003e或Rc::new(dyn trait) ","date":"2024-12-15","objectID":"/posts/rust/:23:4","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#动态大小的类型dst"},{"categories":["Tech"],"content":" 零大小的类型(ZST)当单元类型或单元结构体大小为0时，该类型为ZST rust enum Void{} struct Foo; struct Bar{ foo: Foo, a: (), b: [u8;0], } 上述单元和单元结构体大小均为0，运行时不占用内存空间 ","date":"2024-12-15","objectID":"/posts/rust/:23:5","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#零大小的类型zst"},{"categories":["Tech"],"content":" 高级函数和闭包函数指针(fn)是一个类型，可以作为函数参数传递给其它函数 rust fn add_one(x: i32) -\u003e i32 { x + 1 } fn do_twice(f: fn(i32) -\u003e i32, arg: i32) -\u003e i32 { f(arg) + f(arg) } fn main() { let answer = do_twice(add_one, 5); println!(\"The answer is: {answer}\"); } 函数指针实现了全部三种闭包trait(Fn，FnMut，FnOnce)，这样函数指针不仅可以接收普通函数还可以接收闭包 在 Rust 中，某些构造器可以像函数一样使用，甚至可以作为函数指针或闭包传递。看下面的示例： rust enum Status { Value(u32), Stop, } let list_of_statuses: Vec\u003cStatus\u003e = (0u32..20).map(Status::Value).collect(); 这里的 Status::Value 实际上就像一个函数，它接受一个 u32 参数并返回一个 Status::Value(u32) 枚举变体。我们可以将其直接传递给 map，这说明 枚举的变体（带字段的构造器）可以作为函数或闭包使用 这与我们通常的写法也一致，比如： rust let v = Status::Value(3); 看起来就像是在调用一个函数。这并不是巧合，这些构造器背后本质上就是函数，因此可以像函数一样使用它们，也可以将它们作为高阶函数的参数 我们还可以返回闭包，但是下面的代码会报错，因为rust并不知道返回类型所占空间的大小 rust fn returns_closure() -\u003e dyn Fn(i32) -\u003e i32 { |x| x + 1 } 这样我们就可以使用上小节的内容进行改造 rust fn returns_closure() -\u003e Box\u003cdyn Fn(i32) -\u003e i32\u003e { Box::new(|x| x + 1) } 返回一个指针就可以了 ","date":"2024-12-15","objectID":"/posts/rust/:23:6","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#高级函数和闭包"},{"categories":["Tech"],"content":" 宏(to be continue…)rust宏是对编译器前端进行修改，因此对使用者提出高要求的同时功能也非常强大。它可以获取和操控变量和数据结构的签名和内存，以此来生成代码。由于宏编程难度大，复杂性高，本节不做介绍 ","date":"2024-12-15","objectID":"/posts/rust/:24:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#宏to-be-continue"},{"categories":["Tech"],"content":" 异步编程","date":"2024-12-15","objectID":"/posts/rust/:25:0","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#异步编程"},{"categories":["Tech"],"content":" 异步与多线程异步常用于高IO场景例如数据库，网络服务器等领域，这是由于异步IO的性能瓶颈在于IO而不在于内存或CPU，如果使用同步模型的话，CPU就有大量的时间被浪费在等待IO上面了。异步IO就是在等待IO的时间内去做别的事，可以是其它线程的其它任务，也可以是本线程的其他任务，甚至是其它线程的IO任务 rust的异步性能远高于go，而go又高于其它语言。这是因为go采用了协程的异步框架，但是协程并不支持底层的自定义异步程序，因此go要逊色于rust。而go异步性能高于其它语言的原因是go语言的协程是基于底层写的并有对应的关键字，而其它语言并未深入到底层，并且它们大多采用事件驱动(就是回调)的框架，这会导致回调地狱的问题：：非线性的控制流和结果处理导致了数据流向和错误传播变得难以掌控，还会导致代码可维护性和可读性的大幅降低。下面是异步框架的分类及介绍 OS多线程， 它最简单，也无需改变任何编程模型(业务/代码逻辑)，因此非常适合作为语言的原生并发模型，我们在多线程章节也提到过，Rust 就选择了原生支持线程级的并发编程。但是，这种模型也有缺点，例如线程间的同步将变得更加困难，线程间的上下文切换损耗较大。使用线程池在一定程度上可以提升性能，但是对于 IO 密集的场景来说，线程池还是不够 事件驱动(Event driven)， 这个名词你可能比较陌生，如果说事件驱动常常跟回调( Callback )一起使用，相信各位就恍然大悟了。这种模型性能相当的好，但最大的问题就是存在回调地狱的风险， JavaScript 曾经深受其害 协程(Coroutines) 可能是目前最火的并发模型，Go 语言的协程设计非常优秀，这也是 Go 语言能够迅速火遍全球的杀手锏之一。协程跟线程类似，无需改变编程模型，同时，它也跟 async 类似，可以支持大量的任务并发运行。但协程抽象层次过高，导致用户无法接触到底层的细节，这对于系统编程语言和自定义异步运行时是难以接受的 actor 模型是 erlang 的杀手锏之一，它将所有并发计算分割成一个一个单元，这些单元被称为 actor ，单元之间通过消息传递的方式进行通信和数据传递，这跟分布式系统的设计理念非常相像。由于 actor 模型跟现实很贴近，因此它相对来说更容易实现，但是一旦遇到流控制、失败重试等场景时，就会变得不太好用 async/await， 该模型性能高，还能支持底层编程，同时又像线程和协程那样无需过多的改变编程模型，但有得必有失，async 模型的问题就是内部实现机制过于复杂，对于用户来说，理解和使用起来也没有线程和协程简单，好在前者的复杂性开发者们已经帮我们封装好，而理解和使用起来不够简单，正是本章试图解决的问题 rust采用了OS多线程以及async/await异步框架的解决方案。前者通过标准库实现，使用简单。后者通过标准库和第三方库(例如tokio)实现，尽管async/await模型性能优异，但是代码编写以及维护难度高(异步编程debug时编译器不是很友好，还有可恶的生命周期也参与进来了)，因此对程序员提出了高要求 async/await的缺点：尽管async/await有如此多的好处，但是对应的代价是编译器会为async函数生成状态机，然后将整个运行时打包进来，这会造成二进制可执行文件体积显著增大 async/await与多线程性能比较 操作 async 线程 创建 0.3 微秒 17 微秒 线程切换 0.2 微秒 1.7 微秒 多线程执行器虽然比单线程执行器功能强大，承受的工作负载也更高，但是在多线程间同步数据时也更为复杂和昂贵，具体选用那种执行器需要进行测试 ","date":"2024-12-15","objectID":"/posts/rust/:25:1","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#异步与多线程"},{"categories":["Tech"],"content":" async/await与futureasync/await异步模型原理：最外层的async函数称为future，它们实现了future trait。future trait内部指定了poll函数，poll的参数包括了当前任务等待时要唤醒的线程函数wake:fn()。当显式调用pending或阻塞函数时，当前future会被阻塞并由当前future调用future trait中的poll函数来将其它future调用。那么具体是什么时候调用wake的呢？这个问题等价于什么时候应该在当前线程内继续执行已经pending的future(子任务)。类似的需求在linux基础那篇文章介绍过，我们应该使用内核提供的IO多路复用技术(poll/epoll)，这两种异步调用接口会在一个线程内异步执行多个任务(个人猜测，当某个任务/future执行完毕后会给内核发信号，之后将本线程内的其它任务/future唤醒并执行) 在future间使用block_on函数来相互异步运行，在同一个future内的任务之间(也就是内层的async与async之间)使用await来相互异步运行 执行器类似于os，它负责调度，轮询，监听IO等任务 async/await 是基于 Future 的高级语法糖，该语法糖隐藏了future的复杂性，future拥有强大的控制能力，而async/await拥有强大的抽象能力和易用性。例如，使用future需要手动处理poll，Pin等机制，而aysnc将代码转为一个future的状态机 async把一段代码转化为一个实现future trait的状态机，阻塞当前future会导致其它future的执行。使用await可以异步的等待当前future执行 实现了future trait的类型表示目前可能还用不到但将来可能用到的值。因此future可以表示：下一次网络数据包的到来，下一次鼠标事件的到来 await只能在async块中使用，当执行await时，对应的代码会被执行器poll，根据poll的结果(ready/pending)来决定继续执行当前代码还是将当前代码pending并执行其它async块的代码。为了能够实现这个特性，在async块被pending时，rust会记住当前上下文以应对重新await时的环境恢复 ","date":"2024-12-15","objectID":"/posts/rust/:25:2","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#asyncawait与future"},{"categories":["Tech"],"content":" pinpin用来将对象的内存位置固定，防止其被移动、销毁导致的内存问题，而移动内存对象在多线程异步编程中会经常遇到 使用时只需将对象用Pin包裹即可 Pin的原理： 只有拥有!Unpin标记的对象才可被Pin固定，而拥有Unpin标记的对象使用Pin包裹后仍可被移动。!Unpin对象内部被用一个符号(_marker:PhantoPinned)标记了，因此该对象可以被Pin固定 使用Pin时遇到的unsafe操作 将被Pin固定住的\u0026mut T进行解引用 将!Unpin对象Pin到栈上 当不需要Pin的那个对象时，需要手动drop掉 ","date":"2024-12-15","objectID":"/posts/rust/:25:3","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#pin"},{"categories":["Tech"],"content":" join与selectjoin!：等待所有future都必须完成，在此期间会并发的执行所有future。在第一次运行时，join!会同时运行所有future select!：等待多个future中的一个完成 rust use futures::executor::block_on; use futures::future::select; use futures::{join, pin_mut, select, FutureExt}; use std::thread; use std::time::Duration; use std::future::*; async fn enjoy_book(){ println!(\"enjoy book\"); } async fn enjoy_music(){ println!(\"enjoy music\"); } async fn poll(){ let book = enjoy_book(); let music = enjoy_music(); join!(book,music); } async fn poll2() -\u003e impl Future\u003cOutput = ()\u003e{ async { enjoy_book().await; enjoy_music().await; } } async fn spoll(){ let book = enjoy_book(); let music = enjoy_music(); let bf = book.fuse(); let mf = music.fuse(); pin_mut!(mf ,bf); select! { ()=bf =\u003e println!(\"bf finished\"), ()=mf =\u003e println!(\"mf dinnished\"), } } fn main() { let p = spoll(); //let p = poll(); //let p = poll2(); block_on(p); } 上面的代码在执行spoll时调用了.fuse与pin_mut!方法。前者让当前future实现了fusedfuture trait，实现这个trait的future如果在select循环中已经被异步执行完成，select就不可以对它进行poll。而后者让对象拥有了Unpin trait，这样在第一次pollu有可能不能完成当前future，有了这个trait后，即使在其它线程中也可以poll这个future而不必担心该线程被移动 ","date":"2024-12-15","objectID":"/posts/rust/:25:4","series":null,"tags":["Programing Language","Tech"],"title":"Rust","uri":"/posts/rust/#join与select"},{"categories":["Tech"],"content":"本文是博主移植驱动工作的总结，详细介绍了移植过程以及遇到的问题及其解决方案，希望对各位有帮助。同时，代码已进入RT-Thread主线。博文同时发表在个人博客wumingzi.top ","date":"2024-10-19","objectID":"/posts/planting-esp32spi-to-rtthread/:0:0","series":null,"tags":["Tech","OS","ESP32","RT-Thread"],"title":"移植ESP32SPI驱动至rtthread教程","uri":"/posts/planting-esp32spi-to-rtthread/#"},{"categories":["Tech"],"content":" 移植ESP32SPI驱动至RT-Thread本文主要使用、查阅了以下资料： 参考书籍 RT-Thread设备驱动开发指南，ESP32官方文档 硬件 ESP32-C3-DevKitM-1，W25Q64 ","date":"2024-10-19","objectID":"/posts/planting-esp32spi-to-rtthread/:0:0","series":null,"tags":["Tech","OS","ESP32","RT-Thread"],"title":"移植ESP32SPI驱动至rtthread教程","uri":"/posts/planting-esp32spi-to-rtthread/#移植esp32spi驱动至rt-thread"},{"categories":["Tech"],"content":" 系统平台搭建具体的硬件连线不必多说，参考ESP32C3官方开发板的原理图即可，交叉编译环境可以参考博主的这篇文章ESP32C3环境搭建教程，代码编辑器我使用了vscode+clang的搭配方式，不采用微软的C/C++插件的原因是在编写驱动时vscode发生过多次闪退的情况，并且代码提示和高亮补全残缺，相关配置可自行参考网上 ","date":"2024-10-19","objectID":"/posts/planting-esp32spi-to-rtthread/:1:0","series":null,"tags":["Tech","OS","ESP32","RT-Thread"],"title":"移植ESP32SPI驱动至rtthread教程","uri":"/posts/planting-esp32spi-to-rtthread/#系统平台搭建"},{"categories":["Tech"],"content":" 代码参考我们可以参考其他芯片的SPI驱动代码来编写，个人参考了GD32和STM32的代码，GD32的驱动代码会简单很多，STM32会更复杂一些 ","date":"2024-10-19","objectID":"/posts/planting-esp32spi-to-rtthread/:2:0","series":null,"tags":["Tech","OS","ESP32","RT-Thread"],"title":"移植ESP32SPI驱动至rtthread教程","uri":"/posts/planting-esp32spi-to-rtthread/#代码参考"},{"categories":["Tech"],"content":" 修改Kconfig与SConscript文件Kconfig指定了系统资源，使得我们可以通过menuconfig来选择配置系统。Kconfig原理可以看官方文档，简而言之，我们可以通过menuconfig的tui界面来配置Kconfig从而生成.config文件，而后再由系统解析.config文件最后生成rtconfig.h文件来指定系统宏的值从而配置系统。但当前Kconfg并不支持SPI驱动，因此我们需要新增Kconfig选项。 Kconfig的风格与厂商，开发者个人相关。例如有的厂商会习惯将引脚配置项放在板上菜单中，并将功能配置项放在片上外设菜单中 ，而有的厂商会将两者都混放在片上外设菜单或BSP菜单中。前者代表是ESP32和GD32，后者代表是STM32 新增的代码如下 Kconfig menu \"Onboard Peripheral Drivers\" ··· config RT_BSP_SPI_CS_PIN int \"SPI GPIO PIN SET\" default 10 if BSP_BOARD_LUATOS_ESP32C3 depends on BSP_USING_SPI2 ··· menu \"On-chip Peripheral Drivers\" ··· menuconfig BSP_USING_SPI bool \"Enable SPI\" default n select RT_USING_SPI if BSP_USING_SPI config BSP_USING_SPI2 bool \"Enable SPI2\" default n endif ··· 下面是参数的意义： RT_USING_SPI：是否添加设备驱动框架代码到工程中 BSP_USING_SPI：是否添加总线设备驱动代码到工程中 BSP_USING_SPIx：添加哪个总线设备驱动代码到工程中 scons脚本类似于cmake、make等工具，是一款由python编写的编译工具，详见官方文档，我们要做的只是添加新编写的spi驱动文件到driver/SConscript里就可以了 python ··· if GetDepend('BSP_USING_SPI'): src += ['drv_spi.c'] ··· 对于头文件，我们不需要引入，因为头文件搜索路径已经在脚本里指明为当前文件夹了 python import os from building import * cwd = GetCurrentDir() //获取头文件路径 src = ['board.c'] //CPPPATH不是C++的源文件路径，而是C头文件的搜索路径 CPPPATH = [cwd] ··· group = DefineGroup('Drivers', src, depend = [''], CPPPATH = CPPPATH) Return('group') ","date":"2024-10-19","objectID":"/posts/planting-esp32spi-to-rtthread/:3:0","series":null,"tags":["Tech","OS","ESP32","RT-Thread"],"title":"移植ESP32SPI驱动至rtthread教程","uri":"/posts/planting-esp32spi-to-rtthread/#修改kconfig与sconscript文件"},{"categories":["Tech"],"content":" 编写驱动文件驱动编写的方法策略： 首先spi驱动编写并不困难，我们只需要参考其他spi驱动编写情况将ESP32的驱动用RT-Thread内核api包装起来即可，这与设计模式中的适配器思想很类似 简单起见，我们先参考GD32的spi驱动代码，代码位于bsp/gd32/risc-v/libraries/gd32_drivers/drv_spi.c 映入眼帘的就是gd32_spi类型的结构体数组spi_bus_obj[]。我们可以看到，gd32_spi就是gd32官方提供的结构体，内部的SPIx，GPIO_PIN_x为宏定义的内存地址，指向了gd32对应外设的寄存器，由于spi片选引脚需要应用层来指定，因此结构体内只有3个GPIO宏 c static const struct gd32_spi spi_bus_obj[] = { #ifdef BSP_USING_SPI0 { SPI0, \"spi0\", RCU_SPI0, RCU_GPIOA, \u0026spi_bus0, GPIOA, GPIO_PIN_5, GPIO_PIN_6, GPIO_PIN_7, } #endif /* BSP_USING_SPI0 */ #ifdef BSP_USING_SPI1 { SPI1, \"spi1\", RCU_SPI1, RCU_GPIOB, \u0026spi_bus1, GPIOB, GPIO_PIN_12, GPIO_PIN_14, GPIO_PIN_15, } #endif /* BSP_USING_SPI1 */ #ifdef BSP_USING_SPI2 { SPI2, \"spi2\", RCU_SPI2, RCU_GPIOB, \u0026spi_bus2, GPIOB, GPIO_PIN_3, GPIO_PIN_4, GPIO_PIN_5, } #endif /* BSP_USING_SPI2 */ }; // bsp/gd32/risc-v/libraries/gd32_drivers/drv_spi.h struct gd32_spi { uint32_t spi_periph; char *bus_name; rcu_periph_enum spi_clk; rcu_periph_enum gpio_clk; struct rt_spi_bus *spi_bus; uint32_t spi_port; uint16_t sck_pin; uint16_t miso_pin; uint16_t mosi_pin; }; 下面是GPIO相关的宏定义 c #include \"gd32f10x.h\" /* GPIOx(x=A,B,C,D,E,F,G) definitions */ #define GPIOA (GPIO_BASE + 0x00000000U) #define GPIOB (GPIO_BASE + 0x00000400U) ··· bsp/gd32/arm/libraries/GD32F10x_Firmware_Library/CMSIS/GD/GD32F10x/Include/gd32f10x.h /* bit operations */ #define REG32(addr) (*(volatile uint32_t *)(uint32_t)(addr)) #define REG16(addr) (*(volatile uint16_t *)(uint32_t)(addr)) #define REG8(addr) (*(volatile uint8_t *)(uint32_t)(addr)) #define BIT(x) ((uint32_t)((uint32_t)0x01U\u003c\u003c(x))) #define BITS(start, end) ((0xFFFFFFFFUL \u003c\u003c (start)) \u0026 (0xFFFFFFFFUL \u003e\u003e (31U - (uint32_t)(end)))) #define GET_BITS(regval, start, end) (((regval) \u0026 BITS((start),(end))) \u003e\u003e (start)) #define APB2_BUS_BASE ((uint32_t)0x40010000U) /*!\u003c apb2 base address */ #define GPIO_BASE (APB2_BUS_BASE + 0x00000800U) /*!\u003c GPIO base address */ spi_bus_obj写成结构体数组的含义也很好懂：支持未指定数量的spi的外设，并利用宏进行编译期的内存优化。而这里的宏就是我们在修改Kconfig配置时的添加的宏。值得主义的是spi_bus_obj结构体中含有rt_spi_bus变量，这一变量实际上是将这个结构体挂载到内核的挂载点，一个合理的推测是可以利用类似linux内核中container_of宏来通过rt_spi_bus获取结构体首地址，这样就可以取得所需数据了 这里也可以看到结构体数组的名称是spi_bus_obj，这里的bus指的就是可以控制多个外设的控制器，有时也被称为controller，adapter。当然，他们之间的也有一些区别，这里按下不表 之后是最重要的部分，即初始化，配置以及传输函数，在这里我们简化并重新排序代码块： c static struct rt_spi_ops gd32_spi_ops = { .configure = spi_configure, .xfer = spixfer, }; static void gd32_spi_init(struct gd32_spi *gd32_spi) { /* enable SPI clock */ rcu_periph_clock_enable(gd32_spi-\u003espi_clk); rcu_periph_clock_enable(gd32_spi-\u003egpio_clk); /* Init SPI SCK MOSI */ gpio_init(gd32_spi-\u003espi_port, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, gd32_spi-\u003esck_pin | gd32_spi-\u003emosi_pin); /* Init SPI MISO */ gpio_init(gd32_spi-\u003espi_port, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, gd32_spi-\u003emiso_pin); } static rt_err_t spi_configure(struct rt_spi_device* device, struct rt_spi_configuration* configuration) { ··· gd32_spi_init(spi_device); /* configuration something */ ··· max_hz = configuration-\u003emax_hz; if(configuration-\u003emode \u0026 RT_SPI_MSB) { spi_init_struct.endian = SPI_ENDIAN_MSB; } spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX; spi_init_struct.device_mode = SPI_MASTER; spi_init_struct.nss = SPI_NSS_SOFT; ··· spi_init(spi_periph, \u0026spi_init_struct); /* Enable SPI_MASTER */ spi_enable(spi_periph); ··· } static rt_uint32_t spixfer(struct rt_spi_device* device, struct rt_spi_message* message) { struct rt_spi_bus * gd32_spi_bus = (struct rt_spi_bus *)device-\u003ebus; struct gd32_spi *spi_device = (struct gd32_spi *)gd32_spi_bus-\u003eparent.user_data; struct rt_spi_configuration * config = \u0026device-\u003econfig; struct gd32_spi_cs * gd32_spi_cs = device-\u003eparent.user_data; uint32_t spi_periph = spi_device-\u003espi_periph; /* take CS */ if(message-\u003ecs_take) { gpio_bit_reset(gd32_spi_cs-\u003eGPIOx, gd32_spi_cs-\u003eGPIO_Pin); LOG_D(\"spi take cs\\n\"); } ··· /* choose transfer ways */ ··· while(RESET == spi_i2s_flag_get(spi_periph, SPI_FLAG_TBE)); // Send the byte spi_i2s_data_transmit(spi_periph, data); //Wait until a data is received while(RESET == spi_i2","date":"2024-10-19","objectID":"/posts/planting-esp32spi-to-rtthread/:4:0","series":null,"tags":["Tech","OS","ESP32","RT-Thread"],"title":"移植ESP32SPI驱动至rtthread教程","uri":"/posts/planting-esp32spi-to-rtthread/#编写驱动文件"},{"categories":["Tech"],"content":" 测试驱动最后的测试代码参考于《RT-Thread设备驱动开发指南》，代码比较简单： c void spi_w25q_sample(void) { rt_hw_spi_device_attach(SPI_BUS_NAME, W25Q_SPI_DEVICE_NAME, GPIO_NUM_10 ); struct rt_spi_device *spi_w25q; struct rt_spi_configuration cfg; rt_uint8_t w25x_read_id[5] = {0x9f, 0xff, 0xff, 0x00, 0xff}; rt_uint8_t id[5] = {0x00,0x00,0x00,0x00,0x00,}; spi_w25q = (struct rt_spi_device*)rt_device_find(W25Q_SPI_DEVICE_NAME); if(!spi_w25q) { rt_kprintf(\"spi asmple run failed! can't find %s device\\n\",W25Q_SPI_DEVICE_NAME); } else { rt_spi_configure(spi_w25q, \u0026cfg); struct rt_spi_message msg1; msg1.send_buf = \u0026w25x_read_id; msg1.recv_buf = \u0026id; msg1.length = 48; msg1.cs_take = 1; msg1.cs_release = 0; msg1.next = RT_NULL; rt_spi_transfer_message(spi_w25q, \u0026msg1); rt_kprintf(\"use rt_spi_transfer_message() read w25q ID is:%x %x%x\\n\", id[1], id[2], id[3]); } } MSH_CMD_EXPORT(spi_w25q_sample, spi w25q sample); 至此，驱动代码编写完成。本代码还有很大的改进空间，未来会做源码上的改动，但无论如何改成什么样子，基本框架是不变的，读者完全可以参考本文编写spi甚至其他的驱动。另一方面，我们也可以看到RT-Thread驱动编写形式与Linux非常相似，这也是RT-Thread深受Linux启发的证明，读者也可以参考Linux来学习RT-Thread ","date":"2024-10-19","objectID":"/posts/planting-esp32spi-to-rtthread/:5:0","series":null,"tags":["Tech","OS","ESP32","RT-Thread"],"title":"移植ESP32SPI驱动至rtthread教程","uri":"/posts/planting-esp32spi-to-rtthread/#测试驱动"},{"categories":["Tech"],"content":"个人搭建动态博客的详细过程，由Halo框架+NexT主题构成 ","date":"2024-10-19","objectID":"/posts/using-nginx-for-trojan-and-rsshub/:0:0","series":null,"tags":["Tech","RSS","Nginx","Life"],"title":"nginx反向代理trojan与rsshub","uri":"/posts/using-nginx-for-trojan-and-rsshub/#"},{"categories":["Tech"],"content":" nginx反向代理trojan与rsshub最终效果：外网通过rss.domin.top访问rsshub服务，通过free.domin.top访问trojan服务，通过free.domin.top/admin访问trojan-web管理服务。内部使用docker隔离包括nginx在内的所有服务 ","date":"2024-10-19","objectID":"/posts/using-nginx-for-trojan-and-rsshub/:0:0","series":null,"tags":["Tech","RSS","Nginx","Life"],"title":"nginx反向代理trojan与rsshub","uri":"/posts/using-nginx-for-trojan-and-rsshub/#nginx反向代理trojan与rsshub"},{"categories":["Tech"],"content":" 前置准备","date":"2024-10-19","objectID":"/posts/using-nginx-for-trojan-and-rsshub/:1:0","series":null,"tags":["Tech","RSS","Nginx","Life"],"title":"nginx反向代理trojan与rsshub","uri":"/posts/using-nginx-for-trojan-and-rsshub/#前置准备"},{"categories":["Tech"],"content":" 购买服务器及域名可以从主流的服务器提供商购买服务器以及域名，我选择的服务器厂商是雨云(国际厂商可以选择racknerd或VMISS)，域名提供商是namesilo 购买完毕后需要在国内DNS解析服务器上绑定ip与域名，可以选择腾讯DNS解析服务。绑定格式如下，需要注意的是我这里使用的二级域名需要额外在namesilo生成 2024-10-19_13-49 2024-10-19_13-52 这里记录值改为ip地址即可 ","date":"2024-10-19","objectID":"/posts/using-nginx-for-trojan-and-rsshub/:1:1","series":null,"tags":["Tech","RSS","Nginx","Life"],"title":"nginx反向代理trojan与rsshub","uri":"/posts/using-nginx-for-trojan-and-rsshub/#购买服务器及域名"},{"categories":["Tech"],"content":" 初始化服务器我的系统是Ubuntu22.04，预安装宝塔面板。安装系统完成并进入宝塔面板后，需要下载docker ","date":"2024-10-19","objectID":"/posts/using-nginx-for-trojan-and-rsshub/:1:2","series":null,"tags":["Tech","RSS","Nginx","Life"],"title":"nginx反向代理trojan与rsshub","uri":"/posts/using-nginx-for-trojan-and-rsshub/#初始化服务器"},{"categories":["Tech"],"content":" 正式搭建","date":"2024-10-19","objectID":"/posts/using-nginx-for-trojan-and-rsshub/:2:0","series":null,"tags":["Tech","RSS","Nginx","Life"],"title":"nginx反向代理trojan与rsshub","uri":"/posts/using-nginx-for-trojan-and-rsshub/#正式搭建"},{"categories":["Tech"],"content":" 部署nginx容器我这里使用的是dockerhub上的官方版本 首先拉取镜像到本地 shell docker pull nginx:stable-perl 而后可以在宝塔面板中看到 2024-10-19_11-13 这里我们也可以点击创建容器也可以通过命令 cpp docker run -d -p 443:443 -p 80::80 --net bridge --name nginx nginx:latest 图形化创建容器时需要映射80以及443端口，同时指定容器网络为桥接(指定网络为host后在下文的docker网络配置环节可能会连接不上其他容器网络) 2024-10-19_11-17 2024-10-19_11-20 ","date":"2024-10-19","objectID":"/posts/using-nginx-for-trojan-and-rsshub/:2:1","series":null,"tags":["Tech","RSS","Nginx","Life"],"title":"nginx反向代理trojan与rsshub","uri":"/posts/using-nginx-for-trojan-and-rsshub/#部署nginx容器"},{"categories":["Tech"],"content":" 部署rsshub容器这里可以参考官方文档使用docker compose部署 下载docker compose文件(可以理解为docker的配置文件) shell wget https://raw.githubusercontent.com/DIYgod/RSSHub/master/docker-compose.yml 启动容器(通过docker compose文件下载相关的包并配置参数，完成后启动容器) shell docker-compose up -d 在漫长的下载过程后会在面板中看到如下三个容器 2024-10-19_11-27 这里我映射了1200端口是为了测试用，各位如果不需要测试的话可以不用配置 假如你和我一样保留了1200测试端口，此时我们访问ip:1200端口就可以访问rsshub了，如果404可能是你防火墙没有开，面板中的安全菜单中可以自行配置 ","date":"2024-10-19","objectID":"/posts/using-nginx-for-trojan-and-rsshub/:2:2","series":null,"tags":["Tech","RSS","Nginx","Life"],"title":"nginx反向代理trojan与rsshub","uri":"/posts/using-nginx-for-trojan-and-rsshub/#部署rsshub容器"},{"categories":["Tech"],"content":" 部署trojan容器这里我们选用jroh大佬的trojan镜像 安装trojan之前最好先安装trojan-web服务，因为安装trojan的时候会需要指定trojan-web数据库的ip地址，不指定可能会安装失败 cpp docker run --name trojan-mariadb --restart=always -p 3306:3306 -v /home/mariadb:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=trojan -e MYSQL_ROOT_HOST=% -e MYSQL_DATABASE=trojan -d mariadb:10.2 注意MYSQL_ROOT_PASSWORD=trojan参数是访问trojan-web的密码，我们下面安装trojan时需要输入数据库的密码就是trojan 之后我们拉取trojan的镜像 shell docker pull jrohy/trojan 注意本次trojan使用桥接网络，这与jrohy提供的命令不同，因此不需要将端口映射到主机，但为了后需的调整，我们这里预留4431和4432端口 shell docker run -it -d --name trojan --net=bridge --restart=always --privileged jrohy/trojan init 生成容器后我们进入容器 shell docker exec -it trojan bash 此时我们需要安装trojan shell trojan 进入安装界面，证书选择let’s encrpt证书，域名绑定到服务商域名，此时会需要指定mysql或mariadb的ip和端口号，这里我们可以通过查看容器网络获得也可以给空等待安装完成之后再修改(给空有可能安装错误)。这里如果你没有看到桥接网络的话需要设置mariadb网络为桥接bridge，默认端口号是3306，因此我这里的结果是172.17.0.4:3306 2024-10-19_13-57 之后等待安装完成就可 别忘了启动服务，设置自启动以及更新程序 shell systemctl start trojan-web systemctl enable trojan-web source \u003c(curl -sL https://git.io/trojan-install) 最后退出容器 cpp exit 目前你的容器情况可能如下 2024-10-19_14-01 我们需要指定rsshub为桥接，这样才能使用nginx将流量转发到rsshub，桥接时务必保留原有的rsshub容器网络 接下来我们进行反向代理的配置 ","date":"2024-10-19","objectID":"/posts/using-nginx-for-trojan-and-rsshub/:2:3","series":null,"tags":["Tech","RSS","Nginx","Life"],"title":"nginx反向代理trojan与rsshub","uri":"/posts/using-nginx-for-trojan-and-rsshub/#部署trojan容器"},{"categories":["Tech"],"content":" 申请证书在配置反向代理前我们需要准备证书，这也是我们刚才在安装mariadb时跳过的步骤 申请证书需要提前获取ip以及域名，申请过程可以参考Diaoan’s Blog 我这里直接执行 shell certbot certonly --standalone -d rss.domain.top shell certbot certonly --standalone -d free.domain.top 记录好证书存放位置，之后我们正式开始进行反向代理的配置 ","date":"2024-10-19","objectID":"/posts/using-nginx-for-trojan-and-rsshub/:2:4","series":null,"tags":["Tech","RSS","Nginx","Life"],"title":"nginx反向代理trojan与rsshub","uri":"/posts/using-nginx-for-trojan-and-rsshub/#申请证书"},{"categories":["Tech"],"content":" 网络拓扑图搭建反向代理时搞清网络脱坡是非常有必要的，我当前网络拓扑图是这样的 服务器网络拓扑当前 而我们目标的网络拓扑是这样的：nginx容器接管一切流量并将其转发到对应应用 服务器网络拓扑目标 由此可见，我们应该配置trojan的两个端口，nginx的两个端口。trojan两个端口的作用可以看官方文档，简而言之，近端端口用来进行代理，远端端口用来检测到非法连接从而将非法流量转移到此端口上，因此这个端口可以设置为任意能够ping通的网页。而为了保证流量均由nginx控制，这里采用通过nginx转发trojan远程端口以及管理页面，同时由于远程端口可以任意指定，这里就把管理页面作为远程端口。传输协议方面，由于trojan配置文件需要指定证书文件，因此对于ssl协议的解析需要放在trojan容器内部进行，而rss内部没有解析的功能，我们就需要在nginx内部进行rss协议的处理 ","date":"2024-10-19","objectID":"/posts/using-nginx-for-trojan-and-rsshub/:2:5","series":null,"tags":["Tech","RSS","Nginx","Life"],"title":"nginx反向代理trojan与rsshub","uri":"/posts/using-nginx-for-trojan-and-rsshub/#网络拓扑图"},{"categories":["Tech"],"content":" 修改nginx配置项首先保证nginx，rsshub，trojan均为桥接，保证均处于同一个容器网络中 而后修改nginx容器内的/etc/nginx/nginx.conf文件内容如下 shell user nginx; worker_processes auto; error_log /var/log/nginx/error.log notice; pid /var/run/nginx.pid; events { worker_connections 1024; } # 流量转发核心配置 stream { # SNI 识别，将域名映射到具体服务 map $ssl_preread_server_name $backend_name { free.wumingzi.top trojan; # Trojan 流量转发 rss.wumingzi.top rss; # rsshub流量转发 default rss; # 默认转发到 RSS (避免误匹配) } # 定义 Trojan 的后端服务 upstream trojan { server 172.17.0.5:4431; # Trojan 的后端端口 } upstream rss { server 127.0.0.1:1201; # 这里需要先转到nginx容器的1201端口进行ssl协议处理，处理完成后再转到rsshub容器的1200端口 } # 监听 443 并使用 ssl_preread 对 Trojan 流量转发，不解密 server { listen 443 reuseport; listen [::]:443 reuseport; proxy_pass $backend_name; ssl_preread on; } } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; # 如果端口设置与stream块相同的话就会导致冲突，因此这里只能监听http协议的80而不能监听https的443 server { listen 80; server_name rss.wumingzi.top; return 301 https://$host$request_uri; # 永久重定向为https } server { listen 1201 ssl; server_name rss.wumingzi.top; # 证书解析，上文申请的证书放到容器内的对应位置 ssl_certificate /etc/nginx/certs/rss.wumingzi.top/fullchain1.pem; ssl_certificate_key /etc/nginx/certs/rss.wumingzi.top/privkey1.pem; location / { proxy_pass http://172.17.0.3:1200; # 转到rsshub容器的1200端口，此时解析协议时信息流已经是未加密状态，因此是http } } server { listen 82; # 监听trojan的远程端口，有流量产生时转发到对应服务 server_name free.wumingzi.top; # 后台管理页面,通过 free.wumingzi.top/admin 访问 location /admin { proxy_pass http://172.17.0.5:81/; # 将trojan已经解析的协议发送到nginx容器的81端口这里是trojan-web的协议端口 } # 由于 trojan web 前端的部分资源是写在二进制中的，这些资源的访问路径固定 location ~* ^/(static|common|auth|trojan)/ { proxy_pass http://172.17.0.5:81; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header Host $host; } } } ","date":"2024-10-19","objectID":"/posts/using-nginx-for-trojan-and-rsshub/:2:6","series":null,"tags":["Tech","RSS","Nginx","Life"],"title":"nginx反向代理trojan与rsshub","uri":"/posts/using-nginx-for-trojan-and-rsshub/#修改nginx配置项"},{"categories":["Tech"],"content":" 修改trojan配置项将trojan容器中的/usr/local/etc/trojan/config.json文件修改如下 json { \"run_type\": \"server\", \"local_addr\": \"0.0.0.0\", \"local_port\": 4431, //修改本地端口为nginx配置的转发端口 \"remote_addr\": \"172.17.0.2\", //修改远程ip为nginx容器的ip \"remote_port\": 82, //修改远程端口为nginx的远程端口 \"password\": null, \"log_level\": 1, //这里可以加上日志文件方便调试 \"ssl\": { //修改为对应的证书 \"cert\": \"/usr/local/etc/trojan/certs/free.wumingzi.top/fullchain1.pem\", \"key\": \"/usr/local/etc/trojan/certs/free.wumingzi.top/privkey1.pem\", \"key_password\": \"\", \"cipher\": \"ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384\", \"cipher_tls13\": \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384\", \"prefer_server_cipher\": true, \"alpn\": [\"http/1.1\"], \"alpn_port_override\": { \"h2\": 81 }, \"reuse_session\": true, \"session_ticket\": false, \"session_timeout\": 600, \"plain_http_response\": \"\", \"curves\": \"\", \"dhparam\": \"\", \"sni\": \"free.wumingzi.top\" //这里修改为nginx配置的流量转发的网址 }, \"tcp\": { \"prefer_ipv4\": false, \"no_delay\": true, \"keep_alive\": true, \"reuse_port\": false, \"fast_open\": false, \"fast_open_qlen\": 20 }, \"mysql\": { \"enabled\": true, \"server_addr\": \"172.17.0.4\", //修改为mariadb容器的ip \"server_port\": 3306, //修改为mariadb容器对应的端口号 \"database\": \"trojan\", //下面视情况修改 \"username\": \"root\", \"password\": \"trojan\", \"cafile\": \"\" } } 将trojan中的/etc/systemd/system/trojan-web.service 文件修改如下，第九行新增指定81端口运行 json [Unit] Description=trojan-web Documentation=https://github.com/Jrohy/trojan After=network.target network-online.target nss-lookup.target mysql.service mariadb.service mysqld.service docker.service [Service] Type=simple StandardError=journal ExecStart=/usr/local/bin/trojan web -p 81 ExecReload=/bin/kill -HUP $MAINPID Restart=on-failure RestartSec=3s [Install] WantedBy=multi-user.target 至此配置全部完成，重启全部容器后就可以实现最终效果了 参考文档 VPS 初体验（三）在 VPS 上快速搭建 trojan 服务 VPS 初体验（四）trojan 和 Nginx 共用 443 端口 程小白 Trojan多用户面板+宝塔+Docker 在docker中使用Nginx并实现反向代理 ","date":"2024-10-19","objectID":"/posts/using-nginx-for-trojan-and-rsshub/:2:7","series":null,"tags":["Tech","RSS","Nginx","Life"],"title":"nginx反向代理trojan与rsshub","uri":"/posts/using-nginx-for-trojan-and-rsshub/#修改trojan配置项"},{"categories":["Tech"],"content":"本文为笔者的毕业设计相关内容，目的是使用嵌入式系统将振动数据发送至对应主机。系统使用stm32+rtthread作为基本结构，并选用其他中间件丰富系统功能。由于stm32的ram与rom资源紧缺，后期移植文件系统以及其他中间件会爆内存，因此笔者目前暂停这一方案，并转而使用ESP32C3为主控 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:0:0","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#"},{"categories":["Tech"],"content":" RT-Thread实验参照RTT官方文档以及RTT内核实验手册 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:0:0","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#rt-thread"},{"categories":["Tech"],"content":" RT-Thread简介RT-Thread(下文简称rtt)是一款纯国产的RTOS，其特色在于组件非常丰富，适用于物联网行业。其基本组件包含RTOS内核，wifi协议栈，dfs文件系统，finsh控制台，USB协议栈，安全模块，低功耗模块，音视频框架，压缩解压库等 2024-06-18_20-23 rtt主要运行于32位cpu，但更高等级的cpu也可适用 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:1:0","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#rt-thread简介"},{"categories":["Tech"],"content":" 环境搭建目前我们需要env工具使用menuconfig来进行组件裁剪甚至内核裁剪，在调试的时候我们还需要用到segger公司的systemview工具来查看资源占用，线程调度等信息。在工程代码管理方面，我们使用git从rtt官方库中拉取代码并进行版本管理，使用vscode进行代码编辑，使用keil进行代码烧写，使用scon脚本编译代码和构建产物，使用MobaXterm进行串口调试和执行shell命令。我们暂时不需要MQTT或者websocket等高级功能，但未来可能进行补充 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:2:0","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#环境搭建"},{"categories":["Tech"],"content":" git环境配置及项目搭建首先建立工程需要将代码克隆到本地 shell git clone git@github.com:RT-Thread/rt-thread.git 此操作将会在当前目录下建立一个.git文件夹和一个rt-thread文件夹 如果克隆时遇到了公钥指纹的问题，可以尝试重新登陆 shell git config --global user.name \"用户名\" git config --global user.email \"邮箱\" 克隆成功后我们得到的是master版本，master更新频繁因此适合尝鲜的发烧友使用。而研究学习以及做产品建议使用stable或者lts版本，为了能够下载多个版本我们还需要执行以下命令 shell git branch -r //获取远程仓库分支名 git checkout -b 本地分支名 origin/远程分支名 //将远程分支下载到本地分支 //例如我们如果要下载origin/lts-v4.1.x版本的rtt，我们可以执行以下命令 git checkout -b lts-v4.1.x origin/lts-v4.1.x 这样我们就将远程的lts-v4.1.x分支拉取到本地的lts-v4.1.x分支，即使本地之前没有创建lts-v4.1.x分支也无所谓，git会自动创建 下面是下载好的分支 2024-06-19_08-55 之后我们统一在lts-v4.1.x版本上对代码进行更改 至此本地仓库搭建完毕 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:2:1","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#git环境配置及项目搭建"},{"categories":["Tech"],"content":" env环境搭建Env 是 RT-Thread 推出的开发辅助工具，针对基于 RT-Thread 操作系统的项目工程，提供编译构建环境、图形化系统配置及软件包管理功能。我们使用env最主要的目的就是menuconfig套件，其次env有方便易用的命令行系统。menuconfig是linux和rtt都使用用来配置内核模块的工具。我们可以通过menuconfig图形化系统来配置内核及模块，这样就不必到每个文件夹下修改Kconfig的内容了，十分方便 首先从官网下载env工具包并安装，而后在对应的bsp目录下D:\\Programes\\RT-Thread\\rtt\\rt-thread\\bsp\\stm32\\stm32f103-blue-pill打开env命令行，并使用menuconfig命令来配置软件包 shell D:\\Programes\\RT-Thread\\rtt\\rt-thread\\bsp\\stm32\\stm32f103-blue-pill menuconfig 这里我们只选择 RT-Thread online packages-\u003e tools packages-\u003e SystemView 工具用来配合systemview软件使用。由于我们使用的是在线软件包，因此在选择之后我们还需要去服务器上下载，这一步使用pkgs –update命令 2024-06-19_09-19 空格键就可以选中，?键可以查看帮助 进入到SystemView后我们还需要设置内核为M3 2024-06-19_09-20 并在SystemView buffer configuration中关闭事后分析模式 2024-06-19_09-21 配置完成后退出保存即可 不要忘了在最后还要获取软件包，pkgs是rtt官方维护的包管理工具 shell pkgs --update 软件包下载后还需要把他们编译进代码，我们使用基于python的编译脚本scons进行编译。在bsp目录下执行 shell scons 这样我们就得到了软件包文件夹packages。由于systemview并不能识别rtt系统，我们需要将packages\\segger_debug-xxx\\SystemView_Description\\SYSVIEW_RT-Thread.txt文件拷贝到SystemView 工具安装目录下的 Description 目录下 警告 在v5.0.x版本中使用systemview模块时会产生rtt版本过高的问题 2024-06-28_14-09 为了支持keil等工具，我们还需要执行 shell scons --target=mdk5 之后我们就可以在bsp目录下找到project.uvprojx文件了。最后打开keil进行烧录即可 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:2:2","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#env环境搭建"},{"categories":["Tech"],"content":" vscode项目搭建为了保证编译与编辑的一致性，vscode与keil的项目文件应保持一致。我们在vscode的插件市场搜索project manager，然后将rt-thread文件夹导入，这样在编辑代码时我们就可以保证代码的一致性 为了能够测试systemview，我们还需要在工程内添加测试代码，测试代码源于rtt文档中心 添加后我们还需要重新编译模块，但是执行scons命令后会出现如图所示的错误信息 2024-06-19_18-56 根据提示，原因可能是packages\\SystemView-latest\\SystemView_Src\\Config\\SEGGER_SYSVIEW_RTThread.c文件中的若干变量未定义，找到对应代码如下 2024-06-19_18-59 我们发现引用的头文件与当前文件不属于同级目录，这会导致编译器找不到头文件，因此只需要更改头文件索引目录 2024-06-19_19-01 如果在vscode里面不想看见除了stm32的所有芯片bsp，我们可以在settings.json填写如下代码 json { \"files.exclude\": { \"**/bsp/^(stm32)/**\": true, \"bsp/[!s]*\": true, \"bsp/s[!t]*\": true, \"bsp/st[!m]*\": true, \"bsp/stm[!3]*\": true, \"bsp/stm3[!2]*\": true, \"bsp/stm32/stm32[!f]*\": true, \"bsp/stm32/stm32f[!1]*\": true, \"bsp/stm32/stm32f10[!3]*\": true, \"bsp/stm32/stm32f103-[!b]*\": true, \"bsp/stm32/libraries/STM32[!F]*\":true, \"bsp/stm32/libraries/STM32F[!1]*\":true, \"bsp/stm32/libraries/templates/stm32[!f]*\":true, \"bsp/stm32/libraries/templates/stm32f[!1]*\":true, }, \"search.exclude\": { \"**/bsp/^(stm32)/**\": true, \"bsp/[!s]*\": true, \"bsp/s[!t]*\": true, \"bsp/st[!m]*\": true, \"bsp/stm[!3]*\": true, \"bsp/stm3[!2]*\": true, \"bsp/stm32/stm32[!f]*\": true, \"bsp/stm32/stm32f[!1]*\": true, \"bsp/stm32/stm32f10[!3]*\": true, \"bsp/stm32/stm32f103-[!b]*\": true, \"bsp/stm32/libraries/STM32[!F]*\":true, \"bsp/stm32/libraries/STM32F[!1]*\":true, \"bsp/stm32/libraries/templates/stm32[!f]*\":true, \"bsp/stm32/libraries/templates/stm32f[!1]*\":true, }, } 看起来有点蠢，这是因为vscode目前不支持正则的写法Github的讨论 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:2:3","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#vscode项目搭建"},{"categories":["Tech"],"content":" MobaXterm与msh配置msh会被系统自动执行，但是由于优先级的问题我们应该在main函数做延时处理，防止饿死其他线程 cpp int main(void) { //SEGGER_SYSVIEW_Start(); /* set LED0 pin mode to output */ rt_pin_mode(LED0_PIN, PIN_MODE_OUTPUT); //demo_init(); rt_kprintf(\"hello world\\n\"); while (1) { rt_thread_mdelay(10); } } 接下来我们配置MobaXterm，我们新建会话，类型选择串口。在端口上面我们可以打开设备管理器查看com号也可以根据提示直接进行选择，波特率选择115200 2024-06-24_11-24 至此软件部分设置完毕 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:2:4","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#mobaxterm与msh配置"},{"categories":["Tech"],"content":" 硬件接线首先将jtag接口连接到转接板上，按照最小系统板的原理图将转接板的3.3v，gnd，nrst，tdi，tdo，tms，tck，vref引脚连接到最小系统板上，其中vref是转接板的参考电压引脚，应该与最小系统板的正极并联。连接完成后我们就可以安装jlink驱动程序并烧写程序进板子了，我们也可以使用keil进行jlink的debug。但之前我们必须设置debug选项： 首先选择jlink(注意这里的Driver DLL和Dialog DLL选项及其参数，当修改芯片型号时需要进行修改) 2024-06-24_10-46 而后选择端口为sw(gpt也不知道为什么不使用jtag调试而使用sw) 2024-06-24_10-49 别忘了使能trace 2024-06-24_11-00 下载运行 2024-06-24_11-02 这样keil和调试器我们就设置好了，接下来我们设置串口 rtt可以通过menuconfig配置对应的串口，具体配置路径如图。rtt默认的串口为uart1，在江科大的板子上对应的是pa9，pa10引脚，因此我们的硬件串口连线应该连接在pa9，pa10上，这样我们才能通过串口使用msh进行调试 2024-06-28_13-53 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:3:0","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#硬件接线"},{"categories":["Tech"],"content":" 实验过程","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:4:0","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#实验过程"},{"categories":["Tech"],"content":" 串口实验按照串口官方文档编写程序，需要注意我们使用的是串口1，而官方文档为串口2，我们需要修改代码。除此之外，由于官方例程只能输出固定字符串，我们可以在官方文档上进行改进，添加shell-like serial的功能，这个功能可以使我们像shell一样将从串口发送的信息回显到MobaXterm上 改进后的例程： c #include \u003crtthread.h\u003e #define SAMPLE_UART_NAME \"uart1\" /* 串口设备名称 */ /* 串口接收消息结构*/ struct rx_msg { rt_device_t dev; rt_size_t size; }; /* 串口设备句柄 */ static rt_device_t serial; /* 消息队列控制块 */ static struct rt_messagequeue rx_mq; /* 接收数据回调函数 */ static rt_err_t uart_input(rt_device_t dev, rt_size_t size) { struct rx_msg msg; rt_err_t result; msg.dev = dev; msg.size = size; result = rt_mq_send(\u0026rx_mq, \u0026msg, sizeof(msg)); if ( result == -RT_EFULL) { /* 消息队列满 */ rt_kprintf(\"message queue full！\\n\"); } return result; } static void serial_thread_entry(void *parameter) { struct rx_msg msg; rt_err_t result; rt_uint32_t rx_length = 0; static char rx_buffer[RT_SERIAL_RB_BUFSZ + 1]; char input; while(1) { result = rt_mq_recv(\u0026rx_mq, \u0026msg, sizeof(msg), RT_WAITING_FOREVER); if(result \u003c 0) { rt_kprintf(\"mq recv err\\n\"); } rt_device_read(msg.dev, 0, \u0026input, 1); rx_buffer[rx_length++] = input; rt_kprintf(\"input: %c\\n\",input); /* 以回车为缓冲区输出标志 */ if(input == '\\r') { /* 通过串口设备 serial 输出读取到的消息 */ rt_size_t size = rt_device_write(msg.dev, 0, rx_buffer, sizeof(rx_buffer)); if(size != sizeof(rx_buffer)) { rt_kprintf(\"write err\\n\"); } /* 打印数据 */ rt_kprintf(\"rx_buffer: %s\\n\", rx_buffer); /* 重置初始量 */ rx_length = 0; rt_memset((void*)rx_buffer, 0, sizeof(rx_buffer)); } } } static int uart_dma_sample(int argc, char *argv[]) { rt_err_t ret = RT_EOK; char uart_name[RT_NAME_MAX]; static char msg_pool[256]; char str[] = \"hello RT-Thread!\\r\\n\"; if (argc == 2) { rt_strncpy(uart_name, argv[1], RT_NAME_MAX); } else { rt_strncpy(uart_name, SAMPLE_UART_NAME, RT_NAME_MAX); } /* 查找串口设备 */ serial = rt_device_find(uart_name); if (!serial) { rt_kprintf(\"find %s failed!\\n\", uart_name); return RT_ERROR; } /* 初始化消息队列 */ rt_mq_init(\u0026rx_mq, \"rx_mq\", msg_pool, /* 存放消息的缓冲区 */ sizeof(struct rx_msg), /* 一条消息的最大长度 */ sizeof(msg_pool), /* 存放消息的缓冲区大小 */ RT_IPC_FLAG_FIFO); /* 如果有多个线程等待，按照先来先得到的方法分配消息 */ /* 以 DMA 接收及轮询发送方式打开串口设备 */ rt_device_open(serial, RT_DEVICE_FLAG_DMA_RX); /* 设置接收回调函数 */ rt_device_set_rx_indicate(serial, uart_input); /* 发送字符串 */ rt_device_write(serial, 0, str, (sizeof(str) - 1)); /* 创建 serial 线程 */ rt_thread_t thread = rt_thread_create(\"serial\", serial_thread_entry, RT_NULL, 1024, 25, 10); /* 创建成功则启动线程 */ if (thread != RT_NULL) { rt_thread_startup(thread); } else { ret = RT_ERROR; } return ret; } /* 导出到 msh 命令列表中 */ MSH_CMD_EXPORT(uart_dma_sample, uart device dma sample); 遇到的问题： hardfault 在serial_thread_entry中定义了rt_uint32_t rx_length = 0;，如果仅仅是声明而不初始化rt_uint32_t rx_length;就会导致编译器不会初始化为0，从而在rx_buffer[rx_length++] = input;处访问非法地址，这对于没有mmu的单片机来说是致命的，最终很可能导致hardfault 键盘输入无反应，直至message queue full！错误产生 在serial_thread_entry中有while(1)循环，当去掉循环结构且不改变内部代码时会产生这个错误。这是由于即使我们有信号量或消息邮箱，但如果我们没有存活的线程OS也不会将休眠的线程唤醒。解决的办法是使用while(1)死循环用来保活，这样才能正常的被调度器调度和中断唤醒 获取信号量失败或其他内核对象失败 可能是子函数占据内存太多把父函数爆栈了，需要在父函数申请一个更大的堆栈空间 遇到的问题如果将rt_uint32_t rx_length = 0;改写为rt_uint32_t rx_length;，则会导致下面printf访问非法的内存地址，这在103上会导致总线错误 2024-07-13_13-10 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:4:1","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#串口实验"},{"categories":["Tech"],"content":" 串口实验按照串口官方文档编写程序，需要注意我们使用的是串口1，而官方文档为串口2，我们需要修改代码。除此之外，由于官方例程只能输出固定字符串，我们可以在官方文档上进行改进，添加shell-like serial的功能，这个功能可以使我们像shell一样将从串口发送的信息回显到MobaXterm上 改进后的例程： c #include #define SAMPLE_UART_NAME \"uart1\" /* 串口设备名称 */ /* 串口接收消息结构*/ struct rx_msg { rt_device_t dev; rt_size_t size; }; /* 串口设备句柄 */ static rt_device_t serial; /* 消息队列控制块 */ static struct rt_messagequeue rx_mq; /* 接收数据回调函数 */ static rt_err_t uart_input(rt_device_t dev, rt_size_t size) { struct rx_msg msg; rt_err_t result; msg.dev = dev; msg.size = size; result = rt_mq_send(\u0026rx_mq, \u0026msg, sizeof(msg)); if ( result == -RT_EFULL) { /* 消息队列满 */ rt_kprintf(\"message queue full！\\n\"); } return result; } static void serial_thread_entry(void *parameter) { struct rx_msg msg; rt_err_t result; rt_uint32_t rx_length = 0; static char rx_buffer[RT_SERIAL_RB_BUFSZ + 1]; char input; while(1) { result = rt_mq_recv(\u0026rx_mq, \u0026msg, sizeof(msg), RT_WAITING_FOREVER); if(result \u003c 0) { rt_kprintf(\"mq recv err\\n\"); } rt_device_read(msg.dev, 0, \u0026input, 1); rx_buffer[rx_length++] = input; rt_kprintf(\"input: %c\\n\",input); /* 以回车为缓冲区输出标志 */ if(input == '\\r') { /* 通过串口设备 serial 输出读取到的消息 */ rt_size_t size = rt_device_write(msg.dev, 0, rx_buffer, sizeof(rx_buffer)); if(size != sizeof(rx_buffer)) { rt_kprintf(\"write err\\n\"); } /* 打印数据 */ rt_kprintf(\"rx_buffer: %s\\n\", rx_buffer); /* 重置初始量 */ rx_length = 0; rt_memset((void*)rx_buffer, 0, sizeof(rx_buffer)); } } } static int uart_dma_sample(int argc, char *argv[]) { rt_err_t ret = RT_EOK; char uart_name[RT_NAME_MAX]; static char msg_pool[256]; char str[] = \"hello RT-Thread!\\r\\n\"; if (argc == 2) { rt_strncpy(uart_name, argv[1], RT_NAME_MAX); } else { rt_strncpy(uart_name, SAMPLE_UART_NAME, RT_NAME_MAX); } /* 查找串口设备 */ serial = rt_device_find(uart_name); if (!serial) { rt_kprintf(\"find %s failed!\\n\", uart_name); return RT_ERROR; } /* 初始化消息队列 */ rt_mq_init(\u0026rx_mq, \"rx_mq\", msg_pool, /* 存放消息的缓冲区 */ sizeof(struct rx_msg), /* 一条消息的最大长度 */ sizeof(msg_pool), /* 存放消息的缓冲区大小 */ RT_IPC_FLAG_FIFO); /* 如果有多个线程等待，按照先来先得到的方法分配消息 */ /* 以 DMA 接收及轮询发送方式打开串口设备 */ rt_device_open(serial, RT_DEVICE_FLAG_DMA_RX); /* 设置接收回调函数 */ rt_device_set_rx_indicate(serial, uart_input); /* 发送字符串 */ rt_device_write(serial, 0, str, (sizeof(str) - 1)); /* 创建 serial 线程 */ rt_thread_t thread = rt_thread_create(\"serial\", serial_thread_entry, RT_NULL, 1024, 25, 10); /* 创建成功则启动线程 */ if (thread != RT_NULL) { rt_thread_startup(thread); } else { ret = RT_ERROR; } return ret; } /* 导出到 msh 命令列表中 */ MSH_CMD_EXPORT(uart_dma_sample, uart device dma sample); 遇到的问题： hardfault 在serial_thread_entry中定义了rt_uint32_t rx_length = 0;，如果仅仅是声明而不初始化rt_uint32_t rx_length;就会导致编译器不会初始化为0，从而在rx_buffer[rx_length++] = input;处访问非法地址，这对于没有mmu的单片机来说是致命的，最终很可能导致hardfault 键盘输入无反应，直至message queue full！错误产生 在serial_thread_entry中有while(1)循环，当去掉循环结构且不改变内部代码时会产生这个错误。这是由于即使我们有信号量或消息邮箱，但如果我们没有存活的线程OS也不会将休眠的线程唤醒。解决的办法是使用while(1)死循环用来保活，这样才能正常的被调度器调度和中断唤醒 获取信号量失败或其他内核对象失败 可能是子函数占据内存太多把父函数爆栈了，需要在父函数申请一个更大的堆栈空间 遇到的问题如果将rt_uint32_t rx_length = 0;改写为rt_uint32_t rx_length;，则会导致下面printf访问非法的内存地址，这在103上会导致总线错误 2024-07-13_13-10 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:4:1","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#遇到的问题"},{"categories":["Tech"],"content":" spi实验 硬件连线我们使用w25q64来作为测试spi通信的硬件设备，同时也为搭建文件系统做准备 在这里我们使用103的spi1作为通信接口，因此根据引脚定义，我们需要将w25q64的各个引脚连接到103的pa4~pa7上 bsp制作由于rtt官方bsp给出的f103的bullpill板仅支持spi2，为了能够使用spi1接口我们需要修改bsp 首先下载安装STM32CubeMX，安装完毕后再下载对应的stm32f1系列的sdk 然后将stm提供的ioc文件(位于D:\\Programes\\RT-Thread\\rtt\\rt-thread\\bsp\\stm32\\stm32f103-blue-pill\\board\\CubeMX_Config\\CubeMX_Config.ioc)打开，并将原来复用为adc的pa4~pa7引脚复用为spi，注意不要将pa4设置为spi_nss，因为rtt会对此引脚进行软件控制，我们不需要复用此引脚 2024-07-10_10-04 2024-07-10_10-15 然后通过左侧面板选择复用的spi引脚的模式为全双工。因为rtt会对片选引脚进行软件设置，因此在下方的硬件片选引脚选择disable 2024-07-10_10-06 由于adc1和adc2桥接在不同频率的外设总线上，因此使用预分频的时候adc1选择4，adc2选择2 2024-07-10_10-08 我们也可以在当前栏内配置其他选项，当配置完成后点击generate code就可以生成bsp文件了 为了能够在menuconfig显示菜单项并修改外设配置 ，我们进入board/Kconfig文件，搜索到spi2后复制一份并将spi2替换为spi1，并修改menu项名称为spi1(我这里没修改就会导致出现两个一样的菜单项) 这时我们menuconfig就可以看到新的spi1设备了，使能新设备spi1后进入配置界面，打开dma功能 2024-07-10_10-17 至此，bsp制作完成，接下来进行menuconfig配置rtt组件 menuconfig配置如图所示，在menuconfig中打开spi总线驱动，启用万能 SPI Flash 驱动库serial flash universial driver(sfud)库来为格式化文件系统做准备 2024-07-10_14-51 其他选项如qspi模式，gpio模拟spi等是否启用根据需求来 配置完成后使用scons命令进行编译(或使用keil编译也可) 软件编写下列代码参考官方文档，注意修改参考代码中的spi设备号和总线号 c static void spi_w25q_sample(int argc, char *argv[]) { struct rt_spi_device *spi_dev_w25q; char name[RT_NAME_MAX]; rt_uint8_t w25x_read_id = 0x90; rt_uint8_t id[5] = {0}; if (argc == 2) { rt_strncpy(name, argv[1], RT_NAME_MAX); } else { rt_strncpy(name, W25Q_SPI_DEVICE_NAME, RT_NAME_MAX); } struct rt_spi_device *spi_device = RT_NULL; spi_device = (struct rt_spi_device *)rt_malloc(sizeof(struct rt_spi_device)); if(RT_NULL == spi_device) { LOG_E(\"Failed to malloc the spi device.\"); } /* 查找 spi 设备获取设备句柄 */ spi_dev_w25q = (struct rt_spi_device *)rt_device_find(name); if (!spi_dev_w25q) { rt_kprintf(\"spi sample run failed! can't find %s device!\\n\", name); } else { /* 方式1：使用 rt_spi_send_then_recv()发送命令读取ID */ rt_spi_send_then_recv(spi_dev_w25q, \u0026w25x_read_id, 1, id, 5); rt_kprintf(\"use rt_spi_send_then_recv() read w25q ID is:%x%x\\n\", id[0], id[1]); /* 方式2：使用 rt_spi_transfer_message()发送命令读取ID */ struct rt_spi_message msg1, msg2; msg1.send_buf = \u0026w25x_read_id; msg1.recv_buf = RT_NULL; msg1.length = 1; msg1.cs_take = 1; msg1.cs_release = 0; msg1.next = \u0026msg2; msg2.send_buf = RT_NULL; msg2.recv_buf = id; msg2.length = 5; msg2.cs_take = 0; msg2.cs_release = 1; msg2.next = RT_NULL; rt_spi_transfer_message(spi_dev_w25q, \u0026msg1); rt_kprintf(\"use rt_spi_transfer_message() read w25q ID is:%x%x\\n\", id[3], id[4]); } } /* 导出到 msh 命令列表中 */ MSH_CMD_EXPORT(spi_w25q_sample, spi w25q sample); 这里第一步应该是将spi设备绑定到spi总线上，但为了能够快速进行硬件初始化，所以将绑定代码放到主函数中 c rt_err_t err; err = rt_hw_spi_device_attach(\"spi1\", \"spi10\", GPIOA, GPIO_PIN_4); if(err != RT_EOK) { LOG_E(\"Failed to attach the spi device.\"); } 由于我已经打开了文件系统，这可能会对读写程序有影响，因此读到的数据是0，但是可以看到，系统已经识别了spi1，spi2两条总线，并且还探测到了spi10设备 2024-07-10_11-21 遇到的问题 spi找不到设备但能正常识别总线，产生assert failed at rt_hw_spi_device_attach错误 可能是设备绑定函数使用错误，使用rt_spi_bus_attach_device api和rt_hw_spi_device_attach api是不同的。两者形式如下 c rt_err_t rt_hw_spi_device_attach(const char *bus_name, const char *device_name, GPIO_TypeDef* cs_gpiox, uint16_t cs_gpio_pin); rt_err_t rt_spi_bus_attach_device(struct rt_spi_device *device, const char *name, const char *bus_name, void *user_data) 注意那个void *user_data，这个是用来传struct stm32_hw_spi_cs结构体的。这个结构体包含了端口组号(如GPIOA，GPIOB)和端口号(GPIO_PIN_4，GPIO_PIN_5等)，所以下面的api实际就是上面改进。对于rtt v5+来说，推荐使用rt_spi_bus_attach_device_cspin，这个api是对下面的api的进一步改进，它使用RT-Thread的PIN框架来绑定SPI的片选引脚，解决了不同bsp的上层应用对片选引脚操作不统一的问题 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:4:2","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#spi实验"},{"categories":["Tech"],"content":" spi实验 硬件连线我们使用w25q64来作为测试spi通信的硬件设备，同时也为搭建文件系统做准备 在这里我们使用103的spi1作为通信接口，因此根据引脚定义，我们需要将w25q64的各个引脚连接到103的pa4~pa7上 bsp制作由于rtt官方bsp给出的f103的bullpill板仅支持spi2，为了能够使用spi1接口我们需要修改bsp 首先下载安装STM32CubeMX，安装完毕后再下载对应的stm32f1系列的sdk 然后将stm提供的ioc文件(位于D:\\Programes\\RT-Thread\\rtt\\rt-thread\\bsp\\stm32\\stm32f103-blue-pill\\board\\CubeMX_Config\\CubeMX_Config.ioc)打开，并将原来复用为adc的pa4~pa7引脚复用为spi，注意不要将pa4设置为spi_nss，因为rtt会对此引脚进行软件控制，我们不需要复用此引脚 2024-07-10_10-04 2024-07-10_10-15 然后通过左侧面板选择复用的spi引脚的模式为全双工。因为rtt会对片选引脚进行软件设置，因此在下方的硬件片选引脚选择disable 2024-07-10_10-06 由于adc1和adc2桥接在不同频率的外设总线上，因此使用预分频的时候adc1选择4，adc2选择2 2024-07-10_10-08 我们也可以在当前栏内配置其他选项，当配置完成后点击generate code就可以生成bsp文件了 为了能够在menuconfig显示菜单项并修改外设配置 ，我们进入board/Kconfig文件，搜索到spi2后复制一份并将spi2替换为spi1，并修改menu项名称为spi1(我这里没修改就会导致出现两个一样的菜单项) 这时我们menuconfig就可以看到新的spi1设备了，使能新设备spi1后进入配置界面，打开dma功能 2024-07-10_10-17 至此，bsp制作完成，接下来进行menuconfig配置rtt组件 menuconfig配置如图所示，在menuconfig中打开spi总线驱动，启用万能 SPI Flash 驱动库serial flash universial driver(sfud)库来为格式化文件系统做准备 2024-07-10_14-51 其他选项如qspi模式，gpio模拟spi等是否启用根据需求来 配置完成后使用scons命令进行编译(或使用keil编译也可) 软件编写下列代码参考官方文档，注意修改参考代码中的spi设备号和总线号 c static void spi_w25q_sample(int argc, char *argv[]) { struct rt_spi_device *spi_dev_w25q; char name[RT_NAME_MAX]; rt_uint8_t w25x_read_id = 0x90; rt_uint8_t id[5] = {0}; if (argc == 2) { rt_strncpy(name, argv[1], RT_NAME_MAX); } else { rt_strncpy(name, W25Q_SPI_DEVICE_NAME, RT_NAME_MAX); } struct rt_spi_device *spi_device = RT_NULL; spi_device = (struct rt_spi_device *)rt_malloc(sizeof(struct rt_spi_device)); if(RT_NULL == spi_device) { LOG_E(\"Failed to malloc the spi device.\"); } /* 查找 spi 设备获取设备句柄 */ spi_dev_w25q = (struct rt_spi_device *)rt_device_find(name); if (!spi_dev_w25q) { rt_kprintf(\"spi sample run failed! can't find %s device!\\n\", name); } else { /* 方式1：使用 rt_spi_send_then_recv()发送命令读取ID */ rt_spi_send_then_recv(spi_dev_w25q, \u0026w25x_read_id, 1, id, 5); rt_kprintf(\"use rt_spi_send_then_recv() read w25q ID is:%x%x\\n\", id[0], id[1]); /* 方式2：使用 rt_spi_transfer_message()发送命令读取ID */ struct rt_spi_message msg1, msg2; msg1.send_buf = \u0026w25x_read_id; msg1.recv_buf = RT_NULL; msg1.length = 1; msg1.cs_take = 1; msg1.cs_release = 0; msg1.next = \u0026msg2; msg2.send_buf = RT_NULL; msg2.recv_buf = id; msg2.length = 5; msg2.cs_take = 0; msg2.cs_release = 1; msg2.next = RT_NULL; rt_spi_transfer_message(spi_dev_w25q, \u0026msg1); rt_kprintf(\"use rt_spi_transfer_message() read w25q ID is:%x%x\\n\", id[3], id[4]); } } /* 导出到 msh 命令列表中 */ MSH_CMD_EXPORT(spi_w25q_sample, spi w25q sample); 这里第一步应该是将spi设备绑定到spi总线上，但为了能够快速进行硬件初始化，所以将绑定代码放到主函数中 c rt_err_t err; err = rt_hw_spi_device_attach(\"spi1\", \"spi10\", GPIOA, GPIO_PIN_4); if(err != RT_EOK) { LOG_E(\"Failed to attach the spi device.\"); } 由于我已经打开了文件系统，这可能会对读写程序有影响，因此读到的数据是0，但是可以看到，系统已经识别了spi1，spi2两条总线，并且还探测到了spi10设备 2024-07-10_11-21 遇到的问题 spi找不到设备但能正常识别总线，产生assert failed at rt_hw_spi_device_attach错误 可能是设备绑定函数使用错误，使用rt_spi_bus_attach_device api和rt_hw_spi_device_attach api是不同的。两者形式如下 c rt_err_t rt_hw_spi_device_attach(const char *bus_name, const char *device_name, GPIO_TypeDef* cs_gpiox, uint16_t cs_gpio_pin); rt_err_t rt_spi_bus_attach_device(struct rt_spi_device *device, const char *name, const char *bus_name, void *user_data) 注意那个void *user_data，这个是用来传struct stm32_hw_spi_cs结构体的。这个结构体包含了端口组号(如GPIOA，GPIOB)和端口号(GPIO_PIN_4，GPIO_PIN_5等)，所以下面的api实际就是上面改进。对于rtt v5+来说，推荐使用rt_spi_bus_attach_device_cspin，这个api是对下面的api的进一步改进，它使用RT-Thread的PIN框架来绑定SPI的片选引脚，解决了不同bsp的上层应用对片选引脚操作不统一的问题 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:4:2","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#硬件连线"},{"categories":["Tech"],"content":" spi实验 硬件连线我们使用w25q64来作为测试spi通信的硬件设备，同时也为搭建文件系统做准备 在这里我们使用103的spi1作为通信接口，因此根据引脚定义，我们需要将w25q64的各个引脚连接到103的pa4~pa7上 bsp制作由于rtt官方bsp给出的f103的bullpill板仅支持spi2，为了能够使用spi1接口我们需要修改bsp 首先下载安装STM32CubeMX，安装完毕后再下载对应的stm32f1系列的sdk 然后将stm提供的ioc文件(位于D:\\Programes\\RT-Thread\\rtt\\rt-thread\\bsp\\stm32\\stm32f103-blue-pill\\board\\CubeMX_Config\\CubeMX_Config.ioc)打开，并将原来复用为adc的pa4~pa7引脚复用为spi，注意不要将pa4设置为spi_nss，因为rtt会对此引脚进行软件控制，我们不需要复用此引脚 2024-07-10_10-04 2024-07-10_10-15 然后通过左侧面板选择复用的spi引脚的模式为全双工。因为rtt会对片选引脚进行软件设置，因此在下方的硬件片选引脚选择disable 2024-07-10_10-06 由于adc1和adc2桥接在不同频率的外设总线上，因此使用预分频的时候adc1选择4，adc2选择2 2024-07-10_10-08 我们也可以在当前栏内配置其他选项，当配置完成后点击generate code就可以生成bsp文件了 为了能够在menuconfig显示菜单项并修改外设配置 ，我们进入board/Kconfig文件，搜索到spi2后复制一份并将spi2替换为spi1，并修改menu项名称为spi1(我这里没修改就会导致出现两个一样的菜单项) 这时我们menuconfig就可以看到新的spi1设备了，使能新设备spi1后进入配置界面，打开dma功能 2024-07-10_10-17 至此，bsp制作完成，接下来进行menuconfig配置rtt组件 menuconfig配置如图所示，在menuconfig中打开spi总线驱动，启用万能 SPI Flash 驱动库serial flash universial driver(sfud)库来为格式化文件系统做准备 2024-07-10_14-51 其他选项如qspi模式，gpio模拟spi等是否启用根据需求来 配置完成后使用scons命令进行编译(或使用keil编译也可) 软件编写下列代码参考官方文档，注意修改参考代码中的spi设备号和总线号 c static void spi_w25q_sample(int argc, char *argv[]) { struct rt_spi_device *spi_dev_w25q; char name[RT_NAME_MAX]; rt_uint8_t w25x_read_id = 0x90; rt_uint8_t id[5] = {0}; if (argc == 2) { rt_strncpy(name, argv[1], RT_NAME_MAX); } else { rt_strncpy(name, W25Q_SPI_DEVICE_NAME, RT_NAME_MAX); } struct rt_spi_device *spi_device = RT_NULL; spi_device = (struct rt_spi_device *)rt_malloc(sizeof(struct rt_spi_device)); if(RT_NULL == spi_device) { LOG_E(\"Failed to malloc the spi device.\"); } /* 查找 spi 设备获取设备句柄 */ spi_dev_w25q = (struct rt_spi_device *)rt_device_find(name); if (!spi_dev_w25q) { rt_kprintf(\"spi sample run failed! can't find %s device!\\n\", name); } else { /* 方式1：使用 rt_spi_send_then_recv()发送命令读取ID */ rt_spi_send_then_recv(spi_dev_w25q, \u0026w25x_read_id, 1, id, 5); rt_kprintf(\"use rt_spi_send_then_recv() read w25q ID is:%x%x\\n\", id[0], id[1]); /* 方式2：使用 rt_spi_transfer_message()发送命令读取ID */ struct rt_spi_message msg1, msg2; msg1.send_buf = \u0026w25x_read_id; msg1.recv_buf = RT_NULL; msg1.length = 1; msg1.cs_take = 1; msg1.cs_release = 0; msg1.next = \u0026msg2; msg2.send_buf = RT_NULL; msg2.recv_buf = id; msg2.length = 5; msg2.cs_take = 0; msg2.cs_release = 1; msg2.next = RT_NULL; rt_spi_transfer_message(spi_dev_w25q, \u0026msg1); rt_kprintf(\"use rt_spi_transfer_message() read w25q ID is:%x%x\\n\", id[3], id[4]); } } /* 导出到 msh 命令列表中 */ MSH_CMD_EXPORT(spi_w25q_sample, spi w25q sample); 这里第一步应该是将spi设备绑定到spi总线上，但为了能够快速进行硬件初始化，所以将绑定代码放到主函数中 c rt_err_t err; err = rt_hw_spi_device_attach(\"spi1\", \"spi10\", GPIOA, GPIO_PIN_4); if(err != RT_EOK) { LOG_E(\"Failed to attach the spi device.\"); } 由于我已经打开了文件系统，这可能会对读写程序有影响，因此读到的数据是0，但是可以看到，系统已经识别了spi1，spi2两条总线，并且还探测到了spi10设备 2024-07-10_11-21 遇到的问题 spi找不到设备但能正常识别总线，产生assert failed at rt_hw_spi_device_attach错误 可能是设备绑定函数使用错误，使用rt_spi_bus_attach_device api和rt_hw_spi_device_attach api是不同的。两者形式如下 c rt_err_t rt_hw_spi_device_attach(const char *bus_name, const char *device_name, GPIO_TypeDef* cs_gpiox, uint16_t cs_gpio_pin); rt_err_t rt_spi_bus_attach_device(struct rt_spi_device *device, const char *name, const char *bus_name, void *user_data) 注意那个void *user_data，这个是用来传struct stm32_hw_spi_cs结构体的。这个结构体包含了端口组号(如GPIOA，GPIOB)和端口号(GPIO_PIN_4，GPIO_PIN_5等)，所以下面的api实际就是上面改进。对于rtt v5+来说，推荐使用rt_spi_bus_attach_device_cspin，这个api是对下面的api的进一步改进，它使用RT-Thread的PIN框架来绑定SPI的片选引脚，解决了不同bsp的上层应用对片选引脚操作不统一的问题 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:4:2","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#bsp制作"},{"categories":["Tech"],"content":" spi实验 硬件连线我们使用w25q64来作为测试spi通信的硬件设备，同时也为搭建文件系统做准备 在这里我们使用103的spi1作为通信接口，因此根据引脚定义，我们需要将w25q64的各个引脚连接到103的pa4~pa7上 bsp制作由于rtt官方bsp给出的f103的bullpill板仅支持spi2，为了能够使用spi1接口我们需要修改bsp 首先下载安装STM32CubeMX，安装完毕后再下载对应的stm32f1系列的sdk 然后将stm提供的ioc文件(位于D:\\Programes\\RT-Thread\\rtt\\rt-thread\\bsp\\stm32\\stm32f103-blue-pill\\board\\CubeMX_Config\\CubeMX_Config.ioc)打开，并将原来复用为adc的pa4~pa7引脚复用为spi，注意不要将pa4设置为spi_nss，因为rtt会对此引脚进行软件控制，我们不需要复用此引脚 2024-07-10_10-04 2024-07-10_10-15 然后通过左侧面板选择复用的spi引脚的模式为全双工。因为rtt会对片选引脚进行软件设置，因此在下方的硬件片选引脚选择disable 2024-07-10_10-06 由于adc1和adc2桥接在不同频率的外设总线上，因此使用预分频的时候adc1选择4，adc2选择2 2024-07-10_10-08 我们也可以在当前栏内配置其他选项，当配置完成后点击generate code就可以生成bsp文件了 为了能够在menuconfig显示菜单项并修改外设配置 ，我们进入board/Kconfig文件，搜索到spi2后复制一份并将spi2替换为spi1，并修改menu项名称为spi1(我这里没修改就会导致出现两个一样的菜单项) 这时我们menuconfig就可以看到新的spi1设备了，使能新设备spi1后进入配置界面，打开dma功能 2024-07-10_10-17 至此，bsp制作完成，接下来进行menuconfig配置rtt组件 menuconfig配置如图所示，在menuconfig中打开spi总线驱动，启用万能 SPI Flash 驱动库serial flash universial driver(sfud)库来为格式化文件系统做准备 2024-07-10_14-51 其他选项如qspi模式，gpio模拟spi等是否启用根据需求来 配置完成后使用scons命令进行编译(或使用keil编译也可) 软件编写下列代码参考官方文档，注意修改参考代码中的spi设备号和总线号 c static void spi_w25q_sample(int argc, char *argv[]) { struct rt_spi_device *spi_dev_w25q; char name[RT_NAME_MAX]; rt_uint8_t w25x_read_id = 0x90; rt_uint8_t id[5] = {0}; if (argc == 2) { rt_strncpy(name, argv[1], RT_NAME_MAX); } else { rt_strncpy(name, W25Q_SPI_DEVICE_NAME, RT_NAME_MAX); } struct rt_spi_device *spi_device = RT_NULL; spi_device = (struct rt_spi_device *)rt_malloc(sizeof(struct rt_spi_device)); if(RT_NULL == spi_device) { LOG_E(\"Failed to malloc the spi device.\"); } /* 查找 spi 设备获取设备句柄 */ spi_dev_w25q = (struct rt_spi_device *)rt_device_find(name); if (!spi_dev_w25q) { rt_kprintf(\"spi sample run failed! can't find %s device!\\n\", name); } else { /* 方式1：使用 rt_spi_send_then_recv()发送命令读取ID */ rt_spi_send_then_recv(spi_dev_w25q, \u0026w25x_read_id, 1, id, 5); rt_kprintf(\"use rt_spi_send_then_recv() read w25q ID is:%x%x\\n\", id[0], id[1]); /* 方式2：使用 rt_spi_transfer_message()发送命令读取ID */ struct rt_spi_message msg1, msg2; msg1.send_buf = \u0026w25x_read_id; msg1.recv_buf = RT_NULL; msg1.length = 1; msg1.cs_take = 1; msg1.cs_release = 0; msg1.next = \u0026msg2; msg2.send_buf = RT_NULL; msg2.recv_buf = id; msg2.length = 5; msg2.cs_take = 0; msg2.cs_release = 1; msg2.next = RT_NULL; rt_spi_transfer_message(spi_dev_w25q, \u0026msg1); rt_kprintf(\"use rt_spi_transfer_message() read w25q ID is:%x%x\\n\", id[3], id[4]); } } /* 导出到 msh 命令列表中 */ MSH_CMD_EXPORT(spi_w25q_sample, spi w25q sample); 这里第一步应该是将spi设备绑定到spi总线上，但为了能够快速进行硬件初始化，所以将绑定代码放到主函数中 c rt_err_t err; err = rt_hw_spi_device_attach(\"spi1\", \"spi10\", GPIOA, GPIO_PIN_4); if(err != RT_EOK) { LOG_E(\"Failed to attach the spi device.\"); } 由于我已经打开了文件系统，这可能会对读写程序有影响，因此读到的数据是0，但是可以看到，系统已经识别了spi1，spi2两条总线，并且还探测到了spi10设备 2024-07-10_11-21 遇到的问题 spi找不到设备但能正常识别总线，产生assert failed at rt_hw_spi_device_attach错误 可能是设备绑定函数使用错误，使用rt_spi_bus_attach_device api和rt_hw_spi_device_attach api是不同的。两者形式如下 c rt_err_t rt_hw_spi_device_attach(const char *bus_name, const char *device_name, GPIO_TypeDef* cs_gpiox, uint16_t cs_gpio_pin); rt_err_t rt_spi_bus_attach_device(struct rt_spi_device *device, const char *name, const char *bus_name, void *user_data) 注意那个void *user_data，这个是用来传struct stm32_hw_spi_cs结构体的。这个结构体包含了端口组号(如GPIOA，GPIOB)和端口号(GPIO_PIN_4，GPIO_PIN_5等)，所以下面的api实际就是上面改进。对于rtt v5+来说，推荐使用rt_spi_bus_attach_device_cspin，这个api是对下面的api的进一步改进，它使用RT-Thread的PIN框架来绑定SPI的片选引脚，解决了不同bsp的上层应用对片选引脚操作不统一的问题 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:4:2","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#menuconfig配置"},{"categories":["Tech"],"content":" spi实验 硬件连线我们使用w25q64来作为测试spi通信的硬件设备，同时也为搭建文件系统做准备 在这里我们使用103的spi1作为通信接口，因此根据引脚定义，我们需要将w25q64的各个引脚连接到103的pa4~pa7上 bsp制作由于rtt官方bsp给出的f103的bullpill板仅支持spi2，为了能够使用spi1接口我们需要修改bsp 首先下载安装STM32CubeMX，安装完毕后再下载对应的stm32f1系列的sdk 然后将stm提供的ioc文件(位于D:\\Programes\\RT-Thread\\rtt\\rt-thread\\bsp\\stm32\\stm32f103-blue-pill\\board\\CubeMX_Config\\CubeMX_Config.ioc)打开，并将原来复用为adc的pa4~pa7引脚复用为spi，注意不要将pa4设置为spi_nss，因为rtt会对此引脚进行软件控制，我们不需要复用此引脚 2024-07-10_10-04 2024-07-10_10-15 然后通过左侧面板选择复用的spi引脚的模式为全双工。因为rtt会对片选引脚进行软件设置，因此在下方的硬件片选引脚选择disable 2024-07-10_10-06 由于adc1和adc2桥接在不同频率的外设总线上，因此使用预分频的时候adc1选择4，adc2选择2 2024-07-10_10-08 我们也可以在当前栏内配置其他选项，当配置完成后点击generate code就可以生成bsp文件了 为了能够在menuconfig显示菜单项并修改外设配置 ，我们进入board/Kconfig文件，搜索到spi2后复制一份并将spi2替换为spi1，并修改menu项名称为spi1(我这里没修改就会导致出现两个一样的菜单项) 这时我们menuconfig就可以看到新的spi1设备了，使能新设备spi1后进入配置界面，打开dma功能 2024-07-10_10-17 至此，bsp制作完成，接下来进行menuconfig配置rtt组件 menuconfig配置如图所示，在menuconfig中打开spi总线驱动，启用万能 SPI Flash 驱动库serial flash universial driver(sfud)库来为格式化文件系统做准备 2024-07-10_14-51 其他选项如qspi模式，gpio模拟spi等是否启用根据需求来 配置完成后使用scons命令进行编译(或使用keil编译也可) 软件编写下列代码参考官方文档，注意修改参考代码中的spi设备号和总线号 c static void spi_w25q_sample(int argc, char *argv[]) { struct rt_spi_device *spi_dev_w25q; char name[RT_NAME_MAX]; rt_uint8_t w25x_read_id = 0x90; rt_uint8_t id[5] = {0}; if (argc == 2) { rt_strncpy(name, argv[1], RT_NAME_MAX); } else { rt_strncpy(name, W25Q_SPI_DEVICE_NAME, RT_NAME_MAX); } struct rt_spi_device *spi_device = RT_NULL; spi_device = (struct rt_spi_device *)rt_malloc(sizeof(struct rt_spi_device)); if(RT_NULL == spi_device) { LOG_E(\"Failed to malloc the spi device.\"); } /* 查找 spi 设备获取设备句柄 */ spi_dev_w25q = (struct rt_spi_device *)rt_device_find(name); if (!spi_dev_w25q) { rt_kprintf(\"spi sample run failed! can't find %s device!\\n\", name); } else { /* 方式1：使用 rt_spi_send_then_recv()发送命令读取ID */ rt_spi_send_then_recv(spi_dev_w25q, \u0026w25x_read_id, 1, id, 5); rt_kprintf(\"use rt_spi_send_then_recv() read w25q ID is:%x%x\\n\", id[0], id[1]); /* 方式2：使用 rt_spi_transfer_message()发送命令读取ID */ struct rt_spi_message msg1, msg2; msg1.send_buf = \u0026w25x_read_id; msg1.recv_buf = RT_NULL; msg1.length = 1; msg1.cs_take = 1; msg1.cs_release = 0; msg1.next = \u0026msg2; msg2.send_buf = RT_NULL; msg2.recv_buf = id; msg2.length = 5; msg2.cs_take = 0; msg2.cs_release = 1; msg2.next = RT_NULL; rt_spi_transfer_message(spi_dev_w25q, \u0026msg1); rt_kprintf(\"use rt_spi_transfer_message() read w25q ID is:%x%x\\n\", id[3], id[4]); } } /* 导出到 msh 命令列表中 */ MSH_CMD_EXPORT(spi_w25q_sample, spi w25q sample); 这里第一步应该是将spi设备绑定到spi总线上，但为了能够快速进行硬件初始化，所以将绑定代码放到主函数中 c rt_err_t err; err = rt_hw_spi_device_attach(\"spi1\", \"spi10\", GPIOA, GPIO_PIN_4); if(err != RT_EOK) { LOG_E(\"Failed to attach the spi device.\"); } 由于我已经打开了文件系统，这可能会对读写程序有影响，因此读到的数据是0，但是可以看到，系统已经识别了spi1，spi2两条总线，并且还探测到了spi10设备 2024-07-10_11-21 遇到的问题 spi找不到设备但能正常识别总线，产生assert failed at rt_hw_spi_device_attach错误 可能是设备绑定函数使用错误，使用rt_spi_bus_attach_device api和rt_hw_spi_device_attach api是不同的。两者形式如下 c rt_err_t rt_hw_spi_device_attach(const char *bus_name, const char *device_name, GPIO_TypeDef* cs_gpiox, uint16_t cs_gpio_pin); rt_err_t rt_spi_bus_attach_device(struct rt_spi_device *device, const char *name, const char *bus_name, void *user_data) 注意那个void *user_data，这个是用来传struct stm32_hw_spi_cs结构体的。这个结构体包含了端口组号(如GPIOA，GPIOB)和端口号(GPIO_PIN_4，GPIO_PIN_5等)，所以下面的api实际就是上面改进。对于rtt v5+来说，推荐使用rt_spi_bus_attach_device_cspin，这个api是对下面的api的进一步改进，它使用RT-Thread的PIN框架来绑定SPI的片选引脚，解决了不同bsp的上层应用对片选引脚操作不统一的问题 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:4:2","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#软件编写"},{"categories":["Tech"],"content":" spi实验 硬件连线我们使用w25q64来作为测试spi通信的硬件设备，同时也为搭建文件系统做准备 在这里我们使用103的spi1作为通信接口，因此根据引脚定义，我们需要将w25q64的各个引脚连接到103的pa4~pa7上 bsp制作由于rtt官方bsp给出的f103的bullpill板仅支持spi2，为了能够使用spi1接口我们需要修改bsp 首先下载安装STM32CubeMX，安装完毕后再下载对应的stm32f1系列的sdk 然后将stm提供的ioc文件(位于D:\\Programes\\RT-Thread\\rtt\\rt-thread\\bsp\\stm32\\stm32f103-blue-pill\\board\\CubeMX_Config\\CubeMX_Config.ioc)打开，并将原来复用为adc的pa4~pa7引脚复用为spi，注意不要将pa4设置为spi_nss，因为rtt会对此引脚进行软件控制，我们不需要复用此引脚 2024-07-10_10-04 2024-07-10_10-15 然后通过左侧面板选择复用的spi引脚的模式为全双工。因为rtt会对片选引脚进行软件设置，因此在下方的硬件片选引脚选择disable 2024-07-10_10-06 由于adc1和adc2桥接在不同频率的外设总线上，因此使用预分频的时候adc1选择4，adc2选择2 2024-07-10_10-08 我们也可以在当前栏内配置其他选项，当配置完成后点击generate code就可以生成bsp文件了 为了能够在menuconfig显示菜单项并修改外设配置 ，我们进入board/Kconfig文件，搜索到spi2后复制一份并将spi2替换为spi1，并修改menu项名称为spi1(我这里没修改就会导致出现两个一样的菜单项) 这时我们menuconfig就可以看到新的spi1设备了，使能新设备spi1后进入配置界面，打开dma功能 2024-07-10_10-17 至此，bsp制作完成，接下来进行menuconfig配置rtt组件 menuconfig配置如图所示，在menuconfig中打开spi总线驱动，启用万能 SPI Flash 驱动库serial flash universial driver(sfud)库来为格式化文件系统做准备 2024-07-10_14-51 其他选项如qspi模式，gpio模拟spi等是否启用根据需求来 配置完成后使用scons命令进行编译(或使用keil编译也可) 软件编写下列代码参考官方文档，注意修改参考代码中的spi设备号和总线号 c static void spi_w25q_sample(int argc, char *argv[]) { struct rt_spi_device *spi_dev_w25q; char name[RT_NAME_MAX]; rt_uint8_t w25x_read_id = 0x90; rt_uint8_t id[5] = {0}; if (argc == 2) { rt_strncpy(name, argv[1], RT_NAME_MAX); } else { rt_strncpy(name, W25Q_SPI_DEVICE_NAME, RT_NAME_MAX); } struct rt_spi_device *spi_device = RT_NULL; spi_device = (struct rt_spi_device *)rt_malloc(sizeof(struct rt_spi_device)); if(RT_NULL == spi_device) { LOG_E(\"Failed to malloc the spi device.\"); } /* 查找 spi 设备获取设备句柄 */ spi_dev_w25q = (struct rt_spi_device *)rt_device_find(name); if (!spi_dev_w25q) { rt_kprintf(\"spi sample run failed! can't find %s device!\\n\", name); } else { /* 方式1：使用 rt_spi_send_then_recv()发送命令读取ID */ rt_spi_send_then_recv(spi_dev_w25q, \u0026w25x_read_id, 1, id, 5); rt_kprintf(\"use rt_spi_send_then_recv() read w25q ID is:%x%x\\n\", id[0], id[1]); /* 方式2：使用 rt_spi_transfer_message()发送命令读取ID */ struct rt_spi_message msg1, msg2; msg1.send_buf = \u0026w25x_read_id; msg1.recv_buf = RT_NULL; msg1.length = 1; msg1.cs_take = 1; msg1.cs_release = 0; msg1.next = \u0026msg2; msg2.send_buf = RT_NULL; msg2.recv_buf = id; msg2.length = 5; msg2.cs_take = 0; msg2.cs_release = 1; msg2.next = RT_NULL; rt_spi_transfer_message(spi_dev_w25q, \u0026msg1); rt_kprintf(\"use rt_spi_transfer_message() read w25q ID is:%x%x\\n\", id[3], id[4]); } } /* 导出到 msh 命令列表中 */ MSH_CMD_EXPORT(spi_w25q_sample, spi w25q sample); 这里第一步应该是将spi设备绑定到spi总线上，但为了能够快速进行硬件初始化，所以将绑定代码放到主函数中 c rt_err_t err; err = rt_hw_spi_device_attach(\"spi1\", \"spi10\", GPIOA, GPIO_PIN_4); if(err != RT_EOK) { LOG_E(\"Failed to attach the spi device.\"); } 由于我已经打开了文件系统，这可能会对读写程序有影响，因此读到的数据是0，但是可以看到，系统已经识别了spi1，spi2两条总线，并且还探测到了spi10设备 2024-07-10_11-21 遇到的问题 spi找不到设备但能正常识别总线，产生assert failed at rt_hw_spi_device_attach错误 可能是设备绑定函数使用错误，使用rt_spi_bus_attach_device api和rt_hw_spi_device_attach api是不同的。两者形式如下 c rt_err_t rt_hw_spi_device_attach(const char *bus_name, const char *device_name, GPIO_TypeDef* cs_gpiox, uint16_t cs_gpio_pin); rt_err_t rt_spi_bus_attach_device(struct rt_spi_device *device, const char *name, const char *bus_name, void *user_data) 注意那个void *user_data，这个是用来传struct stm32_hw_spi_cs结构体的。这个结构体包含了端口组号(如GPIOA，GPIOB)和端口号(GPIO_PIN_4，GPIO_PIN_5等)，所以下面的api实际就是上面改进。对于rtt v5+来说，推荐使用rt_spi_bus_attach_device_cspin，这个api是对下面的api的进一步改进，它使用RT-Thread的PIN框架来绑定SPI的片选引脚，解决了不同bsp的上层应用对片选引脚操作不统一的问题 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:4:2","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#遇到的问题-1"},{"categories":["Tech"],"content":" 文件系统实验对于stm32f103c8t6而言，使用文件系统会导致内存不足，这是因为rtt会malloc一个FATFS对象，这个操作会申请4k左右大小的空间，而这对于20k sram的103而言是捉襟见肘的 spi实验完成后f103就可以与w25q64芯片进行通讯了，为了能够创建块设备，我们还需要在代码中加入如下代码 c static int rt_hw_spi_flash_with_sfud_init(void) { if (RT_NULL == rt_sfud_flash_probe(\"W25Q64\", \"spi10\")) { return RT_ERROR; }; return RT_EOK; } INIT_COMPONENT_EXPORT(rt_hw_spi_flash_with_sfud_init) 最后一行表示将函数导出为组件，其内部实现是将代码放进rtt规定的段内在系统开机初始化的时候调用，详解见CSDN。因此如果block_device的启动位于spi驱动之前就会导致不能创建块设备，对于这种情况我们有两种解决办法： 要么根据官方文档-启动流程将主函数中的rt_hw_spi_device_attach函数使用INIT_DEVICE_EXPORT()宏导出，这样可以将spi设备启动顺序提前 要么在主函数中手动调用rt_hw_spi_flash_with_sfud_init函数，这样可以将块设备启动顺序滞后 这样我们就可以看到块设备了 2024-07-10_15-11 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:4:3","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#文件系统实验"},{"categories":["Tech"],"content":" CmBacktrace移植在前面的实验中我们发现排查问题时会很困难，例如hardfault。当程序问题产生的时候，最重要的就是定位问题，对于这种情况我们通常的解决办法是使用keil的单步调试一步步看，有经验的工程师还会使用反编译的文件+寄存器现场来定位问题。但上面两种办法效率太低，因此我们使用CmBacktrace工具来定位问题 CmBacktrace的原理就是栈回溯，所以这跟有经验的工程师所有的寄存器和反编译文件方法没有本质区别 组件移植过程非常简单，我们只需要进入 RT-Thread online packages -\u003e tools packages，使能CmBacktrace套件并配置相关项即可。注意退出时不要忘记pkgs --update 遇到的问题 编译阶段找不到CmBacktrace的头文件，如果包含CmBacktrace的头文件就会导致CmBacktrace头文件的内容与之前已经包含头文件的内容产生冲突 造成这个原因的是keil工程并没有包含所需的头文件 ，因此需要在工程里给定相关头文件的路径 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:4:4","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#cmbacktrace移植"},{"categories":["Tech"],"content":" CmBacktrace移植在前面的实验中我们发现排查问题时会很困难，例如hardfault。当程序问题产生的时候，最重要的就是定位问题，对于这种情况我们通常的解决办法是使用keil的单步调试一步步看，有经验的工程师还会使用反编译的文件+寄存器现场来定位问题。但上面两种办法效率太低，因此我们使用CmBacktrace工具来定位问题 CmBacktrace的原理就是栈回溯，所以这跟有经验的工程师所有的寄存器和反编译文件方法没有本质区别 组件移植过程非常简单，我们只需要进入 RT-Thread online packages -\u003e tools packages，使能CmBacktrace套件并配置相关项即可。注意退出时不要忘记pkgs --update 遇到的问题 编译阶段找不到CmBacktrace的头文件，如果包含CmBacktrace的头文件就会导致CmBacktrace头文件的内容与之前已经包含头文件的内容产生冲突 造成这个原因的是keil工程并没有包含所需的头文件 ，因此需要在工程里给定相关头文件的路径 ","date":"2024-06-17","objectID":"/posts/rtthread-platform-construction-experiment/:4:4","series":null,"tags":["Tech","RT-Thread"],"title":"RT-Thread平台搭建实验","uri":"/posts/rtthread-platform-construction-experiment/#遇到的问题-2"},{"categories":["Tech"],"content":"本文从OSI网络模型出发介绍计算机网络，并涉及多种有关计算机网络的应用。需要注意的是本文有较为浓厚的学术界气息，对于具体的协议使用本文不阐述 ","date":"2024-04-22","objectID":"/posts/computer-network/:0:0","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#"},{"categories":["Tech"],"content":" 计算机网络","date":"2024-04-22","objectID":"/posts/computer-network/:0:0","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#计算机网络"},{"categories":["Tech"],"content":" 分组交换与线路交换线路交换：早期通信设备所采用的方式，该方法通过时分，频分等手段将一条宽带分成若干个通讯链路从而使多个设备同时且独享的通信，这种通讯方式适合电话或者早期互联网 随着互联网的发展设备数爆炸式增长，暴露了线路交换允许同时通信的设备数少的缺点。即当双方通信时，虽然会进行频分或者时分，但是这会占用双方通信时经过的所有路由 分组交换：双方通信时，会在通信的每个路由上开一个buffer来缓存数据，并用两路由之间全部带宽来传输数据。这样就解决了线路交换的缺点。分时交换只会占用传输数据时彼此相邻的两个路由，当buffer里的数据传送完毕后发送方会释放资源。分组交换虽然有这种好处，但这是以延时和丢包为代价的，因为这种传输本身就会增加延时，并且当多个主机同时经过相同路由时就会因为传输队列被填满导致丢包 ","date":"2024-04-22","objectID":"/posts/computer-network/:1:0","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#分组交换与线路交换"},{"categories":["Tech"],"content":" 接入互联网","date":"2024-04-22","objectID":"/posts/computer-network/:2:0","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#接入互联网"},{"categories":["Tech"],"content":" 无线方式接入wlans：常用于建筑物内，代表：wifi 广域无线接入：任何有基站信号的范围，代表：4G ","date":"2024-04-22","objectID":"/posts/computer-network/:2:1","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#无线方式接入"},{"categories":["Tech"],"content":" 协议层次对于不同的TCP应用(如webnet，ftp，telnet)，他们是通过socket接口来下发报文至TCP的 对于链路层设备(交换机)，他是把源主机发来的数据解封装2次到链路层后获得链路层的信息来进行转发的。而对于网络层设备(路由器)，是把源主机发来的数据解封装3次到网络层后获得网络层的信息来进行转发的。对于目标主机，他是解封装5次从而获得数据 ","date":"2024-04-22","objectID":"/posts/computer-network/:3:0","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#协议层次"},{"categories":["Tech"],"content":" 应用层","date":"2024-04-22","objectID":"/posts/computer-network/:4:0","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#应用层"},{"categories":["Tech"],"content":" socket套接字socket的优点在于它通过ip地址，端口号等信息统一向OS注册了一个整数，使得每次发报文时不需要重复指定ip地址，端口号等信息。这简化了传输信息的步骤，并且便于OS管理。更重要的是有了socket之后我们就可以进行多进程操作了，这在网络服务器中被称为多路复用，由于可能有多个客户端对服务器同时发起请求，因此有必要让一个端口支持多个客户端会话，那么怎么区分这些会话从而让信息发送到指定应用和客户端呢？那就是通过socket值的不同来判断，因为ocket是根据源ip和端口号不同而不同的 对于使用TCP传输层协议的应用而言，我们可以指定本机ip及端口号，目的ip及端口号，也可以仅指定目的ip及端口号，而对于使用UDP传输层协议的应用而言，我们只需要指定目的ip及端口号就够了。因为现代的操作系统会将本地ip及端口号隐藏在socket操作中，所以无论是TCP还是UDP，仅需要指定目的ip及端口号就足够 TCP以及UDP都是明文传输的，为了改进TCP的安全性，SSL协议提供了加密的TCP连接。对于SSL，现阶段并没有明确究竟是属于应用层还是传输层，但是它的层次依然是高于TCP的，采用了SSL的http服务被称为https ","date":"2024-04-22","objectID":"/posts/computer-network/:4:1","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#socket套接字"},{"categories":["Tech"],"content":" httphttp：超文本传输协议 使用TCP协议不会区分报文的界限，这件事是由应用层来做的，所以应用层的http会区分 http协议本身是无状态的，这意味着他不会存储客户端状态，例如某用户的历史记录，用户信息等数据。但是我们可以通过加入cookie这种补丁来解决这个问题。无状态的优点是操作简单方便，同一链路容纳的用户数量大 cookie是一个存储登陆信息的内容，客户端首次访问服务器时服务器会在内部分配一个cookie并发给客户端，等客户端需要再次登陆时只需要把cookie发送给服务器即可，此时服务器会将客户端发来的cookie与内部的数据库进行比对从而确定是哪个用户发来的请求 当链路的流量强度很大时可以通过在本地建立缓存服务器来缓解，根据二八定律和局部性原理，大部分流量被本地缓存服务器处理，少部分通过Internet被源服务器处理。这种方法会减少带宽的成本 ","date":"2024-04-22","objectID":"/posts/computer-network/:4:2","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#http"},{"categories":["Tech"],"content":" ftpftp适用于客户端服务器模式的文件传输 ftp：根据TCP协议与服务器21号端口建立连接，采用明文传输，因此会暴露用户名和密码。在21号端口建立的是控制连接，用于发送命令。真正的数据传送是由ftp服务器向客户端发起的，服务器会向客户端20号端口建立连接从而传输文件 ","date":"2024-04-22","objectID":"/posts/computer-network/:4:3","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#ftp"},{"categories":["Tech"],"content":" email用户代理软件：email客户端软件(outlook)是email应用的用户代理，http客户端软件(firefox)是web应用的用户代理，ftp客户端软件(filezilla)是ftp应用的用户代理。我们是通过客户端软件(用户代理)来跟服务器打交道的，不是直接跟服务器打交道的 email使用SMTP协议通过25号端口上传邮件到服务器，之后邮件服务器会进行同步 email使用POP或者IMAP协议进行邮件的下载，IMAP协议有更多的功能，例如允许用户在服务器组织邮箱目录 ","date":"2024-04-22","objectID":"/posts/computer-network/:4:4","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#email"},{"categories":["Tech"],"content":" dns TTL：缓存时间，当本地dns没有记录某个ip与域名的对应关系时，本地dns会向权威名字服务器进行查询，查询到结果后会缓存在本地并保留一段时间，当超过这个时间后没有再次查询的请求，本地dns就会把这条记录删除。这是为了保证一致性并节省空间 ","date":"2024-04-22","objectID":"/posts/computer-network/:4:5","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#dns"},{"categories":["Tech"],"content":" p2p非结构化的p2p：不指定p2p网络结构是什么样子的，例如环状，星状网络等 一般而言，非结构化p2p网络网络分为集中化目录式，完全分布式以及混合式 集中化目录式：有一台服务器维护资源表，这个表可以提供资源与对应peer的关系，想要请求资源时必须查询这个表，迅雷属于这种 完全分布式：所有资源完全分布在用户手中，用户申请资源时需要对邻居节点进行泛洪操作从而遍历整个p2p网络。值得注意的是用户获得最早的邻居节点来源于下载软件时软件自带的经常活跃的peer的ip地址，因此这种方法有一定的不可靠性，同时由于进行泛洪操作也会对网络造成压力 混合式：上述两种方法的混合，peer加入某一个用户组组成的洪流中，bt属于这种 bittorrent：为了提高上传用户保种的积极性，bt应运而生。用户想要获得资源时需要到p2p搜索引擎上找到对应资源，资源内部有tracker文件。如果用户获得了tracker文件就会知道都有哪些peer维护这个文件，这样我们就可以下载这个文件了。当下载时文件会被分成很多文件块，并生成文件位图来表示当前peer是否持有文件块，这些文件块会从那些你曾经给予他们文件支持的那些peer中优先得到，这基于一种算法：上传者会将流量分为三份，前两份来给予曾经帮助过他的peer，最后一份用来随机给陌生用户，这样不仅保证了用户忠诚还有拉新作用。那些在线且文件完整的节点被称为torrent(种子)，否则被称为吸血鬼 ","date":"2024-04-22","objectID":"/posts/computer-network/:4:6","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#p2p"},{"categories":["Tech"],"content":" cdncdn是将内容存储在离用户较近的服务器，这不仅降低延迟提高了用户舒适度而且还减轻了源服务器压力 当用户请求音视频资源时，用户主机会向dns进行请求，而后dns会返回一个cdn的dns的ip，我们用户再解析这个cdn的dns的ip就会得到具体的cdn的ip，这里面就有我们申请的资源。cdn的dns主要起一个重定向的作用，这也是为了负载均衡和优化考虑 ","date":"2024-04-22","objectID":"/posts/computer-network/:4:7","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#cdn"},{"categories":["Tech"],"content":" 传输层ip(网络层)提供的服务是不可靠的，因此需要tcp/udp(传输层)来提供可靠的传输 ","date":"2024-04-22","objectID":"/posts/computer-network/:5:0","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#传输层"},{"categories":["Tech"],"content":" tcp 三次握手与四次挥手建立连接时仅仅两次握手(建立请求-应答回复)是不够的，因为握手时有可能由于延时过大导致客户端重发建立请求，这样后发的请求可能被建立连接，而最初的请求延时一段时间后才进入服务器，这会导致最初的请求产生了一条没有被服务器应答的半连接，长此以往就会耗干服务器资源。这样我们就需要双方均发出两次建立请求，即：客户端建立请求-\u003e服务器端应答回复-\u003e服务器端建立请求-\u003e客户端应答回复。这样线路中延时过大造成服务器延时收到客户端的请求时，服务器通过检查三次握手的同步码就可以丢弃延时的请求(为延时请求从40开始并且已经发送了20，延时的请求从80开始，这样尽管请求都是从同一台机器上发出的，但由于tcp发送数据的一方必定是顺序发送，通过同步码即可丢弃半连接)。双方在发出请求时发出的是随机的同步码(避免预测攻击)，同步码的作用是告知对方哪个数据传输有误从而方便重传，例如92.8的同步码代表92号到99号的字节都已经接收到了，发送方需要从第100个字节处开始传。而在建立请求的第二步和第三步可以统一用一条报文发出，这样就演变成了现在的的三次挥手 断开连接时的操作也类似建立连接，那为什么断开连接就需要四次挥手呢？这是因为在接受来自客户端断开连接请求时的报文上面常常载有数据，服务器端需要对这些数据进行处理，这一过程是耗时的，假如服务器真的想合并第二步第三步使其变成三次挥手，这就可能导致客户端没有收到服务器的ack从而重发连接断开请求。因此断开连接常常需要四次挥手。而建立连接时没有数据解析的需求，我们就可以将服务器端的应答回复和建立请求统一成一步 流量控制当网络拥堵时可以通过协议内部报文标志位从而使网络核心层的路由和边缘层的主机进行通信，路由器进行置位标志位时意味着网络有些拥堵，此时会使边缘层的主机发送速率减半从而防止网络拥堵，这样就进行了流量控制。当网络拥堵时丢包率和延迟也会增加，上述操作不仅减少了网络拥堵同时也改善了丢包率和延迟，这也进行了延时控制 上面操作的缺点：路由向主机发送报文时耗费资源且也容易丢包，这在网络拥堵时也会加重拥堵。因此我们应该从边缘侧来推测网络是否拥堵从而解决这个缺点。我们通常根据下述情况来判断是否网络拥堵： 客户端收到服务端3次重发的ack：这可能是网络拥挤造成的，也可能是服务器端缓冲区不足从而进行流量控制造成的，此时触发客户端流控 客户端发出的数据包超时(未收到ACK回应)：这很有可能是网络拥挤造成的，此时也触发客户端流控 ","date":"2024-04-22","objectID":"/posts/computer-network/:5:1","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#tcp"},{"categories":["Tech"],"content":" tcp 三次握手与四次挥手建立连接时仅仅两次握手(建立请求-应答回复)是不够的，因为握手时有可能由于延时过大导致客户端重发建立请求，这样后发的请求可能被建立连接，而最初的请求延时一段时间后才进入服务器，这会导致最初的请求产生了一条没有被服务器应答的半连接，长此以往就会耗干服务器资源。这样我们就需要双方均发出两次建立请求，即：客户端建立请求-\u003e服务器端应答回复-\u003e服务器端建立请求-\u003e客户端应答回复。这样线路中延时过大造成服务器延时收到客户端的请求时，服务器通过检查三次握手的同步码就可以丢弃延时的请求(为延时请求从40开始并且已经发送了20，延时的请求从80开始，这样尽管请求都是从同一台机器上发出的，但由于tcp发送数据的一方必定是顺序发送，通过同步码即可丢弃半连接)。双方在发出请求时发出的是随机的同步码(避免预测攻击)，同步码的作用是告知对方哪个数据传输有误从而方便重传，例如92.8的同步码代表92号到99号的字节都已经接收到了，发送方需要从第100个字节处开始传。而在建立请求的第二步和第三步可以统一用一条报文发出，这样就演变成了现在的的三次挥手 断开连接时的操作也类似建立连接，那为什么断开连接就需要四次挥手呢？这是因为在接受来自客户端断开连接请求时的报文上面常常载有数据，服务器端需要对这些数据进行处理，这一过程是耗时的，假如服务器真的想合并第二步第三步使其变成三次挥手，这就可能导致客户端没有收到服务器的ack从而重发连接断开请求。因此断开连接常常需要四次挥手。而建立连接时没有数据解析的需求，我们就可以将服务器端的应答回复和建立请求统一成一步 流量控制当网络拥堵时可以通过协议内部报文标志位从而使网络核心层的路由和边缘层的主机进行通信，路由器进行置位标志位时意味着网络有些拥堵，此时会使边缘层的主机发送速率减半从而防止网络拥堵，这样就进行了流量控制。当网络拥堵时丢包率和延迟也会增加，上述操作不仅减少了网络拥堵同时也改善了丢包率和延迟，这也进行了延时控制 上面操作的缺点：路由向主机发送报文时耗费资源且也容易丢包，这在网络拥堵时也会加重拥堵。因此我们应该从边缘侧来推测网络是否拥堵从而解决这个缺点。我们通常根据下述情况来判断是否网络拥堵： 客户端收到服务端3次重发的ack：这可能是网络拥挤造成的，也可能是服务器端缓冲区不足从而进行流量控制造成的，此时触发客户端流控 客户端发出的数据包超时(未收到ACK回应)：这很有可能是网络拥挤造成的，此时也触发客户端流控 ","date":"2024-04-22","objectID":"/posts/computer-network/:5:1","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#三次握手与四次挥手"},{"categories":["Tech"],"content":" tcp 三次握手与四次挥手建立连接时仅仅两次握手(建立请求-应答回复)是不够的，因为握手时有可能由于延时过大导致客户端重发建立请求，这样后发的请求可能被建立连接，而最初的请求延时一段时间后才进入服务器，这会导致最初的请求产生了一条没有被服务器应答的半连接，长此以往就会耗干服务器资源。这样我们就需要双方均发出两次建立请求，即：客户端建立请求-\u003e服务器端应答回复-\u003e服务器端建立请求-\u003e客户端应答回复。这样线路中延时过大造成服务器延时收到客户端的请求时，服务器通过检查三次握手的同步码就可以丢弃延时的请求(为延时请求从40开始并且已经发送了20，延时的请求从80开始，这样尽管请求都是从同一台机器上发出的，但由于tcp发送数据的一方必定是顺序发送，通过同步码即可丢弃半连接)。双方在发出请求时发出的是随机的同步码(避免预测攻击)，同步码的作用是告知对方哪个数据传输有误从而方便重传，例如92.8的同步码代表92号到99号的字节都已经接收到了，发送方需要从第100个字节处开始传。而在建立请求的第二步和第三步可以统一用一条报文发出，这样就演变成了现在的的三次挥手 断开连接时的操作也类似建立连接，那为什么断开连接就需要四次挥手呢？这是因为在接受来自客户端断开连接请求时的报文上面常常载有数据，服务器端需要对这些数据进行处理，这一过程是耗时的，假如服务器真的想合并第二步第三步使其变成三次挥手，这就可能导致客户端没有收到服务器的ack从而重发连接断开请求。因此断开连接常常需要四次挥手。而建立连接时没有数据解析的需求，我们就可以将服务器端的应答回复和建立请求统一成一步 流量控制当网络拥堵时可以通过协议内部报文标志位从而使网络核心层的路由和边缘层的主机进行通信，路由器进行置位标志位时意味着网络有些拥堵，此时会使边缘层的主机发送速率减半从而防止网络拥堵，这样就进行了流量控制。当网络拥堵时丢包率和延迟也会增加，上述操作不仅减少了网络拥堵同时也改善了丢包率和延迟，这也进行了延时控制 上面操作的缺点：路由向主机发送报文时耗费资源且也容易丢包，这在网络拥堵时也会加重拥堵。因此我们应该从边缘侧来推测网络是否拥堵从而解决这个缺点。我们通常根据下述情况来判断是否网络拥堵： 客户端收到服务端3次重发的ack：这可能是网络拥挤造成的，也可能是服务器端缓冲区不足从而进行流量控制造成的，此时触发客户端流控 客户端发出的数据包超时(未收到ACK回应)：这很有可能是网络拥挤造成的，此时也触发客户端流控 ","date":"2024-04-22","objectID":"/posts/computer-network/:5:1","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#流量控制"},{"categories":["Tech"],"content":" 网络层路由位于网络层，决定数据报怎么转发，即通过路由表计算来算出具体的路由 交换机位于数据链路层，只是进行单纯的数据转发，通过路由器算出的路由来进行转发 网络层还可以对数据报进行许多动作：泛洪，block，转发路径，修改某些字段，这些特性仅在sdn(软件定义网络)转发方式中才支持，对于传统方式则不支持 ","date":"2024-04-22","objectID":"/posts/computer-network/:6:0","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#网络层"},{"categories":["Tech"],"content":" ip 在子网内部，只有纯交换机的连接而没有路由器的连接，而互联网是以子网为单位而进行的路由表计算，因此信息到达目标子网后再进行该网络下子网的路由表计算从而找到子网的子网，这样就可以遍历整个互联网了。由于计算路由表时是按ip地址进行匹配的，一般而言同一个区域的ip地址前若干位大致相同，我们可以通过这一特性将其他区域的ip地址划分到有相同前缀ip的路由表下，这样我们就会加快查找效率。这种技术我们称为路由聚集 特殊约定：0.0.0.0的地址代指本主机地址，255.255.255.255的地址代表广播地址，127.x.x.x代表回路地址，代表本主机，访问该地址不会经过物理网卡，因此该地址常用于本机上的软件通信，192.168.x.x代表内网地址 子网掩码为了方便路由器获得主机号和网络号从而做路由运算，ip地址按照一定格式被分为A类，B类，C类地址，A类指的类似255.x.x.x的地址，其子网可容纳6m个主机，B类地址指的是类似255.255.x.x的地址，其子网可容纳65534个设备，C类地址类似，但只能容纳254个设备。如果按子网主机数量来看，大部分厂商需要设备数量处于数百到数千的范围，这样按类划分网络就失去意义了。为了解决这个问题，我们采用了无类地址的方法：设计一个子网掩码，使得路由器再进行路由运算之前先做子网掩码的与运算，从而获得对应的网络号和主机号。这样就可以通过网络号做路由运算找到相应子网，通过主机号在子网中找到对应主机，在表示中有如下例子：200.235.21.15/23，代表前23位是网络号，后9位是主机号，该网络可以容纳512个主机 ","date":"2024-04-22","objectID":"/posts/computer-network/:6:1","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#ip"},{"categories":["Tech"],"content":" ip 在子网内部，只有纯交换机的连接而没有路由器的连接，而互联网是以子网为单位而进行的路由表计算，因此信息到达目标子网后再进行该网络下子网的路由表计算从而找到子网的子网，这样就可以遍历整个互联网了。由于计算路由表时是按ip地址进行匹配的，一般而言同一个区域的ip地址前若干位大致相同，我们可以通过这一特性将其他区域的ip地址划分到有相同前缀ip的路由表下，这样我们就会加快查找效率。这种技术我们称为路由聚集 特殊约定：0.0.0.0的地址代指本主机地址，255.255.255.255的地址代表广播地址，127.x.x.x代表回路地址，代表本主机，访问该地址不会经过物理网卡，因此该地址常用于本机上的软件通信，192.168.x.x代表内网地址 子网掩码为了方便路由器获得主机号和网络号从而做路由运算，ip地址按照一定格式被分为A类，B类，C类地址，A类指的类似255.x.x.x的地址，其子网可容纳6m个主机，B类地址指的是类似255.255.x.x的地址，其子网可容纳65534个设备，C类地址类似，但只能容纳254个设备。如果按子网主机数量来看，大部分厂商需要设备数量处于数百到数千的范围，这样按类划分网络就失去意义了。为了解决这个问题，我们采用了无类地址的方法：设计一个子网掩码，使得路由器再进行路由运算之前先做子网掩码的与运算，从而获得对应的网络号和主机号。这样就可以通过网络号做路由运算找到相应子网，通过主机号在子网中找到对应主机，在表示中有如下例子：200.235.21.15/23，代表前23位是网络号，后9位是主机号，该网络可以容纳512个主机 ","date":"2024-04-22","objectID":"/posts/computer-network/:6:1","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#子网掩码"},{"categories":["Tech"],"content":" natnat(网络地址转换)：通过路由器来软件模拟一个新的端口号，从而解决ip地址不足的问题。当内网设备向外网服务器发出请求时，路由器会根据内网设备的内网ip和端口号来生成一个新的端口号并记录在路由表中，发送的时候需要将内网ip转换到外网ip，端口号更改为生成的端口号。这样当外部的资源返回时就可以根据这个路由表来找到真实的内网主机ip和端口号了 ","date":"2024-04-22","objectID":"/posts/computer-network/:6:2","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#nat"},{"categories":["Tech"],"content":" 隧道技术ipv6的产生解决了ipv4地址不足的问题，但是同时也带来了兼容性的问题。我们可以在ipv6网络边缘层的网关处设置ipv4/v6双栈协议来解决这个问题，具体原理是在网关路由器处将ipv6的信息二次打包为ipv4的信息，这样我们可以将ipv6的报文在ipv4的网络中传输到另一处ipv6的子网内部。这种技术在ipv4的内部构成了像隧道一样结构，因此我们称这种技术为隧道技术 ","date":"2024-04-22","objectID":"/posts/computer-network/:6:3","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#隧道技术"},{"categories":["Tech"],"content":" sdnsdn的具体模型是：有一个中央服务器跑一个网络操作系统，当需要改变网络功能或者对网络进行其他操作时网络操作系统会自动进行路由表计算并部署到分组交换机(一种集合了路由器和交换机功能的设备)中，这样我们就可以通过集中式部署而对网络进行自定义的改造了，改造后的网络在收发数据时不需要中央服务器和网络操作系统的介入，这时报文路由完全靠分组交换机实现 使用sdn后不仅可以大大提高网络弹性，而且isp只需要购买分组交换机这一种设备就可以了，不需要之前的路由器和交换机 ","date":"2024-04-22","objectID":"/posts/computer-network/:6:4","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#sdn"},{"categories":["Tech"],"content":" 路由与路由协议早期路由通过内存来收发信息，现在的路由通过CPU总线结构来收发信息，这样带宽会更大(30Gbps+)，足以满足企业需求 路由协议主要采用BGP协议，其分为外部协议eBGP和内部协议iBGP。外部协议注重策略，内部协议注重性能，例如外部协议以国家，公司为单位，因此需要考虑经济，政治上的原因。内部协议类似内网，由于多个路由器需要内部协议维护，因此更需要考虑效率。由于采用了网络层次和路由聚集，因此我们可以很轻松的找到对应主机。当一个新的主机上线时，我们需要通过当前子网的网关来通告其他的网关，其他的网关再依次算出路由表并且通知内部的子路由，这样一个网络就建立起来了 ","date":"2024-04-22","objectID":"/posts/computer-network/:7:0","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#路由与路由协议"},{"categories":["Tech"],"content":" 链路层计算机广域网采用点对点连接，这是出于物理上的成本考虑的(中美海底电缆之间并没有连接其他任何国家)。而对局域网来说采用多点连接，这样可以保证效率。但是局域网采用多点连接的同时也会引入一个问题：两个主机同时请求造成冲突怎么办，这种冲突我们称为多点访问冲突 链路层传输报文的单位是帧，传输的时候需要加上mac地址，交换机是按照mac地址工作的 链路层服务：流量控制，纠错码，错误检测，全双工半双工 CRC：循环冗余校验码，用来校验信息是否出错 交换机或者路由一般不组成环状结构，因为这会引发广播风暴，但是为了防止链路出现问题(光缆被挖断)，我们需要冗余一条链路以组成环状。这根线路平时不使用，仅在特殊情况下使用，这样既避免了广播风暴问题又解决了线路损坏的问题 数据在子网中传输时需要用到链路层的技术，如arp(存储ip地址，mac地址与端口的表)，交换机等，数据在子网间传输的时候需要用到网络层的技术(ip，路由器等) ","date":"2024-04-22","objectID":"/posts/computer-network/:8:0","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#链路层"},{"categories":["Tech"],"content":" CSMA/CA(以太网技术)ap：无线接入点，一般为路由器或基站 当两个无线设备同时对同一个ap点发送信号时就会叠加电磁波引发冲突，因为ap无法判断这是一个设备发过来的还是多个设备发过来的信号。我们还可以通过无线设备上的电磁波传感器就可以判断是否有其他设备发送无线信号，并以此作为冲突检测的工具 802.11(wlan)的CSMA/CA方法：当信道忙时，发送方等待信道空闲后给一个自减的随机值，等到随机值减到0时再次尝试发送。假如在随机值自减的过程中发送方发现信道又忙，那就等待信道空闲时再次选一个随机值。对于接收方来说，当帧正确时会给一个ack CSMA/CA在高负载情况下会有效率低下的问题，但是这个问题可以引入交换机来解决(交换机可以只监听两个端口) ","date":"2024-04-22","objectID":"/posts/computer-network/:8:1","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#csmaca以太网技术"},{"categories":["Tech"],"content":" mac地址在节点和节点间的数据传递过程中交换机并不能识别ip地址，我们需要通过ip地址解析协议(arp协议)来知道下一跳的mac地址以及对应端口，这样交换机的网卡才知道如何发送数据给其他交换机或目标主机 mac地址由IEEE管理和分配，制造商购入mac地址空间来保证其唯一性 当路由器需要发数据给子网内部设备时，我们需要查询arp表。如果没有查到目标ip对应的mac地址和端口，路由器就会进行广播，对应的设备就会进行回应并把自己的mac地址和端口发送给路由器，之后路由器将这个mac地址加入arp表中缓存起来。当查询到mac地址时路由器会直接把数据发送出去，经过若干跳后到达目标主机 ","date":"2024-04-22","objectID":"/posts/computer-network/:8:2","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#mac地址"},{"categories":["Tech"],"content":" lan(以太网)总线型网络：类似于cpu总线，多个设备挂载到总线上，两端挂载吸收器，这样可以吸收反射的电磁波，防止CSMA/CA技术下设备回声。但是当总线某处出现破损时会造成信号回声，导致任何设备发送数据时都会发现总线忙 集线器(hub)：克服总线型网络的缺点，将总线长度大大缩减并放于金属制容器内(hub)，使得设备回声只发生在某个设备与集线器的线路上，不会影响整个总线从而利于排障。缺点是通信时类似广播，不能控制每个设备的端口单独发送数据，因此使用CSMA/CA技术后会导致高负载工况效率低下，因为每个端口相互影响，在高负载情况下端口只能等待其他端口发送完成才能使用总线，这样就不能进行总线的复用导致降低效率 交换机：克服集线器的缺点，允许两个端口相互通信而不受其他端口的影响，因此解决了使用CSMA/CA技术后会导致高负载效率低下的问题 以太网在传输信号前会发送一串101010的同步序列以同步双方设备的时钟频率，同步的过程是依靠锁相环来进行的 ","date":"2024-04-22","objectID":"/posts/computer-network/:8:3","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#lan以太网"},{"categories":["Tech"],"content":" 编码方式曼彻斯特编码将每一个比特位分为两个时间段（半个比特周期 + 半个比特周期）前一个时间段传输时钟，后一个时间段传输信号，并以电平翻转代表 0 和 1。该方法适合在传输速率小于10Mbps情况下使用，但是每1个比特需要传输2个状态变化，占带宽的2倍，因此不适合高速传输 4b5b编码适合传输速率小于100Mbps的情况下使用，它采用了用5位bit来代表4位bit的数据，通过把全为1和全为0这种信号剔除来保证传输任何信号时钟都不发生偏移，并且同时也很好的利用了带宽，传输4M数据仅需要5M的带宽 8b10b编码适合传输速率小于1000Mbps的情况下使用，尽管与4b5b有着一样的编码效率，但是8b10b的编码优势仍然更胜一筹，例如在高频信号方面，长时间发送1或发送0不仅会造成时钟信号偏移，还会引直流信号分量不均，后者会导致高频信号失真，而8b10b编码在编码规划上更平衡了1和0出现的概率，因此大大减少了直流分量对高频信号的影响。此外，8b10b有着更多的编码冗余，这在错误检测和额外的控制字符编码方面有着巨大优势，这也提高了传输速率 ","date":"2024-04-22","objectID":"/posts/computer-network/:8:4","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#编码方式"},{"categories":["Tech"],"content":" 网络安全证书可以视作公钥的包装，即将通信双方其中一方的信息(公钥，通信一方的信息等)通过ca的私钥签署了的文件 数字签名：通过散列函数(如哈希函数)生成一个128位bit大小的数据来代表原报文，这被称为报文摘要，再通过公钥来加密生成的数据，这个加密后的数据就是数字签名。这种签名不仅有加密的特征而且还代表原报文的所有信息，不仅具有安全性还具有完整性和不可抵赖性 报文摘要常用于长报文的传输，因为对于非对称加密而言加解密的资源消耗太大，我们可以先建立以非对称加密为基础的连接，然后将对称加密的密钥发给对方。这样不仅利用了非对称加密难以破解的优势还利用了对称加密消耗资源少的优点 怎样获得最初的公钥？对于非对称加密而言，例如md5，sha256等加密，在操作系统安装时就已经内置ca(证书颁发机构)的加密证书了，通过这个证书我们就可以获得ca的公钥，那么通信双方又是怎样获得公钥的？首先服务提供方先将自己注册给ca，也就是将公钥和其他信息发送给ca，ca使用私钥签署后将其发送给用户。由于用户在安装操作系统时已经安装了ca的公钥，因此我们可以通过ca的公钥来解出私钥所包含的服务提供方的信息，这样就可以获得服务提供方的公钥从而与其通信了。通过ca的方式可以有效避免中间人攻击 颁发证书的不仅是ca，也可以是其他的服务提供方。当然，与服务提供方通讯时首先要获得他的公钥，而这个公钥不仅可以来自ca也可以来自其他的通讯提供方。这样在互联网中就组成了一个庞大的信任链。有时我们获得证书可能来自于服务提供方本身，这时一般会让我们下载他的证书，常见于中国铁路订票 ","date":"2024-04-22","objectID":"/posts/computer-network/:9:0","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#网络安全"},{"categories":["Tech"],"content":" pgp加密pgp加密是流行的email加密格式，它综合了上面所提到的网络技术。当发送email时，发送方首先通过邮件内容和散列函数生成数据签名，之后再用自己的对称式钥加密数据签名并附在pgp协议的开头，而后使用非对称公钥加密对称式钥，最后发送给接收方 ","date":"2024-04-22","objectID":"/posts/computer-network/:9:1","series":null,"tags":["Tech","Network"],"title":"计算机网络","uri":"/posts/computer-network/#pgp加密"},{"categories":["Tech"],"content":"Linux高级驱动的粗浅介绍，包含PCIE，USB以及其他常用子系统 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:0:0","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#"},{"categories":["Tech"],"content":" Linux深入","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:0:0","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#linux深入"},{"categories":["Tech"],"content":" 内联汇编为了保证效率或者使用特殊指令(如原子操作)时需要使用汇编，使用方法是：单独将汇编代码放在.S文件中，在C程序中使用extern声明要引入的汇编函数之后就可以使用了 对于内联汇编需要使用__asm___关键字修饰函数 2024-02-13_12-19 %0，%1，%2分别代表sum，a，b。=r代表当前寄存器是存储结果用的，不要进行寄存器优化，防止结果不正确 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:1:0","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#内联汇编"},{"categories":["Tech"],"content":" 同步互斥的深入在单核CPU上关中断开中断是可以实现同步互斥的，但是在多核CPU上开关中断不能保证其他CPU不会修改临界变量 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:2:0","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#同步互斥的深入"},{"categories":["Tech"],"content":" 原子操作对于ARMv6之前的内核，通过关中断恢复中断来实现原子操作，但是在v6之后(包括v6)，由于arm支持SMP(多核CPU)，因此不能简单的使用开关中断来实现原子操作，而是使用ldrex，strex汇编语句来实现，其原理是在要ldr数据上打上标记，在要str的数据上消除标记，根据能否消除标记而返回不同的值，根据值来判断是否申请资源成功，不成功的话则再次重复，直到能申请资源为止 2024-02-13_15-41 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:2:1","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#原子操作"},{"categories":["Tech"],"content":" 锁","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:3:0","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#锁"},{"categories":["Tech"],"content":" 自旋锁自旋锁无法休眠，当一段临界区被加上自旋锁时，如果CPU0与CPU1都竞争临界区只有CPU0获得资源的话，那么CPU1不会休眠而是会反复请求资源(当写程序时，在进中断时也要加自旋锁来防止其他CPU打断当前CPU执行irq)，因此，使用自旋锁时临界区代码要尽量精简(5行左右)，且不能休眠 自旋锁在 单核系统(UP) 还可以用来禁止调度防止抢占，对于不同的自旋锁他有不同的防止抢占方式，比如对于最普通的spin_lock()而言，他只能关闭调度，而对于spin_lock_irq()而言，它可以关闭中断 自旋锁的实现：每个自旋锁上都有当前任务编号，和当前任务编号+1的下一个任务编号，内核会检查想要申请资源的自旋锁任务编号与当前自旋锁下一个任务编号是否相同，相同的话则获得锁，否则让这个任务wfe休眠一段时间。值得注意的是，申请当前任务编号这一过程也有可能发生竞态，为了保证编号与任务是一一对应的，这里应该使用原子变量 自旋锁的实现中，通常为每个锁维护两个变量：当前任务编号和下一个可被唤醒的任务编号。内核在判断某个任务是否可以获得锁时，会比较该任务的编号是否等于当前锁的“下一个任务编号”。若相同，任务即可获得锁；否则，它会进入 wfe（wait for event）状态等待一段时间后重试。在锁的控制方面，当一个任务想要获得锁时，内核会根据当前已经分发的编号的数量将下一个编号交给任务，任务会保存这个编号并会不停地检查内核中的下一个编号是否与手中的编号相同，如果相同就获得锁并进入临界区 值得注意的是，申请任务编号本身也可能存在并发竞争，因此内核必须使用原子操作来确保任务编号与具体任务的一一对应关系，从而避免竞态条件 警告 自旋锁不可递归，因为这可能会把自己死锁 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:3:1","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#自旋锁"},{"categories":["Tech"],"content":" 睡眠锁睡眠锁有mutex和semaphore两种 对于信号量来说，它可以休眠，因此对于临界区代码可以比自旋锁复杂很多，信号量用于多进程间访问同步和互斥，更多用于控制并发数量，而互斥锁用于保护某个临界资源 在信号量结构体中，需要用到自旋锁 semaphore的实现：semaphore结构体中有spinlock，还有个count和wait_list，count负责记录wait_list中任务的数量，有新任务申请信号量时count++，老任务归还信号量时count–。当使用spinlock_up获取semaphore时，首先需要获得spinlock，如果成功获得则需要让count++，如果失败的话让内核把该任务挂载到wait_list上并令其休眠，直到前方的任务都被执行完毕，内核会从wait_list唤醒该任务 mutex的实现：与semaphore类似，但是由于追求效率会更为复杂，里面配置了宏开关来优化效率，通过宏可以选择等待mutex的线程是否休眠(休眠开销太大)。当进入临界区获取资源时内核也可以自动判断使用fastpath还是slowpath fastpath与slowpath： 当一段临界区代码很短且需要mutex时，这时大概率会出现线程不需要等待而直接获取资源，并且解锁时也不需要唤醒其他线程，这种情况称为fastpath，而需要等待获取资源且需要唤醒其他线程称为slowpath，两个的选择取决于mutex结构体中的count(是个原子变量)，count值为1时表示unlocked，此时其他线程可以获得锁，count值为0时代表locked，需要解锁，但是当前执行任务的线程解锁后不需要唤醒其他任务此时为fastpath，当count值为-1时，代表当前任务解锁后还需要唤醒其他线程，这时是slowpath mutex的实现比semaphore更复杂，这是因为mutex追求更高的效率，在写驱动程序的时候尽量使用mutex ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:3:2","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#睡眠锁"},{"categories":["Tech"],"content":" USART访问虚拟终端中的前台终端：/dev/tty0 访问当前程序运行的终端(考虑真实的USART等终端)：/dev/tty (不会输出信息到其他tty) 例如echo \"hello\" \u003e /dev/tty0会始终打印hello到在前台终端，即使使用Ctrl+Alt+F16切换终端，打印也会出现在新切换的终端上。echo \"hello\" \u003e /dev/tty会始终打印hello到在执行命令的那个终端，使用Ctrl+Alt+F16切换终端，打印就会消失 在驱动模块崩溃时可以查看LR寄存器来找到崩溃的函数 当驱动程序错误时，可以使用strace -o log.txt ./exe可以在log.txt里获得系统调用 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:4:0","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#usart"},{"categories":["Tech"],"content":" printkprintk后面可以加上打印级别，如果不指定打印级别则会默认打印级别，当console设置的打印级别低于内核级别时则不会打印printk。如果想在多个控制台打印时，可以在设备树或者uboot指定console=tty0，console=tty1，但是只有最后指定的console会收到串口信息。实际上，uboot也是通过修改设备树来实现更改打印终端的 shell echo \"1 4 1 7\" \u003e /proc/sys/kernel/prink //可以修改打印级别，第一个1为console消息级别，4为默认级别 2024-02-14_21-24 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:4:1","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#printk"},{"categories":["Tech"],"content":" PCI与PCIe为了简化CPU与外部设备通信及硬件连线使得访问外设像访问内存一样，PCI总线应运而生。有了PCI后，CPU不必关注具体的操作细节，例如不使用PCI，CPU与GPIO，I2C等设备直接相连时，程序员需要关注GPIO，I2C等设备的具体实现，而使用PCI总线时，直接访问PCI设备控制器即可，具体访问操作会由PCI硬件实现，这同时也会简化硬件的连线复杂度 但是引入PCI总线也会导致设备地址空间分配问题，为了解决这个问题，PCI采用地址偏移量的思想：首先由CPU分配设备内存地址空间，并由PCI设备控制器维护并计算所需要的地址偏移量，待到CPU需要访问具体地址时，由PCI所记录的地址偏移量即可算出真实的物理地址，PCI地址数据线是复用的 为了保证传输速率，PCI一开始被设计为并行总线，但由于速率提高之后并行总线会导致信号干扰，因此新的PCIe总线也诞生了，它采用了串行总线差分信号的结构，这会支持更高的速率 在PCIe中，一对发送接收差分线称为lane，对于低速PCIe，例如PCIe转串口而言只有一条lane，对于视频音频卡而言有多条lane，两PCIe设备之间称为一条link ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:5:0","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#pci与pcie"},{"categories":["Tech"],"content":" PCI总线原理由于PCI总线为并行传输，数据地址统一不做区分的发送到AD引脚上 2024-02-18_23-30 对于非桥设备而言会PCI会发出type0信号以表示访问非桥设备 2024-02-18_23-34 如果想设置PCI设备的地址，首先要在IDSET引脚置高电平，然后由CPU发出cpuaddr，经PCI控制器转换后得到PCIaddr，再发送type1命令并根据type0的function number设置具体的功能，最后按照register number设置寄存器的值，具体的配置项如下图，此配置项写在PCI设备的寄存器内，包含了设备ID，厂家ID以及创建设备时申请多大的PCI空间 如果想读写PCI设备的地址，需要按照手册在C/BE引脚设置值，然后设置frame引脚，再发送type0命令，当frame引脚为低电平时遇到的第一个时钟发出的AD信号是addr，第二个发出的则是data 2024-02-18_23-33 2024-02-18_23-43 对于桥设备而言，如果需要配置PCI设备需要发送type1命令，若header type的值为01h则为桥设备，此时需要根据收到的信息检测bus number，如果在子节点找到bus number那么就转发到下一层PCI设备，如果下一层设备还是桥设备的话就继续转发，直到遇到非桥设备且是目标设备为止，然后根据发送的信息判断是配置还是读写寄存器 2024-02-18_23-48 2024-02-18_23-55 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:5:1","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#pci总线原理"},{"categories":["Tech"],"content":" PCIe总线原理PCIe的配置过程(基于ID的路由方式)： PCIe采用深度优先的配置模式，首先由Host将配置信号发送至子设备，首先由 A设备先进行配置，A设备的上层总线号是Bus0，下层总线号是Bus1，于是A设备在其配置寄存器内记录，由于子设备数sub并不确定，A设备先令其值为255。而后再配置A的子设备C，同理将其配置为1，2，255，之后再配置D，当配置到Bus3的下层的具体设备时，会将bus，dev，fuction的值3，0，1、3，0，0记录在设备中，由于遇到了end point，所以返回至D端口，修改sub将其从255修改至3(bus的最大值)，但由于只配置了D，因此还需要配置同层的E设备，配置方式同D下面的end point。之后返回至上层C，将sub值修改为4(C设备下总线号的最大值) 2024-02-19_15-12 PCIe将发送数据分为三层，分别为：事务层，数据链路层，物理层，每层将上下层数据处理后传递给下一层或者上一层，具体收发数据原理如下： 发送数据时： 首先由CPU发送原始数据至root complex，由rc处理数据后在事务层得到TLP 事务层将原始数据前加入header，数据后加入CRC校验，header内包含数据是读写数据还是配置寄存器，包装后的数据被称为TLP，处理后将数据发至数据链路层 数据链路层规定了数据的重传方式，为此在数据头部添加了seg段，在数据尾部添加了LCRC校验，数据处理完成后将数据发至物理层 物理层负责将信号拆分并发送出去 2024-02-19_15-11 PCIe三种路由方式上述的配置使用基于ID的路由方式，所谓路由，就是如何找到通讯另一方，隐式路由指的是地址和ID这种不单独声明，而是根据type确定通讯地址 物理层负责将信号接收并组合，而后发给数据链路层 接收方的数据链路层所做的与发送方相反，即去掉seg和LCRC，处理完毕后发送给事务层 同理，事务层将接收的数据，去掉CRC校验和header，从而获得原始的data 配置读、配置写：使用基于ID的路由，就是使用\u003cBus, Device, Function\u003e来寻找对方。配置成功后，每个PCIe设备都有自己的PCIe地址空间了。 内存读、内存写或者IO读、IO写： 发出报文给对方：使用基于地址的路由 对方返回数据或者返回状态时：使用基于ID的路由 各类消息，比如中断、广播等：使用隐式路由 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:5:2","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#pcie总线原理"},{"categories":["Tech"],"content":" PCIe总线原理PCIe的配置过程(基于ID的路由方式)： PCIe采用深度优先的配置模式，首先由Host将配置信号发送至子设备，首先由 A设备先进行配置，A设备的上层总线号是Bus0，下层总线号是Bus1，于是A设备在其配置寄存器内记录，由于子设备数sub并不确定，A设备先令其值为255。而后再配置A的子设备C，同理将其配置为1，2，255，之后再配置D，当配置到Bus3的下层的具体设备时，会将bus，dev，fuction的值3，0，1、3，0，0记录在设备中，由于遇到了end point，所以返回至D端口，修改sub将其从255修改至3(bus的最大值)，但由于只配置了D，因此还需要配置同层的E设备，配置方式同D下面的end point。之后返回至上层C，将sub值修改为4(C设备下总线号的最大值) 2024-02-19_15-12 PCIe将发送数据分为三层，分别为：事务层，数据链路层，物理层，每层将上下层数据处理后传递给下一层或者上一层，具体收发数据原理如下： 发送数据时： 首先由CPU发送原始数据至root complex，由rc处理数据后在事务层得到TLP 事务层将原始数据前加入header，数据后加入CRC校验，header内包含数据是读写数据还是配置寄存器，包装后的数据被称为TLP，处理后将数据发至数据链路层 数据链路层规定了数据的重传方式，为此在数据头部添加了seg段，在数据尾部添加了LCRC校验，数据处理完成后将数据发至物理层 物理层负责将信号拆分并发送出去 2024-02-19_15-11 PCIe三种路由方式上述的配置使用基于ID的路由方式，所谓路由，就是如何找到通讯另一方，隐式路由指的是地址和ID这种不单独声明，而是根据type确定通讯地址 物理层负责将信号接收并组合，而后发给数据链路层 接收方的数据链路层所做的与发送方相反，即去掉seg和LCRC，处理完毕后发送给事务层 同理，事务层将接收的数据，去掉CRC校验和header，从而获得原始的data 配置读、配置写：使用基于ID的路由，就是使用来寻找对方。配置成功后，每个PCIe设备都有自己的PCIe地址空间了。 内存读、内存写或者IO读、IO写： 发出报文给对方：使用基于地址的路由 对方返回数据或者返回状态时：使用基于ID的路由 各类消息，比如中断、广播等：使用隐式路由 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:5:2","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#pcie三种路由方式"},{"categories":["Tech"],"content":" PCIe驱动设备模型","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:5:3","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#pcie驱动设备模型"},{"categories":["Tech"],"content":" USB2.0 USB设备插到电脑上去，接触到的设备是什么？ 是USB Host hub，一个usb controller，管理所有的USB设备 既然还没有\"驱动程序\"，为何能知道是\"android phone\" 在电脑中USB总线协议驱动程序已经写好了，USB总线根据协议知道是\"android phone\" 为什么一接入USB设备，PC机就能发现它？ PC的USB控制器内有下拉电阻，USB设备通过引流5v电源在Data+/Data-引脚处产生上拉电阻，使得当USB插入主机时PC的USB控制器D+引脚有电压跳变，PC通过检测引脚的电压跳变来知道是否有设备连接 USB设备种类非常多，为什么一接入电脑，就能识别出来它的种类？ USB协议指定设备种类对应的描述符，通过描述符来知道设备的种类 PC机上接有非常多的USB设备，怎么分辨它们？ 根据分配的编号来分辨他们 USB设备刚接入PC时，还没有编号；那么PC怎么把\"分配的编号\"告诉它 刚接入的设备默认编号为0，通过此编号就可以与设备通信并分配新的编号 2024-02-19_21-59 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:6:0","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#usb20"},{"categories":["Tech"],"content":" 低速，全速与高速信号的识别对于USB2.0而言，支持了高速信号就不能支持低速信号，其设备速率识别方法如下 对于全速或低速设备而言，由于在Data+/Data-引脚处有个上拉电阻，因此PC可以通过检测Data +/Data-引脚的电平高低来检测支持的速率，如果Data+为高电平，那么支持全速速率，Data-为高电平，那么支持低速速率 对于高速设备而言，如果检测到设备支持全速速率，那么就断开上拉电阻并给设备发送一个SE0信号，如果设备支持高速模式，那么就会回应一个特殊信号，主机就知道了设备支持高速模式 工作在高速模式下的设备会断开Data的上拉电阻，这是为了保证高速传输数据时发生干扰，并且还需要在通信双方的D+/D-引脚串联一个45Ohm的电阻，如果不串联电阻，那么发送端的信号到达接收端就会反射，当下次发射信号时，上一次反射的信号会和这一次的信号叠加使信号失真，这种加电阻的方法就叫做阻抗匹配，我们检测高速设备是否断开连接时就是检测反射信号的强弱，当设备断开连接时，接收方相当于阻抗无穷大，会造成反射信号的增强。在开发中，如果发现设备总是断开连接也有可能是阻抗匹配没有做好 2024-02-19_23-11 USB协议通信数据如下 sop(start of package)，具体信号参见手册 eop(end of package)，具体信号参见手册 sync，同步信号，由于USB没有时钟线只有两条数据线，因此sync是为了确定通信速率的 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:6:1","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#低速全速与高速信号的识别"},{"categories":["Tech"],"content":" 数据传输特点在数据传输方面，USB采用了NRZI(Non Return Zero Inverted Code，反向不归零编码)，NRZI的编码方式为：对于数据0，波形翻转；对于数据1，波形不变。例如对01011110为例，传输的结果是11000001，使用NRZI可以发送一串0来把时钟频率告诉对方 位填充：由于USB没有时钟线，因此还需要考虑通信双方晶振的误差对信号的影响，例如当传输100个1时，由于晶振的误差会产生接收端接收了99个或101个1的现象，因此协议规定数据包每隔6个连续的1后插入1个0 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:6:2","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#数据传输特点"},{"categories":["Tech"],"content":" 协议内容一次传输由一个或多个事务实现，事务下层根据目的不同被划分成了三种包，令牌包指明传输的对象和地址，数据包只传输数据，握手包由接收方设备发出，内容为各种应答信号。每个包内部又分为各种域(field)，sop field代表传输的开始，sync field代表传输的速率，PID filed代表传输的包的ID，根据取值不同PID被分为四类，令牌类，数据类，握手类，特殊类，令牌类用于令牌包，表明发送的是令牌类数据。在PID field后的filed就是传输的数据，为了保证数据正确还需要CRC field，在传输的末尾还要加上eop field来表明传输完成 对于握手包而言没有Data field与CRC field 2024-02-20_10-22 USB设备种类繁多有不同要求，这些要求可以分为下列几种 批量传输：对实时性要求不高，但要求传输可靠，且传输的数据量很大，例如U盘 实时传输：对数据量要求不大，可靠性要求也不高，但实时性要求很高，例如摄像头 中断传输：对可靠性和实时性要求都很高：如鼠标 控制传输：对设备进行控制 对于批量传输而言，每次传输有三个阶段 对于中断传输而言，每次传输有三个阶段，但需要Host定期访问设备请求数据以保证实时性 对于实时传输而言，每次传输有两个阶段，去掉了握手包，类似UDP 注意中断传输，这里的中断传输与一般意义上的中断没有关系，因为USB协议要求Host拥有总线控制权，从设备不能主动访问Host，因此中断传输只能由主设备通过轮询来模拟 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:6:3","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#协议内容"},{"categories":["Tech"],"content":" 设备配置过程 得到设备描述符 设置非零的新地址 再次获得设备描述符 获得配置描述符，并同时获得接口描述符和端点描述符 设置配置 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:6:4","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#设备配置过程"},{"categories":["Tech"],"content":" OTGOTG(On To Go)，插上即用的缩写。OTG是USB2.0协议的补充，当设备使用OTG连接时，两方设备可以在不经过PC的情况下可以直接通信 OTG通过内部硬件的上拉电阻来识别Host/Device，Host通过ID引脚的取值决定是否向Device供电，供电引脚为VBUS 引脚名 作用 VBUS 作为Host时，对外供电 作为Device时，接收外部输入的电源 DM 数据信号 DP 数据信号 ID 分辨自己角色的引脚： 1：作为Device 0：作为Host GND 地线 当插入OTG接口时，id引脚(typec模式时为cc引脚)被连接，id引脚的取值被Host设备的主控芯片(arm)所决定，当arm板以Device模式通信时，由于arm芯片内部有100k的上拉电阻因此三极管是导通的，EN引脚为低电平，5v的电源不能输出，此时为Device模式。而当转换器接入板子时，转换器内部的下拉电阻会将arm的上拉电阻拉低，导致5v电源能够输出，此时arm板可以给外界设备供电，工作在Host模式 2024-02-20_16-43 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:6:5","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#otg"},{"categories":["Tech"],"content":" I2C深入对于通用的platform_device在i2c驱动模型中被称为i2c_client 2024-03-08_10-16 I2C驱动框架如图所示，在基础的设备总线驱动模型的基础上加入了adapter适配器，这可以使每一个I2C硬件设备支持不同的adapter使其产生不同的功能。具体的驱动编写框架如下： 修改设备树或者对应.c文件 调用i2c专用的register函数使其调用probe函数注册adapter 实现adapter结构体，实现master_xfer函数以作为adapter成员，master_xfer是最为关键的传输函数 2024-02-20_19-30 总结： i2c驱动注册时： 由底层向高层注册，首先根据设备树的配置项注册adapter(i2c的Controller)，配置相关的时序，模式，频率等基本参数，使得芯片可以驱动i2c设备，在注册adapter的同时顺便把client注册了(cilent注册的时机是在adapter靠后的位置)，client负责具体的i2c外设，这由外设厂家编写，通过配置i2c的初始信号来访问某个固定的寄存器，确定信息传输完成后延时时间，以及对应外设芯片的寄存器配置，使得芯片可以与外设通信 在adapter注册时需要的模型是platform-bus模型，内核会根据设备树中的adapter的数量来确定有几个adapter即几条总线，并根据驱动程序和设备树来两两匹配。在每次注册adapter的过程中还需要顺便注册client，它是device-bus模型。内核在注册client时会发送探测信号来扫描总线上是否存在设备，并根据设备树和驱动来两两匹配并注册进内核 i2c驱动使用时： 由高层向底层调用，当app需要访问某个设备时，首先会找到对应外设的client，根据内部client经过内核的i2c_core找到对应adapter，再找到对应的xfer发送函数来控制adapter发送到对应外设 Linux驱动：I2C驱动学习看这一篇就够了 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:7:0","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#i2c深入"},{"categories":["Tech"],"content":" SPI深入 警告 spi框架与i2c极为相似，只不过原本在i2c中的adapter变成了master，需要配置的重点由adapter.xfer变为了master.transfer SPI驱动程序设备树框架： 对于SPI控制器而言，如果使用platform_bus的match函数匹配到了platform_device与platform_driver的话就会调用SPI控制器的probe函数注册生成一个spi_master，除此之外还会由设备树生成一个spi_device 内核从上面得到的spi_device解析，并调用match函数来检测spi设备驱动spi_driver是否匹配，如果匹配就调用SPI设备的probe函数注册生成一个字符设备以及file_operation结构体 对于SPI控制器而言可以扩展多个设备，具体可以看设备树文件 由于SPI控制器与SPI设备分别由内核解析，并且采用了分离的思想，因此在写SPI设备的驱动程序时需要调用Linux提供的函数接口来引入SPI控制器的资源，尤其是spi_master.transfer函数 2024-03-07_15-58 2024-03-07_15-43 在SPI子系统一个transfer对应一个传输，为了管理多个传输采用了链表结构，SPI控制器的驱动程序spi_master内部有一个queue，每一个具体设备spi_device都会生成一个message并挂载到queue，每一个message会有多种transfer，这些transfer会挂载到message上 2024-02-20_21-16 2024-02-20_22-13 新方法的spi_master的驱动程序，使用方便但规矩多，支持同步异步传输 2024-02-20_22-22 老方法的spi_master的驱动程序，使用繁琐规矩少，支持同步异步传输 2024-02-20_22-22_1 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:8:0","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#spi深入"},{"categories":["Tech"],"content":" GPIO深入GPIO Controller驱动是GPIO编程的核心，其他LED，Button驱动程序只是调用GPIO Controller驱动的函数，对于LED，Button驱动程序只需要调用内核的GPIO lib库即可，我们编写控制器驱动程序的时候也只需要将驱动注册进GPIO lib库 一个GPIO Controller对应一个GPIO device结构体，其内部有chips(相当于fop)，desc(描述单个引脚的数组指针，内部描述了引脚的高低电平，输入输出模式等)，base(引脚基地址等) 2024-02-20_22-55 Pinctl子系统会统一管理引脚，GPIO引脚与Pinctl引脚的映射统一在设备树中管理 2024-02-20_23-04 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:9:0","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#gpio深入"},{"categories":["Tech"],"content":" Pinctl深入使用设备树时分为Pinctl Controller与Client 每一个Pinctl Controller都会使用Pinctl device来描述，Pinctl Controller有三大功能：引脚配置，复用及命名，三者统一在pinctrl_dev.pinctrl_decs结构体中实现 如果写Pinctl Controller驱动，则需要实现pinctrl_decs，并使用pinctrl_register注册 2024-02-20_23-31 platform_device从设备树中解析得到，里面会构造一个dev.dev_pin_info结构体，内部的pinctrl与pinctrl_state结构体储存了设备树中节点的信息 2024-02-20_23-44 Pinctl Controller下的子节点会被内核解析成一个个pinctrl_map，然后被转换为成一个个pinctrl_setting挂载到pinctrl_state，client就可以从pinctrl_state结构体中获得设备树信息 2024-02-21_00-00 2024-02-20_23-45 ","date":"2024-02-23","objectID":"/posts/linux-advanced-drivers/:10:0","series":null,"tags":["OS","Tech"],"title":"Linux高级驱动","uri":"/posts/linux-advanced-drivers/#pinctl深入"},{"categories":["Tech"],"content":"本文阐述系统为x86体系架构，idt，gdt，tss，系统启动引导过程均以x86架构为蓝本，arm不适用，并且由于参考资料过于过于久远，读者应谨慎参考 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:0:0","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#"},{"categories":["Tech"],"content":" Linux内核基础","date":"2024-02-21","objectID":"/posts/linux-kernel/:0:0","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#linux内核基础"},{"categories":["Tech"],"content":" Linux内核体系结构nmi(not mask interrupt)不可屏蔽中断 系统启动时会读取RTC并赋值给jiffies 内核中定时器使用链表进行管理 每个进程都有LDT(局部描述符)，即代码段和数据段。单处理器系统只有一个GDT，而在多处理器系统中每个CPU都有一个GDT，GDT(全局描述符)内部包含各个段的基地址，大小和访问权限等信息 IDT(中断描述符表)，其作用也类似于中断向量表，只是其中每个中断描述符项中除了含有中断服务程序地址以外，还包含有关特权级和描述符类别等信息 中断向量表和中断描述符表IDT-CSDN linux分段-CSDN 2024-02-22_21-06 TSS(任务状态段)就是特殊寄存器 + 通用寄存器的信息 2024-02-22_09-49 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:1:0","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#linux内核体系结构"},{"categories":["Tech"],"content":" fork的实现 申请内存空间 把父进程的task_struct拷贝到子进程的task_struct并重新设置 设置进程状态为可运行，返回pid 需要注意的是fork出的子进程的文件描述符比父进程大1，这也是文章Linux基础中的现象 2024-02-22_10-28 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:1:1","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#fork的实现"},{"categories":["Tech"],"content":" 进程调度在0.11内核中，进程调度分为调度和切换两个步骤，调度负责将用完时间片的进程挂起，并将进程的状态位改为暂停状态，切换时为了效率采用汇编，它的作用是将那些设置状态位的进程加载进CPU寄存器中，即执行上下文切换 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:1:2","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#进程调度"},{"categories":["Tech"],"content":" 进程销毁以syscall_和do_开头的基本上是系统调用，即中断服务函数 进程的销毁流程 进入do_exit函数 首先释放数据段和代码段占用的内存 关闭进程打开的所有文件，对当前的目录和i节点进行同步 如果进程是个会话头进程，则会终止会话中的所有进程 改变进程运行状态为TASK_ZOMBIE，并且向父进程发送SIGCHLD信号，do_exit函数执行完毕 在父进程中进行最后的处理工作，父进程运行子进程的时候一般都会运行wait或waitpid这两个函数(父进程等待某个子进程终止的函数)，当父进程收到SIGCHLD信号时会终止僵死状态的子进程 首先父进程会把子进程的运行时间(utime,stime)累加到自己的进程变量中，之后把要销毁的子进程的进程描述结构体进行释放，置空任务数组中的子进程任务槽 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:1:3","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#进程销毁"},{"categories":["Tech"],"content":" Linux内核启动引导","date":"2024-02-21","objectID":"/posts/linux-kernel/:2:0","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#linux内核启动引导"},{"categories":["Tech"],"content":" 操作系统的启动Linux启动时的硬件信息是由bootloader传进来的 Linux启动流程 首先由BIOS/bootloader进行一系列的硬件初始化和参数设置，并把bootsect.s从硬盘中某个固定地址搬到内存中的某个固定地址，需要注意在内核初始化需要关中断来防止初始化被中断 bootsect.s将setup.s代码从磁盘中加载到紧接着bootsect.s的地方，最后跳转到setup.s中运行 setup.s负责将bootloader传进来的信息进行解析，关中断并加载system模块，使system模块正好覆盖bootsect.s(关中断是为了防止覆盖bootsect.s的代码后系统不能处理中断而导致崩溃)。设置LDT，GDT，IDT，而后设置中断芯片，进入到保护模式(svc32)运行，在代码的最后会跳转到head.s(0x00000000)执行 head.s加载内核运行时的各数据段寄存器，并重新设置IDT(防止被数据区覆盖)，设置内存对齐以及分页，最后跳转到main.c开始运行，系统启动完成 Linux在启动的时候是如何拿到硬件参数的 通过bootloader加载传入的参数(_atags_pointer)，这个参数是一块指向存有硬件信息内存的首地址的指针，通过这个指针就可以获得硬件参数 Linux在初始化运行中都做了什么 进行硬件的初始化(就是下文中各种段的设置)，fork出0号进程 系统第一个APP是根文件系统(linuxrc) 4.9.88内核main函数位于/init文件夹，调用流程如下 c asmlinkage __visible void __init start_kernel(void) static noinline void __ref rest_init(void) pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags) { return _do_fork(flags|CLONE_VM|CLONE_UNTRACED, (unsigned long)fn, (unsigned long)arg, NULL, NULL, 0); } kernel_thread(kernel_init, NULL, CLONE_FS); static int __ref kernel_init(void *unused)//在内部启动系统第一个APP，根文件系统 /sbin/init /etc/init /bin/init /bin/sh 内核main函数： 在内核初始化的过程中会手动创建(fork出来)0号进程，它是所有进程的父进程 之后在0号进程中分别打开标准输入，标准输出，标准错误的控制台句柄。并创建1号进程 在1号进程中，首先打开/etc/rc(配置文件，类似启动项管理)，而后执行shell程序(实际上是被转移到了busybox里面，因为/bin/sh是busy/box的软链接，而后在busybox内部初始化shell) 0号进程不会关闭，如果其他进程没有被执行，那么就执行0号进程，内部是pause函数 2024-02-22_13-35 init函数就是在不断地创建shell，并在子进程中执行，等子进程执行完毕后由父进程接收结果 c void init(void) { int pid,i; setup((void *) \u0026drive_info); (void) open(\"/dev/tty0\",O_RDWR,0); (void) dup(0); //复制stdin文件描述符 (void) dup(0); //复制stdin文件描述符 printf(\"%d buffers = %d bytes buffer space\\n\\r\",NR_BUFFERS, NR_BUFFERS*BLOCK_SIZE); printf(\"Free mem: %d bytes\\n\\r\",memory_end-main_memory_start); if (!(pid=fork())) { //1号进程 close(0); if (open(\"/etc/rc\",O_RDONLY,0)) _exit(1); execve(\"/bin/sh\",argv_rc,envp_rc); _exit(2); } if (pid\u003e0) while (pid != wait(\u0026i)) /* nothing */ //不断地创建进程 while (1) { if ((pid=fork())\u003c0) { printf(\"Fork failed in init\\r\\n\"); continue; } //如果在子进程中则打开tty并执行shell命令 if (!pid) { close(0);close(1);close(2); setsid(); (void) open(\"/dev/tty0\",O_RDWR,0); (void) dup(0); (void) dup(0); _exit(execve(\"/bin/sh\",argv,envp)); } //如果在父进程中则等待子进程处理的结果 while (1) if (pid == wait(\u0026i)) break; printf(\"\\n\\rchild %d died with code %04x\\n\\r\",pid,i); sync(); } _exit(0); /* NOTE! _exit, not exit() */ } Linux启动时会进行异常的初始化，这些初始化函数分为两种，一类是设置用户特权的异常，一类是设置内核特权的异常 machine_desc结构体是用于让linux识别设备的结构体，该结构体被限定在了某个内存区域，该内存区域是内核与bootloader的桥梁。通过该结构体，内核可以通过taglist的方式检索外设并进行配置，并在之后的启动或其他函数中对该结构体内部的成员进行调用 内核通过分段将machine_desc结构体放于内存某一固定位置中，这些machine_desc用于linux识别设备 2024-02-22_21-23 此代码位于head-common.s，在head.s被调用 2024-02-22_21-27 2024-02-22_21-27_1 2024-02-22_21-34 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:2:1","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#操作系统的启动"},{"categories":["Tech"],"content":" Linux移植浅谈Linux系统移植分为2步： 进行初始化的适配，让板子能够运行到main函数 进行驱动系统的移植 Linux内核移植必须能够在庞大的源码中找到所需代码 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:2:2","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#linux移植浅谈"},{"categories":["Tech"],"content":" Linux内核文件系统 2024-02-28_14-51 2024-02-25_01-21_1 2024-02-25_01-24 文件系统由内核启动： 由bootloader传进来的taglist放入内存中某个段，由内核进行解析后(也就是字符串处理)将原有的init=linuxrc转换为comandline=linuxrc，如果bootloader没有定义init=linuxrc，那么内核会在下列文件夹中依次寻找，然后进入文件系统。默认情况下/sbin/init等文件是一个指向/bin/busybox的软链接，这个busybox只有在嵌入式系统中才有，对于Ubuntu而言对应的则是bash，而后由busybox启动文件系统 2024-02-23_13-31 busybox是一个极简的工具箱，它提供了基础的命令，与文件系统关系紧密 启动脚本位于/etc/rc.d 文件系统工作流程(以下过程均在busybox/init.c源码中的init_main函数中完成) 传入参数与解析参数 用户自定义/etc/inittab配置文件(读取文件原理类似设备树)，内核将文件中的init_main进行读取，根据文件中的action参数形成一条action_list链表，链表内部包含的shell命令就是参数，如果用户没有指定参数，那么执行默认的参数 使用参数 逐个运行链表中的shell命令即可(实际上此时还没有启动，这时的命令只是命令行参数) 在init_main函数结尾，busybox会执行如下死循环，这个死循环会不停的做以下事情： 执行run_action，然后等待其退出 退出后再次执行run_action，不断的重复第一步 2024-02-24_09-28 一个文件系统需要什么？ /dev/console，没有了这个文件或者console初始化失败都会导致busybox无法启动 需要init_main函数来初始化(执行启动脚本等)，这由busybox提供 /etc.init.d/rcS脚本，如果不提供这个脚本会导致系统阻塞在文件系统启动之前，无法正常返回 因为需要运行shell命令，因此需要busybox本身 还需要busybox的运行环境glibc 分页： 当CPU开始运行程序时会从硬盘中加载若干页的代码到内存中，当CPU发现这些页并不足以运行程序时就会发出缺页中断(软中断)，硬盘就会继续加载若干页代码到内存中 VFS(虚拟文件系统)：将各种硬件抽象成为文件 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:3:0","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#linux内核文件系统"},{"categories":["Tech"],"content":" 文件系统结构引导块：用于引导设备 超级块：该文件子系统的描述符，当位数超过某个值时会按照类似内存映射的方式进行块的映射 逻辑块位图：每一位对应一个逻辑块的使用情况，如果逻辑块被使用了则对应逻辑块位图对应位置1 i节点位图：同理，描述inode节点的使用情况 逻辑块：用来存储数据的数据存储单元 i节点：目录与磁盘的桥接，文件的属性描述 2024-03-04_16-44 2024-02-24_10-19 2024-02-24_10-21 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:3:1","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#文件系统结构"},{"categories":["Tech"],"content":" 高速缓冲区高速缓冲区存储着块设备驱动程序的数据，并且当从块设备读取数据时，OS会首先在高速缓冲区中查找，找到了且是最新的数据，那么直接和高速缓冲区交互，如果没有找到或者不是最新的则需要在块设备或内存中查找 2024-03-28_12-56 哈希(hash)表哈希表又称为散列表，由哈希函数和数组(也称为散列数组)构成，哈希表是为了解决遍历数组时间复杂度O(logn，以2为底)的问题，首先由输入元素经过哈希函数生成一个整数n，然后再把该元素放到arr[n]的位置，下次如果需要找到此元素，则可以通过hash函数让同一个输入元素生成一个整数n，从而在数组中找到之前的元素，这样就把查询的时间复杂度降为O(1)了。因此对于hash函数有如下要求： 每一个独立的元素都应该有唯一的hash值与之对应 每一个hash值都只对应一个元素 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:3:2","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#高速缓冲区"},{"categories":["Tech"],"content":" 高速缓冲区高速缓冲区存储着块设备驱动程序的数据，并且当从块设备读取数据时，OS会首先在高速缓冲区中查找，找到了且是最新的数据，那么直接和高速缓冲区交互，如果没有找到或者不是最新的则需要在块设备或内存中查找 2024-03-28_12-56 哈希(hash)表哈希表又称为散列表，由哈希函数和数组(也称为散列数组)构成，哈希表是为了解决遍历数组时间复杂度O(logn，以2为底)的问题，首先由输入元素经过哈希函数生成一个整数n，然后再把该元素放到arr[n]的位置，下次如果需要找到此元素，则可以通过hash函数让同一个输入元素生成一个整数n，从而在数组中找到之前的元素，这样就把查询的时间复杂度降为O(1)了。因此对于hash函数有如下要求： 每一个独立的元素都应该有唯一的hash值与之对应 每一个hash值都只对应一个元素 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:3:2","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#哈希hash表"},{"categories":["Tech"],"content":" 缓冲区头 2024-03-02_13-20 高速缓冲区结构中有个缓冲区头，类似于文件系统引导块 2024-02-24_10-56 c struct buffer_head { char * b_data; /* pointer to data block (1024 bytes)，指向数据块 */ unsigned long b_blocknr; /* block number，数据逻辑块号 */ unsigned short b_dev; /* device (0 = free)，块设备号 */ unsigned char b_uptodate; /* 是否更新 */ unsigned char b_dirt; /* 0-clean,1-dirty，是否被占用 */ unsigned char b_count; /* users using this block */ unsigned char b_lock; /* 0 - ok, 1 -locked，是否锁定 */ struct task_struct * b_wait; struct buffer_head * b_prev; struct buffer_head * b_next; struct buffer_head * b_prev_free; /* 空闲缓冲区由循环双向链表构成 */ struct buffer_head * b_next_free; }; 因此，对于块设备而言我们想要获得块，所需要做的是： 分配一个buffer_head 设置该buffer指向空闲缓冲区的一个有效buffer 如果找到的话需要等待解锁 解锁后还需要判断找到的块是否是要申请的块，因为有可能在等待解锁期间块的信息已经被改变了 块如果被改变了则返回到第一步 判断该块是否脏了，即是否有残余数据，有残余数据的话就回写 从空闲缓冲区链表中出元素，设置对应的结构体信息如块设备号，逻辑块号等 写入所需数据 算出该buffer_head的hash值，填入散列数组对应的链表的尾部 需要注意的是，在第二步等待内核分配数据块时，内核在申请前后加了锁，这是为了防止其他线程再次申请内存块 无论读取什么资源，都是先getblk(获取资源对应设备和块号的高速缓冲区)，然后再bread(确认数据是否为最新的)，最后进行区域内存的拷贝，从bh的b_data区域拷贝到要用到数据的内存中 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:3:3","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#缓冲区头"},{"categories":["Tech"],"content":" bio在2.6内核后，buffer_head的功能逐渐弱化为映射内存和磁盘关系的结构体，大部分的操作函数主要在bio结构体中实现 2024-03-02_14-33 bio里重要的结构体： bi_io_vec bi_io_vec指向bio_vec结构体链表表头，链表内包含了各页面的指针 bi_idx bi_idx指向指向bio_vec结构体链表当前的节点，这可以找到当前io操作的位置 bi_vcnt bi_vcnt记录了bio结构体的使用计数，当为0时就需要回收这个bio结构体 2024-03-02_14-38 2024-03-02_14-39 相比buffer_head，bio有如下优点： buffer_head处理的是page指针，但是bio处理的是page指针数组，因此bio有大块内存的处理能力，这在高端内存中很有用 bio适用于先分散后集中的IO操作，操作的数据可以来自于多个不相邻的物理页面 bio时更轻量级的结构体，因为它只存储IO操作的信息 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:3:4","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#bio"},{"categories":["Tech"],"content":" inodeLinux 文件系统会为每个文件分配两个数据结构：索引节点（index node）和目录项（directory entry），它们主要用来记录文件的元信息和目录层次结构 索引节点，也就是 inode，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间 目录项，也就是 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，例如/mnt/cdrom/music中，/，mnt，cdrom，music均为目录项。但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。VFS在执行目录操作时会现场创建目录项。 扇区：块设备上一个长度为512B的数据块，在不同文件系统中，扇区和盘块的对应关系是不同的，有的文件系统是4个扇区对应一个盘块，有的是8个 mount：把文件系统的超级块读到高速缓冲区中，并且放到超级块数组中。超级快的信息包括文件系统类型(ext4，xfs)，块大小，总块数等核心数据，加载超级块是识别文件系统的必要条件 从磁盘中读写信息，数据，inode的流程 找到指定dev，并根据dev找到超级块 通过超级块中的信息计算要读的逻辑块号，并将这个块放入高速缓冲区 读：读取块中的b_data，读完之后释放高速缓冲区 写：将要写入的数据写入b_data，写完之后设置dirty标志位，等待sys_sync系统调用统一写入块设备，最后释放高速缓冲区 硬链接：只要链接数不为0，即使删除源文件，内容也不会消失 删除文件就是把inode的link数改为0 inode中有dev和block，根据这两个信息就可以把硬盘载入高速缓冲区 从上面代码中可以看出，内核从哈希表中搜索现成的缓冲块时只看设备号和块号，其他的什么都不管。只要缓冲块与硬盘数据块的绑定关系还存在，就认定数据块中的数据仍然停留在缓冲块中，就可以直接用，不需要从硬盘上读取，节省了硬盘读取时间 2024-02-26_14-23 2024-02-26_16-33 2024-02-26_16-32 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:3:5","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#inode"},{"categories":["Tech"],"content":" IO调度算法由于APP对读写要求的不同：对读操作时间敏感，对写操作则不然，并且主流存储设备为磁盘时还需要优化寻道时间，因此产生了如下算法 适用于机械硬盘的算法 电梯算法Linus电梯算法是最早的适用于机械硬盘的算法，这种算法在接受IO请求时会将此次的IO与尚未执行的请求合并，这样多次请求就可以转化为一次请求。如果合并失败，算法会尝试将此次请求按磁盘扇区的排列顺序插入到请求队列中，这也是Linus电梯算法适合机械硬盘设备的原因。这种算法与电梯调度类似，因此得名为Linus电梯算法，同时也是下面几种机械硬盘IO调度算法的基础 最终期限IO调度算法(deadline)Linus电梯算法不能解决请求数太多时对其他请求的饥饿问题，deadline算法在Linus电梯的排序队列基础上又引入了读写双队列来保证新请求的响应性，对于读操作来说，当超过500ms未响应就会强制执行读操作，即从读队列中获取操作，写操作则为5s 预测IO调度算法(anticipatory)deadline算法在解决了请求的饥饿问题时损失了系统吞吐量，因为当响应读操作磁头移动的过程中不能进行写操作。为了解决这一问题，预测算法在响应操作时会等待几ms，这样当有在新请求的扇区附近有请求时会一并执行(相当于在deadline里套了个Linus电梯) 完全公平队列IO调度算法(cfq)这种算法与上列算法截然不同，它是按照进程来对IO操作分类的，比如music进程下有4个IO操作，movie有8个IO操作，那么这种算法会使用时间片轮流对IO操作进行调度，保证进程的公平，这种算法主要用于桌面操作，但是如果没有特殊情况，在其他情况下工作的也很好 适用于固态硬盘的算法 空操作的IO调度算法(noop)这种算法除了合并IO操作外什么也不做，因为固态硬盘不需要寻道操作 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:3:6","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#io调度算法"},{"categories":["Tech"],"content":" IO调度算法由于APP对读写要求的不同：对读操作时间敏感，对写操作则不然，并且主流存储设备为磁盘时还需要优化寻道时间，因此产生了如下算法 适用于机械硬盘的算法 电梯算法Linus电梯算法是最早的适用于机械硬盘的算法，这种算法在接受IO请求时会将此次的IO与尚未执行的请求合并，这样多次请求就可以转化为一次请求。如果合并失败，算法会尝试将此次请求按磁盘扇区的排列顺序插入到请求队列中，这也是Linus电梯算法适合机械硬盘设备的原因。这种算法与电梯调度类似，因此得名为Linus电梯算法，同时也是下面几种机械硬盘IO调度算法的基础 最终期限IO调度算法(deadline)Linus电梯算法不能解决请求数太多时对其他请求的饥饿问题，deadline算法在Linus电梯的排序队列基础上又引入了读写双队列来保证新请求的响应性，对于读操作来说，当超过500ms未响应就会强制执行读操作，即从读队列中获取操作，写操作则为5s 预测IO调度算法(anticipatory)deadline算法在解决了请求的饥饿问题时损失了系统吞吐量，因为当响应读操作磁头移动的过程中不能进行写操作。为了解决这一问题，预测算法在响应操作时会等待几ms，这样当有在新请求的扇区附近有请求时会一并执行(相当于在deadline里套了个Linus电梯) 完全公平队列IO调度算法(cfq)这种算法与上列算法截然不同，它是按照进程来对IO操作分类的，比如music进程下有4个IO操作，movie有8个IO操作，那么这种算法会使用时间片轮流对IO操作进行调度，保证进程的公平，这种算法主要用于桌面操作，但是如果没有特殊情况，在其他情况下工作的也很好 适用于固态硬盘的算法 空操作的IO调度算法(noop)这种算法除了合并IO操作外什么也不做，因为固态硬盘不需要寻道操作 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:3:6","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#适用于机械硬盘的算法"},{"categories":["Tech"],"content":" IO调度算法由于APP对读写要求的不同：对读操作时间敏感，对写操作则不然，并且主流存储设备为磁盘时还需要优化寻道时间，因此产生了如下算法 适用于机械硬盘的算法 电梯算法Linus电梯算法是最早的适用于机械硬盘的算法，这种算法在接受IO请求时会将此次的IO与尚未执行的请求合并，这样多次请求就可以转化为一次请求。如果合并失败，算法会尝试将此次请求按磁盘扇区的排列顺序插入到请求队列中，这也是Linus电梯算法适合机械硬盘设备的原因。这种算法与电梯调度类似，因此得名为Linus电梯算法，同时也是下面几种机械硬盘IO调度算法的基础 最终期限IO调度算法(deadline)Linus电梯算法不能解决请求数太多时对其他请求的饥饿问题，deadline算法在Linus电梯的排序队列基础上又引入了读写双队列来保证新请求的响应性，对于读操作来说，当超过500ms未响应就会强制执行读操作，即从读队列中获取操作，写操作则为5s 预测IO调度算法(anticipatory)deadline算法在解决了请求的饥饿问题时损失了系统吞吐量，因为当响应读操作磁头移动的过程中不能进行写操作。为了解决这一问题，预测算法在响应操作时会等待几ms，这样当有在新请求的扇区附近有请求时会一并执行(相当于在deadline里套了个Linus电梯) 完全公平队列IO调度算法(cfq)这种算法与上列算法截然不同，它是按照进程来对IO操作分类的，比如music进程下有4个IO操作，movie有8个IO操作，那么这种算法会使用时间片轮流对IO操作进行调度，保证进程的公平，这种算法主要用于桌面操作，但是如果没有特殊情况，在其他情况下工作的也很好 适用于固态硬盘的算法 空操作的IO调度算法(noop)这种算法除了合并IO操作外什么也不做，因为固态硬盘不需要寻道操作 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:3:6","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#电梯算法"},{"categories":["Tech"],"content":" IO调度算法由于APP对读写要求的不同：对读操作时间敏感，对写操作则不然，并且主流存储设备为磁盘时还需要优化寻道时间，因此产生了如下算法 适用于机械硬盘的算法 电梯算法Linus电梯算法是最早的适用于机械硬盘的算法，这种算法在接受IO请求时会将此次的IO与尚未执行的请求合并，这样多次请求就可以转化为一次请求。如果合并失败，算法会尝试将此次请求按磁盘扇区的排列顺序插入到请求队列中，这也是Linus电梯算法适合机械硬盘设备的原因。这种算法与电梯调度类似，因此得名为Linus电梯算法，同时也是下面几种机械硬盘IO调度算法的基础 最终期限IO调度算法(deadline)Linus电梯算法不能解决请求数太多时对其他请求的饥饿问题，deadline算法在Linus电梯的排序队列基础上又引入了读写双队列来保证新请求的响应性，对于读操作来说，当超过500ms未响应就会强制执行读操作，即从读队列中获取操作，写操作则为5s 预测IO调度算法(anticipatory)deadline算法在解决了请求的饥饿问题时损失了系统吞吐量，因为当响应读操作磁头移动的过程中不能进行写操作。为了解决这一问题，预测算法在响应操作时会等待几ms，这样当有在新请求的扇区附近有请求时会一并执行(相当于在deadline里套了个Linus电梯) 完全公平队列IO调度算法(cfq)这种算法与上列算法截然不同，它是按照进程来对IO操作分类的，比如music进程下有4个IO操作，movie有8个IO操作，那么这种算法会使用时间片轮流对IO操作进行调度，保证进程的公平，这种算法主要用于桌面操作，但是如果没有特殊情况，在其他情况下工作的也很好 适用于固态硬盘的算法 空操作的IO调度算法(noop)这种算法除了合并IO操作外什么也不做，因为固态硬盘不需要寻道操作 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:3:6","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#最终期限io调度算法deadline"},{"categories":["Tech"],"content":" IO调度算法由于APP对读写要求的不同：对读操作时间敏感，对写操作则不然，并且主流存储设备为磁盘时还需要优化寻道时间，因此产生了如下算法 适用于机械硬盘的算法 电梯算法Linus电梯算法是最早的适用于机械硬盘的算法，这种算法在接受IO请求时会将此次的IO与尚未执行的请求合并，这样多次请求就可以转化为一次请求。如果合并失败，算法会尝试将此次请求按磁盘扇区的排列顺序插入到请求队列中，这也是Linus电梯算法适合机械硬盘设备的原因。这种算法与电梯调度类似，因此得名为Linus电梯算法，同时也是下面几种机械硬盘IO调度算法的基础 最终期限IO调度算法(deadline)Linus电梯算法不能解决请求数太多时对其他请求的饥饿问题，deadline算法在Linus电梯的排序队列基础上又引入了读写双队列来保证新请求的响应性，对于读操作来说，当超过500ms未响应就会强制执行读操作，即从读队列中获取操作，写操作则为5s 预测IO调度算法(anticipatory)deadline算法在解决了请求的饥饿问题时损失了系统吞吐量，因为当响应读操作磁头移动的过程中不能进行写操作。为了解决这一问题，预测算法在响应操作时会等待几ms，这样当有在新请求的扇区附近有请求时会一并执行(相当于在deadline里套了个Linus电梯) 完全公平队列IO调度算法(cfq)这种算法与上列算法截然不同，它是按照进程来对IO操作分类的，比如music进程下有4个IO操作，movie有8个IO操作，那么这种算法会使用时间片轮流对IO操作进行调度，保证进程的公平，这种算法主要用于桌面操作，但是如果没有特殊情况，在其他情况下工作的也很好 适用于固态硬盘的算法 空操作的IO调度算法(noop)这种算法除了合并IO操作外什么也不做，因为固态硬盘不需要寻道操作 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:3:6","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#预测io调度算法anticipatory"},{"categories":["Tech"],"content":" IO调度算法由于APP对读写要求的不同：对读操作时间敏感，对写操作则不然，并且主流存储设备为磁盘时还需要优化寻道时间，因此产生了如下算法 适用于机械硬盘的算法 电梯算法Linus电梯算法是最早的适用于机械硬盘的算法，这种算法在接受IO请求时会将此次的IO与尚未执行的请求合并，这样多次请求就可以转化为一次请求。如果合并失败，算法会尝试将此次请求按磁盘扇区的排列顺序插入到请求队列中，这也是Linus电梯算法适合机械硬盘设备的原因。这种算法与电梯调度类似，因此得名为Linus电梯算法，同时也是下面几种机械硬盘IO调度算法的基础 最终期限IO调度算法(deadline)Linus电梯算法不能解决请求数太多时对其他请求的饥饿问题，deadline算法在Linus电梯的排序队列基础上又引入了读写双队列来保证新请求的响应性，对于读操作来说，当超过500ms未响应就会强制执行读操作，即从读队列中获取操作，写操作则为5s 预测IO调度算法(anticipatory)deadline算法在解决了请求的饥饿问题时损失了系统吞吐量，因为当响应读操作磁头移动的过程中不能进行写操作。为了解决这一问题，预测算法在响应操作时会等待几ms，这样当有在新请求的扇区附近有请求时会一并执行(相当于在deadline里套了个Linus电梯) 完全公平队列IO调度算法(cfq)这种算法与上列算法截然不同，它是按照进程来对IO操作分类的，比如music进程下有4个IO操作，movie有8个IO操作，那么这种算法会使用时间片轮流对IO操作进行调度，保证进程的公平，这种算法主要用于桌面操作，但是如果没有特殊情况，在其他情况下工作的也很好 适用于固态硬盘的算法 空操作的IO调度算法(noop)这种算法除了合并IO操作外什么也不做，因为固态硬盘不需要寻道操作 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:3:6","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#完全公平队列io调度算法cfq"},{"categories":["Tech"],"content":" IO调度算法由于APP对读写要求的不同：对读操作时间敏感，对写操作则不然，并且主流存储设备为磁盘时还需要优化寻道时间，因此产生了如下算法 适用于机械硬盘的算法 电梯算法Linus电梯算法是最早的适用于机械硬盘的算法，这种算法在接受IO请求时会将此次的IO与尚未执行的请求合并，这样多次请求就可以转化为一次请求。如果合并失败，算法会尝试将此次请求按磁盘扇区的排列顺序插入到请求队列中，这也是Linus电梯算法适合机械硬盘设备的原因。这种算法与电梯调度类似，因此得名为Linus电梯算法，同时也是下面几种机械硬盘IO调度算法的基础 最终期限IO调度算法(deadline)Linus电梯算法不能解决请求数太多时对其他请求的饥饿问题，deadline算法在Linus电梯的排序队列基础上又引入了读写双队列来保证新请求的响应性，对于读操作来说，当超过500ms未响应就会强制执行读操作，即从读队列中获取操作，写操作则为5s 预测IO调度算法(anticipatory)deadline算法在解决了请求的饥饿问题时损失了系统吞吐量，因为当响应读操作磁头移动的过程中不能进行写操作。为了解决这一问题，预测算法在响应操作时会等待几ms，这样当有在新请求的扇区附近有请求时会一并执行(相当于在deadline里套了个Linus电梯) 完全公平队列IO调度算法(cfq)这种算法与上列算法截然不同，它是按照进程来对IO操作分类的，比如music进程下有4个IO操作，movie有8个IO操作，那么这种算法会使用时间片轮流对IO操作进行调度，保证进程的公平，这种算法主要用于桌面操作，但是如果没有特殊情况，在其他情况下工作的也很好 适用于固态硬盘的算法 空操作的IO调度算法(noop)这种算法除了合并IO操作外什么也不做，因为固态硬盘不需要寻道操作 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:3:6","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#适用于固态硬盘的算法"},{"categories":["Tech"],"content":" IO调度算法由于APP对读写要求的不同：对读操作时间敏感，对写操作则不然，并且主流存储设备为磁盘时还需要优化寻道时间，因此产生了如下算法 适用于机械硬盘的算法 电梯算法Linus电梯算法是最早的适用于机械硬盘的算法，这种算法在接受IO请求时会将此次的IO与尚未执行的请求合并，这样多次请求就可以转化为一次请求。如果合并失败，算法会尝试将此次请求按磁盘扇区的排列顺序插入到请求队列中，这也是Linus电梯算法适合机械硬盘设备的原因。这种算法与电梯调度类似，因此得名为Linus电梯算法，同时也是下面几种机械硬盘IO调度算法的基础 最终期限IO调度算法(deadline)Linus电梯算法不能解决请求数太多时对其他请求的饥饿问题，deadline算法在Linus电梯的排序队列基础上又引入了读写双队列来保证新请求的响应性，对于读操作来说，当超过500ms未响应就会强制执行读操作，即从读队列中获取操作，写操作则为5s 预测IO调度算法(anticipatory)deadline算法在解决了请求的饥饿问题时损失了系统吞吐量，因为当响应读操作磁头移动的过程中不能进行写操作。为了解决这一问题，预测算法在响应操作时会等待几ms，这样当有在新请求的扇区附近有请求时会一并执行(相当于在deadline里套了个Linus电梯) 完全公平队列IO调度算法(cfq)这种算法与上列算法截然不同，它是按照进程来对IO操作分类的，比如music进程下有4个IO操作，movie有8个IO操作，那么这种算法会使用时间片轮流对IO操作进行调度，保证进程的公平，这种算法主要用于桌面操作，但是如果没有特殊情况，在其他情况下工作的也很好 适用于固态硬盘的算法 空操作的IO调度算法(noop)这种算法除了合并IO操作外什么也不做，因为固态硬盘不需要寻道操作 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:3:6","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#空操作的io调度算法noop"},{"categories":["Tech"],"content":" Linux内核内存管理内核空间也需要分页，但不像应用层那样按需请求按需分页 linux内存布局 使用命令行生成内存布局 2024-03-04_22-19 2024-03-04_22-42 vmalloc是在虚拟内存中申请一块连续地址，kmalloc则是在物理内存中申请一块连续地址。内核代码主要使用kmalloc，这是因为当物理地址不连续时需要为每个独立的物理地址项建立页表项会损失性能 内核空间栈较小，用户空间栈较大且可变 中断程序的栈与内核栈分开，这样哪怕在编译时给定内核栈为1页也不会爆栈了，并且也不需要每次分给多页内存给内核栈，这样在机器长时间运行后的分配内存的压力也会变小 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:4:0","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#linux内核内存管理"},{"categories":["Tech"],"content":" 内存碎片当需要1字节却创建一整块页表时，剩余的4095字节被称为内部碎片，当内存空间被各种进程分割为大大小小的区域时产生的碎片被称为外部碎片，可以通过内存紧缩等算法减少外部碎片 伙伴算法伙伴算法(buddy system)是为了管理大块的内存页从而减少外部碎片的一种算法，首先内核将内存分为11个链表，每个链表所管理的内存大小固定，大小均为4K*2^n倍，例如0号链表管理的内存为4K，1号链表为8K，当需要申请内存时需要从相应的链表中获得内存，比如需要12K的内存则需要从2号链表中获取，这样就可以统一管理大块内存从而减少内部碎片的产生 slabslab是为了管理小块的内存从而减少内部碎片的一种算法，首先内核将所有高速缓存分为大小不同的组，每一组有若干块高速缓存并在内部存储相同的对象，每一块高速缓存下有若干slab块并有三条slab链表，分别是空闲的slab链表，被占用的slab链表，被占满的slab链表，每个slab块都有若干页并且管理相同的数据结构，比如某块slab专门用于管理inode，或者专门管理task_struct，因此需要这种类似结构的内存时，只需要获取对应slab就可以了，而不必新申请一个页 因此使用slab会有很多好处： 适应了小块内存的分配，解决了伙伴算法不能管理小块内存并产生大量内部碎片的缺点 将频繁使用的对象缓存起来，减少分配回收时的开销 对于小型嵌入式系统来说，存在一个slab模拟层，名字叫做slob，但会有碎片问题 用户空间的内存管理上面的内存管理机制是针对内核空间的，在用户空间的内存管理则简单又熟悉。在减少外部碎片方面，用户空间依然采用了伙伴算法，只不过是通过mmap和brk等机制调用的，因此我们使用mmap时就不会产生大量的外部碎片了。在减少内部碎片方面，用户空间采用了libc的内存管理器，也就是malloc函数族，当然，在malloc申请的内存大小达到一定程度后，会在libc内部被自动转换为mmap ","date":"2024-02-21","objectID":"/posts/linux-kernel/:4:1","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#内存碎片"},{"categories":["Tech"],"content":" 内存碎片当需要1字节却创建一整块页表时，剩余的4095字节被称为内部碎片，当内存空间被各种进程分割为大大小小的区域时产生的碎片被称为外部碎片，可以通过内存紧缩等算法减少外部碎片 伙伴算法伙伴算法(buddy system)是为了管理大块的内存页从而减少外部碎片的一种算法，首先内核将内存分为11个链表，每个链表所管理的内存大小固定，大小均为4K*2^n倍，例如0号链表管理的内存为4K，1号链表为8K，当需要申请内存时需要从相应的链表中获得内存，比如需要12K的内存则需要从2号链表中获取，这样就可以统一管理大块内存从而减少内部碎片的产生 slabslab是为了管理小块的内存从而减少内部碎片的一种算法，首先内核将所有高速缓存分为大小不同的组，每一组有若干块高速缓存并在内部存储相同的对象，每一块高速缓存下有若干slab块并有三条slab链表，分别是空闲的slab链表，被占用的slab链表，被占满的slab链表，每个slab块都有若干页并且管理相同的数据结构，比如某块slab专门用于管理inode，或者专门管理task_struct，因此需要这种类似结构的内存时，只需要获取对应slab就可以了，而不必新申请一个页 因此使用slab会有很多好处： 适应了小块内存的分配，解决了伙伴算法不能管理小块内存并产生大量内部碎片的缺点 将频繁使用的对象缓存起来，减少分配回收时的开销 对于小型嵌入式系统来说，存在一个slab模拟层，名字叫做slob，但会有碎片问题 用户空间的内存管理上面的内存管理机制是针对内核空间的，在用户空间的内存管理则简单又熟悉。在减少外部碎片方面，用户空间依然采用了伙伴算法，只不过是通过mmap和brk等机制调用的，因此我们使用mmap时就不会产生大量的外部碎片了。在减少内部碎片方面，用户空间采用了libc的内存管理器，也就是malloc函数族，当然，在malloc申请的内存大小达到一定程度后，会在libc内部被自动转换为mmap ","date":"2024-02-21","objectID":"/posts/linux-kernel/:4:1","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#伙伴算法"},{"categories":["Tech"],"content":" 内存碎片当需要1字节却创建一整块页表时，剩余的4095字节被称为内部碎片，当内存空间被各种进程分割为大大小小的区域时产生的碎片被称为外部碎片，可以通过内存紧缩等算法减少外部碎片 伙伴算法伙伴算法(buddy system)是为了管理大块的内存页从而减少外部碎片的一种算法，首先内核将内存分为11个链表，每个链表所管理的内存大小固定，大小均为4K*2^n倍，例如0号链表管理的内存为4K，1号链表为8K，当需要申请内存时需要从相应的链表中获得内存，比如需要12K的内存则需要从2号链表中获取，这样就可以统一管理大块内存从而减少内部碎片的产生 slabslab是为了管理小块的内存从而减少内部碎片的一种算法，首先内核将所有高速缓存分为大小不同的组，每一组有若干块高速缓存并在内部存储相同的对象，每一块高速缓存下有若干slab块并有三条slab链表，分别是空闲的slab链表，被占用的slab链表，被占满的slab链表，每个slab块都有若干页并且管理相同的数据结构，比如某块slab专门用于管理inode，或者专门管理task_struct，因此需要这种类似结构的内存时，只需要获取对应slab就可以了，而不必新申请一个页 因此使用slab会有很多好处： 适应了小块内存的分配，解决了伙伴算法不能管理小块内存并产生大量内部碎片的缺点 将频繁使用的对象缓存起来，减少分配回收时的开销 对于小型嵌入式系统来说，存在一个slab模拟层，名字叫做slob，但会有碎片问题 用户空间的内存管理上面的内存管理机制是针对内核空间的，在用户空间的内存管理则简单又熟悉。在减少外部碎片方面，用户空间依然采用了伙伴算法，只不过是通过mmap和brk等机制调用的，因此我们使用mmap时就不会产生大量的外部碎片了。在减少内部碎片方面，用户空间采用了libc的内存管理器，也就是malloc函数族，当然，在malloc申请的内存大小达到一定程度后，会在libc内部被自动转换为mmap ","date":"2024-02-21","objectID":"/posts/linux-kernel/:4:1","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#slab"},{"categories":["Tech"],"content":" 内存碎片当需要1字节却创建一整块页表时，剩余的4095字节被称为内部碎片，当内存空间被各种进程分割为大大小小的区域时产生的碎片被称为外部碎片，可以通过内存紧缩等算法减少外部碎片 伙伴算法伙伴算法(buddy system)是为了管理大块的内存页从而减少外部碎片的一种算法，首先内核将内存分为11个链表，每个链表所管理的内存大小固定，大小均为4K*2^n倍，例如0号链表管理的内存为4K，1号链表为8K，当需要申请内存时需要从相应的链表中获得内存，比如需要12K的内存则需要从2号链表中获取，这样就可以统一管理大块内存从而减少内部碎片的产生 slabslab是为了管理小块的内存从而减少内部碎片的一种算法，首先内核将所有高速缓存分为大小不同的组，每一组有若干块高速缓存并在内部存储相同的对象，每一块高速缓存下有若干slab块并有三条slab链表，分别是空闲的slab链表，被占用的slab链表，被占满的slab链表，每个slab块都有若干页并且管理相同的数据结构，比如某块slab专门用于管理inode，或者专门管理task_struct，因此需要这种类似结构的内存时，只需要获取对应slab就可以了，而不必新申请一个页 因此使用slab会有很多好处： 适应了小块内存的分配，解决了伙伴算法不能管理小块内存并产生大量内部碎片的缺点 将频繁使用的对象缓存起来，减少分配回收时的开销 对于小型嵌入式系统来说，存在一个slab模拟层，名字叫做slob，但会有碎片问题 用户空间的内存管理上面的内存管理机制是针对内核空间的，在用户空间的内存管理则简单又熟悉。在减少外部碎片方面，用户空间依然采用了伙伴算法，只不过是通过mmap和brk等机制调用的，因此我们使用mmap时就不会产生大量的外部碎片了。在减少内部碎片方面，用户空间采用了libc的内存管理器，也就是malloc函数族，当然，在malloc申请的内存大小达到一定程度后，会在libc内部被自动转换为mmap ","date":"2024-02-21","objectID":"/posts/linux-kernel/:4:1","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#用户空间的内存管理"},{"categories":["Tech"],"content":" RCURCU(Read-Copy Update)，读时任意读，写时先复制一份副本，然后在副本上更新，最后再一次性的替换旧数据 RCU支持对于某一个数据读写同时操作，这是因为RCU本质上是某一个数据copy一个副本，写进程写副本，读进程读原来的数据。当写完数据时，写进程会检查原数据结构是否被读进程占用，如果被占用就等待读进程完成操作，然后互斥的将副本拷贝进原数据。因此使用RCU可能会读取到旧数据，但这不破坏数据完整性 RCU常用于链表上的数据操作，伪代码： c struct devmem{ struct list_head list; int flag; int length; int data; } LIST_HEAD(list); /* qlist给读进程，qlist给写进程 */ plist = search(list, data); qlist = kmalloc(sizeof(devmem)); /* 拷贝数据 */ *qlist = *plist; /* 写数据 */ qlist-\u003eflag = 1; qlist-\u003elength = 2; qlist-\u003edata = 3; /* 等待读进程完成操作 */ synchronize_rcu(); /* 拷贝到原数据 */ list_replace_rcu(plist, qlist); kfree(qlist); ","date":"2024-02-21","objectID":"/posts/linux-kernel/:4:2","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#rcu"},{"categories":["Tech"],"content":" 堆内存管理mmap与malloc都会调用到brk系统调用(实际上malloc调用的堆空间大于128k时会自动调用mmap)，内核维护着start_brk与brk两个指针，分别指向堆空间起始和终止地址，申请内存本质上是通过改变brk的边界来扩展内存的 为了保证内存管理的高效性，linux在glibc，标准IO(fread/fwrite)分别设置了两层缓冲，glibc内部有个内存分配器，标准IO内部又有缓冲区，经过这两层后之后才会进入内核的缓冲区 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:4:3","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#堆内存管理"},{"categories":["Tech"],"content":" 匿名内存映射在内存中的文件具有相应的路径和名称，这就是普通的文件映射。而对于堆栈，mmap这种内存来说并没有对应的文件而只有对应的进程，我们称后者这些内存为匿名内存 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:4:4","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#匿名内存"},{"categories":["Tech"],"content":" Linux内核数据结构","date":"2024-02-21","objectID":"/posts/linux-kernel/:5:0","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#linux内核数据结构"},{"categories":["Tech"],"content":" 算法复杂度O(1)并不一定优于O(n)，例如当执行某些算法时，时间复杂度O(1)的程序无论输入如何总是需要3小时才运行完毕，但这个程序输入很小的情况下O(n)明显更合适 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:5:1","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#算法复杂度"},{"categories":["Tech"],"content":" Linux内核进程调度内核抢占：在内核态也可以被中断调度出去执行更高优先级的代码的特性 Linux对进程或线程不做结构上的区分，他们的结构体是完全一样的，只是线程可以进行资源的共享 Linux采用了完全公平算法(CFS) 普通的调度算法会根据nice值(-20~+19，nice值越大，占用的时间片越少，默认nice值为0)来分配时间片，但只这会造成以下问题： * 随着任务数的增多，时间片会接近0，系统始终处于调度当中 * 当进程优先级分配不合理时，进程切换会频繁。比如同样是两个进程，如果nice都是0的话会轮流调度，对于5ms的时间片来说它们每5ms就会调度一次，而对于nice值为20和0的进程来说，他们调度的总时长是(20+1)*5=105ms，两者每105ms会调度一次 * nice值是相对的，则会导致进程调度的效果不同。比如nice为20和19的进程，这两个进程时间片分别是100ms和105ms，但是对于nice值为0和1的进程来说，时间片分别是10ms和5ms，两者占据时间片的百分比差距很大 CFS的解决办法： 规定时间片的最小粒度为1ms 时间片不与nice绝对值挂钩，而与相对值挂钩 但是当任务数过大时(比如几千个)，CFS并不是公平的，随着任务数的增多，nice的影响会越来越小，使得每个任务运行时间都最终趋近于1ms CFS采用了计算vruntime的方法来保证公平调度，vruntime是一个加权后的时间，当需要调度时，CFS会找出vruntime最小的那个进程或线程进行调度 为了管理众多进程，CFS采用红黑树的数据结构，这样可以使搜索时间显著下降 内存屏障：由于CPU执行与编译器编译后的结果是乱序的，为了保证代码按正确的顺序的运行，厂家提供了内存屏障指令，在内存屏障的上下文代码按一定顺序执行，如下文，在线程2，先执行c=b;而后执行d=a;，如果没有内存屏障代码的话假如线程1与线程2被执行时同时颠倒顺序会导致出现预料外的结果 2024-03-01_11-20 为了保证检索定时器的效率，Linux将定时器按照精度和触发时间分为五组，层级越高的距离触发时间越长，且时间粒度越粗，这样内核就可以只比较距离触发最近的那组定时器，对于触发时间较远的可以低精度比较，这样就大大减少了内核负担。另外，当低层级定时器全部到期时，内核会把高层级的定时器移动到低层级，这样就能保证所有定时器在触发时的精度，该机制被称为时间轮 不负责的程序员经常使用get_cpu()等函数来保证数据与CPU绑定(每个CPU都有一段专属的内存区域)，虽然这对防止竟态有重要作用(唯一需要注意的内核抢占问题也在get_cpu()中自动实现了)，但是这也会造成一核有难多核围观的后果。造成该后果的原因是当使用get_cpu()时会关闭内核抢占，防止当前任务被切换到其他cpu造成数据不一致的情况，而这带来的副作用是长时间关闭内核抢占会导致该任务只被一个核处理，其他核只能看着，这就是一核有难，多核围观 警告 即使不了解Linux代码风格也可以使用官方的indent工具来格式化代码 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:6:0","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#linux内核进程调度"},{"categories":["Tech"],"content":" 读写锁读写锁支持多个进程同时读数据，但只能有一个进程写数据。由于读读不互斥，读写互斥(读到写到一半的脏数据)，写写互斥，因此需要读锁来保证读写互斥，写锁保证写写互斥。因此在写操作时，所有读操作都被阻塞(读写互斥)，而这会对内核造成巨大灾难，目前内核采用了rcu机制来优化此问题 警告 务必注意return的时候是否解锁，如果程序中有多处return那么可以考虑使用goto来统一跳转解决 ","date":"2024-02-21","objectID":"/posts/linux-kernel/:6:1","series":null,"tags":["OS","Tech"],"title":"Linux内核","uri":"/posts/linux-kernel/#读写锁"},{"categories":["Tech"],"content":"基础的Linux应用与驱动开发 ","date":"2024-01-23","objectID":"/posts/linux-basics/:0:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#"},{"categories":["Tech"],"content":" Linux","date":"2024-01-23","objectID":"/posts/linux-basics/:0:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#linux"},{"categories":["Tech"],"content":" Linux基础shell负责解析命令，当用户在shell中输入命令时，根据输入的结果，shell通过PATH环境变量的位置找到相应的程序执行，因此可以通过将可执行文件复制到PATH从而直接在任何目录下运行可执行文件，否则只能使用绝对路径或相对路径的方式来执行 []代表可选参数 \u003c\u003e代表必选参数 ","date":"2024-01-23","objectID":"/posts/linux-basics/:1:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#linux基础"},{"categories":["Tech"],"content":" Linux基础命令与操作. 当前目录 .. 上一级目录 - 切换前上一次的目录 shell cd .. 返回到上一级目录 cd - 返回到切换前上一次的目录 rm -r 递归删除 touch existfile 修改文件更改时间 2024-01-23_21-07 拥有文件权限的组分别为：book用户，book用户所在组的其他用户，其他用户 shell file 文件名 查看文件详细信息 chmod 777 赋予所有权限 chmod a-x filename 去除所有用户的x权限 chmod u+x filename 加上拥有者的x权限 chown 用户组:用户组 filename 改变文件的拥有者 su 用户名 切换用户 find 目录名 选项 查找条件 find directoryname -name \"*1.txt*\" 在directoryname下找到包含为1.txt的文件 grep 参数 \"字符串\" 文件名 grep -rwn \"abc\" * 在当前目录中查找含有abc字符串的文件，查找模式是，递归的(r)，整词的(w)，找到行号(n) ifconfig 查看网络 2024-01-23_21-55 tar命令 shell tar cjf filename.tar.bz2 filename 文件使用bzip2压缩算法压缩 tar czf filename.tar.gz filename 文件使用gzip压缩算法压缩 tar xjf filename.tar.bz2 文件使用bzip2压缩算法解压 tar xzf filename.tar.gz 文件使用gzip压缩算法解压 ","date":"2024-01-23","objectID":"/posts/linux-basics/:1:1","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#linux基础命令与操作"},{"categories":["Tech"],"content":" Linux环境搭建为了能够便捷配置环境以及工具链，我们需要在Linux环境下进行开发，因此我们选择Ubuntu虚拟机作为服务器，为了能够将Ubuntu上编译后的程序在开发板上也能运行，我们需要配置交叉编译环境，为了开发板与Ubuntu能够传输文件，我们需要设置网口，配置ip， 开启nfs服务，由于我们是小白，为了能够使用win下的笔记，截图工具，我们需要win下的通信工具mobaxterm，同时我们需要保证win，Ubuntu，开发板能够互相通信 网络拓扑如下 100ask开发板网络拓扑 ","date":"2024-01-23","objectID":"/posts/linux-basics/:2:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#linux环境搭建"},{"categories":["Tech"],"content":" 设置NAT以及桥接网卡NAT网卡可以保证Ubuntu可以上网，NAT实现Ubuntu与Windows网络互通 桥接网卡保证Ubuntu可以与开发板互通 默认ip： 开发板 192.168.5.9 windows 192.168.5.10 Ubuntu 192.168.5.11 ","date":"2024-01-23","objectID":"/posts/linux-basics/:2:1","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#设置nat以及桥接网卡"},{"categories":["Tech"],"content":" 开启NFSNFS(net file system)，为了方便开发板与Ubuntu之间通信，可以设置开启NFS 开启步骤 在Ubuntu中开启开发板访问Ubuntu的权限，在/etc/export中加入要共享的文件夹 开启NFS服务 在开发板中挂载Ubuntu中的某个目录(默认为/home/book/nfs_rootfs)到/mnt下 ","date":"2024-01-23","objectID":"/posts/linux-basics/:2:2","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#开启nfs"},{"categories":["Tech"],"content":" 交叉编译环境的使用 环境变量有三种方式可以修改 永久修改： 修改/etc/environment，添加对应的目录，对所有用户有效 修改~/.bashrc，在行尾添加export PATH=$PATH:对应的目录，并执行source ~/.bashrc，只对当前用户有效 临时设置： 在终端执行export PATH=$PATH:对应的目录，但只对当前终端有效 由于开发板使用的是arm架构，虚拟机使用的是x86架构，且环境、资源基本不同，因此为了能够使由Ubuntu编译后的文件在开发板上使用，需要配置交叉环境编译链，百问网使用脚本自动配置，我们只需在编译时使用这些编译工具即可 如果没有使用交叉编译链编译文件，在开发板上执行时会提示格式错误 ","date":"2024-01-23","objectID":"/posts/linux-basics/:2:3","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#交叉编译环境的使用"},{"categories":["Tech"],"content":" IMX6ULL工具链IMX6ULL工具链有两种分别为arm-buildroot-linux-gnueabihf-gcc 与 arm-linux-gnueabihf-gcc，前者工具链较全，包含了zlib等库，后者较为精简，有的库没有包含 ","date":"2024-01-23","objectID":"/posts/linux-basics/:2:4","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#imx6ull工具链"},{"categories":["Tech"],"content":" 编译第一个应用程序在Ubuntu上执行arm-buildroot-linux-gnueabihf-gcc -o hello hello.c来使编译后的文件能够在开发板上执行 ","date":"2024-01-23","objectID":"/posts/linux-basics/:2:5","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#编译第一个应用程序"},{"categories":["Tech"],"content":" 编译第一个驱动程序由于驱动程序依赖内核，因此必须有内核的源码且内核必须编译过，这样驱动程序才能依赖配置，编译过的内核而运行 2024-01-26_21-03 编译内核步骤如下： 准备好内核，设备树，并使用make编译 将编译后的文件拷贝到nfs文件夹下，以便开发板能够访问。其中，编译内核生成的zImage以及编译设备树生成的dtb均放入nfs/boot下 编译内核模块，将内核模块安装在nfs文件夹下，而后将nfs下生成的modules目录拷贝到lib目录下 挂载在开发板mnt下的内核，将编译内核模块产生的lib放在开发板的lib下 执行sync命令，以便将内存中的内容刷写到flash上 重启开发板，这样就诞生了一个自己编译内核的开发板 ","date":"2024-01-23","objectID":"/posts/linux-basics/:2:6","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#编译第一个驱动程序"},{"categories":["Tech"],"content":" Linux应用开发基础在int main(int argc, char** argv)中，编译执行输入./filename command时argc是2，argv[0]是filename，argv[1]是command，argv的值可以传进函数做参数 引用的头文件在哪？ 在工具链的系统目录，或者编译时-I指定目录 头文件和库文件的区别 头文件是文本文件，可供阅读，库文件是二进制文件，不可阅读，因此库文件有一定的保密性 头文件在编译阶段使用，库文件在链接阶段使用 头文件一般只包括声明，库文件包括了内部实现 头文件是手动编写的，库文件是生成的 2024-01-26_13-22_1 2024-01-26_13-23 ","date":"2024-01-23","objectID":"/posts/linux-basics/:3:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#linux应用开发基础"},{"categories":["Tech"],"content":" GCC GCC操作gcc(g++) options -o 指定文件名 -fexec-charset=GBK 指定运行时编码 -finput-charset=UTF-8 指定源文件编码 -Wall 输出警告信息 -O(0-3) 指定代码优化等级(0为不优化) -I 指定文件目录来查找头文件(一般为./) -L 指定文件目录来查找库文件(一般为./) -v 输出编译的信息 编译过程 预处理阶段 (-E，得到.i文件)（巧记：ESC，iso） 处理#include预编译指令，将被包含的文件直接插入到预编译指令的位置 处理所有的条件预编译指令，比如#if，#else，#endif，#ifdef等 预处理器将所有的#define删除，并且展开所有的宏定义 删除所有的注释 添加行号和文件标识，以便编译错误时提供错误或警告的行号 保留所有#pragma编译器指令 shell gcc -E -o hello.i hello.c 编译阶段 (-S，得到.s文件) 将预处理后的file.i文件进行语法词法分析，翻译成文本文件file.s shell gcc -S -o hello.s hello.i 汇编阶段 (-c，得到.o文件) 得到二进制机器码文件，生成各个段，生成符号表 shell gcc -c -o hello.o hello.s 链接阶段 (gcc file.o) 将链接文件链接到file.o文件中 静态链接：内存开销大，速度快。将所有需要的函数的二进制代码拷贝到可执行文件中去 动态链接：内存开销小，速度慢。不需要将所有需要的函数的二进制代码拷贝到可执行文件中去，而是记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统将这些动态库加载到内存中，然后当程序运行到指定代码时，去共享执行内存中找到已经加载动态库可执行代码，最终达到运行时链接的目的 shell gcc -M hello.c 打印hello.c的依赖 gcc -M -MF hello.d hello.c 输出hello.c的依赖到hello.d文件内 gcc -c -o hello.o hello.c -MD -MF hello.d 编译hello.c并输出依赖到hello.d文件 为了防止编译大型项目后再对其中某一个文件修改而重新编译整个系统，可以采用先编译大型项目中的文件，最后再链接 使用include\"文件\"代表去当前目录下查找库文件 使用include\u003c文件\u003e代表去工具链目录下查找库文件 静态库以.a结尾，动态库以.so结尾 ","date":"2024-01-23","objectID":"/posts/linux-basics/:3:1","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#gcc"},{"categories":["Tech"],"content":" GCC GCC操作gcc(g++) options -o 指定文件名 -fexec-charset=GBK 指定运行时编码 -finput-charset=UTF-8 指定源文件编码 -Wall 输出警告信息 -O(0-3) 指定代码优化等级(0为不优化) -I 指定文件目录来查找头文件(一般为./) -L 指定文件目录来查找库文件(一般为./) -v 输出编译的信息 编译过程 预处理阶段 (-E，得到.i文件)（巧记：ESC，iso） 处理#include预编译指令，将被包含的文件直接插入到预编译指令的位置 处理所有的条件预编译指令，比如#if，#else，#endif，#ifdef等 预处理器将所有的#define删除，并且展开所有的宏定义 删除所有的注释 添加行号和文件标识，以便编译错误时提供错误或警告的行号 保留所有#pragma编译器指令 shell gcc -E -o hello.i hello.c 编译阶段 (-S，得到.s文件) 将预处理后的file.i文件进行语法词法分析，翻译成文本文件file.s shell gcc -S -o hello.s hello.i 汇编阶段 (-c，得到.o文件) 得到二进制机器码文件，生成各个段，生成符号表 shell gcc -c -o hello.o hello.s 链接阶段 (gcc file.o) 将链接文件链接到file.o文件中 静态链接：内存开销大，速度快。将所有需要的函数的二进制代码拷贝到可执行文件中去 动态链接：内存开销小，速度慢。不需要将所有需要的函数的二进制代码拷贝到可执行文件中去，而是记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统将这些动态库加载到内存中，然后当程序运行到指定代码时，去共享执行内存中找到已经加载动态库可执行代码，最终达到运行时链接的目的 shell gcc -M hello.c 打印hello.c的依赖 gcc -M -MF hello.d hello.c 输出hello.c的依赖到hello.d文件内 gcc -c -o hello.o hello.c -MD -MF hello.d 编译hello.c并输出依赖到hello.d文件 为了防止编译大型项目后再对其中某一个文件修改而重新编译整个系统，可以采用先编译大型项目中的文件，最后再链接 使用include\"文件\"代表去当前目录下查找库文件 使用include\u003c文件\u003e代表去工具链目录下查找库文件 静态库以.a结尾，动态库以.so结尾 ","date":"2024-01-23","objectID":"/posts/linux-basics/:3:1","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#gcc操作"},{"categories":["Tech"],"content":" GCC GCC操作gcc(g++) options -o 指定文件名 -fexec-charset=GBK 指定运行时编码 -finput-charset=UTF-8 指定源文件编码 -Wall 输出警告信息 -O(0-3) 指定代码优化等级(0为不优化) -I 指定文件目录来查找头文件(一般为./) -L 指定文件目录来查找库文件(一般为./) -v 输出编译的信息 编译过程 预处理阶段 (-E，得到.i文件)（巧记：ESC，iso） 处理#include预编译指令，将被包含的文件直接插入到预编译指令的位置 处理所有的条件预编译指令，比如#if，#else，#endif，#ifdef等 预处理器将所有的#define删除，并且展开所有的宏定义 删除所有的注释 添加行号和文件标识，以便编译错误时提供错误或警告的行号 保留所有#pragma编译器指令 shell gcc -E -o hello.i hello.c 编译阶段 (-S，得到.s文件) 将预处理后的file.i文件进行语法词法分析，翻译成文本文件file.s shell gcc -S -o hello.s hello.i 汇编阶段 (-c，得到.o文件) 得到二进制机器码文件，生成各个段，生成符号表 shell gcc -c -o hello.o hello.s 链接阶段 (gcc file.o) 将链接文件链接到file.o文件中 静态链接：内存开销大，速度快。将所有需要的函数的二进制代码拷贝到可执行文件中去 动态链接：内存开销小，速度慢。不需要将所有需要的函数的二进制代码拷贝到可执行文件中去，而是记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统将这些动态库加载到内存中，然后当程序运行到指定代码时，去共享执行内存中找到已经加载动态库可执行代码，最终达到运行时链接的目的 shell gcc -M hello.c 打印hello.c的依赖 gcc -M -MF hello.d hello.c 输出hello.c的依赖到hello.d文件内 gcc -c -o hello.o hello.c -MD -MF hello.d 编译hello.c并输出依赖到hello.d文件 为了防止编译大型项目后再对其中某一个文件修改而重新编译整个系统，可以采用先编译大型项目中的文件，最后再链接 使用include\"文件\"代表去当前目录下查找库文件 使用include\u003c文件\u003e代表去工具链目录下查找库文件 静态库以.a结尾，动态库以.so结尾 ","date":"2024-01-23","objectID":"/posts/linux-basics/:3:1","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#编译过程"},{"categories":["Tech"],"content":" Makefile 如何判断哪个文件被更改了？ 比较源文件与输出文件的时间，如果源文件修改更新的话，那就意味着源文件已经被修改了 makefile #makefile核心：规则 #目标：依赖1 依赖2... #[TAB]命令 #下列目标文件test由a.o b.o链接生成 test:a.o b.o gcc -o test a.o b.o #-c代表编译但不链接 a.o:a.c gcc -c -o a.o a.c b.o:b.c gcc -c -o b.o b.c 通配符： *： 任意字符，但对于目标文件，优先使用%代替* $：取值 @：目标值，@后加shell命令可以不显示命令但输出结果 $@：目标文件 $\u003c：第一个依赖文件 $^：所有依赖文件 $(shell 命令)可以执行shell命令 假想目标文件：.PHONY 用于当目标文件与make命令重名时使用，用法：在makefile文件末尾加上.PHONY: 命令 A = xxx 变量赋值 $(A) 变量取值 = 延时变量，makefile分析完成整个文档后才会对变量赋值，没有写程序时的类似顺序执行的逻辑 := 即时变量，类似写程序时的顺序执行的关系，需要在当前行之前声明定义变量 ?= 在此行之前就已经定义变量时该语句无效，类似#ifndef += 附加，并不是加，是延时变量还是即时变量取决于前文 $(foreach var,list,text) 在list中的每一个var，都换为text $(filter pattern,text) 在text中取出符合pattern的值 $(filter-out pattern,text) 在text中取出不符合pattern的值 $(wildcard pattern) 在已存在的文件中取出符合pattern的值 $(patsubst pattern,replacement,$(var)) 在var中取出符合pattern的值，并替换为replacement CFLAGS 这个变量可以后加gcc的编译选项 ","date":"2024-01-23","objectID":"/posts/linux-basics/:4:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#makefile"},{"categories":["Tech"],"content":" 文件IO和标准IOLinux是参照Unix制作出来的，为了使App能够在Linux与Unix上都能运行，Linux就需要实现与Unix相同的接口，这套接口统称为POSIX接口(posix Portable Operating System Interface for uniX)，任何支持POSIX标准的操作系统都支持文件IO 文件IO，IO函数包括read/open/write，每次调用的时候都会直接进入内核，实现了POSIX接口的APP可以在Linux，Unix上运行 标准IO，IO函数包括fread/fopen/fwrite，是为了解决App读写数据时频繁进入内核而诞生的，通过App自身的buffer来减少访问内核的次数从而提高效率，标准IO是从POSIX接口封装出来的，标准IO函数包括fread/fopen/fwrite。同时，如果使用了标准IO开发App，经过编译后还可以Windows上运行 文件IO的内部原理是：open，read等函数在访问文件资源时，需要从用户空间转移到内核空间，此时函数的内部实现会抛出异常，也就是触发软中断，将svc或swi设置为0，对应的异常编号会放在R7寄存器(arm64架构放在R8)，而后转到内核，内核获取R7寄存器的值并调用sys_call_table处理异常，这样当CPU可移植性对应的异常处理代码 glibc将文件IO封装出了fread/fopen/fwrite，不仅自带缓冲区，更可以增加代码移植性 2024-01-27_22-22 文件0代表stdin，scanf等操作产生的信息将会发送到此处 文件1代表stdout，printf等操作产生的信息将会发送到此处 文件2代表stderr，perror等操作产生的信息将会发送到此处 文件3代表文件句柄信息 警告 如果用同一个open程序打开不同的文件，返回的文件操作符有可能相等，为什么不会造成冲突？ 即使文件操作符相等，但是open程序处理的文件也处于不同的进程且有独立的进程号，因此有不同的文件句柄空间，这样，文件操作符相等也没有关系。当不同的句柄指向同一个文件结构体时，这两个句柄也不会相互干扰，例如一个文件中内容是123，同一个进程读两次这个文件每次读一个字符时，由于两次读文件返回的是不同的句柄，指向file结构体中的f_pos彼此独立，这样读两次的内容分别为1，1，而不是1，2。若想文件句柄相互关联，可以使用dup(fd)函数复制某个文件句柄，这样，对应句柄指向的file结构体中的f_pos也会被复制下来，于是可以读出1，2了。下图更详细的介绍了文件IO的内部机制 2024-01-27_22-56 内核中有task结构体，其中包含了files结构体，files内还有fdt(fdtable)结构体，fdt内部有fd数组，这个数组储存了文件操作符与文件的关系，fd中每个元素都指向了一个file结构体，该结构体可能来自同一份物理文件也可能来自不同的物理文件，前者代表使用open打开了同一个文件，后者代表使用open打开了不同的文件，每当使用open时都会构建一个新的file结构体并将其地址放入fd并分配一个整数的文件操作符(萨恒温的0，1，2…)，这样在不同task内即使fd的值相同，所指向的文件也会不同 ","date":"2024-01-23","objectID":"/posts/linux-basics/:5:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#文件io和标准io"},{"categories":["Tech"],"content":" open函数具体open函数用法和原理见 man 2 open c /* 打开文件名为argv[1]的文件，以读写模式打开(O_RDWR)，如果没有这个文件就创建这个文件(O_CREAT)，如果文件存在，且权限是读写的话就清空文件(O_TRUNC)，设置文件访问权限为664 */ fd = open(argv[1],O_RDWR | O_CREAT | O_TRUNC, 0664); //0代表8进制 ","date":"2024-01-23","objectID":"/posts/linux-basics/:5:1","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#open函数"},{"categories":["Tech"],"content":" write函数相关函数均可以 man 2 fun c /* 文件指针移到当前位置之后的第9个字符，打开文件时，默认指针位于文件开头 */ lseek(fd, 9, SEEK_SET); /* 对fd文件写not字符串，3为写字符串的长度，第二个参数也可以是argv，这样的话长度使用strlen()来获取 */ write(fd, \"not\", 3); /* 上面的结果是覆盖写 */ ","date":"2024-01-23","objectID":"/posts/linux-basics/:5:2","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#write函数"},{"categories":["Tech"],"content":" read函数 c /* 对文件读sizeof(buf)-1个内容，并存在buf中 */ read(fd, buf, sizeof(buf)-1); 当读一个文件时，是从f_pos位置开始读的，f_pos由内核维护，每读一次文件都会更新f_pos的值 ","date":"2024-01-23","objectID":"/posts/linux-basics/:5:3","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#read函数"},{"categories":["Tech"],"content":" dup函数 c /* 将文件句柄复制一份 */ new_fd = dup(fd) 使用dup后，文件句柄被复制，对应的f_pos也被复制，下次使用new_fd打开文件时，文件指针就是f_pos的位置 c /* 将old_fd重定向到new_fd，使用dup2后，可以将new_fd的io重定向到old_fd */ dup2(old_fd, new_fd) /* 可以将stdin重定向到1.txt中，这样在shell内打印的结果就不会显示，而是输出到1.txt */ dup2(1_txt_fd,1) ","date":"2024-01-23","objectID":"/posts/linux-basics/:5:4","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#dup函数"},{"categories":["Tech"],"content":" framebufferbpp(bits per pixel) framebuffer是一个由驱动程序分配的在内存中的一段区域，其中存储了每个像素的颜色，具体由LCD的硬件控制器实现，值得注意的是写framebuffer到LCD执行会有一定的延迟，尽管肉眼看不到 framebuffer有不同的bpp(bits per pixel)，一般而言有以下几种 2024-01-28_11-12 由于framebuffer由驱动掌管，因此读写framebuffer时需要使用mmap函数映射到用户空间 如果将32bit的像素转换为16bit的像素，则需要将RGB三条通道中8位数据的高n位保留，舍弃掉低(8-n)位。舍弃低位的原因是，高位保留了主要的颜色信息，低位保留细节，而人眼对细节不敏感 ","date":"2024-01-23","objectID":"/posts/linux-basics/:6:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#framebuffer"},{"categories":["Tech"],"content":" fork调用fork只进行页表项的拷贝，对于物理地址的拷贝放在cow时 fork执行的时候，会有两个返回值，一个是父进程的返回值，一个是子进程的返回值 在父进程中fork的返回值是子进程的PID 在子进程中fork的返回值是0 fork失败，返回值为-1 c #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e int main(int argc, char *args[]) { pid_t id = fork(); if (id \u003e 0) printf(\"father id = %d\\n\", id); else printf(\"son id = %d\\n\", id); return 0; } //结果如下 [negivup@negivup mycode]$ gcc -o main main.c [negivup@negivup mycode]$ ./main father id = 12467 [negivup@negivup mycode]$ son id = 0 ","date":"2024-01-23","objectID":"/posts/linux-basics/:7:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#fork调用"},{"categories":["Tech"],"content":" 文本及图像显示","date":"2024-01-23","objectID":"/posts/linux-basics/:8:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#文本及图像显示"},{"categories":["Tech"],"content":" 文本显示文本显示 = 编码 + 字体 ASCII定义了128个字符，因此在第7bit位上始终为0 ASNI由Windows提出，包含了ASCII，根据7bit位是否为0来判断该字是否为ASCII，若不为ASCII，则需要使用两个字节表示一个字，并且之后还需要选定字符集 Unicode不需要判断字符集，主要分为UTF-16 和 UTF-8两种，UTF-16根据大小端模式分为2种，两种编码方式效率都比UTF-8低，因此主流使用UTF-8编码 对于UTF-8，内部保存了长度信息，因此即使某部分字节信息丢失也不会影响整体信息 2024-01-28_11-58 若要显示矢量位图文字，需要使用freetype库，注意编译freetype时还需要freetype的依赖 ","date":"2024-01-23","objectID":"/posts/linux-basics/:8:1","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#文本显示"},{"categories":["Tech"],"content":" Linux应用输入系统编程的四种方式 对于Linux来说，输入设备多种多样，Linux把所有的输入设备的输入数据处理成3种： type：哪类事件？比如EV_ABS类 code：哪个操作？比如ABS_X value：值 2024-01-28_16-08 内核中使用input_event结构体来上报三种数据，除此之外，结构体还有时间信息 2024-01-28_16-09 当type，code，value都为0时，代表已经获得了完整的数据，也称为同步事件，同步事件用来分隔普通事件 输入系统支持的API操作：阻塞，非阻塞，poll/SELECT，异步通知 ","date":"2024-01-23","objectID":"/posts/linux-basics/:9:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#linux应用输入系统编程的四种方式"},{"categories":["Tech"],"content":" 阻塞非阻塞方式访问硬件默认文件API是阻塞执行的，除非在调用时指定 O_NONBLOCK，当阻塞执行时，任务收不到数据将会不断的查询，直至硬件产生数据，当非阻塞方式访问硬件资源时，任务如果得不到硬件数据就会休眠，直至内核将其唤醒 c if (argc == 3 \u0026\u0026 !strcmp(argv[2], \"noblock\")) { fd = open(argv[1], O_RDWR | O_NONBLOCK); } ","date":"2024-01-23","objectID":"/posts/linux-basics/:9:1","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#阻塞非阻塞方式访问硬件"},{"categories":["Tech"],"content":" poll/SELECT方式访问硬件APP主动访问硬件数据的通信方式，与阻塞非阻塞方式的区别是poll函数支持超时时间。如果APP没有获得数据时就会休眠等待，直至超时时间耗尽返回错误。最后，poll函数还可以监测多个文件 poll与select区别在于，select单个进程的连接数有限制，由FD_SETSIZE宏定义，而poll由链表实现，对于连接数没有限制 c struct input_event event; //存放ioctl获得的数据 struct pollfd fds[1]; nfds_t nfds = 1; ... while (1) { fds[0].fd = fd; fds[0].events = pollIN; //想要在硬件中读取数据 fds[0].revents = 0; //存放poll函数的返回值 ret = poll(fds, nfds, 5000); //5000为超时时间 /* 检查poll是否为不超时的返回 */ if (ret \u003e 0) { /* 检查返回事件是否是预期的pollIN事件 */ if (fds[0].revents == pollIN) { while (read(fd, \u0026event, sizeof(event)) == sizeof(event)) { printf(\"get event: type = 0x%x, code = 0x%x, value = 0x%x\\n\", event.type, event.code, event.value); } } } else if (ret == 0) { printf(\"time out\\n\"); } else { printf(\"poll err\\n\"); } } ","date":"2024-01-23","objectID":"/posts/linux-basics/:9:2","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#pollselect方式访问硬件"},{"categories":["Tech"],"content":" 异步通知硬件产生数据了主动通知APP的通信方式被称为异步通知，由于数据是异步发送的，因此我们需要解决以下问题：谁来发，用什么发，发给谁，发之后怎么做，什么时候发，需不需要发 通知流程： 编写信号处理函数，当硬件给APP发消息时会自动执行此函数(发之后怎么做) 注册信号处理函数，使用signal函数在内核中注册信号处理函数(用什么发) 打开驱动设备(谁来发) 把自己的进程ID告诉驱动，这样驱动才能通知指定APP(发给谁) 使能驱动FASYNC位，此位控制驱动是否应该发送消息给应用(什么时候发，需不需要发) c void my_sig_handler(int sig) { /* Todo */ } int main() { /* 注册信号处理函数 */ signal(SIGIO, my_sig_handler); /* 打开驱动程序 */ fd = open(argv[1], O_RDWR | O_NONBLOCK); /* Todo */ /* Todo */ /* Todo */ /* 把APP的进程号告诉驱动程序 */ fcntl(fd, F_SETOWN, getpid()); /* 将FASYNC位置为，使能\"异步通知\" */ flags = fcntl(fd, F_GETFL); fcntl(fd, F_SETFL, flags | FASYNC); } ","date":"2024-01-23","objectID":"/posts/linux-basics/:9:3","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#异步通知"},{"categories":["Tech"],"content":" IO操作的处理方式只有同步才分阻塞非阻塞，非阻塞指的是当进行数据交换时才阻塞，而等待数据交换时为非阻塞。阻塞指的是全过程都阻塞 异步不分阻塞非阻塞(他本身就是非阻塞的) 2024-03-31_10-58 根据上图我们可以总结如下几点内容： 前四种都属于同步io 第一种是阻塞式的，除非数据到来，否则会始终阻塞程序 第二种是非阻塞的，当要获取的数据不在时就直接返回错误，但我们很少使用这点，所以非阻塞式io常与poll/select或异步通知相结合，图中就是与poll/select结合的过程 第三种是io复用，其原理是内核将多个fd或者请求聚合然后进行轮询(这也是对poll减介绍时说的poll函数还可以监测多个文件的含义)，直到接受新的数据，此时内核会通知对应的进程，注意，当进程处理数据时其过程可能会使用read/write，因此仍然可能是阻塞的 第四种是异步通知，尽管名字中含有异步，但在信号处理函数中的read/write还是有可能造成阻塞 第五种是纯粹的异步io，不会阻塞 ","date":"2024-01-23","objectID":"/posts/linux-basics/:9:4","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#io操作的处理方式"},{"categories":["Tech"],"content":" 网络编程本文主要讲解TCP与UDP编程，其他网络编程可自行查找资料 TCP是一种可靠的，有连接的网络通信方式，UDP是一种不可靠的，无连接的网络通信方式，相比UDP，TCP会检查双方通信数据是否送达，若不送达还会进行等待操作，对延迟敏感的可能需要考虑是否使用TCP传输数据 ","date":"2024-01-23","objectID":"/posts/linux-basics/:10:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#网络编程"},{"categories":["Tech"],"content":" TCP编程 服务器 客户端 int socket(int domain, int type,int protocol); socket的返回值类似句柄，它负责表明通讯所需要的协议族及协议，函数内需要填入domain（通讯协族），type（通讯协议），protocol（由于通讯协议已经指定了，因此此处可以填0） int socket(int domain, int type,int protocol); 用法及参数同服务器 int bind(int sockfd, struct sockaddr *server_addr, int addrlen); bind负责连接socket产生的句柄和服务器参数的信息，比如在server_addr结构体内传入端口，ip，协议族信息 int listen(int sockfd,int backlog); listen负责监听端口是否被访问，它需要bind之后的socket文件描述符，而backlog指的是最多允许多少个客户端连接端口 int accept(int sockfd, struct sockaddr *addr,int *addrlen); accept负责接收客户端的连接请求，addr填入空的客户端结构体的地址，这样服务器才能存放客户端connect的具体信息 int connect(int sockfd, struct sockaddr * serv_addr,int addrlen); connect负责连接服务器，sockaddr填入客户端结构体的地址，这样才能让服务器知道连接的客户端的具体信息 ssize_t recv(int sockfd, void *buf, size_t len, int flags); recv负责接收客户端数据，它需要一个buf来存储数据，len可以使用strlen来获取，flag一般填0 ssize_t send(int sockfd, const void *buf, size_t len, int flags); 用法及参数类似服务器 当多个客户端链接一个服务器时，只要客户端访问的是相同的应用程序，那么他们都会从相同的端口进入(80，8080或21等)，随后被分到不同的线程进行处理，这之后区分他们的是不同的accept套接字而不是socket套接字，下面是示例代码： c #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e int main() { // 1. 创建监听套接字（仅1次） int server_fd = socket(AF_INET, SOCK_STREAM, 0); // 2. 绑定IP和端口（仅1次） struct sockaddr_in addr = { .sin_family = AF_INET, .sin_port = htons(8080), .sin_addr.s_addr = INADDR_ANY // 0.0.0.0 }; bind(server_fd, (struct sockaddr*)\u0026addr, sizeof(addr)); // 3. 开始监听（仅1次） listen(server_fd, 5); // 4. 循环接受客户端连接（N次） while (1) { int client_fd = accept(server_fd, NULL, NULL); // 新客户端连接成功，用 client_fd 通信 // （通常这里会 fork() 或创建线程处理） } } ","date":"2024-01-23","objectID":"/posts/linux-basics/:10:1","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#tcp编程"},{"categories":["Tech"],"content":" UDP编程 服务器 客户端 int socket(int domain, int type,int protocol); 同TCP int socket(int domain, int type,int protocol); 用法及参数同服务器 int bind(int sockfd, struct sockaddr *server_addr, int addrlen); 同TCP ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); 由于TDP是非连接型网络通讯协议，因此不需要listen和accept函数，但是向服务器传输数据时必须指明客户端的ip地址，因此在接收数据时，服务器需要定义一个struct sockaddr *src_addr结构体来储存客户端的本机ip，端口等信息 ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen); 用法及参数类似服务器 由于没有accept，udp依赖客户端ip地址+端口号来标识一个唯一\"连接\" ","date":"2024-01-23","objectID":"/posts/linux-basics/:10:2","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#udp编程"},{"categories":["Tech"],"content":" 多线程编程在Linux中，调度的单位是线程，资源分配的单位是进程 互斥量用于多线程中临界资源的互斥访问，不能控制线程执行的先后顺序 信号量用于多线程中程序先后执行顺序的控制 c /* 创建线程(用户态，依赖glibc) */ int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg); /* 线程主动退出 */ void pthread_exit(void *retval); /* 线程被动退出 */ int pthread_cancel(pthread_t thread); /* 线程资源回收(阻塞方式)，即使用上面两个函数后，调用此函数会回收系统分配给这个线程的资源，并获得线程的返回值，该返回值标记了线程的状态 */ int pthread_join(pthread_t thread, void **retval); /* 线程资源回收(非阻塞方式) */ int pthread_tryjoin_np(pthread_t thread, void **retval); /* 初始化互斥量 */ int pthread_mutex_init(phtread_mutex_t *mutex, const pthread_mutexattr_t *restrict attr); /* 互斥量加锁/解锁 */ int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); /* 互斥量加锁(非阻塞方式) */ int pthread_mutex_trylock(pthread_mutex_t *mutex); /* 互斥量销毁(非阻塞方式) */ int pthread_mutex_destory(pthread_mutex_t *mutex); /* 初始化信号量 */ int sem_init(sem_t *sem,int pshared,unsigned int value); /* 信号量 P/V 操作(默认为阻塞操作) */ int sem_wait(sem_t *sem); int sem_post(sem_t *sem); /* 信号量申请(非阻塞方式) */ int sem_trywait(sem_t *sem); /* 信号量销毁 */ int sem_destory(sem_t *sem); /* 创建和销毁条件变量 */ int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);//cond_attr 通常为 NULL int pthread_cond_destroy(pthread_cond_t *cond); /* 等待条件变量 */ int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);//需要与互斥锁共同使用 pthread_mutex_lock(\u0026g_tMutex); // 如果条件不满足则,会 unlock g_tMutex // 条件满足后被唤醒,会 lock g_tMutex pthread_cond_wait(\u0026g_tConVar, \u0026g_tMutex); /* 操作临界资源 */ pthread_mutex_unlock(\u0026g_tMutex); /* 通知条件变量 */ int pthread_cond_signal(pthread_cond_t *cond); ","date":"2024-01-23","objectID":"/posts/linux-basics/:11:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#多线程编程"},{"categories":["Tech"],"content":" 条件变量与信号量条件变量与信号量的区别： 条件变量的主要用途在于线程间的通知/等待机制，而信号量的主要用途在于控制并发访问数量 信号量必须搭配互斥锁使用，否则会造成竞态条件，信号则不必 使用条件变量可以一次唤醒所有等待者，而信号量不能 信号量始终有一个值（状态），而条件变量是没有值的 信号量的意图在于进程间同步（也可以用在线程间同步），条件变量只能用于线程间同步 信号量可以构成互斥锁（二值信号量），所有条件变量的地方都可以使用信号量替换，但这大大增加了程序复杂度，这是因为尽管可以通过信号量实现条件变量，但大部分操作系统没有这么实现，而是使用了更加底层的futex（快速用户态互斥锁）来实现条件变量，保证其效率 下面是条件变量与互斥锁的使用： c #include \u003cpthread.h\u003e #include \u003cstdio.h\u003e pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; pthread_cond_t cond = PTHREAD_COND_INITIALIZER; int buffer = 0; // 共享缓冲区 void* producer(void *arg) { for (int i = 0; i \u003c 5; i++) { pthread_mutex_lock(\u0026mutex); buffer = i; // 生产数据 printf(\"Producer: produced %d\\n\", buffer); pthread_cond_signal(\u0026cond); // 通知消费者 pthread_mutex_unlock(\u0026mutex); sleep(1); // 模拟生产耗时 } return NULL; } void* consumer(void *arg) { for (int i = 0; i \u003c 5; i++) { pthread_mutex_lock(\u0026mutex); while (buffer == 0) { // 缓冲区为空，等待 pthread_cond_wait(\u0026cond, \u0026mutex); // 释放锁并阻塞 } printf(\"Consumer: consumed %d\\n\", buffer); buffer = 0; // 消费数据 pthread_mutex_unlock(\u0026mutex); } return NULL; } int main() { pthread_t tid_producer, tid_consumer; pthread_create(\u0026tid_producer, NULL, producer, NULL); pthread_create(\u0026tid_consumer, NULL, consumer, NULL); pthread_join(tid_producer, NULL); pthread_join(tid_consumer, NULL); pthread_mutex_destroy(\u0026mutex); pthread_cond_destroy(\u0026cond); return 0; } ","date":"2024-01-23","objectID":"/posts/linux-basics/:11:1","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#条件变量与信号量"},{"categories":["Tech"],"content":" 串口编程UART共有4根线，RX，TX，GND，VCC，默认情况下是低位先行 TTL电平为0V~5V或0V~3.3V，RS232为-3V~-15V（代表1）和+3V~+15V（代表0），RS485为-2V~-6V（代表0）和+2V~+6V（代表1），在转换时不仅仅是买个转接口，还需要注意是否购买电平转换芯片 开发板UART发送数据流程： 开发板从内存中读入数据，并将数据载入串口FIFO 移位寄存器从FIFO中获得数据，将数据通过TX口发送出去 ","date":"2024-01-23","objectID":"/posts/linux-basics/:12:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#串口编程"},{"categories":["Tech"],"content":" TTYtty(teletype，电传机)，以前电脑庞大又昂贵，多个科研院所通过多个硬件终端(tty)共用一台计算机。随着科技发展，现在的计算机可以通过一台硬件终端(键鼠+显示器)来模拟多个虚拟终端 tty0代表位于前台的那个终端，因此，只要将信息发给tty0，无论位于哪个tty，都会收到信息 在当前shell中访问/dev/tty就可以知道当前shell使用的是哪个tty 由于历史原因，现在的UART驱动程序都放在了tty中 2024-01-30_11-28 console(控制台)，可以理解为权限更大的终端 当PC机发送lsa+退格键+回车键命令给arm板时，首先l通过UART被发送给arm板的UART，而后经过UART Driver处理后发送给line discipline(行规范)，可以将行规范理解为一个缓冲区，行规范发现l是一个普通字符，于是开发板将l保存在缓冲区中并回显给PC机：首先由行规范将l发送给UART Driver，而后由UART Driver处理将l通过UART发送给PC机，再经由PC机的UART Driver处理后发送给屏幕，此时完成回显。s，a字符同理，但PC当发送退格键时，开发板的行规范层会发现退格不是普通字符，而是转义到退格操作，于是开发板执行退格操作，将缓冲区的a字符清除，之后再次回显到PC。最后当PC发送回车键时，行规范再次转义到回车操作，随后将缓冲区的所有数据发送给开发板的APP(此时是shell)，由shell解析命令并获得结果后通过串口将结果发送给PC机 需要注意的是，默认情况行规范会自动处理数据，在UART外接其他模块时(比如GPS)，需要将行规范的数据处理模式改为RAW，默认不处理数据，并且还要设置一有数据就返回 2024-01-30_11-52 ","date":"2024-01-23","objectID":"/posts/linux-basics/:12:1","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#tty"},{"categories":["Tech"],"content":" I2C编程i2c高位先行 写操作由7位地址位+1位读写方向位构成，读写方向位中0代表写，1代表读 为了防止主从设备一个输出高电平一个输出低电平导致短路，且又因为主从设备均操控SDA，SCL，从而导致输出输入引脚频繁切换，因此i2c的采用了弱上拉结构 一旦设备接收到信息了，那么就意味着设备需要驱动三极管使上拉电阻接地，这样ACK信号永远是低电平信号 Linux中，主设备使用i2c_adapter结构体表示，里面保存了需要的传输函数，以及自己位于第几条i2c总线，从设备使用i2c_client结构体表示，里面保存了设备地址，需要与主设备的第几条总线连接，传输时使用i2c_meg结构体保存传输数据，里面有从机地址，数据的buf等数据 2024-03-08_10-28 2024-03-08_10-16 2024-03-08_10-42 在I2C通讯中，从硬件上来说每个I2C芯片都有若干个I2C Controller(I2C Bus)，与之对应的我们在软件上需要实现若干个adapter(也可以用gpio模拟i2c实现)，但是不同的i2c协议的设备需要与之对应的通讯规则(读取某个寄存器代表开始传输，而这与设备相关)，因此对于at24芯片来说，我们还要实现与之对应的驱动，这在上图中来说就是I2C Device Driver层。I2C Controller Driver层与I2C Device Driver层之间的Core层由内核实现，简便了我们对应用程序的编写 驱动调用关系： c i2c_client addr i2c_adapter nr i2c_algorithm master_xfer 内核中有两种使用i2c驱动的方式，一种是用户态访问，典型的是i2c-tools和i2c_dev驱动，前者是工具集，后者是内核给应用层暴露的接口。第二种是通过内核i2c驱动访问，这常用于依赖i2c驱动的其他驱动，例如i2c的存储设备(还需要块设备驱动支持)，这样在i2c的块设备的驱动中就可以直接调用i2c接口了，并且是内核态接口，有着更高的效率 ","date":"2024-01-23","objectID":"/posts/linux-basics/:13:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#i2c编程"},{"categories":["Tech"],"content":" SMB协议SMB协议是i2c的子集 相比i2c，协议增加了 对电压的规定： I2C 协议：范围很广，甚至讨论了高达 12V 的情况 SMBus：1.8V~5V 最小时钟频率、最大的 Clock Stretching(某个设备需要更多时间进行内部的处理时，它可以把 SCL 拉低占住 I2C 总线，规定 Clock Stretching可以防止死锁) I2C 协议：时钟频率最小值无限制，Clock Stretching 时长也没有限制 SMBus：时钟频率最小值是 10KHz，Clock Stretching 的最大时间值也有限制 地址回应 I2C 协议：没有强制要求必须发出回应信号 SMBus：强制要求必须发出回应信号，这样对方才知道该设备的状态：busy，failed，或是被移除了 重复起始条件 I2C 协议：读写寄存器时，需要发送停止信号p，再发送起始信号s SMBus：规定了重复起始条件，节省了重复操作 SMBus有低功耗版本 Linux推荐使用SMBus，即使从设备缺少硬件支持，Linux也有软件模拟SMBus的功能 ","date":"2024-01-23","objectID":"/posts/linux-basics/:14:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#smb协议"},{"categories":["Tech"],"content":" Linux驱动开发基础","date":"2024-01-23","objectID":"/posts/linux-basics/:0:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#linux驱动开发基础"},{"categories":["Tech"],"content":" 驱动开发的原则只提供功能不提供策略，这意味着驱动开发只提供基础的查询，休眠唤醒，poll，寄存器封装等机制，但是对于这些函数怎么使用则由APP决定 ","date":"2024-01-23","objectID":"/posts/linux-basics/:1:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#驱动开发的原则"},{"categories":["Tech"],"content":" 驱动的框架实现驱动的步骤如下： 指定主设备号major，如果为0则代表让系统自动分配 实现具体驱动的相关函数，如open/read/write/close等操作，并将操作保留在file_operations结构体中 在设备初始化函数(也称为入口函数)中调用register_chrdev以及class_create函数注册设备并在sysfs下创建设备类，并调用device_create去寻找sysfs下的设备，若找到新设备那么就在/dev/下创建设备 在设备退出函数(也称为出口函数)中依次调用device_destroy，class_destroy，unregister_chrdev函数注销设备 准备其他信息如module_init，module_exit等函数来初始化第4步的函数，使用MODULE_LICENSE(\"GPL\");来表明协议(内核驱动强制开源，应用驱动可以不开源) 警告 驱动代码中没有主函数，并且编译时需要与内核一起编译 警告 对于与linux很相似的rtthread而言，register与unregister是将设备挂载到设备管理器的链表上或将其在设备管理器的链表上移除，但这一操作并不会申请或回收初始化设备时申请的内存空间。而unregister与destory是将设备完全从内存中移除，这个操作会申请或回收内存空间 ","date":"2024-01-23","objectID":"/posts/linux-basics/:2:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#驱动的框架"},{"categories":["Tech"],"content":" 最简单的LED驱动程序 2024-02-01_09-43 c dmesg | grep filename.c //可以获得在内核中打印的信息，用于检测驱动设备是否正常运行 对于读写硬件的驱动程序，具体操作如下 指定主设备号major，如果为0则代表让系统自动分配 实现具体驱动的相关函数，如open/read/write/close等操作，并将操作保留在file_operations结构体中，同时还需要将寄存器的读写操作在具体函数中实现 在设备初始化函数(也称为入口函数)中调用register_chrdev以及class_create函数注册设备并创建设备类，并调用device_create在/dev/下创建设备，并且还需要使用ioremap函数来映射硬件地址到虚拟地址中 在设备退出函数(也称为出口函数)中依次调用device_destroy，class_destroy，unregister_chrdev函数注销设备，并且还需要使用iounmap来解除映射 准备其他信息如module_init，module_exit等函数来初始化第4步的函数，使用MODULE_LICENSE(\"GPL\");来表明协议(内核驱动强制开源，应用驱动可以不开源) ","date":"2024-01-23","objectID":"/posts/linux-basics/:2:1","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#最简单的led驱动程序"},{"categories":["Tech"],"content":" 驱动设计的思想","date":"2024-01-23","objectID":"/posts/linux-basics/:3:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#驱动设计的思想"},{"categories":["Tech"],"content":" 面向对象file_opration结构体中有函数指针，可以使用指针来进行操作 ","date":"2024-01-23","objectID":"/posts/linux-basics/:3:1","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#面向对象"},{"categories":["Tech"],"content":" 分层 c /*************************在下层的驱动文件中定义，直接操作硬件*******************/ static struct led_operations board_demo_led_opr = { .num = 2, .init = board_demo_led_init,//这个结构体赋值了.h文件中的结构体，并将返回值付给了get_board_led_opr .exit = board_demo_led_exit, .ctl = board_demo_led_ctl, }; struct led_operations *get_board_led_opr(void) { return \u0026board_demo_led_opr; } /***********在.h文件中定义作为接口，上下层的驱动文件都要包含这个头文件***********/ struct led_operations { int num; int (*init) (int which); /* 初始化LED, which-哪个LED */ void (*exit) (int which); /* 取消初始化LED, which-哪个LED */ int (*ctl) (int which, char status); /* 控制LED, which-哪个LED, status:1-亮,0-灭 */ }; struct led_operations *get_board_led_opr(void); /*************************在上层的驱动文件中定义，注册驱动*******************/ struct led_operations *p_led_opr; p_led_opr = get_board_led_opr();//从.h文件中得到接口的地址 static int led_drv_open (struct inode *node, struct file *file) { int minor = iminor(node); p_led_opr-\u003einit(minor); } static ssize_t led_drv_write (struct file *file, const char __user *buf, size_t size, loff_t *offset) { struct inode *inode = file_inode(file); int minor = iminor(inode); /* 根据次设备号和status控制LED */ err = copy_from_user(\u0026status, buf, 1); p_led_opr-\u003ectl(minor, status); } //给Linux内核的fop函数 static struct file_operations led_drv = { .owner = THIS_MODULE, .open = led_drv_open, .read = led_drv_read, .write = led_drv_write, .release = led_drv_close, }; 驱动程序分为boarda.c，boardb.c，以及上层的drv.c，在前两者中，只进行寄存器和内存映射操作，是单片机的延续，后者是进行注册驱动等操作 ","date":"2024-01-23","objectID":"/posts/linux-basics/:3:2","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#分层"},{"categories":["Tech"],"content":" 分离除了上下层分层外，有的复杂驱动还需要同层分离，比如对于某种主板来说，尽管LED会有不同，但是芯片是只有一种的，因此对于不同的LED需要一个resource.h文件来管理具体LED寄存器，而board.c文件则需要负责将这些管理好的寄存器进行配置和高级的封装，并将函数在和结构体在resource.h文件声明，日后chip.c会直接调用resource.h的函数和结构体声明 ","date":"2024-01-23","objectID":"/posts/linux-basics/:3:3","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#分离"},{"categories":["Tech"],"content":" 总线设备驱动模型为了解决设备和驱动资源的相互关系，更好的解耦两者，Linux推出了Bus(虚拟总线)机制，设备会在内核中注册platform结构体，这个结构体会通过platform_device被挂载到设备链表上，驱动程序也有类似操作，最终会通过platform_driver被挂载到驱动链表上，两个链表由内核统一管理，根据在platform中注册的设备ID，名字等参数来耦合两者 ","date":"2024-01-23","objectID":"/posts/linux-basics/:4:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#总线设备驱动模型"},{"categories":["Tech"],"content":" 设备树驱动模型随着越来越多的设备加入了内核，即使使用总线设备驱动模型也难以让各个设备使用统一的接口来接入Linux，使得相似的驱动程序充斥着内核源码，为了解决这个问题，Linux推出了设备树 进入内核根目录后执行make dtbs即可编译设备树，在编译过程中，内核使用gcc将dtbs文件预处理，而后由内核中的脚本文件将预处理完成的文件转化为dtb文件 将修改的设备树挂载到设备上的操作： shell /* 进入Linux内核主目录 */ make dtbs /* 将生成的dtb文件拷贝到目标机器的/boot目录下 */ cp xxx.dtb ~/nfs/boot /* 重启目标设备 */ reboot /* 查看设备树是否更新,base为设备树的根节点 */ cd /sys/firmware/base 在设备树模型中，每个节点都会被内核构造成device_node，只有位于根节点下的子节点或者标明了compatile = \"xxxbus\"属性的父节点下的子节点才会有被转换成platform_device，在根节点下的I2C、SPI节点也会被转换成platform_device，但是I2C、SPI下的子节点不转换为platform_device，这是因为总线下的子节点应该交由对应的总线控制器(如I2C Controller)处理 在platform_driver中有of_match_table结构体，这个结构体中有compatible，执行probe操作时就是比较设备树的compatible与paltform_driver的compatible是否相同，若相同则将该driver注册进内核 警告 采用了设备树后我们应该怎么调用设备树里的资源呢？ 使用of_开头的函数就可以调用内核解析出来的设备树的资源了，这里的of代表open firmware，例如of_gpio_count，这是因为根节点被保存在全局变量 of_root 中,从 of_root 开始可以访问到任意节点 ","date":"2024-01-23","objectID":"/posts/linux-basics/:5:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#设备树驱动模型"},{"categories":["Tech"],"content":" Linux驱动输入系统编程的四种方式","date":"2024-01-23","objectID":"/posts/linux-basics/:6:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#linux驱动输入系统编程的四种方式"},{"categories":["Tech"],"content":" 查询方式 2024-02-02_18-30 查询方式是应用层使用open,read函数时调用驱动层的drv_open,drv_read来获得硬件接口状态 2024-02-04_15-55 ","date":"2024-01-23","objectID":"/posts/linux-basics/:6:1","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#查询方式"},{"categories":["Tech"],"content":" 休眠唤醒机制 2024-02-02_18-31 2024-02-04_15-58 2024-02-04_15-58_1 休眠唤醒机制需要在驱动层注册中断服务程序，当外部信号触发了驱动层时，会直接将获得的数据发送给应用层 首先需要初始化等待队列wq，这需要使用DECLARE_WAIT_QUEUE_HEAD宏来初始化任务队列，然后使用wait_event_interruptible宏完成核心的休眠操作，如果没有中断通过wake_up_interruptible函数发送信号程序就会一直休眠，对应的应用也会收到驱动的信号并休眠自己。当按键被按下触发中断函数时，中断会向驱动发送停止休眠的信号，而后驱动将数据由内核空间拷贝到用户空间 ","date":"2024-01-23","objectID":"/posts/linux-basics/:6:2","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#休眠唤醒机制"},{"categories":["Tech"],"content":" poll(轮询)机制 2024-02-02_18-31_1 2024-02-04_15-53 2024-02-04_15-54 在休眠唤醒机制的中断基础上又发展了poll机制，首先驱动层需要在fop中实现poll函数，当应用调用poll函数时会使用驱动层的drv_poll函数，如果在给定的超时时间内触发中断，则会将数据返回，没有数据则会休眠，如果超时时间内都没有触发中断，则在超时时间后程序也会被内核自动唤醒。需要注意的是，poll的超时时间并不是一次性的，而是每隔若干时间去查看是否有数据给APP ","date":"2024-01-23","objectID":"/posts/linux-basics/:6:3","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#poll轮询机制"},{"categories":["Tech"],"content":" 异步通知 2024-02-02_18-32 2024-02-02_18-41 2024-02-04_15-49 2024-02-04_15-52 对于异步通知来说，驱动层需要实现drv_fasync函数，这个函数中仅仅记录进程号，在应用层需要提供注册信号处理函数signal，当触发外部中断时，由内核统一接管，首先将触发中断的数据保存，然后从驱动程序获得给注册信号处理函数的程序的进程号，并发送kill_fasync信号(kill在Linux中就是发送信号的意思)给注册信号处理函数的程序，从而通知应用程序 异步通知时启动信号函数以及恢复现场的过程： 首先根据驱动程序所保存的PID找到进程在内核的task_struct结构体，修改里面的某些成员表示收到了信号 APP从内核态返回到用户态前，内核发现APP有信号在等待处理时，会修改APP的栈，增加一个新的“运行环境”，新环境里“运行地址”是信号处理函数的地址。这样，APP从内核态返回用户态时，运行的是信号处理函数。信号处理函数执行完毕后，会再次返回到内核态，在内核态里再使用旧的“运行环境”恢复APP的运行 警告 kill在Linux中就是发送信号的意思，使用的kill -9是将九号信号发给程序，也就是杀掉程序 2024-02-12_18-11 ","date":"2024-01-23","objectID":"/posts/linux-basics/:6:4","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#异步通知-1"},{"categories":["Tech"],"content":" 阻塞与非阻塞APP调用open函数时，传入O_NONBLOCK，就表示要使用非阻塞方式，默认是阻塞方式 警告 注意：对于普通文件、块设备文件，O_NONBLOCK 不起作用。这是因为普通文件和块设备文件都是非阻塞的，只要请求就一定会响应，而不是字符设备那样需要等待设备有数据，缓冲区满或者其他设备发送数据等需要不定时等待的情况。尽管普通文件、块设备文件可以随时响应，但是读写速度太慢了，因此我们需要异步io来让这两个文件设备的请求异步执行，从而实现上一个请求还没有完成时就可以执行下一个请求的高效率代码2025年7月5日 19:28:06 注意：对于字符设备文件，O_NONBLOCK起作用的前提是驱动程序针对O_NONBLOCK做了处理 ","date":"2024-01-23","objectID":"/posts/linux-basics/:7:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#阻塞与非阻塞"},{"categories":["Tech"],"content":" Pinctrl子系统由于接入设备过多，即使有数百的引脚的CPU也不能承受，此时就需要通用中断控制器(GIC)，由于此时的映射关系导致了若想知道是哪个外部设备引起的中断就必须经历CPU-\u003eGIC-\u003eGPIO-\u003e具体中断设备，这就要求了在设备树中应有多个cell来描述外部设备 2024-02-04_16-13 为了管理数量众多的引脚，不再频繁使用IOMUX和GPIO，Linux提供了Pinctrl子系统功能，使得可以在设备树中指定引脚资源 有的厂家，像NXP，会推出GUI的设备树代码生成软件 警告 给这些引脚引入Pinctrl功能的一定是对芯片特别熟悉的人，这些人就是BSP工程师，我们驱动工程师会使用即可，但是对于优秀的驱动工程师也需要能够实现Pinctrl功能 可以从设备树开始学习Pinctrl，在图片中，左侧称为controller，右侧称为client，两侧都处于同一个设备树文件中，controller可以根据client的需求将引脚划分为group，并根据功能划分function，尽管在芯片厂家中并不一定看到这两个关键字，但是思想是一样的。对于client来说，可以配置若干功能，在左侧的controller可以一一对应 2024-02-02_21-33 ","date":"2024-01-23","objectID":"/posts/linux-basics/:8:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#pinctrl子系统"},{"categories":["Tech"],"content":" 异常，中断与轮询中断与轮询的区别： 中断是CPU处于被动状态下来接受设备的信号，而轮询是CPU主动去查询该设备是否有请求 对于一个频繁请求CPU的设备，或者有大量数据请求的网络设备，那么轮询的效率比中断高 如果是一般设备，并且该设备请求CPU的频率比较低，则用中断效率要高一些 对于外界的可以屏蔽的信号来源，比如按键，定时器，网络报文等称为中断，对于无法屏蔽的信号来源，比如指令错误，内存访问错误等称为异常，中断属于异常中的一种 由于Linux任务调度的最小单位是线程，而资源分配的最小单位是进程，因此每个线程都有一个栈，每个进程都有公共资源，比如文件句柄，全局变量 中断流程 中断源发出信号，CPU被硬件设置为强制跳转到异常向量表中的某个异常向量的地址 在异常向量表中找到要执行的中断服务函数，跳转到那个函数 保存现场 执行中断服务程序 恢复现场 Linux为了防止中断多层嵌套后导致爆栈，因此不支持中断嵌套，但是Linux不支持中断嵌套会导致当某个中断服务程序执行时间过长使其他线程不能响应的问题，所以中断程序应该执行的越快越好，但是对于网卡这类需要在中断中读取大量数据的设备则无能为力，解决办法是中断分为上半部和下半部，在上半部分处理紧急的事务，在下半部分处理不那么紧急的事务，这个下半部分由软件中断实现，当执行完硬件中断后，系统会顺便执行软件中断，在软件中断中有标志位，用来识别这个硬件中断是否需要软件中断 当中断下半部耗时不是很长且中断服务程序较简单时，使用tasklet，但是tasklet并不支持与APP竞争，他的优先级始终高于APP 当下半部分耗时比较长时，由于中断下半部分属于软中断，优先级比APP高，会霸占CPU使得APP卡顿，这时就需要work来将中断下半部放入workqueue，使其成为内核线程以便与APP共同竞争 但是对于多核处理器来说，使用workqueue会造成一个workqueue中work数量过多，这不利于线程并行，因此又引入了threaded irq操作来将中断线程并行化 由于初始化tasklet后需要把tasklet放入内核链表，而运行taklet函数后会把tasklet从链表中删除，因此想要再次执行tasklet函数就需要再次调度 Linux中的内核线程是一个while(1)循环，里面是一个workqueue，驱动程序使用work相关函数将想要执行的函数放入workqueue时会唤醒内核线程，并执行放入的那个函数。但是这种做法有个缺点：当内核线程里有某个线程执行时间过长时会导致下一个线程执行不及时，解决办法是在内核中单开一个内核线程运行这个线程 2024-02-04_19-42 2024-02-15_11-05 ","date":"2024-01-23","objectID":"/posts/linux-basics/:9:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#异常中断与轮询"},{"categories":["Tech"],"content":" 定时器硬件定时器systick每次中断时就会触发内核中的jiffies加一，我们只要检测jiffies是否超过定时器结构体中的expires参数就能判断timer是否超时 timer定时器属于软件中断 c /* 初始化timer结构体 */ setup_timer(timer, fn, data) /* 将初始化的timer结构体加入timer链表中 */ void add_timer(struct timer_list *timer) /* 修改定时器的时间 */ int mod_timer(struct timer_list *timer, unsigned long expires) /* 删除定时器 */ int del_timer(struct timer_list *timer) ","date":"2024-01-23","objectID":"/posts/linux-basics/:10:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#定时器"},{"categories":["Tech"],"content":" ioremapioremap仅用于内核态，负责将寄存器的物理地址映射到内核的虚拟地址，用于内核态的驱动访问硬件 ","date":"2024-01-23","objectID":"/posts/linux-basics/:11:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#ioremap"},{"categories":["Tech"],"content":" mmap一般情况下，APP数据交换发生在用户态和内核态之间，但是当交换数据量较大时效率会很低，改进的方法是让APP直接读取驱动程序的buffer，这时可以使用mmap将用户空间虚拟内存映射到文件/设备内存，一般读写大文件如framebuffer时需要用到此函数 mmap由用户空间发起，通过内核修改用户空间程序的页表的PA将虚拟内存映射到用户空间。这样，用户空间就有了一块之前没有权限访问的虚拟内存，同时当需要操作大文件时不必在内核态多次复制，内核会自动进行零拷贝的操作。下面以磁盘的文件拷贝到用户空间为例展示具体过程： 未使用mmap时：文件从磁盘拷贝到内核页缓存(1次)，但是该过程由DMA实现，而后通过read/write等系统调用从内核页缓存拷贝到用户空间(2次)，但是这次需要CPU参与拷贝 使用mmap时：文件从磁盘拷贝到内核页缓存(1次)，依然由DMA实现，而后内核修改对应程序的页表，使得该程序能访问这块虚拟内存，整个过程无需CPU参与拷贝 为了保证大文件的堆管理效率，malloc空间大于128k时系统也会自动调用mmap ","date":"2024-01-23","objectID":"/posts/linux-basics/:12:0","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#mmap"},{"categories":["Tech"],"content":" 地址映射地址映射是MMU维护的，MMU的两大作用： 地址映射：在访问一个被执行两次的程序中的全局变量时，全局变量的地址是一样的，但是真实的物理地址一定不同，这是由MMU维护的 权限保护：CPU访问的硬件地址需要MMU审核后才可访问 2024-02-04_22-27 执行两次test后发现a的地址相同但值不同，这是因为CPU看到的是MMU给的虚拟地址，每一个进程都有其页表，这个局部描述表由内核维护且处于内核空间，每个进程自己的页表都有对应的虚拟地址与物理地址映射关系，因此虚拟地址可以重复 详解 2024-02-04_22-29 进程的空间由内核维护，具体的虚拟地址与物理地址映射关系放在了页目录表里，页目录表分为一级页目录表和二级页目录表，一级页目录表大小最小为1M，二级页目录表最小为1k，Linux下默认为4k，以下是通过查找页目录表来寻找物理地址的过程： CPU 发出虚拟地址 vaddr，假设为 0x12345678 MMU读取当前程序的页表基地址寄存器作为一级页表的起始地址，寄存器的值会根据进程的不同而不同，这也是现代页表管理机制的核心 MMU 根据 vaddr[31:20](0x123)找到一级页表项里的第123项，根据读取的[1:0]发现这是个一级页表项，从而获得section base address，假如为0xabc00000 将vaddr的剩下的[20:0]与section base address拼接找到偏移地址0xabc45678，此时为真实的物理地址 对于二级页表，由于二级页表是放在一级页表中的，因此首先查询一级页表： CPU 发出虚拟地址 vaddr，假设为 0x12345678 MMU读取当前程序的页表基地址寄存器作为一级页表的起始地址，寄存器的值会根据进程的不同而不同，这也是现代页表管理机制的核心 MMU 根据 vaddr[31:20](0x123)找到一级页表项里的第123项，根据读取的[1:0]发现这是个二级页表项，从而获得level 2 descriptor base address 使用level 2 descriptor base address找到二级页表的地址 根据vasddr的[19:12]找到二级页表的第45项，从而得到page base addr，假设为0xabc00000 将vaddr的剩下的[11:0]与page base addr拼接找到偏移地址0xabc00678，此时为真实的物理地址 2024-02-04_22-38 2024-02-04_23-15 为了保证数据能够尽快写入其他硬件，CPU应该绕过cache直接访问内存，有如下情况时应该使用这种方法： 读写寄存器时 读写framebuffer时 读写DMA控制的区域时 新数据由CPU写入cache的同时也从cache写入内存的方式叫做write through(写通) 新数据由CPU写入cache，但需要等数据满一章后再从cache写入内存的方式叫做write back(写回)，写回操作经过写缓冲器，其本质是个FIFO 2024-02-21_15-42 2024-02-05_13-49 ","date":"2024-01-23","objectID":"/posts/linux-basics/:12:1","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#地址映射"},{"categories":["Tech"],"content":" cache与写buffercache负责加速CPU读数据的效率，写buffer本质上是个FIFO，能提高cache写内存的效率 2024-02-13_11-12 ","date":"2024-01-23","objectID":"/posts/linux-basics/:12:2","series":null,"tags":["OS","Tech"],"title":"Linux基础","uri":"/posts/linux-basics/#cache与写buffer"},{"categories":["Tech"],"content":"本文较为详细地介绍了C++的语法和使用中可能遇到的坑，还介绍了STL库和Modern C++，例如C++20的部分新特性。在最后，我们大致的介绍了代码编写时常用的设计模式 ","date":"2024-01-14","objectID":"/posts/cpp/:0:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#"},{"categories":["Tech"],"content":" C++","date":"2024-01-14","objectID":"/posts/cpp/:0:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#c"},{"categories":["Tech"],"content":" 从C到C++","date":"2024-01-14","objectID":"/posts/cpp/:1:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#从c到c"},{"categories":["Tech"],"content":" 对象与实例 什么是对象？ 对象是类的具体化，类是对象的模板或蓝图。类定义了数据的结构（成员变量）和操作数据的方法（成员函数），但类本身并不占用内存 。对于那些重载函数操作运算符的类我们称为函数对象 什么是实例？ 实例是对象的另一个名称。一个类可以有多个对象，每个对象都是该类的一个实例 ","date":"2024-01-14","objectID":"/posts/cpp/:1:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#对象与实例"},{"categories":["Tech"],"content":" new和delete尽管C++11引入了智能指针，但是为了兼容老程序，new和delete的方法也应值得注意 C原生的melloc与free使用起来较为复杂，需要根据返回值来判断下一步做什么 C原生的melloc与free也只进行内存申请但不进行对象实例化，也就是说C仅仅返回内存地址的指针，而C++返回的是一块特定类型的指针 更重要的是C++在调用new时会自动执行对象的构造函数，C原生的melloc与free则不支持 在使用delete回收数组时需要告诉他数组的类型 cpp new int arr[10]; delete [] arr; template\u003ctypename T, typename U\u003e auto add2(T x, U y) -\u003e decltype(x+y){ //C++14已经支持auto自动推导模板函数返回值了，因此此处的 -\u003e decltype(x+y)可以省略 return x + y; } cpp //new和delete使用时需要加上数据类型 new int(10) //从堆区获取1个整型的空间，并赋值为10 int *p = new int[10] //从堆区获取10个整型的数组空间 delete [10] p //从堆区释放10个整型的数组空间 ","date":"2024-01-14","objectID":"/posts/cpp/:1:2","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#new和delete"},{"categories":["Tech"],"content":" 作用域运算符当在函数内需要访问全局变量时我们可以使用 ::全局变量 的方式访问，这在全局变量和局部变量名字冲突时会用到 ","date":"2024-01-14","objectID":"/posts/cpp/:1:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#作用域运算符"},{"categories":["Tech"],"content":" 命名空间为了在大型项目中管理符号与名称，C语言采用了static关键字，而C++采用了命名空间，这样在调用多个厂商的类库时就不会重名了 cpp namespace A { int a = 100; } namespace B { int a = 200; } int main() { cout \u003c\u003c A::a \u003c\u003c endl; } ","date":"2024-01-14","objectID":"/posts/cpp/:1:4","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#命名空间"},{"categories":["Tech"],"content":" using的使用使用using关键字后就可以不需要指定哪个命名空间的作用域了 cpp namespace A { int a = 100; } namespace B { int a = 200; } int main() { using namespace A cout \u003c\u003c a \u003c\u003c endl; } using还用于类型别名的声明，我们终于可以不用忍受蹩脚的typedef了 cpp using func_t = void (int); //或者这样 using func_t = void (*)(int); template\u003cclass T\u003e using Vec = vector\u003cT, Alloc\u003cT\u003e\u003e; // 类型标识为 vector\u003cT, Alloc\u003cT\u003e\u003e ","date":"2024-01-14","objectID":"/posts/cpp/:1:5","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#using的使用"},{"categories":["Tech"],"content":" 函数的别名我们可以使用typedef与using来给函数起别名 cpp #include \u003ciostream\u003e using func_t = void (int); void hello(func_t func3){ func3(6); } void func(int a){ std::cout \u003c\u003c a \u003c\u003c std::endl; } int main() { hello(func); return 0; } 实际上我们写成下面的形式也会过编译 cpp using func_t = void (int); void hello(func_t * func3){ func3(6); } //或者下面这样的 using func_t = void (*)(int); void hello(func_t func3){ func3(6); } //但就不能写成下面的的形式，这会报编译错误 error: cannot convert 'void (*)(int)' to 'void (**)(int) using func_t = void (*)(int); void hello(func_t * func3){ func3(6); } typedef也同理 cpp //下面3个没问题 typedef void(*func_t)(int); void hello(func_t func3){ func3(6); } typedef void(func_t)(int); void hello(func_t func3){ func3(6); } typedef void(func_t)(int); void hello(func_t * func3){ func3(6); } //这就有问题了 typedef void(*func_t)(int); void hello(func_t * func3){ func3(6); } ","date":"2024-01-14","objectID":"/posts/cpp/:2:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#函数的别名"},{"categories":["Tech"],"content":" .与::点号(.)用于访问类的实例的成员，而双冒号(::)用于访问类的静态成员，因此::前面的的一定是某个类或者某个命名空间 ","date":"2024-01-14","objectID":"/posts/cpp/:2:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#与"},{"categories":["Tech"],"content":" 引用 cpp int c = 20; int a = 10; int \u0026b = a; int \u0026b; //错误，引用必须初始化 int \u0026b = c;//错误，引用不能被更改 b = c; //正确，将c的值赋值给b所指向的内存 此时称b为a的别名，b与a操作的是同一块内存地址，因此可以通过b来修改a的值 ","date":"2024-01-14","objectID":"/posts/cpp/:3:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#引用"},{"categories":["Tech"],"content":" 引用作为函数参数 cpp void swap(int \u0026a, int \u0026b) //相当于形参引用了实参:int \u0026a = a; { int temp = a; int a = b; int b = temp; } int main() { int a = 10; int b = 20; swap(a, b); } ","date":"2024-01-14","objectID":"/posts/cpp/:3:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#引用作为函数参数"},{"categories":["Tech"],"content":" 函数调用可以作为左值 cpp int\u0026 left_call() { static int a = 10; return a; } int main() { left_call() = 1000; //相当于给a所引用的那块内存地址赋值 return 0; } ","date":"2024-01-14","objectID":"/posts/cpp/:3:2","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#函数调用可以作为左值"},{"categories":["Tech"],"content":" 引用的本质引用的本质是一个指针常量 cpp int a = 10; int \u0026ref = a; //int* const ref = \u0026a; int \u0026b = 10; //错误，10只是一个临时的寄存器变量，不是一个位于内存的持久化的左值 const int\u0026 b = 10; //正确，这样可以避免修改常量区 ","date":"2024-01-14","objectID":"/posts/cpp/:3:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#引用的本质"},{"categories":["Tech"],"content":" 函数","date":"2024-01-14","objectID":"/posts/cpp/:4:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#函数"},{"categories":["Tech"],"content":" 函数的默认参数 cpp int func(int a, int b = 10, int c = 20) //如果b已经有了默认参数，那么b之后的形参也必须要有对应的初值(在C++11后不做要求) { } 函数声明与实现只能有一个赋予默认参数初值，这是为了防止二义性 ","date":"2024-01-14","objectID":"/posts/cpp/:4:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#函数的默认参数"},{"categories":["Tech"],"content":" 函数重载函数重载条件： 同一个作用域下 函数名相同 函数参数类型不同，个数不同，顺序不同 但是返回值不能作为函数重载的条件 当碰到默认参数时函数重载可能会产生二义性 cpp int func(int a, int b = 10) { cout \u003c\u003c \"func(int a, int b = 10)\" \u003c\u003c endl; } int func(int a) { cout \u003c\u003c \"func(int a,)\" \u003c\u003c endl; } int main() { int a = 10; fun(a); //产生二义性，编译错误 return 0; } ","date":"2024-01-14","objectID":"/posts/cpp/:4:2","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#函数重载"},{"categories":["Tech"],"content":" 类和对象","date":"2024-01-14","objectID":"/posts/cpp/:5:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#类和对象"},{"categories":["Tech"],"content":" 权限管理 公共权限public: 类内可以访问，类外也可以访问 保护权限protected: 类内可以访问，类外不可以访问，子类可以访问 私有权限private: 类内可以访问，类外不可以访问，子类不可以访问 class中默认权限为private，struct默认权限为public 我们可以利用权限控制来对成员进行操作 cpp class person { public: string get_name() { return m_name; } void set_name(string name) { m_name = name; } int get_age() { return m_age; } void set_paaword(int pswd) { m_passwaord = pswd; } private: string m_name; //可读可写 int m_age = 18; //只读 int m_password = 123456; //只写 }； 这样就可以利用public的函数来控制private的成员了 ","date":"2024-01-14","objectID":"/posts/cpp/:5:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#权限管理"},{"categories":["Tech"],"content":" 构造与析构构造函数可以有参数，因此能发生重载，但构造函数没有返回值也不需要void。析构函数不可以有参数，因此不能发生重载 每当创建对象后会自动调用构造函数，当对象被销毁后会自动调用析构函数 cpp class person { public: person() { cout \u003c\u003c \"person的构造\" \u003c\u003c std::endl; } ~person() { cout \u003c\u003c \"person的析构\" \u003c\u003c std::endl; } }; int main() { person p; return 0; } 拷贝构造函数普通构造函数解决了成员的初值问题，但是当同一个类的某个对象需要另一个类的对象时就需要用到拷贝构造函数，拷贝构造函数与普通构造函数的区别在于参数，拷贝构造函数的参数是一个常量引用的类，因为我们不希望原类在拷贝时被修改，所以要加const修饰 cpp class person { public: person(const person \u0026p) { age = p.age; } }; int main() { person p1; //默认构造函数 person p2(10); //有参构造函数，person(10)为匿名对象 person p3(p2); //拷贝构造函数 person p4 = p3(p2); //重载()函数，假设已经实现了重载函数 } 调用默认拷贝构造函数时不要加\"()\"，这会使得编译器以为是函数的声明 产生匿名对象时，当执行完当前行时系统会回收这个匿名对象，但用一个临时变量接受匿名对象则会延长这个对象的生命周期 当进行下列操作时会调用对象的拷贝构造函数 使用已经初始化的对象来初始化另一个对象 将对象以值传递的方法给函数参数传参 对象以值传递的方式做函数返回值 如果我们已经提供了有参构造函数或者拷贝构造函数，那么编译器就不会提供默认构造函数，此时创建对象时必须加上参数，否则会报没有默认构造函数的错误。但编译器依然会提供拷贝构造函数 ","date":"2024-01-14","objectID":"/posts/cpp/:5:2","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#构造与析构"},{"categories":["Tech"],"content":" 构造与析构构造函数可以有参数，因此能发生重载，但构造函数没有返回值也不需要void。析构函数不可以有参数，因此不能发生重载 每当创建对象后会自动调用构造函数，当对象被销毁后会自动调用析构函数 cpp class person { public: person() { cout \u003c\u003c \"person的构造\" \u003c\u003c std::endl; } ~person() { cout \u003c\u003c \"person的析构\" \u003c\u003c std::endl; } }; int main() { person p; return 0; } 拷贝构造函数普通构造函数解决了成员的初值问题，但是当同一个类的某个对象需要另一个类的对象时就需要用到拷贝构造函数，拷贝构造函数与普通构造函数的区别在于参数，拷贝构造函数的参数是一个常量引用的类，因为我们不希望原类在拷贝时被修改，所以要加const修饰 cpp class person { public: person(const person \u0026p) { age = p.age; } }; int main() { person p1; //默认构造函数 person p2(10); //有参构造函数，person(10)为匿名对象 person p3(p2); //拷贝构造函数 person p4 = p3(p2); //重载()函数，假设已经实现了重载函数 } 调用默认拷贝构造函数时不要加\"()\"，这会使得编译器以为是函数的声明 产生匿名对象时，当执行完当前行时系统会回收这个匿名对象，但用一个临时变量接受匿名对象则会延长这个对象的生命周期 当进行下列操作时会调用对象的拷贝构造函数 使用已经初始化的对象来初始化另一个对象 将对象以值传递的方法给函数参数传参 对象以值传递的方式做函数返回值 如果我们已经提供了有参构造函数或者拷贝构造函数，那么编译器就不会提供默认构造函数，此时创建对象时必须加上参数，否则会报没有默认构造函数的错误。但编译器依然会提供拷贝构造函数 ","date":"2024-01-14","objectID":"/posts/cpp/:5:2","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#拷贝构造函数"},{"categories":["Tech"],"content":" 深拷贝与浅拷贝编译器默认的拷贝构造函数是浅拷贝的，这会导致在堆区申请的内存不会被拷贝，从而有多个指针指向这块堆区内存，每当调用一次拷贝构造函数后系统就会自动调用一次析构函数，而当所有对象都调用析构函数时就会导致同一块堆区被释放多次的错误，该错误也被称为double free 因此当申请堆区内存时我们不能使用默认的拷贝构造函数，我们应该自己实现一个拷贝构造函数，此时的拷贝构造函数应该一起把堆区内存复制了，此时我们称这种拷贝构造函数为深拷贝 cpp class person { public: person(const person \u0026p) { age = p.age; height = new int(*p.height); //实现了深拷贝 } ~person() { if(height) delete height; //析构函数也要进行处理 } }; ","date":"2024-01-14","objectID":"/posts/cpp/:5:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#深拷贝与浅拷贝"},{"categories":["Tech"],"content":" 类对象作为类成员当一个类中包含另一个类的对象时，我们称这个类对象为类成员。在构造过程中与c的结构体类似，首先会先构造类成员而后再构造本类。析构的顺序与构造相反，类似Linux驱动程序init和exit函数 空类耗费内存大小为1，空类也是对象，只要是对象就要在内存中占据一定的空间 ","date":"2024-01-14","objectID":"/posts/cpp/:5:4","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#类对象作为类成员"},{"categories":["Tech"],"content":" 静态成员与静态函数类中的变量使用static修饰时我们称其为静态成员变量，它有如下特点： 类内声明，类外初始化 所有对象共享同一份静态成员，这也意味着静态对象是属于类的而不是属于对象的 内存分配在编译期 cpp class person { static int a; }; int person::a = 10; 因为静态成员变量存储在全局区内，因此可以通过类名的方式访问，同时它也支持对象访问 静态成员变量也可以设置访问权限 静态成员函数和静态成员变量不属于某个对象，他们只属于这个类，因此可以通过类名进行访问 静态成员函数不能访问非静态变量，这是因为静态成员函数不属于某个对象，这样其他对象里有什么非静态变量，这些变量是否冲突静态成员函数都不知道，因此不能访问 静态成员函数也可以设置访问权限 只有静态成员变量才属于类上，其他类型的成员函数和成员变量都不属于类上，而是属于各自的对象 ","date":"2024-01-14","objectID":"/posts/cpp/:5:5","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#静态成员与静态函数"},{"categories":["Tech"],"content":" this指针每个非静态成员函数会产生一份函数实例，也就是说多个同类型对象会共用同一份代码，那么怎样通过同一份代码控制不同对象的成员呢？答案是使用this指针，每个对象实例都会维护他自己的this指针，因此我们可以通过这个this指针来区分不同的对象 如果要返回对象本身，可以直接使用return *this cpp class person { public: person(int age) { this-\u003eage = age; } person\u0026 person_ageadd(person\u0026 p) //参数类型如果是person\u0026的话就会触发默认拷贝构造函数，此时返回的不是p2本身而是p2'，因此最终输出的p2就是20 { this-\u003eage += p.age; return *this; } int age; }; int main() { person p1(10); person p2(10); p2.person_ageadd(p1).person_ageadd(p1); //链式编程 std::cout \u003c\u003c p2.age \u003c\u003c std::endl; } this指针本质是个指针常量，其指向不可修改 类内任何成员前面都隐藏了一个this-\u003e ","date":"2024-01-14","objectID":"/posts/cpp/:5:6","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#this指针"},{"categories":["Tech"],"content":" 常函数与常对象类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员(准确地说是非静态数据成员)作任何改变 常函数： const位于成员函数后 常函数不能修改成员属性 但是成员属性加入mutable关键字后就可以在常函数中修改 常对象： const位于声明对象前 常对象只能调用常函数 常函数本质上是在this前加了一个const关键字，这样this不仅不能修改指向，它所指向的值也修改不了。函数也不能随意指定const的位置，因为如果在函数前加const会与函数返回值的const重复从而导致错误，这样const只能放在成员函数后面了 cpp // 隐式转换：成员函数的 this 指针类型 void func() const; // 实际：void func(const MyClass* this); void func(); // 实际：void func(MyClass* this); 因为只有非常函数可以修改成员变量，这样当常对象调用非常函数就很危险了(这会与常函数定义相违背)，因此常对象只能调用常函数 ","date":"2024-01-14","objectID":"/posts/cpp/:5:7","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#常函数与常对象"},{"categories":["Tech"],"content":" 友元当外部函数或者其他的类需要用到某个类的private作用域中的成员时，我们可以使用friend关键字 需要友元操作的成员需要将其声明放到类的最前方，并前加friend cpp class house { friend void goodgay(house \u0026h1); //友元 public: int score = 10; private: int password = 123456; }; void goodgay(house \u0026h1) { std::cout \u003c\u003c h1-\u003epassword \u003c\u003c std::endl; } 当一个函数被添加为友元符号时，这意味着这个函数已经是全局函数了(或者为权限为public)，因为如果还是成员函数的话就与友元的定义起冲突(不同类的成员函数之间不能相互访问) ","date":"2024-01-14","objectID":"/posts/cpp/:5:8","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#友元"},{"categories":["Tech"],"content":" 运算符重载当需要对某些运算进行运算符重载时，我们需要写一个函数，函数名是编译器提供的operator及其运算符，函数内部写出这个运算符重载的实现 以operator+为例，在调用时我们原本需要写成person p3 = p1.operator+(p2)(成员函数的写法)，或者person p3 = operator+(p1，p2)(全局函数的写法)，但是在编译器的简化下我们可以写为person p3 = p1+p2 运算符重载也支持函数重载，所以我们不需要担心函数重名的问题 使用运算符重载()时因为写法与函数很像，因此被称为仿函数。有时我们也会将匿名对象和运算符重载连用 cpp class myadd { public: operator()(int a, int b) { return a + b; } }; int main() { int ret; // 创建 myadd 的临时匿名对象并调用其 operator() // 等价于： // myadd temp; // ret = temp(1, 2); // 临时对象在表达式结束后自动销毁 ret = myadd()(1, 2); std::cout \u003c\u003c ret \u003c\u003c std::endl; return 0; } ","date":"2024-01-14","objectID":"/posts/cpp/:5:9","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#运算符重载"},{"categories":["Tech"],"content":" 继承 2024-05-06_19-56 cpp class base { public: int a; protected: int b; private: int c; }; class son: protected base { public: son() //构造函数无返回类型 { a = 100; //必须在构造函数内赋值，或者在类内的重载函数内赋值，在函数外赋值是不被允许的 b = 200; c = 300; //报错 } }; void func() { son s; s.b = 300; //报错 } 子类可以继承父类中的所有成员(包括静态成员)，这意味着权限为private的成员变量也可以被继承，但是在访问时编译器进行了权限设置，因此我们访问不到。但如果子类和父类的成员重名，我们可以通过子类对象.父类名::成员，来访问父类中的成员 cpp class Base { public: int x = 10; }; class Derived : public Base { public: int x = 20; // 隐藏 Base::x }; //内存布局： Derived 对象： +----------------+ | Base::x = 10 | \u003c-- 父类成员仍然存在！ +----------------+ | Derived::x = 20| \u003c-- 子类新增成员 +----------------+ #include \u003ciostream\u003e using namespace std; class Base { public: void print() { cout \u003c\u003c \"Base::print()\" \u003c\u003c endl; } // 父类成员函数 }; class Derived : public Base { public: void print() { cout \u003c\u003c \"Derived::print()\" \u003c\u003c endl; } // 子类同名成员函数 }; int main() { Derived obj; obj.print(); // 调用子类函数：输出 \"Derived::print()\" obj.Base::print(); // 显式调用父类函数：输出 \"Base::print()\" return 0; } 我们可以通过类名::成员来访问静态成员 菱形继承为了解决菱形继承，我们引入关键字virtual，在继承之前加上这个关键字可以让继承变为虚继承，这样原来我们不能修改的基类成员就可以修改了同时也不会发生冲突 cpp class animal { public: int age; }; class sheep:virtual public animal { public: int age = 15; }; class tuo:virtual public animal { public: int age = 20; }; class sheeptuo:public sheep, public tuo { public: int age = 38; //age可以重定义 }; int main() { sheeptuo st; std::cout \u003c\u003c st.age \u003c\u003c std::endl; std::cout \u003c\u003c st.sheep::age \u003c\u003c std::endl; } 使用virtual关键字后，编译器维护了一张vbtable(虚基类表)，当我们想要访问基类成员时通过查表即可获得指针偏移量，通过偏移量就可以找到成员的值了。这样当我们无论是否产生了菱形继承都可以使用vbtable来找到我们需要的成员 对象切割(object-slicing)生成继承父类的多个子类对象时，父类的内容会在子类中拷贝一份完全相同的，并在之后的子类操作中修改其及继承的父类内容，但这一切都不会影响其他子类继承的内容，也不会影响父类中的内容 从上面可以看到，父类内容会被多次拷贝并继承给子类。但是当我们通过子类访问父类又会怎样呢？这要分为两种情况讨论： 发生对象切割时： 当我们将子类对象赋值给父类对象时，就会触发对象切割。此时编译器会在内存中创建一个子类副本，这个副本是临时对象且与原来的子类无关。更重要的是，这个子类副本会将其本身的内容切割掉，仅仅保留父类对象的内容，这就会生成一个类似父类对象的子类对象 不发生对象切割时： 也就是当我们将子类对象的引用或指针赋值给父类对象时。程序会按我们预期的方式进行 下面是例子： cpp class Base { protected: int m_value{}; public: Base(int value) : m_value{ value } { } virtual const char* getName() const { return \"Base\"; } int getValue() const { return m_value; } }; class Derived: public Base { public: Derived(int value) : Base{ value } { } virtual const char* getName() const { return \"Derived\"; } }; void printName(const Base base) // note: base 通过值传参，而不是引用 { std::cout \u003c\u003c \"I am a \" \u003c\u003c base.getName() \u003c\u003c '\\n'; } int main() { Derived d{ 5 }; printName(d); // oops, 没有意识到这是通过值传参，触发对象切割，输出I am a Base。 return 0; } // void printName(const Base \u0026base) // note: base 通过引用传参 // { // std::cout \u003c\u003c \"I am a \" \u003c\u003c base.getName() \u003c\u003c '\\n'; // } // int main() // { // Derived d{ 5 }; // printName(d); //输出I am a Derived。 // return 0; // } 很多新手程序员尝试创建一个 引用类型的std::vector像这样 cpp std::vector\u003cBase\u0026\u003e v{}; 但这是不对的，因为vector要求传入的是一个可修改的对象，而Base\u0026是引用对象，引用是不能被修改的，它只能被设置初值 解决办法是创建一个指针类型的Base cpp std::vector\u003cBase*\u003e v{}; ","date":"2024-01-14","objectID":"/posts/cpp/:5:10","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#继承"},{"categories":["Tech"],"content":" 继承 2024-05-06_19-56 cpp class base { public: int a; protected: int b; private: int c; }; class son: protected base { public: son() //构造函数无返回类型 { a = 100; //必须在构造函数内赋值，或者在类内的重载函数内赋值，在函数外赋值是不被允许的 b = 200; c = 300; //报错 } }; void func() { son s; s.b = 300; //报错 } 子类可以继承父类中的所有成员(包括静态成员)，这意味着权限为private的成员变量也可以被继承，但是在访问时编译器进行了权限设置，因此我们访问不到。但如果子类和父类的成员重名，我们可以通过子类对象.父类名::成员，来访问父类中的成员 cpp class Base { public: int x = 10; }; class Derived : public Base { public: int x = 20; // 隐藏 Base::x }; //内存布局： Derived 对象： +----------------+ | Base::x = 10 | \u003c-- 父类成员仍然存在！ +----------------+ | Derived::x = 20| \u003c-- 子类新增成员 +----------------+ #include using namespace std; class Base { public: void print() { cout \u003c\u003c \"Base::print()\" \u003c\u003c endl; } // 父类成员函数 }; class Derived : public Base { public: void print() { cout \u003c\u003c \"Derived::print()\" \u003c\u003c endl; } // 子类同名成员函数 }; int main() { Derived obj; obj.print(); // 调用子类函数：输出 \"Derived::print()\" obj.Base::print(); // 显式调用父类函数：输出 \"Base::print()\" return 0; } 我们可以通过类名::成员来访问静态成员 菱形继承为了解决菱形继承，我们引入关键字virtual，在继承之前加上这个关键字可以让继承变为虚继承，这样原来我们不能修改的基类成员就可以修改了同时也不会发生冲突 cpp class animal { public: int age; }; class sheep:virtual public animal { public: int age = 15; }; class tuo:virtual public animal { public: int age = 20; }; class sheeptuo:public sheep, public tuo { public: int age = 38; //age可以重定义 }; int main() { sheeptuo st; std::cout \u003c\u003c st.age \u003c\u003c std::endl; std::cout \u003c\u003c st.sheep::age \u003c\u003c std::endl; } 使用virtual关键字后，编译器维护了一张vbtable(虚基类表)，当我们想要访问基类成员时通过查表即可获得指针偏移量，通过偏移量就可以找到成员的值了。这样当我们无论是否产生了菱形继承都可以使用vbtable来找到我们需要的成员 对象切割(object-slicing)生成继承父类的多个子类对象时，父类的内容会在子类中拷贝一份完全相同的，并在之后的子类操作中修改其及继承的父类内容，但这一切都不会影响其他子类继承的内容，也不会影响父类中的内容 从上面可以看到，父类内容会被多次拷贝并继承给子类。但是当我们通过子类访问父类又会怎样呢？这要分为两种情况讨论： 发生对象切割时： 当我们将子类对象赋值给父类对象时，就会触发对象切割。此时编译器会在内存中创建一个子类副本，这个副本是临时对象且与原来的子类无关。更重要的是，这个子类副本会将其本身的内容切割掉，仅仅保留父类对象的内容，这就会生成一个类似父类对象的子类对象 不发生对象切割时： 也就是当我们将子类对象的引用或指针赋值给父类对象时。程序会按我们预期的方式进行 下面是例子： cpp class Base { protected: int m_value{}; public: Base(int value) : m_value{ value } { } virtual const char* getName() const { return \"Base\"; } int getValue() const { return m_value; } }; class Derived: public Base { public: Derived(int value) : Base{ value } { } virtual const char* getName() const { return \"Derived\"; } }; void printName(const Base base) // note: base 通过值传参，而不是引用 { std::cout \u003c\u003c \"I am a \" \u003c\u003c base.getName() \u003c\u003c '\\n'; } int main() { Derived d{ 5 }; printName(d); // oops, 没有意识到这是通过值传参，触发对象切割，输出I am a Base。 return 0; } // void printName(const Base \u0026base) // note: base 通过引用传参 // { // std::cout \u003c\u003c \"I am a \" \u003c\u003c base.getName() \u003c\u003c '\\n'; // } // int main() // { // Derived d{ 5 }; // printName(d); //输出I am a Derived。 // return 0; // } 很多新手程序员尝试创建一个 引用类型的std::vector像这样 cpp std::vector v{}; 但这是不对的，因为vector要求传入的是一个可修改的对象，而Base\u0026是引用对象，引用是不能被修改的，它只能被设置初值 解决办法是创建一个指针类型的Base cpp std::vector v{}; ","date":"2024-01-14","objectID":"/posts/cpp/:5:10","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#菱形继承"},{"categories":["Tech"],"content":" 继承 2024-05-06_19-56 cpp class base { public: int a; protected: int b; private: int c; }; class son: protected base { public: son() //构造函数无返回类型 { a = 100; //必须在构造函数内赋值，或者在类内的重载函数内赋值，在函数外赋值是不被允许的 b = 200; c = 300; //报错 } }; void func() { son s; s.b = 300; //报错 } 子类可以继承父类中的所有成员(包括静态成员)，这意味着权限为private的成员变量也可以被继承，但是在访问时编译器进行了权限设置，因此我们访问不到。但如果子类和父类的成员重名，我们可以通过子类对象.父类名::成员，来访问父类中的成员 cpp class Base { public: int x = 10; }; class Derived : public Base { public: int x = 20; // 隐藏 Base::x }; //内存布局： Derived 对象： +----------------+ | Base::x = 10 | \u003c-- 父类成员仍然存在！ +----------------+ | Derived::x = 20| \u003c-- 子类新增成员 +----------------+ #include using namespace std; class Base { public: void print() { cout \u003c\u003c \"Base::print()\" \u003c\u003c endl; } // 父类成员函数 }; class Derived : public Base { public: void print() { cout \u003c\u003c \"Derived::print()\" \u003c\u003c endl; } // 子类同名成员函数 }; int main() { Derived obj; obj.print(); // 调用子类函数：输出 \"Derived::print()\" obj.Base::print(); // 显式调用父类函数：输出 \"Base::print()\" return 0; } 我们可以通过类名::成员来访问静态成员 菱形继承为了解决菱形继承，我们引入关键字virtual，在继承之前加上这个关键字可以让继承变为虚继承，这样原来我们不能修改的基类成员就可以修改了同时也不会发生冲突 cpp class animal { public: int age; }; class sheep:virtual public animal { public: int age = 15; }; class tuo:virtual public animal { public: int age = 20; }; class sheeptuo:public sheep, public tuo { public: int age = 38; //age可以重定义 }; int main() { sheeptuo st; std::cout \u003c\u003c st.age \u003c\u003c std::endl; std::cout \u003c\u003c st.sheep::age \u003c\u003c std::endl; } 使用virtual关键字后，编译器维护了一张vbtable(虚基类表)，当我们想要访问基类成员时通过查表即可获得指针偏移量，通过偏移量就可以找到成员的值了。这样当我们无论是否产生了菱形继承都可以使用vbtable来找到我们需要的成员 对象切割(object-slicing)生成继承父类的多个子类对象时，父类的内容会在子类中拷贝一份完全相同的，并在之后的子类操作中修改其及继承的父类内容，但这一切都不会影响其他子类继承的内容，也不会影响父类中的内容 从上面可以看到，父类内容会被多次拷贝并继承给子类。但是当我们通过子类访问父类又会怎样呢？这要分为两种情况讨论： 发生对象切割时： 当我们将子类对象赋值给父类对象时，就会触发对象切割。此时编译器会在内存中创建一个子类副本，这个副本是临时对象且与原来的子类无关。更重要的是，这个子类副本会将其本身的内容切割掉，仅仅保留父类对象的内容，这就会生成一个类似父类对象的子类对象 不发生对象切割时： 也就是当我们将子类对象的引用或指针赋值给父类对象时。程序会按我们预期的方式进行 下面是例子： cpp class Base { protected: int m_value{}; public: Base(int value) : m_value{ value } { } virtual const char* getName() const { return \"Base\"; } int getValue() const { return m_value; } }; class Derived: public Base { public: Derived(int value) : Base{ value } { } virtual const char* getName() const { return \"Derived\"; } }; void printName(const Base base) // note: base 通过值传参，而不是引用 { std::cout \u003c\u003c \"I am a \" \u003c\u003c base.getName() \u003c\u003c '\\n'; } int main() { Derived d{ 5 }; printName(d); // oops, 没有意识到这是通过值传参，触发对象切割，输出I am a Base。 return 0; } // void printName(const Base \u0026base) // note: base 通过引用传参 // { // std::cout \u003c\u003c \"I am a \" \u003c\u003c base.getName() \u003c\u003c '\\n'; // } // int main() // { // Derived d{ 5 }; // printName(d); //输出I am a Derived。 // return 0; // } 很多新手程序员尝试创建一个 引用类型的std::vector像这样 cpp std::vector v{}; 但这是不对的，因为vector要求传入的是一个可修改的对象，而Base\u0026是引用对象，引用是不能被修改的，它只能被设置初值 解决办法是创建一个指针类型的Base cpp std::vector v{}; ","date":"2024-01-14","objectID":"/posts/cpp/:5:10","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#对象切割object-slicing"},{"categories":["Tech"],"content":" 多态静态多态：函数重载和运算符重载，这些静态多态函数在编译阶段就已经确定函数地址了 动态多态：派生类和虚函数，这些动态多态函数在运行时才确定函数地址 cpp class animal { public: virtual void func() //这里需要加virtual关键字，这样子类才会重写这个函数，如果没有使用virtual的话就会输出animal { std::cout \u003c\u003c \"animal\" \u003c\u003c std::endl; } }; class cat:public animal { public: void func() { std::cout \u003c\u003c \"cat\" \u003c\u003c std::endl; } }; class dog:public animal { public: void func() { std::cout \u003c\u003c \"dog\" \u003c\u003c std::endl; } }; void func(animal\u0026 animal) //这里需要使用引用或者指针，因为使用动态多态时需要对类进行实例化，如果没有使用引用的话就找不到子类的地址，这样就会输出父类中的函数 { animal.func(); } int main() { dog d; func(d); return 0; } 下面的代码可能会对运行时多态有更好的理解 cpp class Animal { public : virtual void shout() = 0; }; class Dog :public Animal { public: virtual void shout(){ cout \u003c\u003c \"汪汪！\"\u003c\u003cendl; } }; class Cat :public Animal { public: virtual void shout(){ cout \u003c\u003c \"喵喵~\"\u003c\u003cendl; } }; class Bird : public Animal { public: virtual void shout(){ cout \u003c\u003c \"叽喳!\"\u003c\u003cendl; } }; int main() { Animal * anim1 = new Dog; //运行时在堆区申请内存 Animal * anim2 = new Cat; Animal * anim3 = new Bird; //由指针（或引用）调用的接口，在运行期确定指针（或引用）所指对象的真正类型，调用该类型对应的接口 anim1-\u003eshout(); anim2-\u003eshout(); anim3-\u003eshout(); //delete 对象 return 0; } 使用virtual修饰函数时，编译器会生成虚函数指针(vfptr)并指向一个虚函数表(vftable)，这张表的内容是virtual修饰的函数。子类继承父类时会将虚函数指针和虚函数表一同继承下来，子类重写父类中的虚函数时会修改虚函数表，当函数调用父类对象的引用而实际传入的是一个子类的对象时就会发生多态 重写的条件：函数返回值，函数名，参数列表均相同 ","date":"2024-01-14","objectID":"/posts/cpp/:5:11","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#多态"},{"categories":["Tech"],"content":" 纯虚函数与抽象类纯虚函数是指基类中不实现而在子类中实现的函数。含有纯虚函数的类称为抽象类，在抽象类中允许定义数据成员 cpp virtual void func() = 0; //纯虚函数写法 抽象类无法实例化对象 子类必须实现抽象类 下面是一个简单的例子 cpp struct Pet { virtual void speak() = 0; }; struct CatPet ：Pet { void speak() override { puts(\"喵\"); } }; struct DogPet ：Pet { void speak() override { puts(\"汪\"); } }; int main() { Pet *cat = new CatPet(); //注意这个写法，将子类对象的指针赋值给父类对象的指针 Pet *dog = new DogPet(); cat-\u003espeak(); //然后就可以使用 子类对象-\u003e父类纯虚函数 调用子类重写后的方法了 dog-\u003espeak(); } ","date":"2024-01-14","objectID":"/posts/cpp/:5:12","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#纯虚函数与抽象类"},{"categories":["Tech"],"content":" 虚析构当父类有纯虚函数且子类构造函数在堆区申请了内存时可能会导致内存泄漏，这是因为父类在析构时并不能调用到子类的析构函数中，解决办法是将父类的析构函数变为虚析构函数。实际操作是在父类析构函数前加virtual关键字，并且当需要加上初始化参数时要么令其 = 0并在全局作用域内给出定义(空定义也可以)，或是让析构函数 = default。这是由于析构函数必须在父类中给出定义，如果不在父类中给出定义也必须在全局作用域内重写父类 = 0的析构函数的定义，否则在删除对象时就找不到与析构函数的定义，这会报链接错误。因此在使用虚析构时要么令其 = 0并在全局作用域内给出定义，要么或是让析构函数 = default。当然，这两种方法都不影响父类调用子类析构函数 调用子类析构函数时是自动的 ","date":"2024-01-14","objectID":"/posts/cpp/:5:13","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#虚析构"},{"categories":["Tech"],"content":" 模板除了面向对象外，C++还使用了泛型编程的思想，主要用到的技术就是模板 使用模板时我们推荐通过模板参数列表显式调用函数模板或类模板，这样能够避免隐式调用造成与普通函数混淆的问题 ","date":"2024-01-14","objectID":"/posts/cpp/:6:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#模板"},{"categories":["Tech"],"content":" 函数模板使用模板可以进行泛型编程 cpp template \u003ctypename T\u003e //除了typename外还可以使用class，这两个没有区别，只是使用习惯不同 void myswap(T \u0026a, T \u0026b) //不能将函数名改为swap，这会导致call of overloaded 'swap(int\u0026, int\u0026)' is ambiguous错误，这意味着自定义函数名与系统库的函数名冲突 { T temp = a; a = b; b = temp; } int main() { int a = 10; int b = 20; myswap(a, b); //myswap\u003cint\u003e(a, b); //显式调用模板 std::cout \u003c\u003c a \u003c\u003c std::endl; std::cout \u003c\u003c b \u003c\u003c std::endl; return 0; } 需要注意的是当显式调用函数模板时有可能发生隐式类型转换 cpp template \u003ctypename T\u003e void myswap(T \u0026a, T \u0026b) { T temp = a; a = b; b = temp; } int main() { int a = 10; int b = 20; char c = 'c'; myswap\u003cint\u003e(a, c); //显式调用模板产生隐式类型转换 std::cout \u003c\u003c a \u003c\u003c std::endl; std::cout \u003c\u003c b \u003c\u003c std::endl; return 0; } 使用函数模板的注意事项 函数模板和函数都可以调用时优先调用函数，但当需要进行隐式类型转换时会优先调用函数模板 可以通过空模板列表强制调用函数模板 函数模板可以发生函数重载(也就是模板特化) 因此在开发中使用了函数模板就不要提供同名的函数 cpp myswap\u003c\u003e(a,c); //空模板列表 有些自定义数据类型的操作模板无法识别，如比较两个数组是否相等，因此模板不是万能的，但我们可以通过模板的重载来解决这个问题 cpp #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; // 自定义 person 类 class person { public: string name; int age; }; // 通用模板（适用于一般类型） template \u003ctypename T\u003e bool my_compare(const T\u0026 a, const T\u0026 b) { return a == b; // 依赖类型的 == 运算符 } // 特化版本（专门用于 person 类型） template\u003c\u003e bool my_compare\u003cperson\u003e(const person \u0026p1, const person \u0026p2) { return (p1.name == p2.name \u0026\u0026 p1.age == p2.age); } int main() { person p1 = {\"Alice\", 25}; person p2 = {\"Alice\", 25}; person p3 = {\"Bob\", 30}; cout \u003c\u003c my_compare(p1, p2) \u003c\u003c endl; // true（name 和 age 相同） cout \u003c\u003c my_compare(p1, p3) \u003c\u003c endl; // false（name 不同） int x = 10, y = 10; cout \u003c\u003c my_compare(x, y) \u003c\u003c endl; // true（调用通用模板） return 0; } ","date":"2024-01-14","objectID":"/posts/cpp/:6:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#函数模板"},{"categories":["Tech"],"content":" 类模板类模板没有类型自动推导的调用方式，我们只能通过模板参数列表显式调用类模板 cpp #include \u003ciostream\u003e #include\u003cstring\u003e using namespace std; template \u003cclass nametype, class agetype\u003e class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; int main() { person\u003cstring,int\u003e p1(\"xiaoming\",14); //注意对象实例化 p1.showperson(); return 0; } 在定义类模板时可以在参数列表中指定默认参数，这样在调用时就不用指定参数列表了 cpp template \u003cclass nametype = string, class agetype = int\u003e //指定默认参数 class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; int main() { person p1(\"xiaoming\",14); p1.showperson(); return 0; } 类模板中成员函数在调用时才会创建，这与类中的成员函数不同。这就意味着，无论是否调用，类内的成员函数总会在目标文件中生成代码，尽管在未被调用时可能被优化掉。但是类模板中的成员函数在调用前都不会生成，直到被调用(也就是指明了类型)才会在编译期生成目标代码 类模板对象做函数参数类模板做函数参数时需要加上参数列表 cpp template \u003cclass nametype, class agetype\u003e class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; void showperson2(person\u003cstring,int\u003e p) //类模板作为函数参数 { p.showperson(); std::cout \u003c\u003c \"p2.name: \" \u003c\u003c p.name \u003c\u003c std::endl; } int main() { person\u003cstring,int\u003ep1(\"xiaoming\",14); showperson2(p1); return 0; } 类模板的继承类模板有两种继承方式 继承父类模板时在父类后指定参数列表 将父类模板的参数列表模板化 cpp template \u003cclass nametype, class agetype\u003e class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; class son1: public person\u003cstring,int\u003e //注意要给出模板参数列表 { }; template\u003cclass T1, class T2, class T3\u003e class son2: public person\u003cT1,T2\u003e // 将父类模板的参数列表模板化 { T3 obj; }; 类模板成员函数的类外实现 cpp #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; template \u003cclass nametype, class agetype\u003e class person { public: person(nametype name, agetype age); //这里给出声明，实现在下面 // { // this-\u003ename = name; // this-\u003eage = age; // } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } void showpersonname(); nametype name; agetype age; }; //注意类模板的写法 template \u003cclass nametype, class agetype\u003e //先利用类模板定义nametype person\u003cnametype, agetype\u003e::person(nametype name, agetype age) //再写好作用域，并且后面要跟上类模板的参数列表，即使用不到参数也必须给出，因为这是模板的类型 { this-\u003ename = name; this-\u003eage = age; } template \u003ctypename T1, typename T2\u003e void person\u003cT1,T2\u003e::showpersonname() { std::cout \u003c\u003c name \u003c\u003c std::endl; } int main() { person\u003cstring,int\u003ep1(\"xiaoming\",14); //p1.showperson(); //showperson2(p1); p1.showpersonname(); return 0; } 类模板分文件编写当代码按如下方式组织时会产生外部符号无法解析的错误 cpp //person.h template \u003cclass nametype, class agetype\u003e class person { public: person(nametype name, agetype age); // { // this-\u003ename = name; // this-\u003eage = age; // } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } void showpersonname(); nametype name; agetype age; }; //person.cpp #include \"person.h\" template \u003cclass nametype, class agetype\u003e person\u003cnametype, agetype\u003e::person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } template \u003ctypename T1, typename T2\u003e void person\u003cT1,T2\u003e::showpersonname() { std::cout \u003c\u003c name \u003c\u003c std::endl; } //main.cpp #include \"person.h\" int main() { person\u003cstring,int\u003ep1(\"xiaoming\",14); //p1.showperson(); //showperson2(p1); p1.showpersonname(); return 0; } 这是由于类模板中的成员函数只有在调用时才会实例化，因此在链接阶段时链接器无法从.o文件中找到在.cpp中定义的符号，这会导致未定义外部符号的错误。但当main文件包含了.cpp文件时，编译器就会自动将cpp文件中的代码实例化以保证链接通过，但这么写会导致重复包含.cpp文件的错误或者导致代码膨胀编译时间增加 因此在编写类模板时我们需要将.h和.cpp文件写在一起，即将声明和实现写在一起并统一命后缀名为.hpp ","date":"2024-01-14","objectID":"/posts/cpp/:6:2","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#类模板"},{"categories":["Tech"],"content":" 类模板类模板没有类型自动推导的调用方式，我们只能通过模板参数列表显式调用类模板 cpp #include #include using namespace std; template class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; int main() { person p1(\"xiaoming\",14); //注意对象实例化 p1.showperson(); return 0; } 在定义类模板时可以在参数列表中指定默认参数，这样在调用时就不用指定参数列表了 cpp template //指定默认参数 class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; int main() { person p1(\"xiaoming\",14); p1.showperson(); return 0; } 类模板中成员函数在调用时才会创建，这与类中的成员函数不同。这就意味着，无论是否调用，类内的成员函数总会在目标文件中生成代码，尽管在未被调用时可能被优化掉。但是类模板中的成员函数在调用前都不会生成，直到被调用(也就是指明了类型)才会在编译期生成目标代码 类模板对象做函数参数类模板做函数参数时需要加上参数列表 cpp template class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; void showperson2(person p) //类模板作为函数参数 { p.showperson(); std::cout \u003c\u003c \"p2.name: \" \u003c\u003c p.name \u003c\u003c std::endl; } int main() { personp1(\"xiaoming\",14); showperson2(p1); return 0; } 类模板的继承类模板有两种继承方式 继承父类模板时在父类后指定参数列表 将父类模板的参数列表模板化 cpp template class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; class son1: public person //注意要给出模板参数列表 { }; template class son2: public person // 将父类模板的参数列表模板化 { T3 obj; }; 类模板成员函数的类外实现 cpp #include #include using namespace std; template class person { public: person(nametype name, agetype age); //这里给出声明，实现在下面 // { // this-\u003ename = name; // this-\u003eage = age; // } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } void showpersonname(); nametype name; agetype age; }; //注意类模板的写法 template //先利用类模板定义nametype person::person(nametype name, agetype age) //再写好作用域，并且后面要跟上类模板的参数列表，即使用不到参数也必须给出，因为这是模板的类型 { this-\u003ename = name; this-\u003eage = age; } template void person::showpersonname() { std::cout \u003c\u003c name \u003c\u003c std::endl; } int main() { personp1(\"xiaoming\",14); //p1.showperson(); //showperson2(p1); p1.showpersonname(); return 0; } 类模板分文件编写当代码按如下方式组织时会产生外部符号无法解析的错误 cpp //person.h template class person { public: person(nametype name, agetype age); // { // this-\u003ename = name; // this-\u003eage = age; // } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } void showpersonname(); nametype name; agetype age; }; //person.cpp #include \"person.h\" template person::person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } template void person::showpersonname() { std::cout \u003c\u003c name \u003c\u003c std::endl; } //main.cpp #include \"person.h\" int main() { personp1(\"xiaoming\",14); //p1.showperson(); //showperson2(p1); p1.showpersonname(); return 0; } 这是由于类模板中的成员函数只有在调用时才会实例化，因此在链接阶段时链接器无法从.o文件中找到在.cpp中定义的符号，这会导致未定义外部符号的错误。但当main文件包含了.cpp文件时，编译器就会自动将cpp文件中的代码实例化以保证链接通过，但这么写会导致重复包含.cpp文件的错误或者导致代码膨胀编译时间增加 因此在编写类模板时我们需要将.h和.cpp文件写在一起，即将声明和实现写在一起并统一命后缀名为.hpp ","date":"2024-01-14","objectID":"/posts/cpp/:6:2","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#类模板对象做函数参数"},{"categories":["Tech"],"content":" 类模板类模板没有类型自动推导的调用方式，我们只能通过模板参数列表显式调用类模板 cpp #include #include using namespace std; template class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; int main() { person p1(\"xiaoming\",14); //注意对象实例化 p1.showperson(); return 0; } 在定义类模板时可以在参数列表中指定默认参数，这样在调用时就不用指定参数列表了 cpp template //指定默认参数 class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; int main() { person p1(\"xiaoming\",14); p1.showperson(); return 0; } 类模板中成员函数在调用时才会创建，这与类中的成员函数不同。这就意味着，无论是否调用，类内的成员函数总会在目标文件中生成代码，尽管在未被调用时可能被优化掉。但是类模板中的成员函数在调用前都不会生成，直到被调用(也就是指明了类型)才会在编译期生成目标代码 类模板对象做函数参数类模板做函数参数时需要加上参数列表 cpp template class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; void showperson2(person p) //类模板作为函数参数 { p.showperson(); std::cout \u003c\u003c \"p2.name: \" \u003c\u003c p.name \u003c\u003c std::endl; } int main() { personp1(\"xiaoming\",14); showperson2(p1); return 0; } 类模板的继承类模板有两种继承方式 继承父类模板时在父类后指定参数列表 将父类模板的参数列表模板化 cpp template class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; class son1: public person //注意要给出模板参数列表 { }; template class son2: public person // 将父类模板的参数列表模板化 { T3 obj; }; 类模板成员函数的类外实现 cpp #include #include using namespace std; template class person { public: person(nametype name, agetype age); //这里给出声明，实现在下面 // { // this-\u003ename = name; // this-\u003eage = age; // } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } void showpersonname(); nametype name; agetype age; }; //注意类模板的写法 template //先利用类模板定义nametype person::person(nametype name, agetype age) //再写好作用域，并且后面要跟上类模板的参数列表，即使用不到参数也必须给出，因为这是模板的类型 { this-\u003ename = name; this-\u003eage = age; } template void person::showpersonname() { std::cout \u003c\u003c name \u003c\u003c std::endl; } int main() { personp1(\"xiaoming\",14); //p1.showperson(); //showperson2(p1); p1.showpersonname(); return 0; } 类模板分文件编写当代码按如下方式组织时会产生外部符号无法解析的错误 cpp //person.h template class person { public: person(nametype name, agetype age); // { // this-\u003ename = name; // this-\u003eage = age; // } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } void showpersonname(); nametype name; agetype age; }; //person.cpp #include \"person.h\" template person::person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } template void person::showpersonname() { std::cout \u003c\u003c name \u003c\u003c std::endl; } //main.cpp #include \"person.h\" int main() { personp1(\"xiaoming\",14); //p1.showperson(); //showperson2(p1); p1.showpersonname(); return 0; } 这是由于类模板中的成员函数只有在调用时才会实例化，因此在链接阶段时链接器无法从.o文件中找到在.cpp中定义的符号，这会导致未定义外部符号的错误。但当main文件包含了.cpp文件时，编译器就会自动将cpp文件中的代码实例化以保证链接通过，但这么写会导致重复包含.cpp文件的错误或者导致代码膨胀编译时间增加 因此在编写类模板时我们需要将.h和.cpp文件写在一起，即将声明和实现写在一起并统一命后缀名为.hpp ","date":"2024-01-14","objectID":"/posts/cpp/:6:2","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#类模板的继承"},{"categories":["Tech"],"content":" 类模板类模板没有类型自动推导的调用方式，我们只能通过模板参数列表显式调用类模板 cpp #include #include using namespace std; template class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; int main() { person p1(\"xiaoming\",14); //注意对象实例化 p1.showperson(); return 0; } 在定义类模板时可以在参数列表中指定默认参数，这样在调用时就不用指定参数列表了 cpp template //指定默认参数 class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; int main() { person p1(\"xiaoming\",14); p1.showperson(); return 0; } 类模板中成员函数在调用时才会创建，这与类中的成员函数不同。这就意味着，无论是否调用，类内的成员函数总会在目标文件中生成代码，尽管在未被调用时可能被优化掉。但是类模板中的成员函数在调用前都不会生成，直到被调用(也就是指明了类型)才会在编译期生成目标代码 类模板对象做函数参数类模板做函数参数时需要加上参数列表 cpp template class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; void showperson2(person p) //类模板作为函数参数 { p.showperson(); std::cout \u003c\u003c \"p2.name: \" \u003c\u003c p.name \u003c\u003c std::endl; } int main() { personp1(\"xiaoming\",14); showperson2(p1); return 0; } 类模板的继承类模板有两种继承方式 继承父类模板时在父类后指定参数列表 将父类模板的参数列表模板化 cpp template class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; class son1: public person //注意要给出模板参数列表 { }; template class son2: public person // 将父类模板的参数列表模板化 { T3 obj; }; 类模板成员函数的类外实现 cpp #include #include using namespace std; template class person { public: person(nametype name, agetype age); //这里给出声明，实现在下面 // { // this-\u003ename = name; // this-\u003eage = age; // } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } void showpersonname(); nametype name; agetype age; }; //注意类模板的写法 template //先利用类模板定义nametype person::person(nametype name, agetype age) //再写好作用域，并且后面要跟上类模板的参数列表，即使用不到参数也必须给出，因为这是模板的类型 { this-\u003ename = name; this-\u003eage = age; } template void person::showpersonname() { std::cout \u003c\u003c name \u003c\u003c std::endl; } int main() { personp1(\"xiaoming\",14); //p1.showperson(); //showperson2(p1); p1.showpersonname(); return 0; } 类模板分文件编写当代码按如下方式组织时会产生外部符号无法解析的错误 cpp //person.h template class person { public: person(nametype name, agetype age); // { // this-\u003ename = name; // this-\u003eage = age; // } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } void showpersonname(); nametype name; agetype age; }; //person.cpp #include \"person.h\" template person::person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } template void person::showpersonname() { std::cout \u003c\u003c name \u003c\u003c std::endl; } //main.cpp #include \"person.h\" int main() { personp1(\"xiaoming\",14); //p1.showperson(); //showperson2(p1); p1.showpersonname(); return 0; } 这是由于类模板中的成员函数只有在调用时才会实例化，因此在链接阶段时链接器无法从.o文件中找到在.cpp中定义的符号，这会导致未定义外部符号的错误。但当main文件包含了.cpp文件时，编译器就会自动将cpp文件中的代码实例化以保证链接通过，但这么写会导致重复包含.cpp文件的错误或者导致代码膨胀编译时间增加 因此在编写类模板时我们需要将.h和.cpp文件写在一起，即将声明和实现写在一起并统一命后缀名为.hpp ","date":"2024-01-14","objectID":"/posts/cpp/:6:2","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#类模板成员函数的类外实现"},{"categories":["Tech"],"content":" 类模板类模板没有类型自动推导的调用方式，我们只能通过模板参数列表显式调用类模板 cpp #include #include using namespace std; template class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; int main() { person p1(\"xiaoming\",14); //注意对象实例化 p1.showperson(); return 0; } 在定义类模板时可以在参数列表中指定默认参数，这样在调用时就不用指定参数列表了 cpp template //指定默认参数 class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; int main() { person p1(\"xiaoming\",14); p1.showperson(); return 0; } 类模板中成员函数在调用时才会创建，这与类中的成员函数不同。这就意味着，无论是否调用，类内的成员函数总会在目标文件中生成代码，尽管在未被调用时可能被优化掉。但是类模板中的成员函数在调用前都不会生成，直到被调用(也就是指明了类型)才会在编译期生成目标代码 类模板对象做函数参数类模板做函数参数时需要加上参数列表 cpp template class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; void showperson2(person p) //类模板作为函数参数 { p.showperson(); std::cout \u003c\u003c \"p2.name: \" \u003c\u003c p.name \u003c\u003c std::endl; } int main() { personp1(\"xiaoming\",14); showperson2(p1); return 0; } 类模板的继承类模板有两种继承方式 继承父类模板时在父类后指定参数列表 将父类模板的参数列表模板化 cpp template class person { public: person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } nametype name; agetype age; }; class son1: public person //注意要给出模板参数列表 { }; template class son2: public person // 将父类模板的参数列表模板化 { T3 obj; }; 类模板成员函数的类外实现 cpp #include #include using namespace std; template class person { public: person(nametype name, agetype age); //这里给出声明，实现在下面 // { // this-\u003ename = name; // this-\u003eage = age; // } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } void showpersonname(); nametype name; agetype age; }; //注意类模板的写法 template //先利用类模板定义nametype person::person(nametype name, agetype age) //再写好作用域，并且后面要跟上类模板的参数列表，即使用不到参数也必须给出，因为这是模板的类型 { this-\u003ename = name; this-\u003eage = age; } template void person::showpersonname() { std::cout \u003c\u003c name \u003c\u003c std::endl; } int main() { personp1(\"xiaoming\",14); //p1.showperson(); //showperson2(p1); p1.showpersonname(); return 0; } 类模板分文件编写当代码按如下方式组织时会产生外部符号无法解析的错误 cpp //person.h template class person { public: person(nametype name, agetype age); // { // this-\u003ename = name; // this-\u003eage = age; // } void showperson() { std::cout \u003c\u003c name \u003c\u003c std::endl; std::cout \u003c\u003c age \u003c\u003c std::endl; } void showpersonname(); nametype name; agetype age; }; //person.cpp #include \"person.h\" template person::person(nametype name, agetype age) { this-\u003ename = name; this-\u003eage = age; } template void person::showpersonname() { std::cout \u003c\u003c name \u003c\u003c std::endl; } //main.cpp #include \"person.h\" int main() { personp1(\"xiaoming\",14); //p1.showperson(); //showperson2(p1); p1.showpersonname(); return 0; } 这是由于类模板中的成员函数只有在调用时才会实例化，因此在链接阶段时链接器无法从.o文件中找到在.cpp中定义的符号，这会导致未定义外部符号的错误。但当main文件包含了.cpp文件时，编译器就会自动将cpp文件中的代码实例化以保证链接通过，但这么写会导致重复包含.cpp文件的错误或者导致代码膨胀编译时间增加 因此在编写类模板时我们需要将.h和.cpp文件写在一起，即将声明和实现写在一起并统一命后缀名为.hpp ","date":"2024-01-14","objectID":"/posts/cpp/:6:2","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#类模板分文件编写"},{"categories":["Tech"],"content":" STLSTL(standard template library，标准模板库)，它的诞生是为了提高代码复用性的问题。主要包括算法，容器，迭代器，分配器，函数对象，适配器六大部分，stl几乎所有代码都采用了模板类或模板函数 ","date":"2024-01-14","objectID":"/posts/cpp/:7:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#stl"},{"categories":["Tech"],"content":" 容器 2024-05-12_17-10 vector容器vector与数组很类似，但是支持动态扩展，实际上当向vector里插入数据时，vector会在内存中找一块更大的空间(通常是2倍扩容)，然后将原数据和新数据一起拷贝进去 2024-05-09_19-41 cpp #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; void print(vector\u003cint\u003e \u0026v) { for(vector\u003cint\u003e::iterator it = v.begin(); it != v.end(); it++) //注意迭代器写法 { std::cout \u003c\u003c (*it) \u003c\u003c \" \"; } std::cout \u003c\u003c endl; } void test() { int i; vector\u003cint\u003e v1; //无参构造赋值 for(i = 0; i \u003c 10; i++) { v1.push_back(i); } print(v1); vector\u003cint\u003e v2 = v1; //重载运算符赋值(调用到vector提供的重载函数) print(v2); vector\u003cint\u003e v3(v1); //拷贝构造函数赋值 print(v3); } int main() { test(); return 0; } vector容器的方法： cpp empty() //判断容器是否为空 capacity() //获取当前容器中的最大容量，超过此值会导致realloc size() //获取当前容器中元素的个数 shrink_to_fit() //删除元素后调用，可以释放被占用的内存 resize(int num) //重新指定容器大小，比原来大就用默认值填充容器，比原来小将容器末尾元素舍去 push_back(element) //尾部添加一个元素element pop_back() //尾部删除一个元素 insert(const_iterator pos, element) //在pos位置插入元素element erase(const_iterator pos) //在pos位置删除元素 clear() //删除容器内所有元素 at(int index) //返回指定下标的元素 operator[] //同上 front() //返回容器内第一个元素 back() //返回容器内最后一个元素 deque容器deque容器使用方法与vector容器一样，区别在于当在头部插入元素时由于vector是单端容器所以需要开辟一块新的内存空间并将所有元素都复制一遍，这样效率很低，但deque内部管理多块内存，所以在拷贝容器时不像vector一样将所有元素都拷贝一遍，因此在经常扩增容器容量或者频繁往头尾写入数据的情况下deque效率很高 deque容器的方法： 其他用法与vector一样，头插数据时使用专用方法 cpp push_front(element) //头部添加一个元素element pop_front() //头部删除一个元素 deque没有capacity方法，这是因为deque的内存组织比较复杂，没有固定的大小，vector需要一定的capacity，以避免频繁扩容 stack容器与栈的结构相同，不允许遍历(这是STL设计哲学和栈的定义决定的)，这是因为栈只能查看栈顶元素 stack容器的方法： cpp push(element) //向栈顶添加元素 pop() //从栈顶移除第一个元素 top() //返回栈顶元素但并不移除 empty() //判断栈是否为空 size() //返回栈的大小 queue容器与队列的结构相同，同样也不允许遍历，这是因为只有队列头和队列尾才能访问到 queue容器的方法： cpp push(element) //从队尾添加元素 pop() //从队头移除第一个元素 back() //查看队尾元素 front() //查看对头元素 empty() //判断队列是否为空 size() //返回队列的大小 list容器与链表的结构相同，底层是一个双向循环链表，内部同样实现了begin()，end()迭代器，迭代器不支持随机查找，只支持前移后移 list和vector是最常使用的容器 list容器基本使用方法与vector一样 list容器的方法： cpp erase(const_iterator pos) //在pos位置删除元素 remove(element) //删除容器中所有与element值匹配的元素 reverse() //反转排序 sort() //排序函数，默认从小到大 由于list不支持随机访问，因此也没有实现[]和at的方法 所有不支持随机访问的迭代器不可以使用标准算法(算法库中的算法)，但内部会提供对应算法 cpp list\u003cint\u003e l; l.sort() //默认排序从小到大 set/mutiset容器所有元素插入时会被自动从小到大排序，底层是二叉树 set与mutiset区别： mutiset允许元素重复，但set不允许 set只有insert()的方法，同时set也不支持resize()，因为假如支持resize的话，新的set比原来set大会添加多个默认元素，而set是不允许元素重复的 set容器的方法： cpp find(key) //查找key是否存在，若存在，返回该元素的迭代器，若不存在，返回set.end() count(key) //查找key是否存在 指定set从大到小排序： cpp class mycompare { public: bool operator()(int val1, int val2) //重载仿函数 { return val1 \u003e val2; } }; int main() { set\u003cint,mycompare\u003e s; //在此处传入回调函数 } 由于set的参数要求传入typename，因此只能传入mycompare，不能传入mycompare() 存放自定义数据类型时必须指定仿函数 cpp class person { public: person(string name, int age) { this-\u003ename = name; this-\u003eage = age; } string name; int age; }; class mycompare { public: bool operator()(const person val1, const person val2) { return val1.age \u003e val2.age; } }; int main() { set\u003cperson,mycompare\u003e s; /* todo */ } map/mutimap容器map与mutimap区别： mutimap允许元素重复，但map不允许 map中所有元素都是pair pair中第一个元素为key，起索引作用，第二个元素为value 所有元素否会根据key值进行排序 map底层使用二叉树实现 map操作与上述容器类似 pair(对组)队组在stl中应用非常广泛，常用于存储成对的数据 创建队组的方式： cpp #include \u003cutility\u003e pair\u003ctype,type\u003e p(typeval1,typeval2); pair\u003ctype,type\u003e p = make_pair(typeval1,typeval2) ","date":"2024-01-14","objectID":"/posts/cpp/:7:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#容器"},{"categories":["Tech"],"content":" 容器 2024-05-12_17-10 vector容器vector与数组很类似，但是支持动态扩展，实际上当向vector里插入数据时，vector会在内存中找一块更大的空间(通常是2倍扩容)，然后将原数据和新数据一起拷贝进去 2024-05-09_19-41 cpp #include #include using namespace std; void print(vector \u0026v) { for(vector::iterator it = v.begin(); it != v.end(); it++) //注意迭代器写法 { std::cout \u003c\u003c (*it) \u003c\u003c \" \"; } std::cout \u003c\u003c endl; } void test() { int i; vector v1; //无参构造赋值 for(i = 0; i \u003c 10; i++) { v1.push_back(i); } print(v1); vector v2 = v1; //重载运算符赋值(调用到vector提供的重载函数) print(v2); vector v3(v1); //拷贝构造函数赋值 print(v3); } int main() { test(); return 0; } vector容器的方法： cpp empty() //判断容器是否为空 capacity() //获取当前容器中的最大容量，超过此值会导致realloc size() //获取当前容器中元素的个数 shrink_to_fit() //删除元素后调用，可以释放被占用的内存 resize(int num) //重新指定容器大小，比原来大就用默认值填充容器，比原来小将容器末尾元素舍去 push_back(element) //尾部添加一个元素element pop_back() //尾部删除一个元素 insert(const_iterator pos, element) //在pos位置插入元素element erase(const_iterator pos) //在pos位置删除元素 clear() //删除容器内所有元素 at(int index) //返回指定下标的元素 operator[] //同上 front() //返回容器内第一个元素 back() //返回容器内最后一个元素 deque容器deque容器使用方法与vector容器一样，区别在于当在头部插入元素时由于vector是单端容器所以需要开辟一块新的内存空间并将所有元素都复制一遍，这样效率很低，但deque内部管理多块内存，所以在拷贝容器时不像vector一样将所有元素都拷贝一遍，因此在经常扩增容器容量或者频繁往头尾写入数据的情况下deque效率很高 deque容器的方法： 其他用法与vector一样，头插数据时使用专用方法 cpp push_front(element) //头部添加一个元素element pop_front() //头部删除一个元素 deque没有capacity方法，这是因为deque的内存组织比较复杂，没有固定的大小，vector需要一定的capacity，以避免频繁扩容 stack容器与栈的结构相同，不允许遍历(这是STL设计哲学和栈的定义决定的)，这是因为栈只能查看栈顶元素 stack容器的方法： cpp push(element) //向栈顶添加元素 pop() //从栈顶移除第一个元素 top() //返回栈顶元素但并不移除 empty() //判断栈是否为空 size() //返回栈的大小 queue容器与队列的结构相同，同样也不允许遍历，这是因为只有队列头和队列尾才能访问到 queue容器的方法： cpp push(element) //从队尾添加元素 pop() //从队头移除第一个元素 back() //查看队尾元素 front() //查看对头元素 empty() //判断队列是否为空 size() //返回队列的大小 list容器与链表的结构相同，底层是一个双向循环链表，内部同样实现了begin()，end()迭代器，迭代器不支持随机查找，只支持前移后移 list和vector是最常使用的容器 list容器基本使用方法与vector一样 list容器的方法： cpp erase(const_iterator pos) //在pos位置删除元素 remove(element) //删除容器中所有与element值匹配的元素 reverse() //反转排序 sort() //排序函数，默认从小到大 由于list不支持随机访问，因此也没有实现[]和at的方法 所有不支持随机访问的迭代器不可以使用标准算法(算法库中的算法)，但内部会提供对应算法 cpp list l; l.sort() //默认排序从小到大 set/mutiset容器所有元素插入时会被自动从小到大排序，底层是二叉树 set与mutiset区别： mutiset允许元素重复，但set不允许 set只有insert()的方法，同时set也不支持resize()，因为假如支持resize的话，新的set比原来set大会添加多个默认元素，而set是不允许元素重复的 set容器的方法： cpp find(key) //查找key是否存在，若存在，返回该元素的迭代器，若不存在，返回set.end() count(key) //查找key是否存在 指定set从大到小排序： cpp class mycompare { public: bool operator()(int val1, int val2) //重载仿函数 { return val1 \u003e val2; } }; int main() { set s; //在此处传入回调函数 } 由于set的参数要求传入typename，因此只能传入mycompare，不能传入mycompare() 存放自定义数据类型时必须指定仿函数 cpp class person { public: person(string name, int age) { this-\u003ename = name; this-\u003eage = age; } string name; int age; }; class mycompare { public: bool operator()(const person val1, const person val2) { return val1.age \u003e val2.age; } }; int main() { set s; /* todo */ } map/mutimap容器map与mutimap区别： mutimap允许元素重复，但map不允许 map中所有元素都是pair pair中第一个元素为key，起索引作用，第二个元素为value 所有元素否会根据key值进行排序 map底层使用二叉树实现 map操作与上述容器类似 pair(对组)队组在stl中应用非常广泛，常用于存储成对的数据 创建队组的方式： cpp #include pair p(typeval1,typeval2); pair p = make_pair(typeval1,typeval2) ","date":"2024-01-14","objectID":"/posts/cpp/:7:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#vector容器"},{"categories":["Tech"],"content":" 容器 2024-05-12_17-10 vector容器vector与数组很类似，但是支持动态扩展，实际上当向vector里插入数据时，vector会在内存中找一块更大的空间(通常是2倍扩容)，然后将原数据和新数据一起拷贝进去 2024-05-09_19-41 cpp #include #include using namespace std; void print(vector \u0026v) { for(vector::iterator it = v.begin(); it != v.end(); it++) //注意迭代器写法 { std::cout \u003c\u003c (*it) \u003c\u003c \" \"; } std::cout \u003c\u003c endl; } void test() { int i; vector v1; //无参构造赋值 for(i = 0; i \u003c 10; i++) { v1.push_back(i); } print(v1); vector v2 = v1; //重载运算符赋值(调用到vector提供的重载函数) print(v2); vector v3(v1); //拷贝构造函数赋值 print(v3); } int main() { test(); return 0; } vector容器的方法： cpp empty() //判断容器是否为空 capacity() //获取当前容器中的最大容量，超过此值会导致realloc size() //获取当前容器中元素的个数 shrink_to_fit() //删除元素后调用，可以释放被占用的内存 resize(int num) //重新指定容器大小，比原来大就用默认值填充容器，比原来小将容器末尾元素舍去 push_back(element) //尾部添加一个元素element pop_back() //尾部删除一个元素 insert(const_iterator pos, element) //在pos位置插入元素element erase(const_iterator pos) //在pos位置删除元素 clear() //删除容器内所有元素 at(int index) //返回指定下标的元素 operator[] //同上 front() //返回容器内第一个元素 back() //返回容器内最后一个元素 deque容器deque容器使用方法与vector容器一样，区别在于当在头部插入元素时由于vector是单端容器所以需要开辟一块新的内存空间并将所有元素都复制一遍，这样效率很低，但deque内部管理多块内存，所以在拷贝容器时不像vector一样将所有元素都拷贝一遍，因此在经常扩增容器容量或者频繁往头尾写入数据的情况下deque效率很高 deque容器的方法： 其他用法与vector一样，头插数据时使用专用方法 cpp push_front(element) //头部添加一个元素element pop_front() //头部删除一个元素 deque没有capacity方法，这是因为deque的内存组织比较复杂，没有固定的大小，vector需要一定的capacity，以避免频繁扩容 stack容器与栈的结构相同，不允许遍历(这是STL设计哲学和栈的定义决定的)，这是因为栈只能查看栈顶元素 stack容器的方法： cpp push(element) //向栈顶添加元素 pop() //从栈顶移除第一个元素 top() //返回栈顶元素但并不移除 empty() //判断栈是否为空 size() //返回栈的大小 queue容器与队列的结构相同，同样也不允许遍历，这是因为只有队列头和队列尾才能访问到 queue容器的方法： cpp push(element) //从队尾添加元素 pop() //从队头移除第一个元素 back() //查看队尾元素 front() //查看对头元素 empty() //判断队列是否为空 size() //返回队列的大小 list容器与链表的结构相同，底层是一个双向循环链表，内部同样实现了begin()，end()迭代器，迭代器不支持随机查找，只支持前移后移 list和vector是最常使用的容器 list容器基本使用方法与vector一样 list容器的方法： cpp erase(const_iterator pos) //在pos位置删除元素 remove(element) //删除容器中所有与element值匹配的元素 reverse() //反转排序 sort() //排序函数，默认从小到大 由于list不支持随机访问，因此也没有实现[]和at的方法 所有不支持随机访问的迭代器不可以使用标准算法(算法库中的算法)，但内部会提供对应算法 cpp list l; l.sort() //默认排序从小到大 set/mutiset容器所有元素插入时会被自动从小到大排序，底层是二叉树 set与mutiset区别： mutiset允许元素重复，但set不允许 set只有insert()的方法，同时set也不支持resize()，因为假如支持resize的话，新的set比原来set大会添加多个默认元素，而set是不允许元素重复的 set容器的方法： cpp find(key) //查找key是否存在，若存在，返回该元素的迭代器，若不存在，返回set.end() count(key) //查找key是否存在 指定set从大到小排序： cpp class mycompare { public: bool operator()(int val1, int val2) //重载仿函数 { return val1 \u003e val2; } }; int main() { set s; //在此处传入回调函数 } 由于set的参数要求传入typename，因此只能传入mycompare，不能传入mycompare() 存放自定义数据类型时必须指定仿函数 cpp class person { public: person(string name, int age) { this-\u003ename = name; this-\u003eage = age; } string name; int age; }; class mycompare { public: bool operator()(const person val1, const person val2) { return val1.age \u003e val2.age; } }; int main() { set s; /* todo */ } map/mutimap容器map与mutimap区别： mutimap允许元素重复，但map不允许 map中所有元素都是pair pair中第一个元素为key，起索引作用，第二个元素为value 所有元素否会根据key值进行排序 map底层使用二叉树实现 map操作与上述容器类似 pair(对组)队组在stl中应用非常广泛，常用于存储成对的数据 创建队组的方式： cpp #include pair p(typeval1,typeval2); pair p = make_pair(typeval1,typeval2) ","date":"2024-01-14","objectID":"/posts/cpp/:7:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#deque容器"},{"categories":["Tech"],"content":" 容器 2024-05-12_17-10 vector容器vector与数组很类似，但是支持动态扩展，实际上当向vector里插入数据时，vector会在内存中找一块更大的空间(通常是2倍扩容)，然后将原数据和新数据一起拷贝进去 2024-05-09_19-41 cpp #include #include using namespace std; void print(vector \u0026v) { for(vector::iterator it = v.begin(); it != v.end(); it++) //注意迭代器写法 { std::cout \u003c\u003c (*it) \u003c\u003c \" \"; } std::cout \u003c\u003c endl; } void test() { int i; vector v1; //无参构造赋值 for(i = 0; i \u003c 10; i++) { v1.push_back(i); } print(v1); vector v2 = v1; //重载运算符赋值(调用到vector提供的重载函数) print(v2); vector v3(v1); //拷贝构造函数赋值 print(v3); } int main() { test(); return 0; } vector容器的方法： cpp empty() //判断容器是否为空 capacity() //获取当前容器中的最大容量，超过此值会导致realloc size() //获取当前容器中元素的个数 shrink_to_fit() //删除元素后调用，可以释放被占用的内存 resize(int num) //重新指定容器大小，比原来大就用默认值填充容器，比原来小将容器末尾元素舍去 push_back(element) //尾部添加一个元素element pop_back() //尾部删除一个元素 insert(const_iterator pos, element) //在pos位置插入元素element erase(const_iterator pos) //在pos位置删除元素 clear() //删除容器内所有元素 at(int index) //返回指定下标的元素 operator[] //同上 front() //返回容器内第一个元素 back() //返回容器内最后一个元素 deque容器deque容器使用方法与vector容器一样，区别在于当在头部插入元素时由于vector是单端容器所以需要开辟一块新的内存空间并将所有元素都复制一遍，这样效率很低，但deque内部管理多块内存，所以在拷贝容器时不像vector一样将所有元素都拷贝一遍，因此在经常扩增容器容量或者频繁往头尾写入数据的情况下deque效率很高 deque容器的方法： 其他用法与vector一样，头插数据时使用专用方法 cpp push_front(element) //头部添加一个元素element pop_front() //头部删除一个元素 deque没有capacity方法，这是因为deque的内存组织比较复杂，没有固定的大小，vector需要一定的capacity，以避免频繁扩容 stack容器与栈的结构相同，不允许遍历(这是STL设计哲学和栈的定义决定的)，这是因为栈只能查看栈顶元素 stack容器的方法： cpp push(element) //向栈顶添加元素 pop() //从栈顶移除第一个元素 top() //返回栈顶元素但并不移除 empty() //判断栈是否为空 size() //返回栈的大小 queue容器与队列的结构相同，同样也不允许遍历，这是因为只有队列头和队列尾才能访问到 queue容器的方法： cpp push(element) //从队尾添加元素 pop() //从队头移除第一个元素 back() //查看队尾元素 front() //查看对头元素 empty() //判断队列是否为空 size() //返回队列的大小 list容器与链表的结构相同，底层是一个双向循环链表，内部同样实现了begin()，end()迭代器，迭代器不支持随机查找，只支持前移后移 list和vector是最常使用的容器 list容器基本使用方法与vector一样 list容器的方法： cpp erase(const_iterator pos) //在pos位置删除元素 remove(element) //删除容器中所有与element值匹配的元素 reverse() //反转排序 sort() //排序函数，默认从小到大 由于list不支持随机访问，因此也没有实现[]和at的方法 所有不支持随机访问的迭代器不可以使用标准算法(算法库中的算法)，但内部会提供对应算法 cpp list l; l.sort() //默认排序从小到大 set/mutiset容器所有元素插入时会被自动从小到大排序，底层是二叉树 set与mutiset区别： mutiset允许元素重复，但set不允许 set只有insert()的方法，同时set也不支持resize()，因为假如支持resize的话，新的set比原来set大会添加多个默认元素，而set是不允许元素重复的 set容器的方法： cpp find(key) //查找key是否存在，若存在，返回该元素的迭代器，若不存在，返回set.end() count(key) //查找key是否存在 指定set从大到小排序： cpp class mycompare { public: bool operator()(int val1, int val2) //重载仿函数 { return val1 \u003e val2; } }; int main() { set s; //在此处传入回调函数 } 由于set的参数要求传入typename，因此只能传入mycompare，不能传入mycompare() 存放自定义数据类型时必须指定仿函数 cpp class person { public: person(string name, int age) { this-\u003ename = name; this-\u003eage = age; } string name; int age; }; class mycompare { public: bool operator()(const person val1, const person val2) { return val1.age \u003e val2.age; } }; int main() { set s; /* todo */ } map/mutimap容器map与mutimap区别： mutimap允许元素重复，但map不允许 map中所有元素都是pair pair中第一个元素为key，起索引作用，第二个元素为value 所有元素否会根据key值进行排序 map底层使用二叉树实现 map操作与上述容器类似 pair(对组)队组在stl中应用非常广泛，常用于存储成对的数据 创建队组的方式： cpp #include pair p(typeval1,typeval2); pair p = make_pair(typeval1,typeval2) ","date":"2024-01-14","objectID":"/posts/cpp/:7:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#stack容器"},{"categories":["Tech"],"content":" 容器 2024-05-12_17-10 vector容器vector与数组很类似，但是支持动态扩展，实际上当向vector里插入数据时，vector会在内存中找一块更大的空间(通常是2倍扩容)，然后将原数据和新数据一起拷贝进去 2024-05-09_19-41 cpp #include #include using namespace std; void print(vector \u0026v) { for(vector::iterator it = v.begin(); it != v.end(); it++) //注意迭代器写法 { std::cout \u003c\u003c (*it) \u003c\u003c \" \"; } std::cout \u003c\u003c endl; } void test() { int i; vector v1; //无参构造赋值 for(i = 0; i \u003c 10; i++) { v1.push_back(i); } print(v1); vector v2 = v1; //重载运算符赋值(调用到vector提供的重载函数) print(v2); vector v3(v1); //拷贝构造函数赋值 print(v3); } int main() { test(); return 0; } vector容器的方法： cpp empty() //判断容器是否为空 capacity() //获取当前容器中的最大容量，超过此值会导致realloc size() //获取当前容器中元素的个数 shrink_to_fit() //删除元素后调用，可以释放被占用的内存 resize(int num) //重新指定容器大小，比原来大就用默认值填充容器，比原来小将容器末尾元素舍去 push_back(element) //尾部添加一个元素element pop_back() //尾部删除一个元素 insert(const_iterator pos, element) //在pos位置插入元素element erase(const_iterator pos) //在pos位置删除元素 clear() //删除容器内所有元素 at(int index) //返回指定下标的元素 operator[] //同上 front() //返回容器内第一个元素 back() //返回容器内最后一个元素 deque容器deque容器使用方法与vector容器一样，区别在于当在头部插入元素时由于vector是单端容器所以需要开辟一块新的内存空间并将所有元素都复制一遍，这样效率很低，但deque内部管理多块内存，所以在拷贝容器时不像vector一样将所有元素都拷贝一遍，因此在经常扩增容器容量或者频繁往头尾写入数据的情况下deque效率很高 deque容器的方法： 其他用法与vector一样，头插数据时使用专用方法 cpp push_front(element) //头部添加一个元素element pop_front() //头部删除一个元素 deque没有capacity方法，这是因为deque的内存组织比较复杂，没有固定的大小，vector需要一定的capacity，以避免频繁扩容 stack容器与栈的结构相同，不允许遍历(这是STL设计哲学和栈的定义决定的)，这是因为栈只能查看栈顶元素 stack容器的方法： cpp push(element) //向栈顶添加元素 pop() //从栈顶移除第一个元素 top() //返回栈顶元素但并不移除 empty() //判断栈是否为空 size() //返回栈的大小 queue容器与队列的结构相同，同样也不允许遍历，这是因为只有队列头和队列尾才能访问到 queue容器的方法： cpp push(element) //从队尾添加元素 pop() //从队头移除第一个元素 back() //查看队尾元素 front() //查看对头元素 empty() //判断队列是否为空 size() //返回队列的大小 list容器与链表的结构相同，底层是一个双向循环链表，内部同样实现了begin()，end()迭代器，迭代器不支持随机查找，只支持前移后移 list和vector是最常使用的容器 list容器基本使用方法与vector一样 list容器的方法： cpp erase(const_iterator pos) //在pos位置删除元素 remove(element) //删除容器中所有与element值匹配的元素 reverse() //反转排序 sort() //排序函数，默认从小到大 由于list不支持随机访问，因此也没有实现[]和at的方法 所有不支持随机访问的迭代器不可以使用标准算法(算法库中的算法)，但内部会提供对应算法 cpp list l; l.sort() //默认排序从小到大 set/mutiset容器所有元素插入时会被自动从小到大排序，底层是二叉树 set与mutiset区别： mutiset允许元素重复，但set不允许 set只有insert()的方法，同时set也不支持resize()，因为假如支持resize的话，新的set比原来set大会添加多个默认元素，而set是不允许元素重复的 set容器的方法： cpp find(key) //查找key是否存在，若存在，返回该元素的迭代器，若不存在，返回set.end() count(key) //查找key是否存在 指定set从大到小排序： cpp class mycompare { public: bool operator()(int val1, int val2) //重载仿函数 { return val1 \u003e val2; } }; int main() { set s; //在此处传入回调函数 } 由于set的参数要求传入typename，因此只能传入mycompare，不能传入mycompare() 存放自定义数据类型时必须指定仿函数 cpp class person { public: person(string name, int age) { this-\u003ename = name; this-\u003eage = age; } string name; int age; }; class mycompare { public: bool operator()(const person val1, const person val2) { return val1.age \u003e val2.age; } }; int main() { set s; /* todo */ } map/mutimap容器map与mutimap区别： mutimap允许元素重复，但map不允许 map中所有元素都是pair pair中第一个元素为key，起索引作用，第二个元素为value 所有元素否会根据key值进行排序 map底层使用二叉树实现 map操作与上述容器类似 pair(对组)队组在stl中应用非常广泛，常用于存储成对的数据 创建队组的方式： cpp #include pair p(typeval1,typeval2); pair p = make_pair(typeval1,typeval2) ","date":"2024-01-14","objectID":"/posts/cpp/:7:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#queue容器"},{"categories":["Tech"],"content":" 容器 2024-05-12_17-10 vector容器vector与数组很类似，但是支持动态扩展，实际上当向vector里插入数据时，vector会在内存中找一块更大的空间(通常是2倍扩容)，然后将原数据和新数据一起拷贝进去 2024-05-09_19-41 cpp #include #include using namespace std; void print(vector \u0026v) { for(vector::iterator it = v.begin(); it != v.end(); it++) //注意迭代器写法 { std::cout \u003c\u003c (*it) \u003c\u003c \" \"; } std::cout \u003c\u003c endl; } void test() { int i; vector v1; //无参构造赋值 for(i = 0; i \u003c 10; i++) { v1.push_back(i); } print(v1); vector v2 = v1; //重载运算符赋值(调用到vector提供的重载函数) print(v2); vector v3(v1); //拷贝构造函数赋值 print(v3); } int main() { test(); return 0; } vector容器的方法： cpp empty() //判断容器是否为空 capacity() //获取当前容器中的最大容量，超过此值会导致realloc size() //获取当前容器中元素的个数 shrink_to_fit() //删除元素后调用，可以释放被占用的内存 resize(int num) //重新指定容器大小，比原来大就用默认值填充容器，比原来小将容器末尾元素舍去 push_back(element) //尾部添加一个元素element pop_back() //尾部删除一个元素 insert(const_iterator pos, element) //在pos位置插入元素element erase(const_iterator pos) //在pos位置删除元素 clear() //删除容器内所有元素 at(int index) //返回指定下标的元素 operator[] //同上 front() //返回容器内第一个元素 back() //返回容器内最后一个元素 deque容器deque容器使用方法与vector容器一样，区别在于当在头部插入元素时由于vector是单端容器所以需要开辟一块新的内存空间并将所有元素都复制一遍，这样效率很低，但deque内部管理多块内存，所以在拷贝容器时不像vector一样将所有元素都拷贝一遍，因此在经常扩增容器容量或者频繁往头尾写入数据的情况下deque效率很高 deque容器的方法： 其他用法与vector一样，头插数据时使用专用方法 cpp push_front(element) //头部添加一个元素element pop_front() //头部删除一个元素 deque没有capacity方法，这是因为deque的内存组织比较复杂，没有固定的大小，vector需要一定的capacity，以避免频繁扩容 stack容器与栈的结构相同，不允许遍历(这是STL设计哲学和栈的定义决定的)，这是因为栈只能查看栈顶元素 stack容器的方法： cpp push(element) //向栈顶添加元素 pop() //从栈顶移除第一个元素 top() //返回栈顶元素但并不移除 empty() //判断栈是否为空 size() //返回栈的大小 queue容器与队列的结构相同，同样也不允许遍历，这是因为只有队列头和队列尾才能访问到 queue容器的方法： cpp push(element) //从队尾添加元素 pop() //从队头移除第一个元素 back() //查看队尾元素 front() //查看对头元素 empty() //判断队列是否为空 size() //返回队列的大小 list容器与链表的结构相同，底层是一个双向循环链表，内部同样实现了begin()，end()迭代器，迭代器不支持随机查找，只支持前移后移 list和vector是最常使用的容器 list容器基本使用方法与vector一样 list容器的方法： cpp erase(const_iterator pos) //在pos位置删除元素 remove(element) //删除容器中所有与element值匹配的元素 reverse() //反转排序 sort() //排序函数，默认从小到大 由于list不支持随机访问，因此也没有实现[]和at的方法 所有不支持随机访问的迭代器不可以使用标准算法(算法库中的算法)，但内部会提供对应算法 cpp list l; l.sort() //默认排序从小到大 set/mutiset容器所有元素插入时会被自动从小到大排序，底层是二叉树 set与mutiset区别： mutiset允许元素重复，但set不允许 set只有insert()的方法，同时set也不支持resize()，因为假如支持resize的话，新的set比原来set大会添加多个默认元素，而set是不允许元素重复的 set容器的方法： cpp find(key) //查找key是否存在，若存在，返回该元素的迭代器，若不存在，返回set.end() count(key) //查找key是否存在 指定set从大到小排序： cpp class mycompare { public: bool operator()(int val1, int val2) //重载仿函数 { return val1 \u003e val2; } }; int main() { set s; //在此处传入回调函数 } 由于set的参数要求传入typename，因此只能传入mycompare，不能传入mycompare() 存放自定义数据类型时必须指定仿函数 cpp class person { public: person(string name, int age) { this-\u003ename = name; this-\u003eage = age; } string name; int age; }; class mycompare { public: bool operator()(const person val1, const person val2) { return val1.age \u003e val2.age; } }; int main() { set s; /* todo */ } map/mutimap容器map与mutimap区别： mutimap允许元素重复，但map不允许 map中所有元素都是pair pair中第一个元素为key，起索引作用，第二个元素为value 所有元素否会根据key值进行排序 map底层使用二叉树实现 map操作与上述容器类似 pair(对组)队组在stl中应用非常广泛，常用于存储成对的数据 创建队组的方式： cpp #include pair p(typeval1,typeval2); pair p = make_pair(typeval1,typeval2) ","date":"2024-01-14","objectID":"/posts/cpp/:7:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#list容器"},{"categories":["Tech"],"content":" 容器 2024-05-12_17-10 vector容器vector与数组很类似，但是支持动态扩展，实际上当向vector里插入数据时，vector会在内存中找一块更大的空间(通常是2倍扩容)，然后将原数据和新数据一起拷贝进去 2024-05-09_19-41 cpp #include #include using namespace std; void print(vector \u0026v) { for(vector::iterator it = v.begin(); it != v.end(); it++) //注意迭代器写法 { std::cout \u003c\u003c (*it) \u003c\u003c \" \"; } std::cout \u003c\u003c endl; } void test() { int i; vector v1; //无参构造赋值 for(i = 0; i \u003c 10; i++) { v1.push_back(i); } print(v1); vector v2 = v1; //重载运算符赋值(调用到vector提供的重载函数) print(v2); vector v3(v1); //拷贝构造函数赋值 print(v3); } int main() { test(); return 0; } vector容器的方法： cpp empty() //判断容器是否为空 capacity() //获取当前容器中的最大容量，超过此值会导致realloc size() //获取当前容器中元素的个数 shrink_to_fit() //删除元素后调用，可以释放被占用的内存 resize(int num) //重新指定容器大小，比原来大就用默认值填充容器，比原来小将容器末尾元素舍去 push_back(element) //尾部添加一个元素element pop_back() //尾部删除一个元素 insert(const_iterator pos, element) //在pos位置插入元素element erase(const_iterator pos) //在pos位置删除元素 clear() //删除容器内所有元素 at(int index) //返回指定下标的元素 operator[] //同上 front() //返回容器内第一个元素 back() //返回容器内最后一个元素 deque容器deque容器使用方法与vector容器一样，区别在于当在头部插入元素时由于vector是单端容器所以需要开辟一块新的内存空间并将所有元素都复制一遍，这样效率很低，但deque内部管理多块内存，所以在拷贝容器时不像vector一样将所有元素都拷贝一遍，因此在经常扩增容器容量或者频繁往头尾写入数据的情况下deque效率很高 deque容器的方法： 其他用法与vector一样，头插数据时使用专用方法 cpp push_front(element) //头部添加一个元素element pop_front() //头部删除一个元素 deque没有capacity方法，这是因为deque的内存组织比较复杂，没有固定的大小，vector需要一定的capacity，以避免频繁扩容 stack容器与栈的结构相同，不允许遍历(这是STL设计哲学和栈的定义决定的)，这是因为栈只能查看栈顶元素 stack容器的方法： cpp push(element) //向栈顶添加元素 pop() //从栈顶移除第一个元素 top() //返回栈顶元素但并不移除 empty() //判断栈是否为空 size() //返回栈的大小 queue容器与队列的结构相同，同样也不允许遍历，这是因为只有队列头和队列尾才能访问到 queue容器的方法： cpp push(element) //从队尾添加元素 pop() //从队头移除第一个元素 back() //查看队尾元素 front() //查看对头元素 empty() //判断队列是否为空 size() //返回队列的大小 list容器与链表的结构相同，底层是一个双向循环链表，内部同样实现了begin()，end()迭代器，迭代器不支持随机查找，只支持前移后移 list和vector是最常使用的容器 list容器基本使用方法与vector一样 list容器的方法： cpp erase(const_iterator pos) //在pos位置删除元素 remove(element) //删除容器中所有与element值匹配的元素 reverse() //反转排序 sort() //排序函数，默认从小到大 由于list不支持随机访问，因此也没有实现[]和at的方法 所有不支持随机访问的迭代器不可以使用标准算法(算法库中的算法)，但内部会提供对应算法 cpp list l; l.sort() //默认排序从小到大 set/mutiset容器所有元素插入时会被自动从小到大排序，底层是二叉树 set与mutiset区别： mutiset允许元素重复，但set不允许 set只有insert()的方法，同时set也不支持resize()，因为假如支持resize的话，新的set比原来set大会添加多个默认元素，而set是不允许元素重复的 set容器的方法： cpp find(key) //查找key是否存在，若存在，返回该元素的迭代器，若不存在，返回set.end() count(key) //查找key是否存在 指定set从大到小排序： cpp class mycompare { public: bool operator()(int val1, int val2) //重载仿函数 { return val1 \u003e val2; } }; int main() { set s; //在此处传入回调函数 } 由于set的参数要求传入typename，因此只能传入mycompare，不能传入mycompare() 存放自定义数据类型时必须指定仿函数 cpp class person { public: person(string name, int age) { this-\u003ename = name; this-\u003eage = age; } string name; int age; }; class mycompare { public: bool operator()(const person val1, const person val2) { return val1.age \u003e val2.age; } }; int main() { set s; /* todo */ } map/mutimap容器map与mutimap区别： mutimap允许元素重复，但map不允许 map中所有元素都是pair pair中第一个元素为key，起索引作用，第二个元素为value 所有元素否会根据key值进行排序 map底层使用二叉树实现 map操作与上述容器类似 pair(对组)队组在stl中应用非常广泛，常用于存储成对的数据 创建队组的方式： cpp #include pair p(typeval1,typeval2); pair p = make_pair(typeval1,typeval2) ","date":"2024-01-14","objectID":"/posts/cpp/:7:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#setmutiset容器"},{"categories":["Tech"],"content":" 容器 2024-05-12_17-10 vector容器vector与数组很类似，但是支持动态扩展，实际上当向vector里插入数据时，vector会在内存中找一块更大的空间(通常是2倍扩容)，然后将原数据和新数据一起拷贝进去 2024-05-09_19-41 cpp #include #include using namespace std; void print(vector \u0026v) { for(vector::iterator it = v.begin(); it != v.end(); it++) //注意迭代器写法 { std::cout \u003c\u003c (*it) \u003c\u003c \" \"; } std::cout \u003c\u003c endl; } void test() { int i; vector v1; //无参构造赋值 for(i = 0; i \u003c 10; i++) { v1.push_back(i); } print(v1); vector v2 = v1; //重载运算符赋值(调用到vector提供的重载函数) print(v2); vector v3(v1); //拷贝构造函数赋值 print(v3); } int main() { test(); return 0; } vector容器的方法： cpp empty() //判断容器是否为空 capacity() //获取当前容器中的最大容量，超过此值会导致realloc size() //获取当前容器中元素的个数 shrink_to_fit() //删除元素后调用，可以释放被占用的内存 resize(int num) //重新指定容器大小，比原来大就用默认值填充容器，比原来小将容器末尾元素舍去 push_back(element) //尾部添加一个元素element pop_back() //尾部删除一个元素 insert(const_iterator pos, element) //在pos位置插入元素element erase(const_iterator pos) //在pos位置删除元素 clear() //删除容器内所有元素 at(int index) //返回指定下标的元素 operator[] //同上 front() //返回容器内第一个元素 back() //返回容器内最后一个元素 deque容器deque容器使用方法与vector容器一样，区别在于当在头部插入元素时由于vector是单端容器所以需要开辟一块新的内存空间并将所有元素都复制一遍，这样效率很低，但deque内部管理多块内存，所以在拷贝容器时不像vector一样将所有元素都拷贝一遍，因此在经常扩增容器容量或者频繁往头尾写入数据的情况下deque效率很高 deque容器的方法： 其他用法与vector一样，头插数据时使用专用方法 cpp push_front(element) //头部添加一个元素element pop_front() //头部删除一个元素 deque没有capacity方法，这是因为deque的内存组织比较复杂，没有固定的大小，vector需要一定的capacity，以避免频繁扩容 stack容器与栈的结构相同，不允许遍历(这是STL设计哲学和栈的定义决定的)，这是因为栈只能查看栈顶元素 stack容器的方法： cpp push(element) //向栈顶添加元素 pop() //从栈顶移除第一个元素 top() //返回栈顶元素但并不移除 empty() //判断栈是否为空 size() //返回栈的大小 queue容器与队列的结构相同，同样也不允许遍历，这是因为只有队列头和队列尾才能访问到 queue容器的方法： cpp push(element) //从队尾添加元素 pop() //从队头移除第一个元素 back() //查看队尾元素 front() //查看对头元素 empty() //判断队列是否为空 size() //返回队列的大小 list容器与链表的结构相同，底层是一个双向循环链表，内部同样实现了begin()，end()迭代器，迭代器不支持随机查找，只支持前移后移 list和vector是最常使用的容器 list容器基本使用方法与vector一样 list容器的方法： cpp erase(const_iterator pos) //在pos位置删除元素 remove(element) //删除容器中所有与element值匹配的元素 reverse() //反转排序 sort() //排序函数，默认从小到大 由于list不支持随机访问，因此也没有实现[]和at的方法 所有不支持随机访问的迭代器不可以使用标准算法(算法库中的算法)，但内部会提供对应算法 cpp list l; l.sort() //默认排序从小到大 set/mutiset容器所有元素插入时会被自动从小到大排序，底层是二叉树 set与mutiset区别： mutiset允许元素重复，但set不允许 set只有insert()的方法，同时set也不支持resize()，因为假如支持resize的话，新的set比原来set大会添加多个默认元素，而set是不允许元素重复的 set容器的方法： cpp find(key) //查找key是否存在，若存在，返回该元素的迭代器，若不存在，返回set.end() count(key) //查找key是否存在 指定set从大到小排序： cpp class mycompare { public: bool operator()(int val1, int val2) //重载仿函数 { return val1 \u003e val2; } }; int main() { set s; //在此处传入回调函数 } 由于set的参数要求传入typename，因此只能传入mycompare，不能传入mycompare() 存放自定义数据类型时必须指定仿函数 cpp class person { public: person(string name, int age) { this-\u003ename = name; this-\u003eage = age; } string name; int age; }; class mycompare { public: bool operator()(const person val1, const person val2) { return val1.age \u003e val2.age; } }; int main() { set s; /* todo */ } map/mutimap容器map与mutimap区别： mutimap允许元素重复，但map不允许 map中所有元素都是pair pair中第一个元素为key，起索引作用，第二个元素为value 所有元素否会根据key值进行排序 map底层使用二叉树实现 map操作与上述容器类似 pair(对组)队组在stl中应用非常广泛，常用于存储成对的数据 创建队组的方式： cpp #include pair p(typeval1,typeval2); pair p = make_pair(typeval1,typeval2) ","date":"2024-01-14","objectID":"/posts/cpp/:7:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#mapmutimap容器"},{"categories":["Tech"],"content":" 容器 2024-05-12_17-10 vector容器vector与数组很类似，但是支持动态扩展，实际上当向vector里插入数据时，vector会在内存中找一块更大的空间(通常是2倍扩容)，然后将原数据和新数据一起拷贝进去 2024-05-09_19-41 cpp #include #include using namespace std; void print(vector \u0026v) { for(vector::iterator it = v.begin(); it != v.end(); it++) //注意迭代器写法 { std::cout \u003c\u003c (*it) \u003c\u003c \" \"; } std::cout \u003c\u003c endl; } void test() { int i; vector v1; //无参构造赋值 for(i = 0; i \u003c 10; i++) { v1.push_back(i); } print(v1); vector v2 = v1; //重载运算符赋值(调用到vector提供的重载函数) print(v2); vector v3(v1); //拷贝构造函数赋值 print(v3); } int main() { test(); return 0; } vector容器的方法： cpp empty() //判断容器是否为空 capacity() //获取当前容器中的最大容量，超过此值会导致realloc size() //获取当前容器中元素的个数 shrink_to_fit() //删除元素后调用，可以释放被占用的内存 resize(int num) //重新指定容器大小，比原来大就用默认值填充容器，比原来小将容器末尾元素舍去 push_back(element) //尾部添加一个元素element pop_back() //尾部删除一个元素 insert(const_iterator pos, element) //在pos位置插入元素element erase(const_iterator pos) //在pos位置删除元素 clear() //删除容器内所有元素 at(int index) //返回指定下标的元素 operator[] //同上 front() //返回容器内第一个元素 back() //返回容器内最后一个元素 deque容器deque容器使用方法与vector容器一样，区别在于当在头部插入元素时由于vector是单端容器所以需要开辟一块新的内存空间并将所有元素都复制一遍，这样效率很低，但deque内部管理多块内存，所以在拷贝容器时不像vector一样将所有元素都拷贝一遍，因此在经常扩增容器容量或者频繁往头尾写入数据的情况下deque效率很高 deque容器的方法： 其他用法与vector一样，头插数据时使用专用方法 cpp push_front(element) //头部添加一个元素element pop_front() //头部删除一个元素 deque没有capacity方法，这是因为deque的内存组织比较复杂，没有固定的大小，vector需要一定的capacity，以避免频繁扩容 stack容器与栈的结构相同，不允许遍历(这是STL设计哲学和栈的定义决定的)，这是因为栈只能查看栈顶元素 stack容器的方法： cpp push(element) //向栈顶添加元素 pop() //从栈顶移除第一个元素 top() //返回栈顶元素但并不移除 empty() //判断栈是否为空 size() //返回栈的大小 queue容器与队列的结构相同，同样也不允许遍历，这是因为只有队列头和队列尾才能访问到 queue容器的方法： cpp push(element) //从队尾添加元素 pop() //从队头移除第一个元素 back() //查看队尾元素 front() //查看对头元素 empty() //判断队列是否为空 size() //返回队列的大小 list容器与链表的结构相同，底层是一个双向循环链表，内部同样实现了begin()，end()迭代器，迭代器不支持随机查找，只支持前移后移 list和vector是最常使用的容器 list容器基本使用方法与vector一样 list容器的方法： cpp erase(const_iterator pos) //在pos位置删除元素 remove(element) //删除容器中所有与element值匹配的元素 reverse() //反转排序 sort() //排序函数，默认从小到大 由于list不支持随机访问，因此也没有实现[]和at的方法 所有不支持随机访问的迭代器不可以使用标准算法(算法库中的算法)，但内部会提供对应算法 cpp list l; l.sort() //默认排序从小到大 set/mutiset容器所有元素插入时会被自动从小到大排序，底层是二叉树 set与mutiset区别： mutiset允许元素重复，但set不允许 set只有insert()的方法，同时set也不支持resize()，因为假如支持resize的话，新的set比原来set大会添加多个默认元素，而set是不允许元素重复的 set容器的方法： cpp find(key) //查找key是否存在，若存在，返回该元素的迭代器，若不存在，返回set.end() count(key) //查找key是否存在 指定set从大到小排序： cpp class mycompare { public: bool operator()(int val1, int val2) //重载仿函数 { return val1 \u003e val2; } }; int main() { set s; //在此处传入回调函数 } 由于set的参数要求传入typename，因此只能传入mycompare，不能传入mycompare() 存放自定义数据类型时必须指定仿函数 cpp class person { public: person(string name, int age) { this-\u003ename = name; this-\u003eage = age; } string name; int age; }; class mycompare { public: bool operator()(const person val1, const person val2) { return val1.age \u003e val2.age; } }; int main() { set s; /* todo */ } map/mutimap容器map与mutimap区别： mutimap允许元素重复，但map不允许 map中所有元素都是pair pair中第一个元素为key，起索引作用，第二个元素为value 所有元素否会根据key值进行排序 map底层使用二叉树实现 map操作与上述容器类似 pair(对组)队组在stl中应用非常广泛，常用于存储成对的数据 创建队组的方式： cpp #include pair p(typeval1,typeval2); pair p = make_pair(typeval1,typeval2) ","date":"2024-01-14","objectID":"/posts/cpp/:7:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#pair对组"},{"categories":["Tech"],"content":" 函数对象函数对象使用重载的()时，我们称为仿函数或函数对象 函数对象实际上是个类，并不是函数 谓词(predicate) 我们将返回值为bool类型的函数对象称为谓词 如果operator()()接受一个参数我们称为一元谓词 如果operator()()接受两个参数我们称为二元谓词 一般由重载()且返回值是bool类型的函数对象，函数指针，lambda表达式充当谓词 cpp #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e using namespace std; class mycompare { public: bool operator()(int v1, int v2) //二元谓词 { return v1 \u003e v2; } }; void test() { vector\u003cint\u003e v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for(vector\u003cint\u003e::iterator it = v1.begin(); it != v1.end(); it++) { cout \u003c\u003c (*it) \u003c\u003c \" \"; } cout \u003c\u003c endl; //这里的greater是函数模板的名字，\u003c\u003e代表是个模板，()代表参数列表 sort(v1.begin(),v1.end(),greater\u003cint\u003e()); //sort默认的排序方式为less\u003c\u003e，如果我们需要自定义排序函数就需要传入系统提供的谓词greater，也别忘了需要引入头文件functional for(vector\u003cint\u003e::iterator it = v1.begin(); it != v1.end(); it++) { cout \u003c\u003c (*it) \u003c\u003c \" \"; } cout \u003c\u003c endl; sort(v1.begin(),v1.end(),mycompare()); //sort默认的排序方式为less\u003c\u003e，如果我们需要自定义排序函数就需要传入仿函数 for(vector\u003cint\u003e::iterator it = v1.begin(); it != v1.end(); it++) { cout \u003c\u003c (*it) \u003c\u003c \" \"; } cout \u003c\u003c endl; } int main() { test(); } ","date":"2024-01-14","objectID":"/posts/cpp/:7:2","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#函数对象"},{"categories":["Tech"],"content":" 函数对象函数对象使用重载的()时，我们称为仿函数或函数对象 函数对象实际上是个类，并不是函数 谓词(predicate) 我们将返回值为bool类型的函数对象称为谓词 如果operator()()接受一个参数我们称为一元谓词 如果operator()()接受两个参数我们称为二元谓词 一般由重载()且返回值是bool类型的函数对象，函数指针，lambda表达式充当谓词 cpp #include #include #include using namespace std; class mycompare { public: bool operator()(int v1, int v2) //二元谓词 { return v1 \u003e v2; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for(vector::iterator it = v1.begin(); it != v1.end(); it++) { cout \u003c\u003c (*it) \u003c\u003c \" \"; } cout \u003c\u003c endl; //这里的greater是函数模板的名字，\u003c\u003e代表是个模板，()代表参数列表 sort(v1.begin(),v1.end(),greater()); //sort默认的排序方式为less\u003c\u003e，如果我们需要自定义排序函数就需要传入系统提供的谓词greater，也别忘了需要引入头文件functional for(vector::iterator it = v1.begin(); it != v1.end(); it++) { cout \u003c\u003c (*it) \u003c\u003c \" \"; } cout \u003c\u003c endl; sort(v1.begin(),v1.end(),mycompare()); //sort默认的排序方式为less\u003c\u003e，如果我们需要自定义排序函数就需要传入仿函数 for(vector::iterator it = v1.begin(); it != v1.end(); it++) { cout \u003c\u003c (*it) \u003c\u003c \" \"; } cout \u003c\u003c endl; } int main() { test(); } ","date":"2024-01-14","objectID":"/posts/cpp/:7:2","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#谓词predicate"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e #include \u003cfunctional\u003e using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector\u003cint\u003e v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e // transform int main() { std::vector\u003cint\u003e src = {1, 2, 3, 4, 5}; std::vector\u003cint\u003e des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container\u003ctype\u003e::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e #include \u003cfunctional\u003e using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector\u003cperson\u003e v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector\u003cperson\u003e::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container\u003ctype\u003e::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e #include \u003cfunctional\u003e using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector\u003cperson\u003e v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector\u003cperson\u003e::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container\u003ctype\u003e::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e #include \u003cfunctional\u003e using namespace std; void test() { int i; vector\u003cint\u003e v1; vector\u003cint\u003e v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#遍历算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#for_each算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#transform算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#查找算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#find算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#find_if算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#adjacent_find算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#binary_search算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#count算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#count_if算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#排序算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#sort算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#merge算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#reverse算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#拷贝和替换算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#copy算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#replace算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#replace_if算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#swap算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#算数生成算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#accumulate算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#集合算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#set_intersection算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#set_union算法"},{"categories":["Tech"],"content":" 算法算法需要引入头文件algorithm 遍历算法 for_each算法 cpp for_each(iterator begin(), iterator end(), pred); cpp #include #include #include #include using namespace std; void print1(int val) { cout \u003c\u003c val \u003c\u003c \" \"; } class print2 { public: void operator()(int v1) { cout \u003c\u003c v1 \u003c\u003c \" \"; } }; void test() { vector v1; v1.push_back(10); v1.push_back(50); v1.push_back(40); v1.push_back(20); v1.push_back(30); for_each(v1.begin(),v1.end(),print1); //传入函数地址 for_each(v1.begin(),v1.end(),print2()); //传入函数对象，必须加括号 cout \u003c\u003c endl; } int main() { test(); } transform算法将一个容器的数据转移到另一个容器 使用transform前必须使用resize方法指定容器大小 cpp transform(iterator src_begin(), iterator src_end(), iterator des_begin(), pred); 下民是示例： cpp #include #include #include // transform int main() { std::vector src = {1, 2, 3, 4, 5}; std::vector des(src.size()); // 必须提前分配空间 // 对 src 的每个元素 +1，结果存入 des std::transform( src.begin(), src.end(), // 源范围 des.begin(), // 目标起始位置 [](int x) { return x + 1; } // 转换函数（Lambda） ); // 输出 des: 2 3 4 5 6 for (int x : des) std::cout \u003c\u003c x \u003c\u003c \" \"; return 0; } 查找算法 find算法find的返回结果是个迭代器，如果找到的话返回迭代器，没找到的话返回end() cpp container::iterator it = find(iterator begin(), iterator end(), pred); 下面是示例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } bool operator==(const person\u0026 p) //如果不想编译器给你写小作文的话这里必须使用const，自用数据类型不需要这么写，但为了stl::find还是将就一下吧 { //如果这里没有运算符重载的话，下面的if(it == v1.end())就不知道怎么做了 if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) return true; else return false; } string name; int age; }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find(v1.begin(), v1.end(), p6); //find的返回值是个迭代器 if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); return 0; } find_if算法从此处开始，predicated(谓词)被简写为pred cpp container::iterator it = find_if(iterator begin(), iterator end(), pred); 下面是实例： cpp #include #include #include #include using namespace std; class person { public: person(string name, int age) { this-\u003eage = age; this-\u003ename = name; } // bool operator==(const person\u0026 p) //相比find来说由于find_if需要传入返回值为bool的仿函数(谓词)，在仿函数中就已经表明了要对数据进行的操作，因此不需要进行重载了 // { // if(this-\u003eage == p.age \u0026\u0026 this-\u003ename == p.name) // return true; // else // return false; // } string name; int age; }; class greater20 { public: bool operator()(person\u0026 p) { if(p.age \u003e 20) return true; else return false; } }; void test() { vector v1; person p1(\"aaa\",10); person p2(\"bbb\",20); person p3(\"ccc\",30); person p4(\"ddd\",40); person p5(\"eee\",50); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); person p6 = person(\"bbb\",20); vector::iterator it = find_if(v1.begin(), v1.end(), greater20()); if(it == v1.end()) { cout \u003c\u003c \"not find\" \u003c\u003c endl; } else { cout \u003c\u003c \"find\" \u003c\u003c endl; } } int main() { test(); } adjacent_find算法查找相邻元素是否重复 cpp container::iterator it = adjacent_find(iterator begin(), iterator end()） binary_search算法二分法查找元素是否存在 在使用binary_search前的数据必须是有序序列，这是二分法原理要求的，并且binary_search源码要求必须为升序排列 count算法查询元素数量 count参数并没有谓词，因此需要自行实现==运算符重载 count_if算法需要谓词的count算法 排序算法 sort算法对容器进行排序，默认为升序 cpp sort(iterator begin(), iterator end(), pred) merge算法使用前需要使用resize设置目标容器大小 将两容器合并到一个容器里，使用前要保证两个容器都是有序的 cpp merge(iterator container1_begin(), iterator container1_end(),iterator container2_begin(), iterator container2_end(), iterator dest_begin()) cpp #include #include #include #include using namespace std; void test() { int i; vector v1; vector v2; for(i = 0; i \u003c 10; i++) { ","date":"2024-01-14","objectID":"/posts/cpp/:7:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#set_difference算法"},{"categories":["Tech"],"content":" 杂项 std::ref首先引用不是对象，它不一定占有内存空间，换句话说，编译器不能保证引用一定占有内存，有可能会被优化掉，这也表现为引用不能被取地址。引用本身在进行运算时则需要对象，为了能够进行引用的引用等操作，我们可以采用std::ref来包装引用，使其生成一个引用的包装器，而这个包装器则是对象并可以被引用进行运算(此时包装器占有内存了)。这种情况多用于线程传参，此时必须使用std::ref对参数进行包装，这可以明确告诉编译器：我传入的是指针不是值，防止值拷贝造成的线程数据修改无效(线程间参数采用值传递的原因是避免线程间不同步造成悬垂指针)。其次当模板函数传左值引用时函数本身并不能辨别到底是传引用还是传值，使用std::ref对参数进行包装可以明确告诉编译器：我传入的是左值引用，这是个引用不是值。std::ref在底层调用的是std::reference_wrapper std::ref与直接传值的不同 这样看std::ref使用方法与std::move非常类似，只不过std::ref获得的结果是左值引用 参考文档 函数对象与函数对象类型类是在内存中生成的数据(对象)的蓝图，任何对象都是类实例化出来的，函数对象也不例外。我们可以通过重载operator()的类来创建函数对象，相对于函数，函数对象可以保存自己的成员变量 那些重载函数操作运算符的类我们称为函数对象(function object)，使用时需要加{}或()来实例化对象 cpp class myadd { public: operator()(int a, int b) { return a + b; } }; int main() { int ret; ret = myadd()(1, 2); //实例化匿名对象并将(1, 2)参数传入 std::cout \u003c\u003c ret \u003c\u003c std::endl; return 0; } 而函数对象类型(function object type)是一个类型，类型无需实例化，典型应用是stl的set容器的参数，当我们需要指定set容器默认排序为从大到小时我们要给出模板参数列表的函数对象类型 cpp class mycompare { public: bool operator()(int val1, int val2) { return val1 \u003e val2; } }; int main() { set\u003cint,mycompare\u003e s; //指定函数对象类型，无需添加()或{} } ","date":"2024-01-14","objectID":"/posts/cpp/:7:4","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#杂项"},{"categories":["Tech"],"content":" 杂项 std::ref首先引用不是对象，它不一定占有内存空间，换句话说，编译器不能保证引用一定占有内存，有可能会被优化掉，这也表现为引用不能被取地址。引用本身在进行运算时则需要对象，为了能够进行引用的引用等操作，我们可以采用std::ref来包装引用，使其生成一个引用的包装器，而这个包装器则是对象并可以被引用进行运算(此时包装器占有内存了)。这种情况多用于线程传参，此时必须使用std::ref对参数进行包装，这可以明确告诉编译器：我传入的是指针不是值，防止值拷贝造成的线程数据修改无效(线程间参数采用值传递的原因是避免线程间不同步造成悬垂指针)。其次当模板函数传左值引用时函数本身并不能辨别到底是传引用还是传值，使用std::ref对参数进行包装可以明确告诉编译器：我传入的是左值引用，这是个引用不是值。std::ref在底层调用的是std::reference_wrapper std::ref与直接传值的不同 这样看std::ref使用方法与std::move非常类似，只不过std::ref获得的结果是左值引用 参考文档 函数对象与函数对象类型类是在内存中生成的数据(对象)的蓝图，任何对象都是类实例化出来的，函数对象也不例外。我们可以通过重载operator()的类来创建函数对象，相对于函数，函数对象可以保存自己的成员变量 那些重载函数操作运算符的类我们称为函数对象(function object)，使用时需要加{}或()来实例化对象 cpp class myadd { public: operator()(int a, int b) { return a + b; } }; int main() { int ret; ret = myadd()(1, 2); //实例化匿名对象并将(1, 2)参数传入 std::cout \u003c\u003c ret \u003c\u003c std::endl; return 0; } 而函数对象类型(function object type)是一个类型，类型无需实例化，典型应用是stl的set容器的参数，当我们需要指定set容器默认排序为从大到小时我们要给出模板参数列表的函数对象类型 cpp class mycompare { public: bool operator()(int val1, int val2) { return val1 \u003e val2; } }; int main() { set s; //指定函数对象类型，无需添加()或{} } ","date":"2024-01-14","objectID":"/posts/cpp/:7:4","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#stdref"},{"categories":["Tech"],"content":" 杂项 std::ref首先引用不是对象，它不一定占有内存空间，换句话说，编译器不能保证引用一定占有内存，有可能会被优化掉，这也表现为引用不能被取地址。引用本身在进行运算时则需要对象，为了能够进行引用的引用等操作，我们可以采用std::ref来包装引用，使其生成一个引用的包装器，而这个包装器则是对象并可以被引用进行运算(此时包装器占有内存了)。这种情况多用于线程传参，此时必须使用std::ref对参数进行包装，这可以明确告诉编译器：我传入的是指针不是值，防止值拷贝造成的线程数据修改无效(线程间参数采用值传递的原因是避免线程间不同步造成悬垂指针)。其次当模板函数传左值引用时函数本身并不能辨别到底是传引用还是传值，使用std::ref对参数进行包装可以明确告诉编译器：我传入的是左值引用，这是个引用不是值。std::ref在底层调用的是std::reference_wrapper std::ref与直接传值的不同 这样看std::ref使用方法与std::move非常类似，只不过std::ref获得的结果是左值引用 参考文档 函数对象与函数对象类型类是在内存中生成的数据(对象)的蓝图，任何对象都是类实例化出来的，函数对象也不例外。我们可以通过重载operator()的类来创建函数对象，相对于函数，函数对象可以保存自己的成员变量 那些重载函数操作运算符的类我们称为函数对象(function object)，使用时需要加{}或()来实例化对象 cpp class myadd { public: operator()(int a, int b) { return a + b; } }; int main() { int ret; ret = myadd()(1, 2); //实例化匿名对象并将(1, 2)参数传入 std::cout \u003c\u003c ret \u003c\u003c std::endl; return 0; } 而函数对象类型(function object type)是一个类型，类型无需实例化，典型应用是stl的set容器的参数，当我们需要指定set容器默认排序为从大到小时我们要给出模板参数列表的函数对象类型 cpp class mycompare { public: bool operator()(int val1, int val2) { return val1 \u003e val2; } }; int main() { set s; //指定函数对象类型，无需添加()或{} } ","date":"2024-01-14","objectID":"/posts/cpp/:7:4","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#函数对象与函数对象类型"},{"categories":["Tech"],"content":" Mordern C++下列语法特性默认C++版本为C++11 ","date":"2024-01-14","objectID":"/posts/cpp/:0:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#mordern-c"},{"categories":["Tech"],"content":" extern “C” cpp #ifdef __cplusplus extern \"C\" { #endif int add(int x, int y); #ifdef __cplusplus } #endif ","date":"2024-01-14","objectID":"/posts/cpp/:1:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#extern-c"},{"categories":["Tech"],"content":" nullptrC++中禁止void*类型隐式转换为其他类型，这是因为有可能出现double*转换为void*，而后由void*转换为int*的类型安全问题 nullptr是从C++11开始引入的，首先是为了与NULL区分。有的C编译器会将NULL定义为(void*)0，而C++中禁止void*类型隐式转换为其他类型，而NULL天然的有转换到其他类型的趋势，因此NULL就被定义为int 0，但当函数重载时，如果函数参数传入的是NULL，那么很有可能会重载到参数为int类型的重载函数下，而这是非预期的结果。为了解决这个问题我们引入了nullptr cpp template\u003ctypename T\u003e void check(T* ptr) { if (ptr) std::cout \u003c\u003c \"Non-null pointer\\n\"; else std::cout \u003c\u003c \"Null pointer\\n\"; } int main() { check(NULL); // 编译错误（类型不明确） check(nullptr); // 输出 \"Null pointer\" } nullptr的类型为nullptr_t，不会隐式转换为整型，但能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较 ","date":"2024-01-14","objectID":"/posts/cpp/:2:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#nullptr"},{"categories":["Tech"],"content":" constexpr在用const或者static关键字修饰变量，数据类型，或者定义数组时，我们需要显式指明变量，数据类型或者数组长度的值，但C++11提供了constexpr关键字来支持隐式转换： cpp #include \u003ciostream\u003e #define LEN 10 int len_foo() { int i = 2; return i; } constexpr int len_foo_constexpr() { return 5; } constexpr int fibonacci(const int n) { return n == 1 || n == 2 ? 1 : fibonacci(n-1)+fibonacci(n-2); } int main() { char arr_1[10]; // 合法 char arr_2[LEN]; // 合法，宏定义只是字符替换 int len = 10; // char arr_3[len]; // 非法，变量是隐式表达式 const int len_2 = len + 1; constexpr int len_2_constexpr = 1 + 2 + 3; // char arr_4[len_2]; // 非法 char arr_4[len_2_constexpr]; // 合法，使用constexpr修饰的变量或数据类型可以支持隐式表达式 // char arr_5[len_foo()+5]; // 非法 char arr_6[len_foo_constexpr() + 1]; // 合法 std::cout \u003c\u003c fibonacci(10) \u003c\u003c std::endl; //函数递归 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 //打印结果为55 return 0; } ","date":"2024-01-14","objectID":"/posts/cpp/:3:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#constexpr"},{"categories":["Tech"],"content":" 初始化列表我们可以使用{}来统一为变量，容器，非静态成员初始化(C++11)，这相比曾经()与{}混用的情况更规范 下面是示例代码： cpp struct A { int a; string b; std::vector\u003cint\u003e c; }; int main() { A a = {5, \"hello\", {1, 4, 40}}; //这样初始化很方便，写法也很统一 int b = {6}; //这个也是可以编译通过的 string c {\"string\"}; //甚至可以不带等号 std::cout \u003c\u003c a.a \u003c\u003c std::endl; std::cout \u003c\u003c a.b \u003c\u003c std::endl; for_each(a.c.begin(),a.c.end(),[](int value){std::cout \u003c\u003c value \u003c\u003c \" \";}); std::cout \u003c\u003c std::endl; std::cout \u003c\u003c b \u003c\u003c std::endl; return 0; } 实际上，标准容器的初始化是利用std::initializer_list\u003ctype\u003e来进行的，我们也可以利用std::initializer_list\u003ctype\u003e来初始化任意对象，但前提是std::initializer_list\u003ctype\u003e必须作为构造函数的实参，这样编译器才能够支持。即如果一个类希望支持 {value1, value2, …} 这种初始化语法（即初始化列表初始化），它必须显式定义一个以std::initializer_list\u003cT\u003e为参数的构造函数。 cpp class MagicFoo { public: std::vector\u003cint\u003e vec; MagicFoo(std::initializer_list\u003cint\u003e list) { for (std::initializer_list\u003cint\u003e::iterator it = list.begin(); it != list.end(); ++it) vec.push_back(*it); } }; int main() { // after C++11 MagicFoo magicFoo = {1, 2, 3, 4, 5}; std::cout \u003c\u003c \"magicFoo: \"; for (std::vector\u003cint\u003e::iterator it = magicFoo.vec.begin(); it != magicFoo.vec.end(); ++it) std::cout \u003c\u003c *it \u003c\u003c std::endl; } ","date":"2024-01-14","objectID":"/posts/cpp/:4:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#初始化列表"},{"categories":["Tech"],"content":" autoauto关键字可以进行自动类型推导，甚至可以用在函数传参(C++20)，但不能用于数组类型的推导 之前我们写迭代器时需要吟唱这些： cpp for(vector\u003cint\u003e::iterator it = v.begin(); it != v.end(); it++) 但是有了auto关键字后我们可以将其简化为： cpp for(auto it = v.begin(); it != v.end(); it++) 一些其他常见的写法： cpp auto i = 5; // i 被推导为 int auto intp = new auto(10); // intp 被推导为 int * ","date":"2024-01-14","objectID":"/posts/cpp/:5:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#auto"},{"categories":["Tech"],"content":" 区间for迭代有了区间for迭代，我们也可以写出像python那样的for循环了，再结合auto的特性，迭代器的写法会更简单，但是区间for迭代会遍历整个区间，因此如果只想要操作偶数或者奇数位置的元素就需要内嵌条件控制语句 cpp #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e int main() { std::vector\u003cint\u003e vec = {1, 2, 3, 4}; if (auto itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end()) *itr = 4; //冗长的写法 for (auto element : vec) //这语法糖甜死了 std::cout \u003c\u003c element \u003c\u003c std::endl; // read only for (auto \u0026element : vec) { element += 1; // writeable } for (auto element : vec) std::cout \u003c\u003c element \u003c\u003c std::endl; // read only } ","date":"2024-01-14","objectID":"/posts/cpp/:6:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#区间for迭代"},{"categories":["Tech"],"content":" final与override在传统C++中，我们经常在函数重载方面发生错误，例如重载了我们不想重载的方法，部分方法不能被重载 cpp struct Base { virtual void foo(); }; struct SubClass: Base { void foo(); //这个函数并不是我们想重载的，但是由于继承了父类，此时就会发生重载 }; 解决的好方法是使用final关键字，final是为了终止类的继承以及虚函数继续重载引入的 cpp struct Base { virtual void foo() final; }; struct SubClass3: Base { void foo(); // 非法, foo 已 final }; struct SubClass1 final: Base { }; // 合法 struct SubClass2 : SubClass1 { }; // 非法, SubClass1 已 final 当重载虚函数时，引入override关键字将显式的告知编译器进行重载，编译器将检查父类是否存在与子类函数签名一致的虚函数，若有就进行重载，没有将无法通过编译 cpp struct Base { virtual void foo(int); }; struct SubClass: Base { virtual void foo(int) override; // 合法 virtual void foo(float) override; // 非法, 父类没有此虚函数 }; ","date":"2024-01-14","objectID":"/posts/cpp/:7:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#final与override"},{"categories":["Tech"],"content":" decltype与typeiddecltype(declare type，声明类型)与typeof用法类似，但是decltype是C++标准，typeof是GCC扩展 cpp decltype(表达式) auto x = 1; auto y = 2; decltype(x+y) z; decltype与auto都是在编译期进行类型推导的 typeid虽然也是类型推导，但是可以进行动态类型推导，而decltype是在编译期进行推导的 还有一个运行期推导接口dynamic_cast，dynamic_cast与typeid的区别在于如果想要判断的类型是子类，使用dynamic_cast可以被识别，但typeid则不能 dynamic_cast不仅能将子类指针转换为基类指针，甚至还能将基类指针转换为子类指针，如果基类派生出多个子类，那么在转换到我们指定的子类时会返回子类指针，否则在转换到其他子类时会返回nullptr cpp A* test = dynamic_cast\u003cA*\u003e someClassCVar if (test != nullptr) { //it is of class A } if (typeid(someClassCVar) == typeid(A)) { //it is of class A } ","date":"2024-01-14","objectID":"/posts/cpp/:8:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#decltype与typeid"},{"categories":["Tech"],"content":" “\u003c“尖括号带来的歧义问题在传统的C++编译器中，»被视为右移操作符，但这很容易造成歧义 cpp std::vector\u003cstd::vector\u003cint\u003e\u003e matrix; 在C++11中这段代码会被编译通过，但在之前的版本中则不会 ","date":"2024-01-14","objectID":"/posts/cpp/:9:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#尖括号带来的歧义问题"},{"categories":["Tech"],"content":" 变长参数模板类似printf，变长参数模板可以处理不定长的参数变量，并且相对于printf自身实现的变长参数模板更安全 cpp template\u003ctypename... Ts\u003e class Magic; template\u003c\u003e // 表示这是一个特化 class Magic\u003cint, std::vector\u003cint\u003e, std::map\u003cstd::string, std::vector\u003cint\u003e\u003e\u003e { // 特化的实现 }; class Magic\u003cint, std::vector\u003cint\u003e, std::map\u003cstd::string, std::vector\u003cint\u003e\u003e\u003e darkMagic; //实例化一个类 我们可以通过变参模板实现printf函数 cpp #include \u003ciostream\u003e template\u003ctypename T0\u003e //终止递归条件，如果没有这个函数模板当参数为空时就会无限调用空模板printf1()；导致编译错误 void printf1(T0 value) { std::cout \u003c\u003c value \u003c\u003c std::endl; } template\u003ctypename T, typename... Ts\u003e void printf1(T value, Ts... args) { std::cout \u003c\u003c value \u003c\u003c std::endl; printf1(args...); //每次调用变参模板时循环调用，printf1(T0 value) } int main() { printf1(1, 2, \"123\", 1.1); return 0; } 我们可以使用变参模板展开来简化代码(C++17) cpp template\u003ctypename T0, typename... T\u003e void printf2(T0 t0, T... t) { std::cout \u003c\u003c t0 \u003c\u003c std::endl; if constexpr (sizeof...(t) \u003e 0) printf2(t...); //用constexpr关键字来保证编译时添加终止条件而不是运行时，不仅简化代码还优化效率。sizeof...()是专门用于计算变长模板长度的运算符 } 还要注意参数包展开的方式 cpp #include \u003ciostream\u003e #include \u003calgorithm\u003e template\u003cclass...Args,class Ty = std::common_type_t\u003cArgs...\u003e\u003e //将Args...转换为不违反类型安全的共同类型，例如double或float auto max(Args...args) { return std::max({ static_cast\u003cTy\u003e(args)... }); //这里的static_cast\u003cTy\u003e(args)...若改为static_cast\u003cTy\u003e(args...)就会展开成static_cast\u003cTy\u003e(args0，args1，args2)，而这不能满足我们的需求 } int main() { std::cout \u003c\u003c ::max(1, 1.2,5, 'a') \u003c\u003c '\\n'; } ","date":"2024-01-14","objectID":"/posts/cpp/:10:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#变长参数模板"},{"categories":["Tech"],"content":" Lambda表达式lambda表达式又称为闭包，我们可以利用lambda表达式来获得暂时性的函数对象，因此lambda表达式在创建时(不是调用时)耗费资源，在调用完成时销毁资源，并且在访问时，如不特殊指定访问对象，lambda表达式默认禁止访问外部数据 先看个实例 cpp int main() { std::vector\u003cint\u003e vec {1, 5, 10, 4, 7, 15, 12}; auto f = [](int a, int b) //lambda表达式 { return a \u003e b; }; std::sort(vec.begin(), vec.end(), f); return 0; } lambda表达式的格式如下： cpp [捕获列表](参数列表) mutable(可选) 异常属性 -\u003e 返回类型 { // 函数体 } //对于返回类型可以自动推断，因此我们常用的是： [捕获列表](参数列表) mutable(可选) 异常属性 { // 函数体 } 捕获列表中捕获的是外界的变量，并且分为值捕获和引用捕获。在没有mutable修饰的情况下，值捕获的权限是只读的并且在lambda内部也是只读的，引用捕获的权限是读写的。当有mutable修饰时，尽管权限不变，但是lambda可以修改捕获列表中的变量值而不影响外部变量的原始值 值捕获： cpp void lambda_value_capture() { int value = 1; auto copy_value = [value] { return value; }; value = 100; auto stored_value = copy_value(); std::cout \u003c\u003c \"stored_value = \" \u003c\u003c stored_value \u003c\u003c std::endl; // 这时, stored_value == 1, 而 value == 100. // 因为 copy_value 在创建时就保存了一份 value 的拷贝 } 引用捕获： cpp void lambda_reference_capture() { int value = 1; auto copy_value = [\u0026value] { return value; }; value = 100; auto stored_value = copy_value(); std::cout \u003c\u003c \"stored_value = \" \u003c\u003c stored_value \u003c\u003c std::endl; // 这时, stored_value == 100, value == 100. // 因为 copy_value 保存的是引用 } 如果[]中只有\u0026或者=号，这就代表lambda表达式能够访问区域范围内所有的数据，并按\u0026(引用捕获)或者=(值捕获)的方式来获取 全局引用捕获： cpp void lambda_reference_capture() { int value1 = 1; value2 = 100; auto add_value = [\u0026] { return value1 + value2; }; auto stored_value = add_value(); std::cout \u003c\u003c \"stored_value = \" \u003c\u003c stored_value \u003c\u003c std::endl; } lambda表达式会被编译器转化为一个全局的，唯一的(唯一名称的)匿名函数(实现重载()方法) cpp [i = 0] () { i = i + 1; // 编译错误：无法在 const 成员函数里修改成员 printf(\"我被调用了 %d 次\\n\", i); }; 等价于 cpp struct NumberFunc { int i = 0; void operator()() const { //这个const导致了如下编译错误 i = i + 1; // 编译错误：无法在 const 成员函数里修改成员 printf(\"我被调用了 %d 次\\n\", i); } }; 要想去掉仿函数生成的const可以在后面加上mutable关键字 cpp [i = 0] () mutable { i = i + 1; // 编译通过，mutable 的 lambda 允许修改保存的变量值 printf(\"我被调用了 %d 次\\n\", i); }; ","date":"2024-01-14","objectID":"/posts/cpp/:11:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#lambda表达式"},{"categories":["Tech"],"content":" 函数对象包装器将lambda表达式传入一个函数，在函数内部对这个lambda表达式进行调用或处理，我们称这个函数为函数对象包装器 相对于直接调用lambda函数，由于使用包装器的方法能够调用并处理lambda表达式，因此相比原生lambda表达式更灵活 cpp #include \u003ciostream\u003e using foo = void(int); // 定义函数类型, using 的使用见上一节中的别名语法 void funct(foo f) { // 参数列表中定义的函数类型 foo 被视为退化后的函数指针类型 foo* f(1); // 通过函数指针调用函数 } int main() { auto f = [](int value) { std::cout \u003c\u003c value \u003c\u003c std::endl; }; funct(f); // 传递闭包对象，隐式转换为 foo* 类型的函数指针值 f(1); // lambda 表达式调用 return 0; } ","date":"2024-01-14","objectID":"/posts/cpp/:12:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#函数对象包装器"},{"categories":["Tech"],"content":" 左值引用与右值引用在C++中所谓的左值一般是指一个指向特定内存的具有名称的值(具名对象)，它有一个相对稳定的内存地址，并且有一段较长的生命周期。而右值则是不指向稳定内存地址的匿名值(不具名对象)，它的生命周期很短，通常是暂时性的，一般由CPU生成并位于寄存器中。基于这一特征，我们可以用取地址符\u0026来判断左值和右值，能取到内存地址的值为左值，否则为右值 我们可以通过在数据前加\u0026来判断这个数据是左值还是右值，左值可以被改变，因此可以取地址，而右值不可以改变，因此对数据\u0026会报编译错误 除字符串外的所有字面量都是右值(如true,12)，字符串比较特殊，它是const 左值，生命周期极长。值得注意的是，函数返回值和函数地址是右值 左值引用是在类型后面添加\u0026，右值引用是添加\u0026\u0026 但是判断左右值会出现一定的困难： cpp int\u0026\u0026 rv2 = 5; //这个rv2究竟是左值还是右值？ rv2实际上是个声明为右值的左值变量，具体是左值还是右值需要看与谁进行绑定。在上面那一行代码结束后，5这个右值就被绑定到rv2这个左值身上了，因此5延长了与rv2一样长的生命周期，而rv2实际上是左值变量 我们可以先从简单的例子开始来了解右值引用 cpp void reference(int\u0026 v) { std::cout \u003c\u003c \"左值\" \u003c\u003c std::endl; } void reference(int\u0026\u0026 v) { std::cout \u003c\u003c \"右值\" \u003c\u003c std::endl; } template \u003ctypename T\u003e void pass(T\u0026\u0026 v) { std::cout \u003c\u003c \"普通传参:\"; reference(v); // 始终调用 reference(int\u0026)，因为无论是左值还是右值，进入函数时都被看作一个生命周期较长的变量，因此C++如此设计 } int main() { std::cout \u003c\u003c \"传递右值:\" \u003c\u003c std::endl; pass(1); // 1是右值, 但输出是左值 std::cout \u003c\u003c \"传递左值:\" \u003c\u003c std::endl; int l = 1; pass(l); // l 是左值, 输出左值 return 0; } 第10行的reference(v)实际上进行了reference(T\u0026\u0026 v = int\u0026 v)的操作，因此上面的代码块总会输出左值 ","date":"2024-01-14","objectID":"/posts/cpp/:13:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#左值引用与右值引用"},{"categories":["Tech"],"content":" 移动语义为了方便进行左右值的类型转换，C++11提供了std::move这个方法将左值转换为右值使其减少生命周期 cpp #include \u003ciostream\u003e #include \u003cstring\u003e void reference(std::string\u0026 str) { std::cout \u003c\u003c \"左值\" \u003c\u003c std::endl; } void reference(std::string\u0026\u0026 str) { std::cout \u003c\u003c \"右值\" \u003c\u003c std::endl; } int main() { std::string lv1 = \"string \"; // std::string\u0026\u0026 r1 = lv1; // 非法, 右值引用不能引用左值 std::string\u0026\u0026 rv1 = std::move(lv1); // 合法, std::move可以将左值转移为右值 std::cout \u003c\u003c rv1 \u003c\u003c std::endl; std::cout \u003c\u003c lv1 \u003c\u003c std::endl; //当第15行代码执行完毕后，lv1的值就被移动到rv1的位置了，此时访问lv1是ub，即使能访问成功也是编译器的特性。而rv1的生命周期是根据所绑定资源的生命周期决定的，\"string\"的生命周期是整个程序，因此rv1的生命周期就是整个程序 } 之所以右值引用不能引用左值，很可能是因为如果可以的话，由于左值的生命周期长于右值，当右值引用被销毁的时候左值对应的那块内存地址很可能依然存在，这就可能造成内存泄漏或者其他资源管理问题 使用右值引用最大的用途就在于我们可以将数据的拷贝转成指针的移动，这对于提高性能有巨大的帮助，由于右值引用是对原右值对象的生命周期的延长(延长到右值引用的作用域结束)，因此我们可以将这些延长生命周期的对象通过右值引用的返回值延伸到代码块外部，这样我们可以通过操作这些对象(实际上就是指针)来“移动”数据而非拷贝数据了 cpp #include \u003ciostream\u003e class A { public: int *pointer; A():pointer(new int(1)) { std::cout \u003c\u003c \"构造\" \u003c\u003c pointer \u003c\u003c std::endl; } A(A\u0026 a):pointer(new int(*a.pointer)) { std::cout \u003c\u003c \"拷贝\" \u003c\u003c pointer \u003c\u003c std::endl; } // 无意义的对象拷贝 A(A\u0026\u0026 a):pointer(a.pointer) { //移动构造函数，return时会自动调用 a.pointer = nullptr; //先将a.pointer的指针置空，防止其他程序操作这块内存 std::cout \u003c\u003c \"移动\" \u003c\u003c pointer \u003c\u003c std::endl; } ~A(){ std::cout \u003c\u003c \"析构\" \u003c\u003c pointer \u003c\u003c std::endl; delete pointer; } }; // 防止编译器优化 A return_rvalue(bool test) { A a,b; if(test) return a; // 等价于 static_cast\u003cA\u0026\u0026\u003e(a); else return b; // 等价于 static_cast\u003cA\u0026\u0026\u003e(b); } int main() { A obj = return_rvalue(false); std::cout \u003c\u003c \"obj:\" \u003c\u003c std::endl; std::cout \u003c\u003c obj.pointer \u003c\u003c std::endl; std::cout \u003c\u003c *obj.pointer \u003c\u003c std::endl; return 0; } 在上面的代码中： 首先会在 return_rvalue 内部构造两个 A 对象，于是获得两个构造函数的输出 函数返回后，产生一个将亡值，被 A 的移动构造（A(A\u0026\u0026)）引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 obj 中，而后将亡值的指针被设置为 nullptr，防止了这块内存区域被销毁 调用移动构造函数的时机： return一个对象时(在跟拷贝构造函数冲突时使用移动构造函数) 使用 std::move 将一个对象转换为右值引用时 使用容器的insert、emplace_back、emplace等函数时 通过上面的介绍我们可以发现移动语义实际上是在做指针的拷贝，这与浅拷贝的行为很类似。实际上移动语义就是深化了权限管理和资源管理的浅拷贝，这避免了双重释放，内存泄漏和资源共享等问题 ","date":"2024-01-14","objectID":"/posts/cpp/:13:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#移动语义"},{"categories":["Tech"],"content":" 完美转发让我们再次审阅右值引用的代码，我们怎样才能让reference(v)按我们预期的行为运行呢？C++11提供了std::forward这个方法进行参数左右值的状态的转发 cpp #include \u003ciostream\u003e #include \u003cutility\u003e void reference(int\u0026 v) { std::cout \u003c\u003c \"左值引用\" \u003c\u003c std::endl; } void reference(int\u0026\u0026 v) { std::cout \u003c\u003c \"右值引用\" \u003c\u003c std::endl; } template \u003ctypename T\u003e void pass(T\u0026\u0026 v) { std::cout \u003c\u003c \" 普通传参: \"; reference(v); std::cout \u003c\u003c \" std::move 传参: \"; reference(std::move(v)); std::cout \u003c\u003c \" std::forward 传参: \"; reference(std::forward\u003cT\u003e(v)); std::cout \u003c\u003c \"static_cast\u003cT\u0026\u0026\u003e 传参: \"; reference(static_cast\u003cT\u0026\u0026\u003e(v)); } int main() { std::cout \u003c\u003c \"传递右值:\" \u003c\u003c std::endl; pass(1); std::cout \u003c\u003c \"传递左值:\" \u003c\u003c std::endl; int v = 1; pass(v); return 0; } 输出结果： cpp 传递右值: 普通传参: 左值引用 std::move 传参: 右值引用 std::forward 传参: 右值引用 static_cast\u003cT\u0026\u0026\u003e 传参: 右值引用 传递左值: 普通传参: 左值引用 std::move 传参: 右值引用 std::forward 传参: 左值引用 static_cast\u003cT\u0026\u0026\u003e 传参: 左值引用 从结果中可以看到，std::forward和static_cast\u003cT\u0026\u0026\u003e会原封不动的将参数类型转发出去，因此他们可以完成我们参数类型转发的任务。实际上std::forward就是static_cast\u003cT\u0026\u0026\u003e的封装 我们还可以看到，pass(v)竟然可以传给pass(T\u0026\u0026 v)。这实际上是由于T\u0026\u0026和int\u0026\u0026语义不同导致的，当我们使用T\u0026\u0026作为模板参数时，该模板不仅支持右值的传入也支持左值的传入，这是为了支持移动语义和完美转发而设计的。而使用类似int\u0026\u0026作为模板或函数参数时，仅支持int类型的右值传参。至于T\u0026，它不支持移动语义和完美转发，因此只能支持任意类型的左值传参 警告 当在调用链中传递右值时，有一处变为了左值且后续没有调用std::move()，那么这个值就被绑定为左值，该规则被称为引用折叠 当在调用链中传递左值时，若后续没有调用std::move()，那么这个值就依然为左值 ","date":"2024-01-14","objectID":"/posts/cpp/:13:2","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#完美转发"},{"categories":["Tech"],"content":" 智能指针智能指针实际上是个对象，它们是为了解决申请资源忘记释放的问题而诞生的。每个智能指针对象背后都有一套析构函数，当程序结束运行时会自动执行析构函数以释放资源，这样就不会产生内存泄漏的问题 ","date":"2024-01-14","objectID":"/posts/cpp/:14:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#智能指针"},{"categories":["Tech"],"content":" shared_ptrshared_ptr又名共享指针，其内部维护一个引用计数器，每当一个shared_ptr指向同一块内存区域或被引用时引用计数就会自增，每当一个shared_ptr改变指向或者销毁时对应的引用计数器就会自减，当引用计数器自减到0时系统就会自动销毁资源 需要注意的是，每当创建shared_ptr时指向某值A时，C++都会在堆中申请一块内存并用A的值初始化它，而后智能指针会指向这块新申请的内存。因此当有其他新的shared_ptr指向A时，前者的计数器不会改变。 cpp shared_ptr\u003ctype\u003e ptr_name = make_shared\u003ctype\u003e (value); //创建智能指针 shared_ptr\u003cfunc_type\u003e funcptr_name {func, del}; //创建智能指针ptr_name令其指向func函数，当引用计数器减为0时调用del函数 ptr_name.usecount(); //获取引用计数器的值 ptr_name.reset(ptr_new); //改变ptr_name的指向为ptr_new，不加参数为指向nullptr 下面是使用方法 cpp #include \u003cmemory\u003e #include \u003ciostream\u003e int main() { int a = 20; std::shared_ptr\u003cint\u003e p1 = std::make_shared\u003cint\u003e (a); std::shared_ptr\u003cint\u003e p2 = p1; std::shared_ptr\u003cint\u003e p3 = std::make_shared\u003cint\u003e (a); std::cout \u003c\u003c p1.use_count() \u003c\u003c std::endl; std::cout \u003c\u003c p2.use_count() \u003c\u003c std::endl; std::cout \u003c\u003c p3.use_count() \u003c\u003c std::endl; p1.reset(); std::cout \u003c\u003c p1.use_count() \u003c\u003c std::endl; std::cout \u003c\u003c p2.use_count() \u003c\u003c std::endl; return 0; } 输出结果： cpp 2 //此时p1，p2都指向同一块内存地址，因此前两行的输出是2 2 1 //p3指向的是一个新的，独立的动态内存分配的整数 0 //由于p1被reset了，p1指向nullptr，这里的p1引用计数为0 1 //但是p2没有被reset，他还是指向原来的地址，因此此时的p2的指向没有变化，但是指向内存地址的指针只剩下p2了，因此此时的p2引用计数是1 ","date":"2024-01-14","objectID":"/posts/cpp/:14:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#shared_ptr"},{"categories":["Tech"],"content":" unique_ptrunique_ptr又名独占指针，相比shared_ptr来说unique_ptr不允许多个指针指向同一块内存区域，例如下列操作是不允许的 cpp std::unique_ptr p1(p2); p1 = p2; 因此unique_ptr不用维护引用计数器，而这是运行时的开销，因此unique_ptr相比shared_ptr性能更好 unique_ptr是自动管理控制权的，当程序运行到超出控制权管理范围时会自动释放掉unique_ptr及其管理的资源。当unique_ptr使用reset()时也会释放原来指向的资源 unique_ptr虽然不允许左值赋值但允许右值赋值并支持移动语义，这意味着unique_ptr的控制权可以转移，转移之后解引用新的unique_ptr就可以获得对应的值了 cpp std::unique_ptr\u003cint\u003e p1 = std::make_unique\u003cint\u003e(10); std::unique_ptr\u003cint\u003e p2(p1.release()); //p1的控制权就转移到了p2 std::unique_ptr\u003cint\u003e p2(std::move(p1)); //我们也可以使用move()来转移控制权 p1.reset(new_ptr); //reset会删除原p1所指向的对象，而release则需要手动删除 函数传参时默认会复制参数，这给unique_ptr传参造成不便，但我们也有对应解决办法 cpp #include \u003ciostream\u003e #include \u003cmemory\u003e #define change_unique_ptr_in_func 1 void unique_param1(std::unique_ptr\u003cint\u003e\u0026 p) //引用传址，改变生命周期 { std::unique_ptr\u003cint\u003e p1 = std::make_unique\u003cint\u003e(100); std::cout \u003c\u003c *p \u003c\u003c std::endl; #if change_unique_ptr_in_func p.reset(); //我们甚至可以改变std::unique_ptr\u003cint\u003e\u0026 p的值 //p = p1; //当然这是不行的 #endif } void unique_param2(std::unique_ptr\u003cint\u003e p) //必须使用move传值，看下文解释 { std::cout \u003c\u003c *p \u003c\u003c std::endl; #if change_unique_ptr_in_func p.release(); #endif } int main() { std::unique_ptr\u003cint\u003e p1 = std::make_unique\u003cint\u003e(10); unique_param1(p1); #if change_unique_ptr_in_func if(p1 == nullptr) { std::cout \u003c\u003c \"p1 was reseted\" \u003c\u003c std::endl; } #endif std::unique_ptr\u003cint\u003e p2 = std::make_unique\u003cint\u003e(20); unique_param2(std::move(p2)); #if change_unique_ptr_in_func if(p2 == nullptr) { std::cout \u003c\u003c \"p2 was reseted\" \u003c\u003c std::endl; } #endif return 0; } 输出结果为： cpp 10 p1 was reseted 20 p2 was reseted 若第38行不使用std::move将unique_ptr转换为右值，就会产生报错，原因是unique_ptr不允许复制并赋值，而这在传参的时候是系统自动进行的，为了避免复制并赋值，我们需要地址传递(左值引用)或移动语义 我们甚至可以让函数返回一个unique_ptr： cpp std::unique_ptr\u003cint\u003e return_uniqueptr(int value) { return std::make_unique\u003cint\u003e(value); //正常来说这个uniqu_ptr被return了应该被系统回收， //因此main里面打印p3的操作并没有结果，但事实是我们能正常打印。 //造成这个的原因是return后的数据会被转换为右值，具体操作根据编译器的不同而不同 //实际上我们如果使用move来修饰返回值也可以正常运行 } int main() { int value = 30; std::unique_ptr\u003cint\u003e p3 = return_uniqueptr(value); //返回值用unique_ptr接收 std::cout \u003c\u003c *p3 \u003c\u003c std::endl; return 0; //在超出作用域时，std::unique_ptr\u003cint\u003e p3及其资源会被回收。同时也会回收value } ","date":"2024-01-14","objectID":"/posts/cpp/:14:2","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#unique_ptr"},{"categories":["Tech"],"content":" weak_ptr当使用shared_ptr时可能会产生死循环： A类中资源a有共享指针asp指向B类中的资源b B类中资源b有共享指针bsp指向A类中的资源a 此时会像死锁那样造成资源不能释放和析构，为了解决这些问题我们引入了weak_ptr cpp #include \u003ciostream\u003e #include \u003cmemory\u003e struct A; struct B; struct A { std::shared_ptr\u003cB\u003e ptr; A() { std::cout \u003c\u003c __func__ \u003c\u003c std::endl; } ~A() { std::cout \u003c\u003c __func__ \u003c\u003c std::endl; } }; struct B { std::shared_ptr\u003cA\u003e ptr; B() { std::cout \u003c\u003c __func__ \u003c\u003c std::endl; } ~B() { std::cout \u003c\u003c __func__ \u003c\u003c std::endl; } }; int main() { auto pa = std::make_shared\u003cA\u003e(); auto pb = std::make_shared\u003cB\u003e(); pa-\u003eptr = pb; pb-\u003eptr = pa; } 由于A，B类的对象均被两个shared_ptr指针(一个位于栈上，另一个位于堆上)指向，因此对应的智能指针计数器为2。当main函数执行完毕后进行资源回收时，会将栈上的shared_ptr指针回收，但是堆上的并不会自动回收，因此在资源销毁后智能指针计数仍然不为0，这就会产生内存泄漏 仔细观察上述问题，我们也可以自行解决问题：如果说shared_ptr会造成类似死锁的死循环的问题，那么我们只要想解决死锁那样将循环的其中一边解开，死循环的问题就迎刃而解了。实际上weak_ptr也是这么做的。weak_ptr本质上是个不占用资源的shared_ptr，他只负责监视shared_ptr的状态，这就是将循环的一边解开的操作，由于weak_ptr不占用资源，因此不会造成死循环的问题 因此我们在使用weak_ptr时也需要遵守一些规定： 首先是创建指针时weak_ptr无法主动申请资源，必须由已经初始化的shared_ptr或weak_ptr来给它赋值 cpp //这是错误的初始化方法，C++不允许在同一行同时声明和初始化两个变量，其中一个变量依赖于另一个变量的初始化结果 std::weak_ptr\u003cint\u003e wp =std::shared_ptr\u003cint\u003e sp(std::make_shared\u003cint\u003e(a)); //正确的初始化方法 std::weak_ptr\u003cint\u003e wp =std::shared_ptr\u003cint\u003e (std::make_shared\u003cint\u003e(a)); int a = 10; std::shared_ptr\u003cint\u003e sp1 = std::make_shared\u003cint\u003e(a); std::weak_ptr\u003cint\u003e wp1 = sp1; //用shared_ptr给weak_ptr赋值 std::weak_ptr\u003cint\u003e wp2 = wp1; //用weak_ptr给weak_ptr赋值 虽然不能通过weak_ptr修改对应的值，但是我们可以通过weak_ptr.lock()来访问值，如果这个值或者最初的shared_ptr已经被释放了，那么weak_ptr.lock()就会返回nullptr，否则就会返回对应的值 cpp int main() { int a = 10; std::shared_ptr\u003cint\u003e sp1 = std::make_shared\u003cint\u003e(a); std::weak_ptr\u003cint\u003e wp1 = sp1; std::weak_ptr\u003cint\u003e wp2 = wp1; std::cout \u003c\u003c *sp1 \u003c\u003c std::endl; std::cout \u003c\u003c *wp1.lock() \u003c\u003c std::endl; sp1.reset(); if(sp1 == nullptr) { std::cout \u003c\u003c \"sp1 == nullptr\" \u003c\u003c std::endl; } if(wp1.lock() == nullptr) { std::cout \u003c\u003c \"wp1 == nullptr\" \u003c\u003c std::endl; } return 0; } 那么具体该如何解决死循环的问题呢？我们只要将其中一个类下面的shared_ptr改为weak_ptr即可 ","date":"2024-01-14","objectID":"/posts/cpp/:14:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#weak_ptr"},{"categories":["Tech"],"content":" 异常","date":"2024-01-14","objectID":"/posts/cpp/:15:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#异常"},{"categories":["Tech"],"content":" throwthrow用于抛出异常，并曾用于声明该函数会抛出异常(在C++11已弃用) 下面是使用throw的例子： cpp #include \u003ciostream\u003e #include \u003cstdexcept\u003e void legacyFunction() { throw std::runtime_error(\"Something went wrong!\"); } int main() { try { legacyFunction(); } catch (const std::runtime_error\u0026 e) { std::cout \u003c\u003c \"Caught: \" \u003c\u003c e.what() \u003c\u003c std::endl; } } 如果使用的是C++03，还有可能出现下面的写法： cpp #include \u003ciostream\u003e #include \u003cstdexcept\u003e void legacyFunction() throw(std::runtime_error) { //C++11已弃用 throw std::runtime_error(\"Something went wrong!\"); } int main() { try { legacyFunction(); } catch (const std::runtime_error\u0026 e) { std::cout \u003c\u003c \"Caught: \" \u003c\u003c e.what() \u003c\u003c std::endl; } } ","date":"2024-01-14","objectID":"/posts/cpp/:15:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#throw"},{"categories":["Tech"],"content":" try-catch当函数发生异常时，会被try块检测到，在此之后try会根据异常的类型执行到对应的catch()项进行处理 cpp try { f(); } catch (const std::overflow_error\u0026 e) {} // 如果 f() 抛出 std::overflow_error 就会执行它（“相同类型”规则） catch (const std::runtime_error\u0026 e) {} // 如果 f() 抛出 std::underflow_error 就会执行它（“基类”规则） catch (const std::exception\u0026 e) {} // 如果 f() 抛出 std::logic_error 就会执行它（“基类”规则） catch (...) {} // 如果 f() 抛出 std::string 或 int 或任何其他无关类型就会执行它 上述三种异常的继承关系 std::exception ├─ std::runtime_error │ ├─ std::overflow_error // 和 underflow_error 是兄弟类 │ ├─ std::underflow_error │ └─ ... ├─ std::logic_error │ ├─ std::invalid_argument │ └─ ... └─ ... ","date":"2024-01-14","objectID":"/posts/cpp/:15:2","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#try-catch"},{"categories":["Tech"],"content":" noexcept(C++11)使用 noexcept 替代 throw 是为了避免在移动构造函数中产生异常陷阱。因为 throw 无法根据容器中元素的移动操作是否可能抛出异常来判断移动构造函数是否具有不抛异常的保证，这可能导致性能下降或触发不必要的回退行为 noexcept除了作为限定符外还可以当作运算符，其返回值的类型是bool，产生异常时返回值为false，无异常返回true throw()是noexcept(true)的别名，因此在函数定义的末尾加上noexcept与throw()是一样的(throw修饰函数的用法已在C++11中被弃用)，但是想要抛出异常时就只能使用throw了 cpp void bar() noexcept(false) { throw std::runtime_error(\"This function might throw\"); } 函数不加noexcept修饰符时默认会抛出异常 cpp #include \u003ciostream\u003e int foo() noexcept { return 42; } int foo1() { return 42; } int foo2() throw() { return 42; } int main() { std::cout \u003c\u003c std::boolalpha; std::cout \u003c\u003c \"noexcept(foo()) = \" \u003c\u003c noexcept(foo()) \u003c\u003c std::endl; std::cout \u003c\u003c \"noexcept(foo1()) = \" \u003c\u003c noexcept(foo1()) \u003c\u003c std::endl; std::cout \u003c\u003c \"noexcept(foo2()) = \" \u003c\u003c noexcept(foo2()) \u003c\u003c std::endl; } 输出结果 cpp noexcept(foo()) = true noexcept(foo1()) = false noexcept(foo2()) = true ","date":"2024-01-14","objectID":"/posts/cpp/:15:3","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#noexceptc11"},{"categories":["Tech"],"content":" 三路比较运算符(C++20)三路比较运算符(\u003c=\u003e)可以取代\u003c=,\u003c,\u003e,\u003e=,!=运算符，因此只要我们能够实现\u003c=\u003e和==两个运算符就可以实现所有的运算符功能，当然实现的过程中离不开运算符的重载 由于gcc在win10上版本过低，下列代码只能在MSVC中才能编译通过 cpp #include \u003ccompare\u003e #include \u003ciostream\u003e #include \u003cset\u003e 、 struct Point { int x; int y; auto operator\u003c=\u003e(const Point\u0026) const = default; // ... 非比较函数 ... }; // 编译器生成全部六个双路比较运算符 int main() { Point pt1{1, 1}, pt2{1, 2}; std::set\u003cPoint\u003e s; // OK s.insert(pt1); // OK std::cout \u003c\u003c std::boolalpha \u003c\u003c (pt1 == pt2) \u003c\u003c ' ' // false; operator== 被隐式预置。 \u003c\u003c (pt1 != pt2) \u003c\u003c ' ' // true \u003c\u003c (pt1 \u003c pt2) \u003c\u003c ' ' // true \u003c\u003c (pt1 \u003c= pt2) \u003c\u003c ' ' // true \u003c\u003c (pt1 \u003e pt2) \u003c\u003c ' ' // false \u003c\u003c (pt1 \u003e= pt2) \u003c\u003c ' '; // false } 手动实现三路运算比较符: cpp #include \u003ccompare\u003e struct Point { int x; int y; std::strong_ordering operator\u003c=\u003e(const Point\u0026 other) const { if (auto cmp = x \u003c=\u003e other.x; cmp != 0) //这里使用了C++17的if-init语法 return cmp; return y \u003c=\u003e other.y; } bool operator==(const Point\u0026 other) const = default; }; 注意if (auto cmp = x \u003c=\u003e other.x; cmp != 0)的写法，这里使用首先声明并初始化cmp变量以接受x \u003c=\u003e other.x运算的结果，其类型是比较结果类型std::strong_ordering，最后if(cmp!=0)(即结果不相等)就返回，否则就继续比较成员变量y ","date":"2024-01-14","objectID":"/posts/cpp/:16:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#三路比较运算符c20"},{"categories":["Tech"],"content":" 用户类模板推导(C++17)在现代 C++ 中，函数模板的返回类型通常可以通过参数推导轻松确定。而类模板的模板参数则需通过构造函数的参数来推导，但由于构造函数本身不显式指定返回类型，推导起来较为复杂，因此 C++17 引入了推导指引（deduction guide），允许通过 -\u003e 明确指定从构造参数推导出的类模板实例类型(例如从MyClass obj(42); 推导出类模板参数是int)。所以，-\u003e推导指引不可用于函数模板的推导中，因为其参数可以轻松确定，并且-\u003e推导指引的出发点就是只用于类模板的构造函数上 有了推导指引后，我们就可以像函数模板那样简洁的使用类模板 cpp MyClass obj(42); // ✅ 推导 T = int 在这之前需要写下面的代码： cpp MyClass\u003cint\u003e obj(42); // ✅ 明确指定模板参数 如果希望 Wrapper w(42); 推导 T = double，也需要推导指引： cpp template\u003ctypename T\u003e Wrapper(int) -\u003e Wrapper\u003cdouble\u003e; // 强制推导 T = double 虽然auto和尾返回值类型推导可以用于函数类型推导，但是一般用于模板这种难以提前知道返回值类型的情况。对于普通函数则无必要。在auto和-\u003e联合使用时，auto只起占位符作用，与定义变量的int，double并无区别 对于函数来说尾返回类型不是必须的，只是为了便于浏览代码： cpp auto fun3() -\u003e int //将函数返回值推导为int类型 { double a = 2; return a; } 对于模板来说尾返回类型就是必须的，至少对于下面形式的模板是这样的： cpp template\u003ctypename T, typename U\u003e auto add2(T x, U y) -\u003e decltype(x+y){ //这里我们不能在 auto 的位置提前写出 decltype(a + b)，因为 a 和 b 还没有被解析，最终导致x和y的未定义的错误 return x + y; } ","date":"2024-01-14","objectID":"/posts/cpp/:17:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#用户类模板推导c17"},{"categories":["Tech"],"content":" explicit(C++11)有时由于我们的粗心会造成程序未预料的行为 cpp #include \u003ciostream\u003e #include \u003cstring.h\u003e class SomeString { public: SomeString(const char * p) : str_(strdup(p)) {} //这行代码等价于下面的 /* SomeString(const char * p){ * str_(strdup(p)) */ } SomeString(int alloc_size) : str_((char *)malloc(alloc_size)) {} //explicit SomeString(int alloc_size) : str_((char *)malloc(alloc_size)) {} ~SomeString() { free(str_); } private: char *str_; friend void PrintStr(const SomeString\u0026 str); }; void PrintStr(const SomeString\u0026 str) { std::cout \u003c\u003c str.str_ \u003c\u003c std::endl; } int main() { PrintStr(\"hello world\"); PrintStr(58); // 这里想输入的是\"58\"，但却编译成功，但加入explicit时就会产生编译错误 //PrintStr(SomeString(58)); //使用explicit时必须显式调用，这样会减少错误 } 上述问题的解决办法是按注释那样使用explicit修饰符修饰，这样我们在调用PrintStr(58);时需要显式指明调用PrintStr(SomeString(58));，否则就会报错 可以看到，即便使用explicit关键字还是有可能引发错误，例如将PrintStr(SomeString(“58”));写为PrintStr(SomeString(58));，那么为什么C++还是引入explicit呢？ 首先是对显式错误和隐式错误的排查提供了方便，毕竟PrintStr(SomeString(58));是比PrintStr(58);更为清晰的语义，排查错误会更快 其次是让程序员强制思考，当程序员按explicit的要求输入SomeString时，会下意识地考虑类型的问题 当然，最好的解决方法是通过提供更清晰的接口避免歧义，例如SomeString::fromString(\"58\")，SomeString::frommalloc(58) explicit与override的区别：explicit用于调用构造函数时防止编译器自动进行隐式类型转换，override用于指明某个虚函数是用来重写基类中的虚函数的，如果签名不匹配，编译器将报错，从而防止因函数签名错误导致的意外重载或隐藏基类函数 下面还是关于如何使用explicit的例子： cpp class MyInt { public: explicit operator int() const { // ✅ 必须显式转换 return value; } private: int value = 42; }; int main() { MyInt x; // int y = x; // ❌ 编译错误：不能隐式转换 int z = static_cast\u003cint\u003e(x); // ✅ 必须显式转换 } ","date":"2024-01-14","objectID":"/posts/cpp/:18:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#explicitc11"},{"categories":["Tech"],"content":" 弃置函数(C++11)传统C++在解决一些函数生成行为时做法很令人迷惑，例如当需要禁用某个类的拷贝构造函数时，我们需要将这个拷贝构造函数用private声明，这样当外部访问这个函数时就会报错，但是这会让人对函数的所有权产生误解 在C++11后我们引入了delete关键字显式删除我们不需要的函数 cpp class Magic { public: Magic() = default; // 显式声明使用编译器生成的构造 Magic\u0026 operator=(const Magic\u0026) = delete; // 显式声明拒绝编译器生成构造 Magic(int magic_number); } 这常用于定义了析构函数时，因为定义了析构函数就必须删除移动构造函数、移动赋值函数、拷贝构造函数、拷贝赋值函数 parallel101.md ","date":"2024-01-14","objectID":"/posts/cpp/:19:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#弃置函数c11"},{"categories":["Tech"],"content":" 折叠表达式(C++17)折叠表达式常与形参包结合使用，下面是C++11不使用折叠表达式写求和函数的例子 cpp #include \u003ciostream\u003e using namespace std; template\u003ctypename First\u003e First sum1(First\u0026\u0026 value) { return value; } template\u003ctypename First, typename Second, typename... Rest\u003e First sum1(First\u0026\u0026 first, Second\u0026\u0026 second, Rest\u0026\u0026... rest) { return sum1(first + second, forward\u003cRest\u003e(rest)...); //使用了递归模板展开但并没有使用折叠表达式 } template\u003ctypename First, typename... Rest\u003e First sum2(First\u0026\u0026 first, Rest\u0026\u0026... rest) { return (first + ... + rest); //折叠表达式 } int main() { cout \u003c\u003c sum1(1) \u003c\u003c sum1(1, 2) \u003c\u003c sum1(1, 2, 3) \u003c\u003c endl; // 136 cout \u003c\u003c sum2(1) \u003c\u003c sum2(1, 2) \u003c\u003c sum2(1, 2, 3) \u003c\u003c endl; // 136 } 我们可以看出不使用折叠表达式时必须给函数参数数量为1的特化模板，而使用折叠表达式则不必给出此特化 如果要细分的话可以分为下几种(E为形参包)： 一元右折叠 (E 运算符 …) 成为 (E1 运算符 (… 运算符 (EN-1 运算符 EN))) 一元左折叠 (… 运算符 E) 成为 (((E1 运算符 E2) 运算符 …) 运算符 EN) 二元右折叠 (E 运算符 … 运算符 I) 成为 (E1 运算符 (… 运算符 (EN−1 运算符 (EN 运算符 I)))) 二元左折叠 (I 运算符 … 运算符 E) 成为 ((((I 运算符 E1) 运算符 E2) 运算符 …) 运算符 EN) 要理解上面的内容需要把握以下两点： 折叠表达式运算时要视为一个整体 运算符结合性是从左至右的 ","date":"2024-01-14","objectID":"/posts/cpp/:20:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#折叠表达式c17"},{"categories":["Tech"],"content":" 概念与约束(C++20)概念是约束的体现，而约束需要表达式来定义 cpp #include \u003cstring\u003e #include \u003ccstddef\u003e #include \u003cconcepts\u003e using namespace std::literals; // 概念 \"Hashable\" 的声明，可被符合以下条件的任何类型 T 满足： // 对于 T 类型的值 a，表达式 std::hash\u003cT\u003e{}(a) 可编译且其结果可转换为 std::size_t template\u003ctypename T\u003e concept Hashable = requires(T a) { { std::hash\u003cT\u003e{}(a) } -\u003e std::convertible_to\u003cstd::size_t\u003e; //看不懂别急，下面有解释 }; struct meow {}; template\u003cHashable T\u003e void f(T); // 受约束的 C++20 函数模板 // 应用相同约束的另一种方式： // template\u003ctypename T\u003e // requires Hashable\u003cT\u003e // void f(T); // // template\u003ctypename T\u003e // void f(T) requires Hashable\u003cT\u003e; int main() { f(\"abc\"s); // OK，std::string 满足 Hashable f(meow{}); // 错误：meow 不满足 Hashtable } 首先解释一下{ std::hash\u003cT\u003e{}(a) } -\u003e std::convertible_to\u003cstd::size_t\u003e;这段代码，这段代码是用初始化列表{}来初始化对象，而后调用对象的重载()运算符函数并传入a这个参数，最后将其结果使用-\u003e隐式转换为std::convertible_to\u003cstd::size_t\u003e类型，假如能够正常编译就可以返回true或false，若不能编译则会报错 了解了上述代码后就可以理解概念与约束了，概念可以说是一个有名的约束，约束是对若干语句进行求值，实际上更类似于返回值是bool类型的函数，因此概念实际上是一个谓词。使用时当泛型满足这个概念时就会编译通过，反之则会不通过。使用这个新特性的好处是可以在编译期更好的输出编译错误(要不然产生模板编译错误的时候就等着编译器给你写小作文吧) 还有一种简单的运用 cpp template \u003ctypename T\u003e concept should_be_float = std::is_floating_point_v\u003cT\u003e; template \u003ctypename T\u003e requires should_be_float\u003cT\u003e T add(T a, T b) { return a + b; } void concept_test() { auto r = add(1.2, 3.3); auto r2 = add(1, 2); // 编译不过 } ","date":"2024-01-14","objectID":"/posts/cpp/:21:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#概念与约束c20"},{"categories":["Tech"],"content":" 设计模式本节主要参考小彭老师的教程 开闭原则：对于源代码的扩展应该是开放的，而修改则是关闭的 单一责任原则：每个接口只应该负责独立的一个功能，如果违背此原则就会造成模块耦合 依赖倒置原则：高层模块不要直接依赖底层模块，而是依赖高层的抽象类来实现，这些抽象类是继承了底层的模块并重写方法形成的，这是为了实现更好的代码复用 ","date":"2024-01-14","objectID":"/posts/cpp/:0:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#设计模式"},{"categories":["Tech"],"content":" 策略模式实际上就是虚函数+继承使得子类重写父类接口，这是为了实现更好的代码复用。如果我们深入理解了策略模式就会发现，它其实就是依赖倒置原则的具体应用 ","date":"2024-01-14","objectID":"/posts/cpp/:1:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#策略模式"},{"categories":["Tech"],"content":" 迭代器模式提供一个抽象的接口来顺序访问一个集合中的各个元素，而又无需暴露该集合的内部表示 ","date":"2024-01-14","objectID":"/posts/cpp/:2:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#迭代器模式"},{"categories":["Tech"],"content":" 适配器模式将父类的接口或者方法进行继承并再次包装从而生成新子类，这样就能在新子类的中引入新的参数或者方法。从外界看新子类就有了接受新参数的新功能，当调用第三方库而第三方库要求输入一个额外的参数时可以采用此方法将其包装 我们不仅可以把普通的函数或者方法包装为适配器，还可以把适配器包装为一个新的适配器 ","date":"2024-01-14","objectID":"/posts/cpp/:3:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#适配器模式"},{"categories":["Tech"],"content":" 工厂模式当需要创建多个重复的对象时可以采用工厂模式。其具体实现是将想要创建的对象抽象出一个纯虚类，这个纯虚类只返回一个智能指针(普通指针的话会导致内存管理困难)用来控制调用哪个对象，并在后续代码中创建子类重写这个纯虚类从而返回不同的智能指针 那么如何创建多个重复对象呢？我们只需要在上面的基础上使用循环结构来初始化上面指针指向的子类，之后创建数组或容器来容纳返回的智能指针，这样我们就可以用智能指针来控制相应的对象了 cpp struct Gun { virtual Bullet *shoot() = 0; }; struct AK47Gun : Gun { Bullet *shoot() override { return new AK47Bullet(); } }; struct MagicGun : Gun { Bullet *shoot() override { return new MagicBullet(); } }; void player(Gun *gun) { for (int i = 0; i \u003c 100; i++) { //使用工厂模式打出100发子弹 Bullet *bullet = gun-\u003eshoot(); bullet-\u003eexplode(); } } player(new AK47Gun()); player(new MagicGun()); ","date":"2024-01-14","objectID":"/posts/cpp/:4:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#工厂模式"},{"categories":["Tech"],"content":" 享元模式当函数或类有大量的重复数据存储要求时(比如游戏的贴图)，我们需要把这些数据单独封装存储，然后使用指针寻址到这块数据，这样可以避免这些数据块被生成多次(我们当然不想每射击一次就让子弹的贴图生成一遍，那样内存会爆掉的)，这种利用指针去访问类的数据或者调用类的方法来操控数据的方法被称为享元模式 例如下方代码，我们使用texture单独存储大块的不会改变的数据，这些数据被放在Sprite类中，而经常改变的数据如位置，速度等被分离在Bullet类中。当我们需要改变子弹速度和位置时候只需要调用Bullet类，当我们想要多个Bullet对象时也不必多次实例化Sprite，我们需要绘制贴图时只需要把子弹的速度位置传给Bullet内部的指向Sprite对象的智能指针即可 cpp struct Sprite { // Sprite 才是真正持有（很大的）贴图数据的 vector\u003cchar\u003e texture; void draw(glm::vec3 position) { glDrawPixels(position, texture); } }; struct Bullet { glm::vec3 position; glm::vec3 velocity; shared_ptr\u003cSprite\u003e sprite; // 允许多个子弹对象共享同一个精灵贴图的所有权 void draw() { sprite-\u003edraw(position); // 转发给 Sprite 让他帮忙在我的位置绘制贴图 } }; ","date":"2024-01-14","objectID":"/posts/cpp/:5:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#享元模式"},{"categories":["Tech"],"content":" 代理模式与我们生活中的vpn，海外代购类似，代理模式通过设置中间层(代理层)来控制请求的过程。代理模式常用于延迟加载，缓存复用，网络代理等方面 下面是以图片查看器（延迟加载 + 缓存）为例展示代理模式的示例代码： cpp class Image { public: virtual void display() = 0; }; // 真实图片（加载耗时） class RealImage : public Image { private: std::string filename; public: RealImage(const std::string\u0026 file) : filename(file) { loadFromDisk(); // 模拟耗时加载 } void loadFromDisk() { std::cout \u003c\u003c \"Loading image: \" \u003c\u003c filename \u003c\u003c \" (slow operation)\" \u003c\u003c std::endl; } void display() override { std::cout \u003c\u003c \"Displaying image: \" \u003c\u003c filename \u003c\u003c std::endl; } }; // 代理图片（控制访问） class ProxyImage : public Image { private: std::string filename; RealImage* realImage; // 延迟加载 public: ProxyImage(const std::string\u0026 file) : filename(file), realImage(nullptr) {} void display() override { if (!realImage) { realImage = new RealImage(filename); // 第一次访问时才加载 } realImage-\u003edisplay(); } }; // 使用代理 int main() { ProxyImage proxy(\"photo.jpg\"); // 此时未加载真实图片 proxy.display(); // 第一次调用时加载并显示 proxy.display(); // 直接使用已加载的图片（无重复加载） return 0; } 有趣的是，我们甚至可以把Linux看作一个超级代理模式的项目，应用通过内核向驱动发出请求，内核就是代理层 ","date":"2024-01-14","objectID":"/posts/cpp/:6:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#代理模式"},{"categories":["Tech"],"content":" 单例模式单例模式确保一个类在整个程序生命周期中仅有一个实例，并提供一个全局访问点。该模式常用于管理需要全局唯一性的资源或服务，如配置管理、日志系统、数据库连接池等 有两种常见的单例模式：懒汉模式与饿汉模式，其区别在于饿汉模式会在全局自动初始化一个对象，实现依靠全局变量，而懒汉模式则需要手动初始化，实现依靠类内加static关键字 为了实现单例模式我们需要使用static修饰类内部的对象，使其作用域扩大为整个文件。如果对象的定义是在头文件中，在定义对象时我们还需要加上inline关键字，这样C++编译器就会在全局范围内查找同名符号并只实例化一次。这就能保证整个程序中只有一份实例化对象 cpp // Game.hpp inline Game game; inline Game \u0026getGame() { static Game game; return game; } ","date":"2024-01-14","objectID":"/posts/cpp/:7:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#单例模式"},{"categories":["Tech"],"content":" 模板模式模板模式用于封装项目中一些相似的操作，把共同部分集中到基类中。而后使用protected关键字将共同部分封装起来，这样可以既保证子类中可以继承甚至重写这些共同部分，同时也可以避免暴露成员，对于共同部分的逻辑实现则需要使用一个公共类将其封装，并用public修饰来提供给下游 我们可以发现，策略模式与模板模式很像。只不过策略模式采用的是子类继承并重写父类虚函数的方式实现对共同部分的封装，而模板是在基类的自身内部进行实现，并采用权限管理的方式来实现相应的功能。因此策略模式适合于对象需要多种行为，或行为需要经常变动的情况，模板模式则适合于对象行为比较少且固定，容易在类内部实现的方式 模板模式的一个实际应用是封装接口。这与适配器的封装方式很像，但是适配器需要继承被封装的类，而模板模式不需要。模板模式将被封装的接口放在内部的protected作用域下，而在public作用域下对其进行改造和封装。值得注意的是，这里的虚接口常使用do_xxx的命名方式 下面是封装接口的例子： cpp struct Converter { protected: virtual void do_process(const char *s, size_t len) = 0; public: void process(string_view str) { return do_process(str.data(), str.size()); } void process(string str) { return do_process(str.data(), str.size()); } void process(const char *cstr) { return do_process(cstr, strlen(cstr)); } }; ","date":"2024-01-14","objectID":"/posts/cpp/:8:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#模板模式"},{"categories":["Tech"],"content":" 状态模式实际上就是状态机，只不过使用类将状态进行包装了，这样当有更改状态的需求时就不必翻源代码改if-else的内容，我们只需要改对应的类或者直接继承重写就可以了，这样才符合开闭原则 ","date":"2024-01-14","objectID":"/posts/cpp/:9:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#状态模式"},{"categories":["Tech"],"content":" 原型模式原型模式是一种创建型设计模式，它通过复制现有对象原型来创建新对象，而不是通过new实例化。这种方式可以避免重复初始化开销，特别适合创建成本高的对象 cow写时复制技术可以看作原型模式在内存管理中的一种应用，它们都遵循“先复制，再修改”的思想，适合用于构建复杂对象。但是cow着重于线程安全，内存共享，原型模式着重于创建独立对象，和避免重复初始化 通常的拷贝操作不支持拷贝派生类及其成员，也就是说它不支持拷贝的多态性。但是我们可以通过指针来实现这一点 当对象的一次拷贝具有多种类型或多种情况时，普通的拷贝构造函数以及模板就不能满足我们了，因为它不能拷贝虚函数的多态的对象，即使可以使用指针来实现这点，但也不过是浅拷贝，倘若加入类型判断以支持深拷贝的话我们还需要传入类型参数，这样就过于麻烦了 我们的解决办法是将拷贝构造函数变为虚函数，在子函数内部重写相应对象的拷贝构造函数，而后返回一个拷贝出来的对象的指针 cpp struct Ball { virtual Ball *clone() = 0; }; struct RedBall : Ball { Ball *clone() override { return new RedBall(*this); // 调用 RedBall 的拷贝构造函数 } }; struct BlueBall : Ball { Ball *clone() override { return new BlueBall(*this); // 调用 BlueBall 的拷贝构造函数 } int someData; // 如果有成员变量，也会一并被拷贝到 }; 这与我们之前介绍的工厂模式很像，只不过原型模式是传入一个子类，而后可以获得很多拷贝的子类对象。工厂模式则是传入任意类，而后获得拷贝出来的对象 下面是原型模式的使用： cpp Ball *ball = new RedBall(); ... Ball *newball = ball-\u003eclone(); // newball 的类型仍然是 RedBall 如果不使用原型模式的话，当执行Ball *newball = ball时就会发生object-slicing，newball会丢失Redball的信息，最终只剩下Ball 为了保证内存安全，我们还可以像工厂模式那样使用智能指针来管理生成的对象 cpp struct Ball { virtual unique_ptr\u003cBall\u003e clone() = 0; }; struct RedBall : Ball { unique_ptr\u003cBall\u003e clone() override { return make_unique\u003cRedBall\u003e(*this); // 调用 RedBall 的拷贝构造函数 } }; struct BlueBall : Ball { unique_ptr\u003cBall\u003e clone() override { return make_unique\u003cBlueBall\u003e(*this); // 调用 BlueBall 的拷贝构造函数 } int someData; // 如果有成员变量，也会一并被拷贝到新对象中 }; 我们可以更进一步使用模板来强化原型模式 cpp struct Ball { virtual unique_ptr\u003cBall\u003e clone() = 0; }; template \u003cclass Derived\u003e struct BallImpl : Ball { // 自动实现 clone 的辅助工具类 unique_ptr\u003cBall\u003e clone() override { Derived *that = static_cast\u003cDerived *\u003e(this); return make_unique\u003cDerived\u003e(*that); } }; struct RedBall : BallImpl\u003cRedBall\u003e { //没有发生循环引用？下文有解释 // unique_ptr\u003cBall\u003e clone() override { // BallImpl 自动实现的 clone 就是这样子，RedBall只进行重写 // return make_unique\u003cRedBall\u003e(*this); // 调用 RedBall 的拷贝构造函数 // } }; struct BlueBall : BallImpl\u003cBlueBall\u003e { // unique_ptr\u003cBall\u003e clone() override { // BallImpl 自动实现的 clone 就是这样子 // return make_unique\u003cBlueBall\u003e(*this); // 调用 BlueBall 的拷贝构造函数 // } }; 如果细心的话可以发现，在第13行竟然没有发生循环引用的错误，这是因为使用了CRTP技术，简而言之就是基类在实例化成员函数时是惰性的。因此我们可以将子类作为模板类型传入基类模板中并由子类继承，这样就可以通过调用不同的子类产生不同的原型对象 ","date":"2024-01-14","objectID":"/posts/cpp/:10:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#原型模式"},{"categories":["Tech"],"content":" 组件模式组件模式通常用于游戏行业，实际上游戏行业的C++开发者做的更多的是解释器的工作，因为如果按常规的组件模式也就是说将各个对象分成组件随后组装就会造成程序死板，每更新一次就要进行一次程序编译，app审查，apk更新等操作，这是十分耗时耗力的。我们的解决办法是将C++作为解释器(也就是游戏引擎)的开发语言，真正的游戏逻辑使用python，lua等脚本语言进行开发。脚本语言的优势是灵活，安全，不需要进行编译，审查(C++很容易写出病毒的)等操作。这样当游戏更新时就直接发布这些脚本语言和音视频图片等资源的包即可，只有当更新游戏引擎时才需要更新游戏apk ","date":"2024-01-14","objectID":"/posts/cpp/:11:0","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#组件模式"},{"categories":["Tech"],"content":" 组件之间的通信模式每个组件就是一个单独的对象，也是一个单独的类 组件之间需要通信，为了解决这个难题便提出了下列设计模式 观察者模式每个组件都有内部的消息处理函数，发送消息的组件会将消息发送给所有组件，各自组件使用dynamic_cast\u003ctype *\u003e(msg)来判断消息是否应该处理这些消息，如果需要处理的话就调用组件内部的消息处理函数 cpp struct Message { virtual ~Message() = default; // C++ 规定：只有多态类型才能 dynamic_cast，这里我们用不到虚函数，那就只让析构函数为虚函数，即可使 Message 变为多态类型 }; struct MoveMessage : Message { glm::vec3 velocityChange; }; struct Component { virtual void update(GameObject *go) = 0; virtual void handleMessage(Message *msg) = 0; virtual ~Component() = default; }; struct Movable : Component { glm::vec3 position; glm::vec3 velocity; void handleMessage(Message *msg) override { // 所有不同的消息类型都会进入此函数，但只有真正类型为 MoveMessage 的消息会被处理 if (MoveMessage *mm = dynamic_cast\u003cMoveMessage *\u003e(msg)) { // 首先使用 dynamic_cast 将Message转换为MoveMessage类型，如果转换成功话就将转换后的对象的指针赋值给mm，否则将nullptr赋值给mm，最后使用if判断mm的值 velocity += mm-\u003evelocityChange; } } }; struct PlayerController : Component { void update(GameObject *go) override { if (isKeyPressed(GLFW_KEY_W)) { MoveMessage mm; mm.velocityChange.y += 1; go-\u003esend(\u0026mm); } if (isKeyPressed(GLFW_KEY_S)) { MoveMessage mm; mm.velocityChange.y -= 1; go-\u003esend(\u0026mm); } if (isKeyPressed(GLFW_KEY_A)) { MoveMessage mm; mm.velocityChange.x -= 1; go-\u003esend(\u0026mm); } if (isKeyPressed(GLFW_KEY_D)) { MoveMessage mm; mm.velocityChange.x += 1; go-\u003esend(\u0026mm); } } }; struct GameObject { vector\u003cComponent *\u003e components; void add(Component *component) { components.push_back(component); } void update() { for (auto \u0026\u0026c: components) { c-\u003eupdate(this); } } void send(Message *msg) { for (auto \u0026\u0026c: components) { c-\u003ehandleMessage(msg); } } }; 但是这样会造成每个组件都需要处理所有消息，最终会导致性能问题 发布订阅模式发布订阅模式应用广泛，他是观察者模式的改良版。它的原理是构建一个系统总线，让相同类型的消息存储在这个总线上同一个vector，当消息发送时，会调用注册函数将消息发送到指定的vector中，这样就不必像观察者模式那样每次发送时组件内部都要判断是否是发送给他的消息 cpp struct Message { virtual ~Message() = default; }; struct MoveMessage : Message { glm::vec3 velocityChange; }; struct GameObject { vector\u003cComponent *\u003e components; unordered_map\u003ctype_index, vector\u003cComponent *\u003e\u003e subscribers; // 事件总线 // 通过模板成员函数来支持多种类型消息 template \u003ctypename EventType\u003e void subscribe(Component *component) { // 使用typeid获取EventType的运行时信息(RTTI)并返回std::type_info对象，之后使用type_index将type_info包装为type_index对象，使其可以作为哈希表的键。最后利用unordered_map构建哈希表，每个表项是一个component的vector subscribers[type_index(typeid(EventType))].push_back(component); } template \u003ctypename EventType\u003e void send(EventType *msg) { for (auto \u0026\u0026c: subscribers[type_index(typeid(EventType))]) { c-\u003ehandleMessage(msg); } } void add(Component *component) { components.push_back(component); component-\u003esubscribeMessages(this); } void update() { for (auto \u0026\u0026c: components) { c-\u003eupdate(this); } } }; struct Component { virtual void update(GameObject *go) = 0; virtual void subscribeMessages(GameObject *go) = 0; virtual void handleMessage(Message *msg) = 0; virtual ~Component() = default; }; struct Movable : Component { glm::vec3 position; glm::vec3 velocity; void subscribeMessages(GameObject *go) { go-\u003esubscribe\u003cMoveMessage\u003e(this); } void handleMessage(Message *msg) override { if (MoveMessage *mm = dynamic_cast\u003cMoveMessage *\u003e(msg)) { velocity += mm-\u003evelocityChange; } } }; struct PlayerController : Component { void update(GameObject *go) override { if (isKeyPressed(GLFW_KEY_W)) { MoveMessage mm; mm.velocityChange.y += 1; go-\u003esend(\u0026mm); } if (isKeyPressed(GLFW_KEY_S)) { MoveMessage mm; mm.velocityChange.y -= 1; go-\u003esend(\u0026mm); } if (isKeyPressed(GLFW_KEY_A)) { MoveMessage mm; mm.velocityChange.x -= 1; go-\u003esend(\u0026mm); } if (isKeyPressed(GLFW_KEY_D)) { MoveMessage mm; mm.velocityChange.x += 1; go-\u003esend(\u0026mm); } if (isKeyPressed(GLFW_KEY_SPACE)) { JumpMessage jm; go-\u003esend(\u0026jm); } } }; 访问者模式尽管发布订阅模式的性能相比观察者模式有了很大的提高，但仍然需要动态类型转换dynamic_cast\u003ctype *\u003e(msg)才能获得消息，并且无法对消息处理进行细化，因此就诞生了访问者模式 访问者模式特化了数据处理方式，这样我们就可以对每种消息执行对应的处理。比如对于发布订阅的Movable类而言，只继承了component组件，Movable下的跑，跳，减速等移动方式还需要进行动态类型转换才能够处理数据，使用了访问者模式之后就可以在Movable类中通过不同的访问者来处理各种消息了 cpp struct MessageVisitor; // 前向声明 struct Message { virtual void accept(MessageVisitor *visitor) = 0; virtual ~Message() = default; }; struct MoveMe","date":"2024-01-14","objectID":"/posts/cpp/:11:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#组件之间的通信模式"},{"categories":["Tech"],"content":" 组件之间的通信模式每个组件就是一个单独的对象，也是一个单独的类 组件之间需要通信，为了解决这个难题便提出了下列设计模式 观察者模式每个组件都有内部的消息处理函数，发送消息的组件会将消息发送给所有组件，各自组件使用dynamic_cast(msg)来判断消息是否应该处理这些消息，如果需要处理的话就调用组件内部的消息处理函数 cpp struct Message { virtual ~Message() = default; // C++ 规定：只有多态类型才能 dynamic_cast，这里我们用不到虚函数，那就只让析构函数为虚函数，即可使 Message 变为多态类型 }; struct MoveMessage : Message { glm::vec3 velocityChange; }; struct Component { virtual void update(GameObject *go) = 0; virtual void handleMessage(Message *msg) = 0; virtual ~Component() = default; }; struct Movable : Component { glm::vec3 position; glm::vec3 velocity; void handleMessage(Message *msg) override { // 所有不同的消息类型都会进入此函数，但只有真正类型为 MoveMessage 的消息会被处理 if (MoveMessage *mm = dynamic_cast(msg)) { // 首先使用 dynamic_cast 将Message转换为MoveMessage类型，如果转换成功话就将转换后的对象的指针赋值给mm，否则将nullptr赋值给mm，最后使用if判断mm的值 velocity += mm-\u003evelocityChange; } } }; struct PlayerController : Component { void update(GameObject *go) override { if (isKeyPressed(GLFW_KEY_W)) { MoveMessage mm; mm.velocityChange.y += 1; go-\u003esend(\u0026mm); } if (isKeyPressed(GLFW_KEY_S)) { MoveMessage mm; mm.velocityChange.y -= 1; go-\u003esend(\u0026mm); } if (isKeyPressed(GLFW_KEY_A)) { MoveMessage mm; mm.velocityChange.x -= 1; go-\u003esend(\u0026mm); } if (isKeyPressed(GLFW_KEY_D)) { MoveMessage mm; mm.velocityChange.x += 1; go-\u003esend(\u0026mm); } } }; struct GameObject { vector components; void add(Component *component) { components.push_back(component); } void update() { for (auto \u0026\u0026c: components) { c-\u003eupdate(this); } } void send(Message *msg) { for (auto \u0026\u0026c: components) { c-\u003ehandleMessage(msg); } } }; 但是这样会造成每个组件都需要处理所有消息，最终会导致性能问题 发布订阅模式发布订阅模式应用广泛，他是观察者模式的改良版。它的原理是构建一个系统总线，让相同类型的消息存储在这个总线上同一个vector，当消息发送时，会调用注册函数将消息发送到指定的vector中，这样就不必像观察者模式那样每次发送时组件内部都要判断是否是发送给他的消息 cpp struct Message { virtual ~Message() = default; }; struct MoveMessage : Message { glm::vec3 velocityChange; }; struct GameObject { vector components; unordered_map","date":"2024-01-14","objectID":"/posts/cpp/:11:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#观察者模式"},{"categories":["Tech"],"content":" 组件之间的通信模式每个组件就是一个单独的对象，也是一个单独的类 组件之间需要通信，为了解决这个难题便提出了下列设计模式 观察者模式每个组件都有内部的消息处理函数，发送消息的组件会将消息发送给所有组件，各自组件使用dynamic_cast(msg)来判断消息是否应该处理这些消息，如果需要处理的话就调用组件内部的消息处理函数 cpp struct Message { virtual ~Message() = default; // C++ 规定：只有多态类型才能 dynamic_cast，这里我们用不到虚函数，那就只让析构函数为虚函数，即可使 Message 变为多态类型 }; struct MoveMessage : Message { glm::vec3 velocityChange; }; struct Component { virtual void update(GameObject *go) = 0; virtual void handleMessage(Message *msg) = 0; virtual ~Component() = default; }; struct Movable : Component { glm::vec3 position; glm::vec3 velocity; void handleMessage(Message *msg) override { // 所有不同的消息类型都会进入此函数，但只有真正类型为 MoveMessage 的消息会被处理 if (MoveMessage *mm = dynamic_cast(msg)) { // 首先使用 dynamic_cast 将Message转换为MoveMessage类型，如果转换成功话就将转换后的对象的指针赋值给mm，否则将nullptr赋值给mm，最后使用if判断mm的值 velocity += mm-\u003evelocityChange; } } }; struct PlayerController : Component { void update(GameObject *go) override { if (isKeyPressed(GLFW_KEY_W)) { MoveMessage mm; mm.velocityChange.y += 1; go-\u003esend(\u0026mm); } if (isKeyPressed(GLFW_KEY_S)) { MoveMessage mm; mm.velocityChange.y -= 1; go-\u003esend(\u0026mm); } if (isKeyPressed(GLFW_KEY_A)) { MoveMessage mm; mm.velocityChange.x -= 1; go-\u003esend(\u0026mm); } if (isKeyPressed(GLFW_KEY_D)) { MoveMessage mm; mm.velocityChange.x += 1; go-\u003esend(\u0026mm); } } }; struct GameObject { vector components; void add(Component *component) { components.push_back(component); } void update() { for (auto \u0026\u0026c: components) { c-\u003eupdate(this); } } void send(Message *msg) { for (auto \u0026\u0026c: components) { c-\u003ehandleMessage(msg); } } }; 但是这样会造成每个组件都需要处理所有消息，最终会导致性能问题 发布订阅模式发布订阅模式应用广泛，他是观察者模式的改良版。它的原理是构建一个系统总线，让相同类型的消息存储在这个总线上同一个vector，当消息发送时，会调用注册函数将消息发送到指定的vector中，这样就不必像观察者模式那样每次发送时组件内部都要判断是否是发送给他的消息 cpp struct Message { virtual ~Message() = default; }; struct MoveMessage : Message { glm::vec3 velocityChange; }; struct GameObject { vector components; unordered_map","date":"2024-01-14","objectID":"/posts/cpp/:11:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#发布订阅模式"},{"categories":["Tech"],"content":" 组件之间的通信模式每个组件就是一个单独的对象，也是一个单独的类 组件之间需要通信，为了解决这个难题便提出了下列设计模式 观察者模式每个组件都有内部的消息处理函数，发送消息的组件会将消息发送给所有组件，各自组件使用dynamic_cast(msg)来判断消息是否应该处理这些消息，如果需要处理的话就调用组件内部的消息处理函数 cpp struct Message { virtual ~Message() = default; // C++ 规定：只有多态类型才能 dynamic_cast，这里我们用不到虚函数，那就只让析构函数为虚函数，即可使 Message 变为多态类型 }; struct MoveMessage : Message { glm::vec3 velocityChange; }; struct Component { virtual void update(GameObject *go) = 0; virtual void handleMessage(Message *msg) = 0; virtual ~Component() = default; }; struct Movable : Component { glm::vec3 position; glm::vec3 velocity; void handleMessage(Message *msg) override { // 所有不同的消息类型都会进入此函数，但只有真正类型为 MoveMessage 的消息会被处理 if (MoveMessage *mm = dynamic_cast(msg)) { // 首先使用 dynamic_cast 将Message转换为MoveMessage类型，如果转换成功话就将转换后的对象的指针赋值给mm，否则将nullptr赋值给mm，最后使用if判断mm的值 velocity += mm-\u003evelocityChange; } } }; struct PlayerController : Component { void update(GameObject *go) override { if (isKeyPressed(GLFW_KEY_W)) { MoveMessage mm; mm.velocityChange.y += 1; go-\u003esend(\u0026mm); } if (isKeyPressed(GLFW_KEY_S)) { MoveMessage mm; mm.velocityChange.y -= 1; go-\u003esend(\u0026mm); } if (isKeyPressed(GLFW_KEY_A)) { MoveMessage mm; mm.velocityChange.x -= 1; go-\u003esend(\u0026mm); } if (isKeyPressed(GLFW_KEY_D)) { MoveMessage mm; mm.velocityChange.x += 1; go-\u003esend(\u0026mm); } } }; struct GameObject { vector components; void add(Component *component) { components.push_back(component); } void update() { for (auto \u0026\u0026c: components) { c-\u003eupdate(this); } } void send(Message *msg) { for (auto \u0026\u0026c: components) { c-\u003ehandleMessage(msg); } } }; 但是这样会造成每个组件都需要处理所有消息，最终会导致性能问题 发布订阅模式发布订阅模式应用广泛，他是观察者模式的改良版。它的原理是构建一个系统总线，让相同类型的消息存储在这个总线上同一个vector，当消息发送时，会调用注册函数将消息发送到指定的vector中，这样就不必像观察者模式那样每次发送时组件内部都要判断是否是发送给他的消息 cpp struct Message { virtual ~Message() = default; }; struct MoveMessage : Message { glm::vec3 velocityChange; }; struct GameObject { vector components; unordered_map","date":"2024-01-14","objectID":"/posts/cpp/:11:1","series":null,"tags":["Programing Language","Tech"],"title":"C++","uri":"/posts/cpp/#访问者模式"},{"categories":["Tech"],"content":"本文较为详细地介绍了Python的语法，参考资料为b站的黑马程序员 ","date":"2024-01-14","objectID":"/posts/python/:0:0","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#"},{"categories":["Tech"],"content":" Python","date":"2024-01-14","objectID":"/posts/python/:0:0","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#python"},{"categories":["Tech"],"content":" Python基础","date":"2024-01-14","objectID":"/posts/python/:1:0","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#python基础"},{"categories":["Tech"],"content":" 解释器与编译器解释器输出运行的结果 编译器输出编译的文件 字面量：写在代码中的值，可以被分为整数，浮点数，字符串，元组，列表等 python的单引号和双引号意义相同，但是使用单引号可以打出双引号，但不能打出单引号。使用双引号则反之，如果想使用单引号打出单引号，则需要加上反斜杠代表转义字符 ","date":"2024-01-14","objectID":"/posts/python/:1:1","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#解释器与编译器"},{"categories":["Tech"],"content":" 注释的写法 py # 这是单行注释 \"\"\" 这是多 行注释 \"\"\" python中变量无类型而数据有类型，可以通过type(数据)来查看数据拥有的数据类型，同时也可以使用type(变量)来查看变量拥有的数据类型 ","date":"2024-01-14","objectID":"/posts/python/:1:2","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#注释的写法"},{"categories":["Tech"],"content":" 类型转换 py int(x) # 将x转换为int类型 float(x) # 将x转换为float类型 float转换为int会丢失精度 python舍弃精度时是四舍五入 ","date":"2024-01-14","objectID":"/posts/python/:1:3","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#类型转换"},{"categories":["Tech"],"content":" 运算符 py print(9//4) # 结果为2 print(9%4) # 结果为1 # ** 代表取幂运算 字符串可以通过转义字符来包含引号 ","date":"2024-01-14","objectID":"/posts/python/:1:4","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#运算符"},{"categories":["Tech"],"content":" 拼接 py # 可以进行字符串之间的拼接，也可以进行字面量和变量之间的拼接 name = lzx printf(\"The computer belong to \" + lzx + \"since 2023.\") # 但是不能将整数或其它类型与字符串拼接，例如 tel = 155 printf(\"The computer belong to \" + lzx + \"since 2023.\" + \"tel is\" + tel) #运行报错，提示int类型不能与str类型进行拼接，想要拼接首先要进行格式化 ","date":"2024-01-14","objectID":"/posts/python/:1:5","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#拼接"},{"categories":["Tech"],"content":" 占位符与格式化 py birth = 2001 name = \"lzx\" message = \"我是：%s，出生于：%d\" %(name,birth) # 或者 message = f\"我是：{name}，出生于：{birth}\" # 但是这种用法不能对精度进行控制，也不会考虑数据类型 ","date":"2024-01-14","objectID":"/posts/python/:1:6","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#占位符与格式化"},{"categories":["Tech"],"content":" 输入函数 py input(\"提示语\") # input得到的数据永远是字符串类型 ","date":"2024-01-14","objectID":"/posts/python/:1:7","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#输入函数"},{"categories":["Tech"],"content":" 条件语句python用4个空格来划分所属关系 py if condition: # todo elif condition: # todo else: # todo ","date":"2024-01-14","objectID":"/posts/python/:1:8","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#条件语句"},{"categories":["Tech"],"content":" 循环语句 py while condition: # todo for 临时变量 in 数据集 # for循环无法定义循环条件 #todo 警告 for循环里的临时变量会自动自增，但是while需要手动自增 ","date":"2024-01-14","objectID":"/posts/python/:1:9","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#循环语句"},{"categories":["Tech"],"content":" range py range(num) # 获得一个从0开始不含num的数字序列，例如range(5)，获得一个0，1，2，3，4的序列 range(num1,num2,step) #获得一个从num1开始，到num结束，步进为step的不含num2的数字序列 #range常用来配合for循环使用 for x in range(10) ","date":"2024-01-14","objectID":"/posts/python/:1:10","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#range"},{"categories":["Tech"],"content":" 函数 py def functionname(parameter) # function body return returnvalue temp = 0 def fun1() global temp # 声明全局变量 temp = 100 return None 函数无返回值，返回的是None 对于一些不想要设置初始值的变量来说，可以先让这个变量赋值为None 函数作为参数传递 py def fun1(fun): print(\"fun1\") fun() print(\"fun1\") def fun2(): print(\"fun2\") fun1(fun2) # 注意这里fun2不带() ","date":"2024-01-14","objectID":"/posts/python/:1:11","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#函数"},{"categories":["Tech"],"content":" 数据容器 2024-01-20_13-37 2024-01-20_13-38 数据容器的转换其他数据容器不能转换为字典 py # 将其他数据容器转换为列表 list(tuple_name()) # 字符串转列表会将字符串变为字符再装载进列表，字典转列表只会将Key值放进列表 # 将其他数据容器转换为元组 tuple(dict_name) # 情况与字符串转列表类似 # 将其他数据容器转换为字符串 str(list_name) # 其他数据类型任意转换为字符串 # 将其他数据容器转换为集合 set(str_name) # 情况与字符串转列表类似 列表(list) 2024-01-19_21-28 列表可以存储不同数据类型的元素，并按照一定下标排序，允许重复数据存在 py # 列表的字面量定义 [Item1,Item2,Item3] # 列表内的元素带有下标，可以通过下标索引到元素，索引方向分为从左至右和从右至左两种，下方列表中Item3的下标可以是2，也可以是-1 # 列表的变量定义 list_name = [Item1,Item2,Item3] #定义空列表 list_name = [] list_name = list() 嵌套列表获取元素list_name[0][1] 将函数定义为类中的成员，我们称这种函数叫做方法 py #查询元素 list_name.index(Item1) # 查询Item1的下标，如果找不到则报错ValueError #插入元素 list_name.insert(index，Item2) # 在index处插入Item2 #追加元素 list_name.append(Item3) # 在列表尾部追加append #追加数据容器 list_name.extend(其他数据容器) #在列表尾部追加其他数据容器的元素 #删除元素 element = list_name.pop(index) # 取出index的那个元素并赋值给element，最后在列表中删除 #清空整个列表 list_name.clear() #统计某个元素在列表中的数量 list_name.count(Item4) #统计列表中有多少元素 len(list_name) # 返回值为列表中元素的个数 元组(tuple)元组一旦定义好，内部的元素就不可修改。但如果元组内嵌套了list，则可以修改list的内容，可以将元组视为不可修改元素的list 元组内部数据类型可以不同 py # 定义元组字面量 (Item1，Item2，Item3) # 定义元组变量 tuple_name = (Item1，Item2，Item3) # 定义空元组 tuple_name = tuple() 字符串(str)字符串是一个不可修改的数据容器 py my_str = \"hellow world\" # 字符串的替换 new_str1 = my_str.replace(\"hellow\",\"hello\") # 原字符串不可修改，但得到了一个新的字符串 #字符串的分割 new_str2 = my_str.split(\" \") # 按空格切分字符串，返回一个含有字符串的列表 序列序列是指内容连续，有序，可使用下标索引的一类数据容器 py # 语法 数据容器[start:end:step] # 在数据容器中从start下标开始到end下标结束(不包括end下标)，每隔step-1个元素取出一个数据组成新的序列，步长为负数则代表序列从后向前取 newlist = list_name[::2] 集合(set)集合内元素不能重复且无序，但允许修改 因为集合不支持下标索引，所以不支持while循环，但支持for循环 py # 定义集合字面量 {Item1，Item2，Item3} # 定义集合变量 set_name = {Item1，Item2，Item3} # 定义空集合 set_name = set() # 添加元素 set_name.add(\"Item4\") # 移除元素 set_name.remove(\"Item5\") # 清空集合 set_name.clear() # 随机取元素 set_name.pop(\"Item6\") # 取出集合1不同于集合2的元素 set1 = {1,2,3} set2 = {1,5,6} set3 = set1.difference(set2) # 更新集合1与集合2不同的元素 set1.difference_update(set2) # 结果set1 = {2,3}，set2不变 # 集合的合并 set3 = set1.union(set2) 字典(dict)字典无序没有索引，只能通过Key值找到对应的value 字典的Key不可重复 字典的Key和value可以为任意数据类型(但Key不可为字典) 与集合类似，因为字典不支持下标索引，所以也不支持while循环，但支持for循环 py # 字典的定义 dict_name = {Key:value,Key:value,Key:value} # 空字典的定义 dict_name = dict() # 找到Key对应的value keyvalue = dict[Key] # 添加或更新元素 dict_name[Key] = value # 有对应的key则更新元素，否则添加新的key及其对应元素 # 删除元素 Item = dict_name.pop(Key) # 清空元素 dict_name.clear() # 获取全部的Key AllKeys = dict_name.keys() # 找到全部Key后遍历字典 for key in AllKeys # todo # 或者直接遍历 for key in dict_name: # todo ","date":"2024-01-14","objectID":"/posts/python/:1:12","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#数据容器"},{"categories":["Tech"],"content":" 数据容器 2024-01-20_13-37 2024-01-20_13-38 数据容器的转换其他数据容器不能转换为字典 py # 将其他数据容器转换为列表 list(tuple_name()) # 字符串转列表会将字符串变为字符再装载进列表，字典转列表只会将Key值放进列表 # 将其他数据容器转换为元组 tuple(dict_name) # 情况与字符串转列表类似 # 将其他数据容器转换为字符串 str(list_name) # 其他数据类型任意转换为字符串 # 将其他数据容器转换为集合 set(str_name) # 情况与字符串转列表类似 列表(list) 2024-01-19_21-28 列表可以存储不同数据类型的元素，并按照一定下标排序，允许重复数据存在 py # 列表的字面量定义 [Item1,Item2,Item3] # 列表内的元素带有下标，可以通过下标索引到元素，索引方向分为从左至右和从右至左两种，下方列表中Item3的下标可以是2，也可以是-1 # 列表的变量定义 list_name = [Item1,Item2,Item3] #定义空列表 list_name = [] list_name = list() 嵌套列表获取元素list_name[0][1] 将函数定义为类中的成员，我们称这种函数叫做方法 py #查询元素 list_name.index(Item1) # 查询Item1的下标，如果找不到则报错ValueError #插入元素 list_name.insert(index，Item2) # 在index处插入Item2 #追加元素 list_name.append(Item3) # 在列表尾部追加append #追加数据容器 list_name.extend(其他数据容器) #在列表尾部追加其他数据容器的元素 #删除元素 element = list_name.pop(index) # 取出index的那个元素并赋值给element，最后在列表中删除 #清空整个列表 list_name.clear() #统计某个元素在列表中的数量 list_name.count(Item4) #统计列表中有多少元素 len(list_name) # 返回值为列表中元素的个数 元组(tuple)元组一旦定义好，内部的元素就不可修改。但如果元组内嵌套了list，则可以修改list的内容，可以将元组视为不可修改元素的list 元组内部数据类型可以不同 py # 定义元组字面量 (Item1，Item2，Item3) # 定义元组变量 tuple_name = (Item1，Item2，Item3) # 定义空元组 tuple_name = tuple() 字符串(str)字符串是一个不可修改的数据容器 py my_str = \"hellow world\" # 字符串的替换 new_str1 = my_str.replace(\"hellow\",\"hello\") # 原字符串不可修改，但得到了一个新的字符串 #字符串的分割 new_str2 = my_str.split(\" \") # 按空格切分字符串，返回一个含有字符串的列表 序列序列是指内容连续，有序，可使用下标索引的一类数据容器 py # 语法 数据容器[start:end:step] # 在数据容器中从start下标开始到end下标结束(不包括end下标)，每隔step-1个元素取出一个数据组成新的序列，步长为负数则代表序列从后向前取 newlist = list_name[::2] 集合(set)集合内元素不能重复且无序，但允许修改 因为集合不支持下标索引，所以不支持while循环，但支持for循环 py # 定义集合字面量 {Item1，Item2，Item3} # 定义集合变量 set_name = {Item1，Item2，Item3} # 定义空集合 set_name = set() # 添加元素 set_name.add(\"Item4\") # 移除元素 set_name.remove(\"Item5\") # 清空集合 set_name.clear() # 随机取元素 set_name.pop(\"Item6\") # 取出集合1不同于集合2的元素 set1 = {1,2,3} set2 = {1,5,6} set3 = set1.difference(set2) # 更新集合1与集合2不同的元素 set1.difference_update(set2) # 结果set1 = {2,3}，set2不变 # 集合的合并 set3 = set1.union(set2) 字典(dict)字典无序没有索引，只能通过Key值找到对应的value 字典的Key不可重复 字典的Key和value可以为任意数据类型(但Key不可为字典) 与集合类似，因为字典不支持下标索引，所以也不支持while循环，但支持for循环 py # 字典的定义 dict_name = {Key:value,Key:value,Key:value} # 空字典的定义 dict_name = dict() # 找到Key对应的value keyvalue = dict[Key] # 添加或更新元素 dict_name[Key] = value # 有对应的key则更新元素，否则添加新的key及其对应元素 # 删除元素 Item = dict_name.pop(Key) # 清空元素 dict_name.clear() # 获取全部的Key AllKeys = dict_name.keys() # 找到全部Key后遍历字典 for key in AllKeys # todo # 或者直接遍历 for key in dict_name: # todo ","date":"2024-01-14","objectID":"/posts/python/:1:12","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#数据容器的转换"},{"categories":["Tech"],"content":" 数据容器 2024-01-20_13-37 2024-01-20_13-38 数据容器的转换其他数据容器不能转换为字典 py # 将其他数据容器转换为列表 list(tuple_name()) # 字符串转列表会将字符串变为字符再装载进列表，字典转列表只会将Key值放进列表 # 将其他数据容器转换为元组 tuple(dict_name) # 情况与字符串转列表类似 # 将其他数据容器转换为字符串 str(list_name) # 其他数据类型任意转换为字符串 # 将其他数据容器转换为集合 set(str_name) # 情况与字符串转列表类似 列表(list) 2024-01-19_21-28 列表可以存储不同数据类型的元素，并按照一定下标排序，允许重复数据存在 py # 列表的字面量定义 [Item1,Item2,Item3] # 列表内的元素带有下标，可以通过下标索引到元素，索引方向分为从左至右和从右至左两种，下方列表中Item3的下标可以是2，也可以是-1 # 列表的变量定义 list_name = [Item1,Item2,Item3] #定义空列表 list_name = [] list_name = list() 嵌套列表获取元素list_name[0][1] 将函数定义为类中的成员，我们称这种函数叫做方法 py #查询元素 list_name.index(Item1) # 查询Item1的下标，如果找不到则报错ValueError #插入元素 list_name.insert(index，Item2) # 在index处插入Item2 #追加元素 list_name.append(Item3) # 在列表尾部追加append #追加数据容器 list_name.extend(其他数据容器) #在列表尾部追加其他数据容器的元素 #删除元素 element = list_name.pop(index) # 取出index的那个元素并赋值给element，最后在列表中删除 #清空整个列表 list_name.clear() #统计某个元素在列表中的数量 list_name.count(Item4) #统计列表中有多少元素 len(list_name) # 返回值为列表中元素的个数 元组(tuple)元组一旦定义好，内部的元素就不可修改。但如果元组内嵌套了list，则可以修改list的内容，可以将元组视为不可修改元素的list 元组内部数据类型可以不同 py # 定义元组字面量 (Item1，Item2，Item3) # 定义元组变量 tuple_name = (Item1，Item2，Item3) # 定义空元组 tuple_name = tuple() 字符串(str)字符串是一个不可修改的数据容器 py my_str = \"hellow world\" # 字符串的替换 new_str1 = my_str.replace(\"hellow\",\"hello\") # 原字符串不可修改，但得到了一个新的字符串 #字符串的分割 new_str2 = my_str.split(\" \") # 按空格切分字符串，返回一个含有字符串的列表 序列序列是指内容连续，有序，可使用下标索引的一类数据容器 py # 语法 数据容器[start:end:step] # 在数据容器中从start下标开始到end下标结束(不包括end下标)，每隔step-1个元素取出一个数据组成新的序列，步长为负数则代表序列从后向前取 newlist = list_name[::2] 集合(set)集合内元素不能重复且无序，但允许修改 因为集合不支持下标索引，所以不支持while循环，但支持for循环 py # 定义集合字面量 {Item1，Item2，Item3} # 定义集合变量 set_name = {Item1，Item2，Item3} # 定义空集合 set_name = set() # 添加元素 set_name.add(\"Item4\") # 移除元素 set_name.remove(\"Item5\") # 清空集合 set_name.clear() # 随机取元素 set_name.pop(\"Item6\") # 取出集合1不同于集合2的元素 set1 = {1,2,3} set2 = {1,5,6} set3 = set1.difference(set2) # 更新集合1与集合2不同的元素 set1.difference_update(set2) # 结果set1 = {2,3}，set2不变 # 集合的合并 set3 = set1.union(set2) 字典(dict)字典无序没有索引，只能通过Key值找到对应的value 字典的Key不可重复 字典的Key和value可以为任意数据类型(但Key不可为字典) 与集合类似，因为字典不支持下标索引，所以也不支持while循环，但支持for循环 py # 字典的定义 dict_name = {Key:value,Key:value,Key:value} # 空字典的定义 dict_name = dict() # 找到Key对应的value keyvalue = dict[Key] # 添加或更新元素 dict_name[Key] = value # 有对应的key则更新元素，否则添加新的key及其对应元素 # 删除元素 Item = dict_name.pop(Key) # 清空元素 dict_name.clear() # 获取全部的Key AllKeys = dict_name.keys() # 找到全部Key后遍历字典 for key in AllKeys # todo # 或者直接遍历 for key in dict_name: # todo ","date":"2024-01-14","objectID":"/posts/python/:1:12","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#列表list"},{"categories":["Tech"],"content":" 数据容器 2024-01-20_13-37 2024-01-20_13-38 数据容器的转换其他数据容器不能转换为字典 py # 将其他数据容器转换为列表 list(tuple_name()) # 字符串转列表会将字符串变为字符再装载进列表，字典转列表只会将Key值放进列表 # 将其他数据容器转换为元组 tuple(dict_name) # 情况与字符串转列表类似 # 将其他数据容器转换为字符串 str(list_name) # 其他数据类型任意转换为字符串 # 将其他数据容器转换为集合 set(str_name) # 情况与字符串转列表类似 列表(list) 2024-01-19_21-28 列表可以存储不同数据类型的元素，并按照一定下标排序，允许重复数据存在 py # 列表的字面量定义 [Item1,Item2,Item3] # 列表内的元素带有下标，可以通过下标索引到元素，索引方向分为从左至右和从右至左两种，下方列表中Item3的下标可以是2，也可以是-1 # 列表的变量定义 list_name = [Item1,Item2,Item3] #定义空列表 list_name = [] list_name = list() 嵌套列表获取元素list_name[0][1] 将函数定义为类中的成员，我们称这种函数叫做方法 py #查询元素 list_name.index(Item1) # 查询Item1的下标，如果找不到则报错ValueError #插入元素 list_name.insert(index，Item2) # 在index处插入Item2 #追加元素 list_name.append(Item3) # 在列表尾部追加append #追加数据容器 list_name.extend(其他数据容器) #在列表尾部追加其他数据容器的元素 #删除元素 element = list_name.pop(index) # 取出index的那个元素并赋值给element，最后在列表中删除 #清空整个列表 list_name.clear() #统计某个元素在列表中的数量 list_name.count(Item4) #统计列表中有多少元素 len(list_name) # 返回值为列表中元素的个数 元组(tuple)元组一旦定义好，内部的元素就不可修改。但如果元组内嵌套了list，则可以修改list的内容，可以将元组视为不可修改元素的list 元组内部数据类型可以不同 py # 定义元组字面量 (Item1，Item2，Item3) # 定义元组变量 tuple_name = (Item1，Item2，Item3) # 定义空元组 tuple_name = tuple() 字符串(str)字符串是一个不可修改的数据容器 py my_str = \"hellow world\" # 字符串的替换 new_str1 = my_str.replace(\"hellow\",\"hello\") # 原字符串不可修改，但得到了一个新的字符串 #字符串的分割 new_str2 = my_str.split(\" \") # 按空格切分字符串，返回一个含有字符串的列表 序列序列是指内容连续，有序，可使用下标索引的一类数据容器 py # 语法 数据容器[start:end:step] # 在数据容器中从start下标开始到end下标结束(不包括end下标)，每隔step-1个元素取出一个数据组成新的序列，步长为负数则代表序列从后向前取 newlist = list_name[::2] 集合(set)集合内元素不能重复且无序，但允许修改 因为集合不支持下标索引，所以不支持while循环，但支持for循环 py # 定义集合字面量 {Item1，Item2，Item3} # 定义集合变量 set_name = {Item1，Item2，Item3} # 定义空集合 set_name = set() # 添加元素 set_name.add(\"Item4\") # 移除元素 set_name.remove(\"Item5\") # 清空集合 set_name.clear() # 随机取元素 set_name.pop(\"Item6\") # 取出集合1不同于集合2的元素 set1 = {1,2,3} set2 = {1,5,6} set3 = set1.difference(set2) # 更新集合1与集合2不同的元素 set1.difference_update(set2) # 结果set1 = {2,3}，set2不变 # 集合的合并 set3 = set1.union(set2) 字典(dict)字典无序没有索引，只能通过Key值找到对应的value 字典的Key不可重复 字典的Key和value可以为任意数据类型(但Key不可为字典) 与集合类似，因为字典不支持下标索引，所以也不支持while循环，但支持for循环 py # 字典的定义 dict_name = {Key:value,Key:value,Key:value} # 空字典的定义 dict_name = dict() # 找到Key对应的value keyvalue = dict[Key] # 添加或更新元素 dict_name[Key] = value # 有对应的key则更新元素，否则添加新的key及其对应元素 # 删除元素 Item = dict_name.pop(Key) # 清空元素 dict_name.clear() # 获取全部的Key AllKeys = dict_name.keys() # 找到全部Key后遍历字典 for key in AllKeys # todo # 或者直接遍历 for key in dict_name: # todo ","date":"2024-01-14","objectID":"/posts/python/:1:12","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#元组tuple"},{"categories":["Tech"],"content":" 数据容器 2024-01-20_13-37 2024-01-20_13-38 数据容器的转换其他数据容器不能转换为字典 py # 将其他数据容器转换为列表 list(tuple_name()) # 字符串转列表会将字符串变为字符再装载进列表，字典转列表只会将Key值放进列表 # 将其他数据容器转换为元组 tuple(dict_name) # 情况与字符串转列表类似 # 将其他数据容器转换为字符串 str(list_name) # 其他数据类型任意转换为字符串 # 将其他数据容器转换为集合 set(str_name) # 情况与字符串转列表类似 列表(list) 2024-01-19_21-28 列表可以存储不同数据类型的元素，并按照一定下标排序，允许重复数据存在 py # 列表的字面量定义 [Item1,Item2,Item3] # 列表内的元素带有下标，可以通过下标索引到元素，索引方向分为从左至右和从右至左两种，下方列表中Item3的下标可以是2，也可以是-1 # 列表的变量定义 list_name = [Item1,Item2,Item3] #定义空列表 list_name = [] list_name = list() 嵌套列表获取元素list_name[0][1] 将函数定义为类中的成员，我们称这种函数叫做方法 py #查询元素 list_name.index(Item1) # 查询Item1的下标，如果找不到则报错ValueError #插入元素 list_name.insert(index，Item2) # 在index处插入Item2 #追加元素 list_name.append(Item3) # 在列表尾部追加append #追加数据容器 list_name.extend(其他数据容器) #在列表尾部追加其他数据容器的元素 #删除元素 element = list_name.pop(index) # 取出index的那个元素并赋值给element，最后在列表中删除 #清空整个列表 list_name.clear() #统计某个元素在列表中的数量 list_name.count(Item4) #统计列表中有多少元素 len(list_name) # 返回值为列表中元素的个数 元组(tuple)元组一旦定义好，内部的元素就不可修改。但如果元组内嵌套了list，则可以修改list的内容，可以将元组视为不可修改元素的list 元组内部数据类型可以不同 py # 定义元组字面量 (Item1，Item2，Item3) # 定义元组变量 tuple_name = (Item1，Item2，Item3) # 定义空元组 tuple_name = tuple() 字符串(str)字符串是一个不可修改的数据容器 py my_str = \"hellow world\" # 字符串的替换 new_str1 = my_str.replace(\"hellow\",\"hello\") # 原字符串不可修改，但得到了一个新的字符串 #字符串的分割 new_str2 = my_str.split(\" \") # 按空格切分字符串，返回一个含有字符串的列表 序列序列是指内容连续，有序，可使用下标索引的一类数据容器 py # 语法 数据容器[start:end:step] # 在数据容器中从start下标开始到end下标结束(不包括end下标)，每隔step-1个元素取出一个数据组成新的序列，步长为负数则代表序列从后向前取 newlist = list_name[::2] 集合(set)集合内元素不能重复且无序，但允许修改 因为集合不支持下标索引，所以不支持while循环，但支持for循环 py # 定义集合字面量 {Item1，Item2，Item3} # 定义集合变量 set_name = {Item1，Item2，Item3} # 定义空集合 set_name = set() # 添加元素 set_name.add(\"Item4\") # 移除元素 set_name.remove(\"Item5\") # 清空集合 set_name.clear() # 随机取元素 set_name.pop(\"Item6\") # 取出集合1不同于集合2的元素 set1 = {1,2,3} set2 = {1,5,6} set3 = set1.difference(set2) # 更新集合1与集合2不同的元素 set1.difference_update(set2) # 结果set1 = {2,3}，set2不变 # 集合的合并 set3 = set1.union(set2) 字典(dict)字典无序没有索引，只能通过Key值找到对应的value 字典的Key不可重复 字典的Key和value可以为任意数据类型(但Key不可为字典) 与集合类似，因为字典不支持下标索引，所以也不支持while循环，但支持for循环 py # 字典的定义 dict_name = {Key:value,Key:value,Key:value} # 空字典的定义 dict_name = dict() # 找到Key对应的value keyvalue = dict[Key] # 添加或更新元素 dict_name[Key] = value # 有对应的key则更新元素，否则添加新的key及其对应元素 # 删除元素 Item = dict_name.pop(Key) # 清空元素 dict_name.clear() # 获取全部的Key AllKeys = dict_name.keys() # 找到全部Key后遍历字典 for key in AllKeys # todo # 或者直接遍历 for key in dict_name: # todo ","date":"2024-01-14","objectID":"/posts/python/:1:12","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#字符串str"},{"categories":["Tech"],"content":" 数据容器 2024-01-20_13-37 2024-01-20_13-38 数据容器的转换其他数据容器不能转换为字典 py # 将其他数据容器转换为列表 list(tuple_name()) # 字符串转列表会将字符串变为字符再装载进列表，字典转列表只会将Key值放进列表 # 将其他数据容器转换为元组 tuple(dict_name) # 情况与字符串转列表类似 # 将其他数据容器转换为字符串 str(list_name) # 其他数据类型任意转换为字符串 # 将其他数据容器转换为集合 set(str_name) # 情况与字符串转列表类似 列表(list) 2024-01-19_21-28 列表可以存储不同数据类型的元素，并按照一定下标排序，允许重复数据存在 py # 列表的字面量定义 [Item1,Item2,Item3] # 列表内的元素带有下标，可以通过下标索引到元素，索引方向分为从左至右和从右至左两种，下方列表中Item3的下标可以是2，也可以是-1 # 列表的变量定义 list_name = [Item1,Item2,Item3] #定义空列表 list_name = [] list_name = list() 嵌套列表获取元素list_name[0][1] 将函数定义为类中的成员，我们称这种函数叫做方法 py #查询元素 list_name.index(Item1) # 查询Item1的下标，如果找不到则报错ValueError #插入元素 list_name.insert(index，Item2) # 在index处插入Item2 #追加元素 list_name.append(Item3) # 在列表尾部追加append #追加数据容器 list_name.extend(其他数据容器) #在列表尾部追加其他数据容器的元素 #删除元素 element = list_name.pop(index) # 取出index的那个元素并赋值给element，最后在列表中删除 #清空整个列表 list_name.clear() #统计某个元素在列表中的数量 list_name.count(Item4) #统计列表中有多少元素 len(list_name) # 返回值为列表中元素的个数 元组(tuple)元组一旦定义好，内部的元素就不可修改。但如果元组内嵌套了list，则可以修改list的内容，可以将元组视为不可修改元素的list 元组内部数据类型可以不同 py # 定义元组字面量 (Item1，Item2，Item3) # 定义元组变量 tuple_name = (Item1，Item2，Item3) # 定义空元组 tuple_name = tuple() 字符串(str)字符串是一个不可修改的数据容器 py my_str = \"hellow world\" # 字符串的替换 new_str1 = my_str.replace(\"hellow\",\"hello\") # 原字符串不可修改，但得到了一个新的字符串 #字符串的分割 new_str2 = my_str.split(\" \") # 按空格切分字符串，返回一个含有字符串的列表 序列序列是指内容连续，有序，可使用下标索引的一类数据容器 py # 语法 数据容器[start:end:step] # 在数据容器中从start下标开始到end下标结束(不包括end下标)，每隔step-1个元素取出一个数据组成新的序列，步长为负数则代表序列从后向前取 newlist = list_name[::2] 集合(set)集合内元素不能重复且无序，但允许修改 因为集合不支持下标索引，所以不支持while循环，但支持for循环 py # 定义集合字面量 {Item1，Item2，Item3} # 定义集合变量 set_name = {Item1，Item2，Item3} # 定义空集合 set_name = set() # 添加元素 set_name.add(\"Item4\") # 移除元素 set_name.remove(\"Item5\") # 清空集合 set_name.clear() # 随机取元素 set_name.pop(\"Item6\") # 取出集合1不同于集合2的元素 set1 = {1,2,3} set2 = {1,5,6} set3 = set1.difference(set2) # 更新集合1与集合2不同的元素 set1.difference_update(set2) # 结果set1 = {2,3}，set2不变 # 集合的合并 set3 = set1.union(set2) 字典(dict)字典无序没有索引，只能通过Key值找到对应的value 字典的Key不可重复 字典的Key和value可以为任意数据类型(但Key不可为字典) 与集合类似，因为字典不支持下标索引，所以也不支持while循环，但支持for循环 py # 字典的定义 dict_name = {Key:value,Key:value,Key:value} # 空字典的定义 dict_name = dict() # 找到Key对应的value keyvalue = dict[Key] # 添加或更新元素 dict_name[Key] = value # 有对应的key则更新元素，否则添加新的key及其对应元素 # 删除元素 Item = dict_name.pop(Key) # 清空元素 dict_name.clear() # 获取全部的Key AllKeys = dict_name.keys() # 找到全部Key后遍历字典 for key in AllKeys # todo # 或者直接遍历 for key in dict_name: # todo ","date":"2024-01-14","objectID":"/posts/python/:1:12","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#序列"},{"categories":["Tech"],"content":" 数据容器 2024-01-20_13-37 2024-01-20_13-38 数据容器的转换其他数据容器不能转换为字典 py # 将其他数据容器转换为列表 list(tuple_name()) # 字符串转列表会将字符串变为字符再装载进列表，字典转列表只会将Key值放进列表 # 将其他数据容器转换为元组 tuple(dict_name) # 情况与字符串转列表类似 # 将其他数据容器转换为字符串 str(list_name) # 其他数据类型任意转换为字符串 # 将其他数据容器转换为集合 set(str_name) # 情况与字符串转列表类似 列表(list) 2024-01-19_21-28 列表可以存储不同数据类型的元素，并按照一定下标排序，允许重复数据存在 py # 列表的字面量定义 [Item1,Item2,Item3] # 列表内的元素带有下标，可以通过下标索引到元素，索引方向分为从左至右和从右至左两种，下方列表中Item3的下标可以是2，也可以是-1 # 列表的变量定义 list_name = [Item1,Item2,Item3] #定义空列表 list_name = [] list_name = list() 嵌套列表获取元素list_name[0][1] 将函数定义为类中的成员，我们称这种函数叫做方法 py #查询元素 list_name.index(Item1) # 查询Item1的下标，如果找不到则报错ValueError #插入元素 list_name.insert(index，Item2) # 在index处插入Item2 #追加元素 list_name.append(Item3) # 在列表尾部追加append #追加数据容器 list_name.extend(其他数据容器) #在列表尾部追加其他数据容器的元素 #删除元素 element = list_name.pop(index) # 取出index的那个元素并赋值给element，最后在列表中删除 #清空整个列表 list_name.clear() #统计某个元素在列表中的数量 list_name.count(Item4) #统计列表中有多少元素 len(list_name) # 返回值为列表中元素的个数 元组(tuple)元组一旦定义好，内部的元素就不可修改。但如果元组内嵌套了list，则可以修改list的内容，可以将元组视为不可修改元素的list 元组内部数据类型可以不同 py # 定义元组字面量 (Item1，Item2，Item3) # 定义元组变量 tuple_name = (Item1，Item2，Item3) # 定义空元组 tuple_name = tuple() 字符串(str)字符串是一个不可修改的数据容器 py my_str = \"hellow world\" # 字符串的替换 new_str1 = my_str.replace(\"hellow\",\"hello\") # 原字符串不可修改，但得到了一个新的字符串 #字符串的分割 new_str2 = my_str.split(\" \") # 按空格切分字符串，返回一个含有字符串的列表 序列序列是指内容连续，有序，可使用下标索引的一类数据容器 py # 语法 数据容器[start:end:step] # 在数据容器中从start下标开始到end下标结束(不包括end下标)，每隔step-1个元素取出一个数据组成新的序列，步长为负数则代表序列从后向前取 newlist = list_name[::2] 集合(set)集合内元素不能重复且无序，但允许修改 因为集合不支持下标索引，所以不支持while循环，但支持for循环 py # 定义集合字面量 {Item1，Item2，Item3} # 定义集合变量 set_name = {Item1，Item2，Item3} # 定义空集合 set_name = set() # 添加元素 set_name.add(\"Item4\") # 移除元素 set_name.remove(\"Item5\") # 清空集合 set_name.clear() # 随机取元素 set_name.pop(\"Item6\") # 取出集合1不同于集合2的元素 set1 = {1,2,3} set2 = {1,5,6} set3 = set1.difference(set2) # 更新集合1与集合2不同的元素 set1.difference_update(set2) # 结果set1 = {2,3}，set2不变 # 集合的合并 set3 = set1.union(set2) 字典(dict)字典无序没有索引，只能通过Key值找到对应的value 字典的Key不可重复 字典的Key和value可以为任意数据类型(但Key不可为字典) 与集合类似，因为字典不支持下标索引，所以也不支持while循环，但支持for循环 py # 字典的定义 dict_name = {Key:value,Key:value,Key:value} # 空字典的定义 dict_name = dict() # 找到Key对应的value keyvalue = dict[Key] # 添加或更新元素 dict_name[Key] = value # 有对应的key则更新元素，否则添加新的key及其对应元素 # 删除元素 Item = dict_name.pop(Key) # 清空元素 dict_name.clear() # 获取全部的Key AllKeys = dict_name.keys() # 找到全部Key后遍历字典 for key in AllKeys # todo # 或者直接遍历 for key in dict_name: # todo ","date":"2024-01-14","objectID":"/posts/python/:1:12","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#集合set"},{"categories":["Tech"],"content":" 数据容器 2024-01-20_13-37 2024-01-20_13-38 数据容器的转换其他数据容器不能转换为字典 py # 将其他数据容器转换为列表 list(tuple_name()) # 字符串转列表会将字符串变为字符再装载进列表，字典转列表只会将Key值放进列表 # 将其他数据容器转换为元组 tuple(dict_name) # 情况与字符串转列表类似 # 将其他数据容器转换为字符串 str(list_name) # 其他数据类型任意转换为字符串 # 将其他数据容器转换为集合 set(str_name) # 情况与字符串转列表类似 列表(list) 2024-01-19_21-28 列表可以存储不同数据类型的元素，并按照一定下标排序，允许重复数据存在 py # 列表的字面量定义 [Item1,Item2,Item3] # 列表内的元素带有下标，可以通过下标索引到元素，索引方向分为从左至右和从右至左两种，下方列表中Item3的下标可以是2，也可以是-1 # 列表的变量定义 list_name = [Item1,Item2,Item3] #定义空列表 list_name = [] list_name = list() 嵌套列表获取元素list_name[0][1] 将函数定义为类中的成员，我们称这种函数叫做方法 py #查询元素 list_name.index(Item1) # 查询Item1的下标，如果找不到则报错ValueError #插入元素 list_name.insert(index，Item2) # 在index处插入Item2 #追加元素 list_name.append(Item3) # 在列表尾部追加append #追加数据容器 list_name.extend(其他数据容器) #在列表尾部追加其他数据容器的元素 #删除元素 element = list_name.pop(index) # 取出index的那个元素并赋值给element，最后在列表中删除 #清空整个列表 list_name.clear() #统计某个元素在列表中的数量 list_name.count(Item4) #统计列表中有多少元素 len(list_name) # 返回值为列表中元素的个数 元组(tuple)元组一旦定义好，内部的元素就不可修改。但如果元组内嵌套了list，则可以修改list的内容，可以将元组视为不可修改元素的list 元组内部数据类型可以不同 py # 定义元组字面量 (Item1，Item2，Item3) # 定义元组变量 tuple_name = (Item1，Item2，Item3) # 定义空元组 tuple_name = tuple() 字符串(str)字符串是一个不可修改的数据容器 py my_str = \"hellow world\" # 字符串的替换 new_str1 = my_str.replace(\"hellow\",\"hello\") # 原字符串不可修改，但得到了一个新的字符串 #字符串的分割 new_str2 = my_str.split(\" \") # 按空格切分字符串，返回一个含有字符串的列表 序列序列是指内容连续，有序，可使用下标索引的一类数据容器 py # 语法 数据容器[start:end:step] # 在数据容器中从start下标开始到end下标结束(不包括end下标)，每隔step-1个元素取出一个数据组成新的序列，步长为负数则代表序列从后向前取 newlist = list_name[::2] 集合(set)集合内元素不能重复且无序，但允许修改 因为集合不支持下标索引，所以不支持while循环，但支持for循环 py # 定义集合字面量 {Item1，Item2，Item3} # 定义集合变量 set_name = {Item1，Item2，Item3} # 定义空集合 set_name = set() # 添加元素 set_name.add(\"Item4\") # 移除元素 set_name.remove(\"Item5\") # 清空集合 set_name.clear() # 随机取元素 set_name.pop(\"Item6\") # 取出集合1不同于集合2的元素 set1 = {1,2,3} set2 = {1,5,6} set3 = set1.difference(set2) # 更新集合1与集合2不同的元素 set1.difference_update(set2) # 结果set1 = {2,3}，set2不变 # 集合的合并 set3 = set1.union(set2) 字典(dict)字典无序没有索引，只能通过Key值找到对应的value 字典的Key不可重复 字典的Key和value可以为任意数据类型(但Key不可为字典) 与集合类似，因为字典不支持下标索引，所以也不支持while循环，但支持for循环 py # 字典的定义 dict_name = {Key:value,Key:value,Key:value} # 空字典的定义 dict_name = dict() # 找到Key对应的value keyvalue = dict[Key] # 添加或更新元素 dict_name[Key] = value # 有对应的key则更新元素，否则添加新的key及其对应元素 # 删除元素 Item = dict_name.pop(Key) # 清空元素 dict_name.clear() # 获取全部的Key AllKeys = dict_name.keys() # 找到全部Key后遍历字典 for key in AllKeys # todo # 或者直接遍历 for key in dict_name: # todo ","date":"2024-01-14","objectID":"/posts/python/:1:12","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#字典dict"},{"categories":["Tech"],"content":" 函数进阶 多返回值函数 py def fun_name(): return 1,2 x,y = fun_name() 函数参数种类： 位置参数 fun_name(“小明”,10,“男”) 关键字参数 fun_name(name = “小明”,gender = “男”,age = 10)，顺序可以调换，但与位置参数混用时，需要放在位置参数后面 缺省参数 函数定义时在参数列表中给参数赋值即可指定缺省参数，设置缺省参数时，设置的参数要放在参数列表最后，否则会报错 不定长参数 位置参数的形式：fun_name(*args)，传参示例：10，20，30会将传进去的参数合并成一个元组 关键字传递的形式：fun_name(**kwargs)，传参示例：age = 10，gender = male会将传进去的参数合并成一个字典 kwargs(key word args) lambda函数lambda函数是一种临时函数，使用一次后就被销毁了，下次使用只能再次重写lambda函数并且lambda函数只能写一行 lambda函数语法：lambda 参数 : 函数体 py def test_fun(compete): result = compete(1,2) return result def compete(x,y): return x + y test_fun(compete) #############与下列lambda函数相同################# def test_fun(compete): result = compete(1,2) return result test_fun(lambda x, y: x + y) ","date":"2024-01-14","objectID":"/posts/python/:1:13","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#函数进阶"},{"categories":["Tech"],"content":" 函数进阶 多返回值函数 py def fun_name(): return 1,2 x,y = fun_name() 函数参数种类： 位置参数 fun_name(“小明”,10,“男”) 关键字参数 fun_name(name = “小明”,gender = “男”,age = 10)，顺序可以调换，但与位置参数混用时，需要放在位置参数后面 缺省参数 函数定义时在参数列表中给参数赋值即可指定缺省参数，设置缺省参数时，设置的参数要放在参数列表最后，否则会报错 不定长参数 位置参数的形式：fun_name(*args)，传参示例：10，20，30会将传进去的参数合并成一个元组 关键字传递的形式：fun_name(**kwargs)，传参示例：age = 10，gender = male会将传进去的参数合并成一个字典 kwargs(key word args) lambda函数lambda函数是一种临时函数，使用一次后就被销毁了，下次使用只能再次重写lambda函数并且lambda函数只能写一行 lambda函数语法：lambda 参数 : 函数体 py def test_fun(compete): result = compete(1,2) return result def compete(x,y): return x + y test_fun(compete) #############与下列lambda函数相同################# def test_fun(compete): result = compete(1,2) return result test_fun(lambda x, y: x + y) ","date":"2024-01-14","objectID":"/posts/python/:1:13","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#多返回值函数"},{"categories":["Tech"],"content":" 函数进阶 多返回值函数 py def fun_name(): return 1,2 x,y = fun_name() 函数参数种类： 位置参数 fun_name(“小明”,10,“男”) 关键字参数 fun_name(name = “小明”,gender = “男”,age = 10)，顺序可以调换，但与位置参数混用时，需要放在位置参数后面 缺省参数 函数定义时在参数列表中给参数赋值即可指定缺省参数，设置缺省参数时，设置的参数要放在参数列表最后，否则会报错 不定长参数 位置参数的形式：fun_name(*args)，传参示例：10，20，30会将传进去的参数合并成一个元组 关键字传递的形式：fun_name(**kwargs)，传参示例：age = 10，gender = male会将传进去的参数合并成一个字典 kwargs(key word args) lambda函数lambda函数是一种临时函数，使用一次后就被销毁了，下次使用只能再次重写lambda函数并且lambda函数只能写一行 lambda函数语法：lambda 参数 : 函数体 py def test_fun(compete): result = compete(1,2) return result def compete(x,y): return x + y test_fun(compete) #############与下列lambda函数相同################# def test_fun(compete): result = compete(1,2) return result test_fun(lambda x, y: x + y) ","date":"2024-01-14","objectID":"/posts/python/:1:13","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#lambda函数"},{"categories":["Tech"],"content":" 异常 异常的捕获 py try： 可能发生异常的代码 except： 处理异常的代码 #######################例子如下######################### # 捕获到读取文件异常后(即文件不存在)，就以写的方式创建文件 try: f = open(\"linux.txt\",'r') execept: # execept可以后加异常名称，这样就会接受指定异常，例如 execept (NameError，ZeroDivisionError) as object:，默认情况则捕获所有异常并命名为 object，或者可以写为execept Exeception:，这也是捕获所有异常的写法 f = open(\"linux.txt\",'w') else: # 没有异常则执行的代码 # todo finally: #无论是否出现异常都执行的代码 # todo 异常的传递异常可以根据函数调用呈现传递性 2024-01-20_16-31 ","date":"2024-01-14","objectID":"/posts/python/:1:14","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#异常"},{"categories":["Tech"],"content":" 异常 异常的捕获 py try： 可能发生异常的代码 except： 处理异常的代码 #######################例子如下######################### # 捕获到读取文件异常后(即文件不存在)，就以写的方式创建文件 try: f = open(\"linux.txt\",'r') execept: # execept可以后加异常名称，这样就会接受指定异常，例如 execept (NameError，ZeroDivisionError) as object:，默认情况则捕获所有异常并命名为 object，或者可以写为execept Exeception:，这也是捕获所有异常的写法 f = open(\"linux.txt\",'w') else: # 没有异常则执行的代码 # todo finally: #无论是否出现异常都执行的代码 # todo 异常的传递异常可以根据函数调用呈现传递性 2024-01-20_16-31 ","date":"2024-01-14","objectID":"/posts/python/:1:14","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#异常的捕获"},{"categories":["Tech"],"content":" 异常 异常的捕获 py try： 可能发生异常的代码 except： 处理异常的代码 #######################例子如下######################### # 捕获到读取文件异常后(即文件不存在)，就以写的方式创建文件 try: f = open(\"linux.txt\",'r') execept: # execept可以后加异常名称，这样就会接受指定异常，例如 execept (NameError，ZeroDivisionError) as object:，默认情况则捕获所有异常并命名为 object，或者可以写为execept Exeception:，这也是捕获所有异常的写法 f = open(\"linux.txt\",'w') else: # 没有异常则执行的代码 # todo finally: #无论是否出现异常都执行的代码 # todo 异常的传递异常可以根据函数调用呈现传递性 2024-01-20_16-31 ","date":"2024-01-14","objectID":"/posts/python/:1:14","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#异常的传递"},{"categories":["Tech"],"content":" 模块模块就是一个python文件，可以将模块视作功能包 不同的模块，相同名称的功能，后导入进来的会覆盖先导入进来的 []代表参数可选 py # 只使用import会将模块中所有内容全部导入，而使用from则会将模块中的某一部分导入 # 例如 from time import sleep 使用方法：sleep # 若 import time 使用方法： time.sleep [from 模块名] import [模块 | 类 | 方法 | *] [as 别名] from package import * ：立即将包的所有内容导入内存(立即加载)，并且可以直接只用包内的方法而不必加作用域，使用时可以直接调用func而不必写为package.func import package ：只有使用到具体方法时，才将该方法的所有内容导入内存(惰性加载)，并且必须加作用域，使用时必须写为package.func 这两种调用包的方法都会查找__init__.py的内容，并将该文件内除了子模块的内容导入到文件中 ","date":"2024-01-14","objectID":"/posts/python/:1:15","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#模块"},{"categories":["Tech"],"content":" 包python包 = __init__.py文件 + 若干模块文件 可以在 __init__.py文件内添加 __all__ = [“模块名”]来定义 from package import * 的导入范围 2024-01-20_17-33 ","date":"2024-01-14","objectID":"/posts/python/:1:16","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#包"},{"categories":["Tech"],"content":" 面向对象 类的定义 py class 类名称: 成员变量 成员方法(函数) # 定义类的方法时与普通的函数定义有细微差别，需要在形参列表最前方加入self关键字 # 在成员方法内部调用或赋值成员变量需要用到self.来引出 def add(self,para1,para2): # todo # 创建类的对象 object = class_name() 构造方法构造方法需要使用__init__()方法，与C++构造函数类似，即使不给出__init__()方法，系统也会自动调用 类进行初始化的时候会首先调用__init__()方法，这个函数可以初始化类的成员变量 py class student: name = None age = None tel = None def __init__(self,name,age,tel) self.name = name self.age = age self.tel = tel 魔术方法python中，由两个下划线前后包围起来的方法称为魔术方法 定义__str__方法后，以后将类转换为字符串就会输出__str__方法中的内容 __lt__，__le__，__eq__是比较两个类大小的魔术方法，由于两个类不能比较，所以需要在这三种方法内部重写比较方法，一般比较的是两个类中成员的大小 封装在成员或者方法名称前加两个下划线即可将成员或方法变为私有 py class student: name = None __age = 18 # 私有成员 tel = None def __print_tel(self): # 私有方法 print(f\"self.tel\") 继承class 类名(父类名): 类的内容 想要继承多个父类时使用： class 类名(父类1,父类2,父类3): 类的内容 如果只想继承若干个父类，而不想写类的内容，可以使用pass关键字，以补全类的内容 class 类名(父类1,父类2,父类3): pass 当父类1与父类2中有同名的成员变量或成员方法时，优先继承父类1的内容，遵循先来后到原则 py class student: name = None age = None tel = None class Newstu(student): # 继承 gender = None 当需要对父类的成员变量或者成员方法进行改动时，可以在子类中重新定义，以达到复写的效果 py class student: name = None age = 18 tel = None class Newstu(student): age = 80 多态多态：同一个函数，使用不同的对象，产生不同的结果 通过多子类父类以及继承方式可以实现多态，例如 定义空调父类，定义空调的制冷方法 定义格力空调，美的空调子类，并在其内部重写制冷方法 实现通用制冷函数，可以调用传进来的类的方法 在制冷函数内传入美的或者格力空调子类，这样就实现了多态现象 此时父类称为抽象类或接口，只做大体框架或者顶层实现 2024-01-21_14-40 ","date":"2024-01-14","objectID":"/posts/python/:1:17","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#面向对象"},{"categories":["Tech"],"content":" 面向对象 类的定义 py class 类名称: 成员变量 成员方法(函数) # 定义类的方法时与普通的函数定义有细微差别，需要在形参列表最前方加入self关键字 # 在成员方法内部调用或赋值成员变量需要用到self.来引出 def add(self,para1,para2): # todo # 创建类的对象 object = class_name() 构造方法构造方法需要使用__init__()方法，与C++构造函数类似，即使不给出__init__()方法，系统也会自动调用 类进行初始化的时候会首先调用__init__()方法，这个函数可以初始化类的成员变量 py class student: name = None age = None tel = None def __init__(self,name,age,tel) self.name = name self.age = age self.tel = tel 魔术方法python中，由两个下划线前后包围起来的方法称为魔术方法 定义__str__方法后，以后将类转换为字符串就会输出__str__方法中的内容 __lt__，__le__，__eq__是比较两个类大小的魔术方法，由于两个类不能比较，所以需要在这三种方法内部重写比较方法，一般比较的是两个类中成员的大小 封装在成员或者方法名称前加两个下划线即可将成员或方法变为私有 py class student: name = None __age = 18 # 私有成员 tel = None def __print_tel(self): # 私有方法 print(f\"self.tel\") 继承class 类名(父类名): 类的内容 想要继承多个父类时使用： class 类名(父类1,父类2,父类3): 类的内容 如果只想继承若干个父类，而不想写类的内容，可以使用pass关键字，以补全类的内容 class 类名(父类1,父类2,父类3): pass 当父类1与父类2中有同名的成员变量或成员方法时，优先继承父类1的内容，遵循先来后到原则 py class student: name = None age = None tel = None class Newstu(student): # 继承 gender = None 当需要对父类的成员变量或者成员方法进行改动时，可以在子类中重新定义，以达到复写的效果 py class student: name = None age = 18 tel = None class Newstu(student): age = 80 多态多态：同一个函数，使用不同的对象，产生不同的结果 通过多子类父类以及继承方式可以实现多态，例如 定义空调父类，定义空调的制冷方法 定义格力空调，美的空调子类，并在其内部重写制冷方法 实现通用制冷函数，可以调用传进来的类的方法 在制冷函数内传入美的或者格力空调子类，这样就实现了多态现象 此时父类称为抽象类或接口，只做大体框架或者顶层实现 2024-01-21_14-40 ","date":"2024-01-14","objectID":"/posts/python/:1:17","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#类的定义"},{"categories":["Tech"],"content":" 面向对象 类的定义 py class 类名称: 成员变量 成员方法(函数) # 定义类的方法时与普通的函数定义有细微差别，需要在形参列表最前方加入self关键字 # 在成员方法内部调用或赋值成员变量需要用到self.来引出 def add(self,para1,para2): # todo # 创建类的对象 object = class_name() 构造方法构造方法需要使用__init__()方法，与C++构造函数类似，即使不给出__init__()方法，系统也会自动调用 类进行初始化的时候会首先调用__init__()方法，这个函数可以初始化类的成员变量 py class student: name = None age = None tel = None def __init__(self,name,age,tel) self.name = name self.age = age self.tel = tel 魔术方法python中，由两个下划线前后包围起来的方法称为魔术方法 定义__str__方法后，以后将类转换为字符串就会输出__str__方法中的内容 __lt__，__le__，__eq__是比较两个类大小的魔术方法，由于两个类不能比较，所以需要在这三种方法内部重写比较方法，一般比较的是两个类中成员的大小 封装在成员或者方法名称前加两个下划线即可将成员或方法变为私有 py class student: name = None __age = 18 # 私有成员 tel = None def __print_tel(self): # 私有方法 print(f\"self.tel\") 继承class 类名(父类名): 类的内容 想要继承多个父类时使用： class 类名(父类1,父类2,父类3): 类的内容 如果只想继承若干个父类，而不想写类的内容，可以使用pass关键字，以补全类的内容 class 类名(父类1,父类2,父类3): pass 当父类1与父类2中有同名的成员变量或成员方法时，优先继承父类1的内容，遵循先来后到原则 py class student: name = None age = None tel = None class Newstu(student): # 继承 gender = None 当需要对父类的成员变量或者成员方法进行改动时，可以在子类中重新定义，以达到复写的效果 py class student: name = None age = 18 tel = None class Newstu(student): age = 80 多态多态：同一个函数，使用不同的对象，产生不同的结果 通过多子类父类以及继承方式可以实现多态，例如 定义空调父类，定义空调的制冷方法 定义格力空调，美的空调子类，并在其内部重写制冷方法 实现通用制冷函数，可以调用传进来的类的方法 在制冷函数内传入美的或者格力空调子类，这样就实现了多态现象 此时父类称为抽象类或接口，只做大体框架或者顶层实现 2024-01-21_14-40 ","date":"2024-01-14","objectID":"/posts/python/:1:17","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#构造方法"},{"categories":["Tech"],"content":" 面向对象 类的定义 py class 类名称: 成员变量 成员方法(函数) # 定义类的方法时与普通的函数定义有细微差别，需要在形参列表最前方加入self关键字 # 在成员方法内部调用或赋值成员变量需要用到self.来引出 def add(self,para1,para2): # todo # 创建类的对象 object = class_name() 构造方法构造方法需要使用__init__()方法，与C++构造函数类似，即使不给出__init__()方法，系统也会自动调用 类进行初始化的时候会首先调用__init__()方法，这个函数可以初始化类的成员变量 py class student: name = None age = None tel = None def __init__(self,name,age,tel) self.name = name self.age = age self.tel = tel 魔术方法python中，由两个下划线前后包围起来的方法称为魔术方法 定义__str__方法后，以后将类转换为字符串就会输出__str__方法中的内容 __lt__，__le__，__eq__是比较两个类大小的魔术方法，由于两个类不能比较，所以需要在这三种方法内部重写比较方法，一般比较的是两个类中成员的大小 封装在成员或者方法名称前加两个下划线即可将成员或方法变为私有 py class student: name = None __age = 18 # 私有成员 tel = None def __print_tel(self): # 私有方法 print(f\"self.tel\") 继承class 类名(父类名): 类的内容 想要继承多个父类时使用： class 类名(父类1,父类2,父类3): 类的内容 如果只想继承若干个父类，而不想写类的内容，可以使用pass关键字，以补全类的内容 class 类名(父类1,父类2,父类3): pass 当父类1与父类2中有同名的成员变量或成员方法时，优先继承父类1的内容，遵循先来后到原则 py class student: name = None age = None tel = None class Newstu(student): # 继承 gender = None 当需要对父类的成员变量或者成员方法进行改动时，可以在子类中重新定义，以达到复写的效果 py class student: name = None age = 18 tel = None class Newstu(student): age = 80 多态多态：同一个函数，使用不同的对象，产生不同的结果 通过多子类父类以及继承方式可以实现多态，例如 定义空调父类，定义空调的制冷方法 定义格力空调，美的空调子类，并在其内部重写制冷方法 实现通用制冷函数，可以调用传进来的类的方法 在制冷函数内传入美的或者格力空调子类，这样就实现了多态现象 此时父类称为抽象类或接口，只做大体框架或者顶层实现 2024-01-21_14-40 ","date":"2024-01-14","objectID":"/posts/python/:1:17","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#魔术方法"},{"categories":["Tech"],"content":" 面向对象 类的定义 py class 类名称: 成员变量 成员方法(函数) # 定义类的方法时与普通的函数定义有细微差别，需要在形参列表最前方加入self关键字 # 在成员方法内部调用或赋值成员变量需要用到self.来引出 def add(self,para1,para2): # todo # 创建类的对象 object = class_name() 构造方法构造方法需要使用__init__()方法，与C++构造函数类似，即使不给出__init__()方法，系统也会自动调用 类进行初始化的时候会首先调用__init__()方法，这个函数可以初始化类的成员变量 py class student: name = None age = None tel = None def __init__(self,name,age,tel) self.name = name self.age = age self.tel = tel 魔术方法python中，由两个下划线前后包围起来的方法称为魔术方法 定义__str__方法后，以后将类转换为字符串就会输出__str__方法中的内容 __lt__，__le__，__eq__是比较两个类大小的魔术方法，由于两个类不能比较，所以需要在这三种方法内部重写比较方法，一般比较的是两个类中成员的大小 封装在成员或者方法名称前加两个下划线即可将成员或方法变为私有 py class student: name = None __age = 18 # 私有成员 tel = None def __print_tel(self): # 私有方法 print(f\"self.tel\") 继承class 类名(父类名): 类的内容 想要继承多个父类时使用： class 类名(父类1,父类2,父类3): 类的内容 如果只想继承若干个父类，而不想写类的内容，可以使用pass关键字，以补全类的内容 class 类名(父类1,父类2,父类3): pass 当父类1与父类2中有同名的成员变量或成员方法时，优先继承父类1的内容，遵循先来后到原则 py class student: name = None age = None tel = None class Newstu(student): # 继承 gender = None 当需要对父类的成员变量或者成员方法进行改动时，可以在子类中重新定义，以达到复写的效果 py class student: name = None age = 18 tel = None class Newstu(student): age = 80 多态多态：同一个函数，使用不同的对象，产生不同的结果 通过多子类父类以及继承方式可以实现多态，例如 定义空调父类，定义空调的制冷方法 定义格力空调，美的空调子类，并在其内部重写制冷方法 实现通用制冷函数，可以调用传进来的类的方法 在制冷函数内传入美的或者格力空调子类，这样就实现了多态现象 此时父类称为抽象类或接口，只做大体框架或者顶层实现 2024-01-21_14-40 ","date":"2024-01-14","objectID":"/posts/python/:1:17","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#封装"},{"categories":["Tech"],"content":" 面向对象 类的定义 py class 类名称: 成员变量 成员方法(函数) # 定义类的方法时与普通的函数定义有细微差别，需要在形参列表最前方加入self关键字 # 在成员方法内部调用或赋值成员变量需要用到self.来引出 def add(self,para1,para2): # todo # 创建类的对象 object = class_name() 构造方法构造方法需要使用__init__()方法，与C++构造函数类似，即使不给出__init__()方法，系统也会自动调用 类进行初始化的时候会首先调用__init__()方法，这个函数可以初始化类的成员变量 py class student: name = None age = None tel = None def __init__(self,name,age,tel) self.name = name self.age = age self.tel = tel 魔术方法python中，由两个下划线前后包围起来的方法称为魔术方法 定义__str__方法后，以后将类转换为字符串就会输出__str__方法中的内容 __lt__，__le__，__eq__是比较两个类大小的魔术方法，由于两个类不能比较，所以需要在这三种方法内部重写比较方法，一般比较的是两个类中成员的大小 封装在成员或者方法名称前加两个下划线即可将成员或方法变为私有 py class student: name = None __age = 18 # 私有成员 tel = None def __print_tel(self): # 私有方法 print(f\"self.tel\") 继承class 类名(父类名): 类的内容 想要继承多个父类时使用： class 类名(父类1,父类2,父类3): 类的内容 如果只想继承若干个父类，而不想写类的内容，可以使用pass关键字，以补全类的内容 class 类名(父类1,父类2,父类3): pass 当父类1与父类2中有同名的成员变量或成员方法时，优先继承父类1的内容，遵循先来后到原则 py class student: name = None age = None tel = None class Newstu(student): # 继承 gender = None 当需要对父类的成员变量或者成员方法进行改动时，可以在子类中重新定义，以达到复写的效果 py class student: name = None age = 18 tel = None class Newstu(student): age = 80 多态多态：同一个函数，使用不同的对象，产生不同的结果 通过多子类父类以及继承方式可以实现多态，例如 定义空调父类，定义空调的制冷方法 定义格力空调，美的空调子类，并在其内部重写制冷方法 实现通用制冷函数，可以调用传进来的类的方法 在制冷函数内传入美的或者格力空调子类，这样就实现了多态现象 此时父类称为抽象类或接口，只做大体框架或者顶层实现 2024-01-21_14-40 ","date":"2024-01-14","objectID":"/posts/python/:1:17","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#继承"},{"categories":["Tech"],"content":" 面向对象 类的定义 py class 类名称: 成员变量 成员方法(函数) # 定义类的方法时与普通的函数定义有细微差别，需要在形参列表最前方加入self关键字 # 在成员方法内部调用或赋值成员变量需要用到self.来引出 def add(self,para1,para2): # todo # 创建类的对象 object = class_name() 构造方法构造方法需要使用__init__()方法，与C++构造函数类似，即使不给出__init__()方法，系统也会自动调用 类进行初始化的时候会首先调用__init__()方法，这个函数可以初始化类的成员变量 py class student: name = None age = None tel = None def __init__(self,name,age,tel) self.name = name self.age = age self.tel = tel 魔术方法python中，由两个下划线前后包围起来的方法称为魔术方法 定义__str__方法后，以后将类转换为字符串就会输出__str__方法中的内容 __lt__，__le__，__eq__是比较两个类大小的魔术方法，由于两个类不能比较，所以需要在这三种方法内部重写比较方法，一般比较的是两个类中成员的大小 封装在成员或者方法名称前加两个下划线即可将成员或方法变为私有 py class student: name = None __age = 18 # 私有成员 tel = None def __print_tel(self): # 私有方法 print(f\"self.tel\") 继承class 类名(父类名): 类的内容 想要继承多个父类时使用： class 类名(父类1,父类2,父类3): 类的内容 如果只想继承若干个父类，而不想写类的内容，可以使用pass关键字，以补全类的内容 class 类名(父类1,父类2,父类3): pass 当父类1与父类2中有同名的成员变量或成员方法时，优先继承父类1的内容，遵循先来后到原则 py class student: name = None age = None tel = None class Newstu(student): # 继承 gender = None 当需要对父类的成员变量或者成员方法进行改动时，可以在子类中重新定义，以达到复写的效果 py class student: name = None age = 18 tel = None class Newstu(student): age = 80 多态多态：同一个函数，使用不同的对象，产生不同的结果 通过多子类父类以及继承方式可以实现多态，例如 定义空调父类，定义空调的制冷方法 定义格力空调，美的空调子类，并在其内部重写制冷方法 实现通用制冷函数，可以调用传进来的类的方法 在制冷函数内传入美的或者格力空调子类，这样就实现了多态现象 此时父类称为抽象类或接口，只做大体框架或者顶层实现 2024-01-21_14-40 ","date":"2024-01-14","objectID":"/posts/python/:1:17","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#多态"},{"categories":["Tech"],"content":" 闭包闭包的好处是可以将外层函数的变量置于函数内部，这样可以防止其他函数或操作修改外层函数的变量，使程序更安全。但同时内部函数会持续引用外部函数的值，增大了内存的开销 py def outer(add): def inner(name): print(f\"\u003c{add}\u003e{name}\u003c{add}\u003e\") # 如果想要修改add的值，只需要在add前加nonlocal关键字修饰即可 return inner fn1 = outer(\"海城\") # 按正常的操作，需要定义一个海城的全局变量来传参，但是这样做全局变量有被其他函数修改的风险，使用了闭包后则不会修改这个变量 fn1(\"李政轩\") 2024-01-21_14-53 ","date":"2024-01-14","objectID":"/posts/python/:1:18","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#闭包"},{"categories":["Tech"],"content":" 装饰器装饰器是闭包的一种特殊用法，他将闭包中的全局变量改为函数，可以增加原函数的功能，并支持语法糖 py #############普通的装饰器########## def outer(fun): def inner(): print(\"海城\") fun() print(\"李政轩\") return inner def fun1(): print(\"四中\") fn = outer(fun1) fn() #############带语法糖的装饰器########### def outer(fun): def inner(): print(\"海城\") fun() print(\"李政轩\") return inner @outer # 跟随outer函数名称改变而改变 def fun1(): print(\"四中\") fun1() # 调用的是fun1，而不是outer，这样适合对原函数增加功能后继续调用 ","date":"2024-01-14","objectID":"/posts/python/:1:19","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#装饰器"},{"categories":["Tech"],"content":" 迭代器迭代是 Python 最强大的功能之一，是访问集合元素的一种方式 迭代器是一个可以记住遍历的位置的对象 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能前进不能后退 py #!/usr/bin/python3 list_name=[1,2,3,4] it = iter(list_name) # 创建迭代器对象 for x in it: print (x, end=\" \") 输出结果： py 1 2 3 4 把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与 __next__() __iter__() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 __next__() 方法并通过 StopIteration 异常标识迭代的完成 __next__() 方法（Python 2 里是 next()）会返回下一个迭代器对象 py class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): x = self.a self.a += 1 return x myclass = MyNumbers() myiter = iter(myclass) print(next(myiter)) print(next(myiter)) print(next(myiter)) print(next(myiter)) print(next(myiter)) 输出结果： py 1 2 3 4 5 ","date":"2024-01-14","objectID":"/posts/python/:1:20","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#迭代器"},{"categories":["Tech"],"content":" 生成器在 Python 中，使用了 yield 的函数被称为生成器（generator），生成器函数是一种特殊的函数，可以在迭代过程中逐步产生值(惰性加载)，而不是一次性返回所有结果。因此，生成器是一个返回迭代器的函数，只能用于迭代操作。生成器实际上就是一个迭代器 当在生成器函数中使用 yield 语句时，函数的执行将会暂停，并将 yield 修饰的表达式作为当前迭代的值返回。然后，每次调用生成器的 next() 方法或使用 for 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 yield 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。这样可以不必一次生成大量数据，从而节省内存空间 py def countdown(n): while n \u003e 0: yield n n -= 1 # 创建生成器对象 generator = countdown(5) # 通过迭代生成器获取值 print(next(generator)) # 输出: 5 print(next(generator)) # 输出: 4 print(next(generator)) # 输出: 3 # 使用 for 循环迭代生成器 for value in generator: print(value) # 输出: 2 1 生成器实现fibonacci数列 py #!/usr/bin/python3 import sys def fibonacci(n): # 生成器函数 - 斐波那契 a, b, counter = 0, 1, 0 while True: if (counter \u003e n): return yield a a, b = b, a + b counter += 1 f = fibonacci(10) # f 是一个迭代器，由生成器返回生成 while True: try: print (next(f), end=\" \") # 不可写成print (next(fibonacci(10)), end=\" \")，这会导致每次循环都创建一个迭代器，最终导致无限循环 except StopIteration: sys.exit() 输出结果： py 0 1 1 2 3 5 8 13 21 34 55 ","date":"2024-01-14","objectID":"/posts/python/:1:21","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#生成器"},{"categories":["Tech"],"content":" 设计模式 单例模式类的实例化只进行一次，以后均使用这个实例化的类，这样可以节省内存，多用于工具类的创建 工厂模式将杂散的对象由某个类统一创建，这样可以方便统一管理杂散的数据，并且当其中的数据进行重新赋值时，只进行类内部重新赋值即可而不需要找到每处实例化的对象 ","date":"2024-01-14","objectID":"/posts/python/:1:22","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#设计模式"},{"categories":["Tech"],"content":" 设计模式 单例模式类的实例化只进行一次，以后均使用这个实例化的类，这样可以节省内存，多用于工具类的创建 工厂模式将杂散的对象由某个类统一创建，这样可以方便统一管理杂散的数据，并且当其中的数据进行重新赋值时，只进行类内部重新赋值即可而不需要找到每处实例化的对象 ","date":"2024-01-14","objectID":"/posts/python/:1:22","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#单例模式"},{"categories":["Tech"],"content":" 设计模式 单例模式类的实例化只进行一次，以后均使用这个实例化的类，这样可以节省内存，多用于工具类的创建 工厂模式将杂散的对象由某个类统一创建，这样可以方便统一管理杂散的数据，并且当其中的数据进行重新赋值时，只进行类内部重新赋值即可而不需要找到每处实例化的对象 ","date":"2024-01-14","objectID":"/posts/python/:1:22","series":null,"tags":["Programing Language","Tech"],"title":"Python","uri":"/posts/python/#工厂模式"},{"categories":["Tech"],"content":"本文介绍了Git，GDB，Makefile，CMake四种C/C++编程中常用的工具链，还涉及一点GCC制作库文件的内容 ","date":"2024-01-02","objectID":"/posts/toolchains/:0:0","series":null,"tags":["Tech","Tools"],"title":"工具链","uri":"/posts/toolchains/#"},{"categories":["Tech"],"content":" 工具链","date":"2024-01-02","objectID":"/posts/toolchains/:0:0","series":null,"tags":["Tech","Tools"],"title":"工具链","uri":"/posts/toolchains/#工具链"},{"categories":["Tech"],"content":" Git","date":"2024-01-02","objectID":"/posts/toolchains/:1:0","series":null,"tags":["Tech","Tools"],"title":"工具链","uri":"/posts/toolchains/#git"},{"categories":["Tech"],"content":" Git本地操作版本控制系统分为2种 集中式版本控制系统 如SVN 分布式版本控制系统 如Git 相比SVN，Git可靠性高但操作复杂 git git init [dir]//在dir下创建新的本地仓库，缺省则在当前目录创建 /* 全局配置git仓库的用户名，对所有仓库生效，省略则为本地仓库有效 */ git config --global user.name \"用户名\" /* 全局配置git仓库的邮箱，对所有仓库生效，省略则为本地仓库有效 */ git config --global user.email \"邮箱\" /* 保存用户名和密码 */ git config --global credential.helper store /* 查看当前git配置 */ git config --global --list 2024-01-02_15-10 git的数据管理分为三部分 工作区 .git所在目录，正常编辑代码的区域 暂存区 .git/index所在目录，即将提交到git的文件区域 本地仓库 .git/objects所在目录，init生成的文件区域，是git存储代码和版本信息的主要位置 每次修改文件都需要提交很麻烦，因此产生了暂存区，当修改所有文件完毕后再统一提交至本地仓库 2024-01-02_15-15 git /* 将filename文件添加到暂存区内，支持通配符( * . 等) */ git add [filename] /* 查看当前文件状态 */ git status /* 提交，支持通配符 */ git commit -m \"提交说明\" /* 暂存且提交，支持通配符 */ git commit -a -m \"提交说明\" /* 查看提交日志 */ git log /* 查看暂存区文件 */ git ls-files 警告 需要将文件提交到暂存区内才能使用 git commit命令 git /* 将文件撤销所有更改到最后一次提交的状态 */ git checkout -- \u003cfilename\u003e /* 回退到某一版本,保留工作区和暂存区内容 */ git reset --soft [版本id] /* 不保留工作区和暂存区内容 */ git reset --hard /* 仅保留工作区内容 */ git reset [版本id] git reset --mixed /* 恢复git reset --hard的操作 */ git reflog /* 当在一个分支上进行修改而且需要转到另一个分支上时，可能会提示未保存修改，这时需要用到如下命令保存当前分支已修改的文件 */ git stash 使用 –hard 参数需要谨慎考虑，git reset默认执行 –soft命令 git /* 从工作区和暂存区中删除文件 */ git rm [filename] /* 仅在暂存区中删除文件，保留工作区内容 */ git rm --cached [filename] /* 查看工作区和暂存区的不同，如果暂存区内无文件，就比较工作区与最新提交的不同 */ git diff /* 查看暂存区与本地仓库的不同 */ git diff HEAD /* 查看前第n个提交版本与当前提交版本的不同 */ git diff HEAD~[n] HEAD /* 查看前上个提交版本与当前提交版本的不同(^不支持前第n个版本) */ git diff HEAD^ HEAD /* 查看前第n个提交版本与当前提交版本的某个具体文件不同 */ git diff HEAD~[n] HEAD [filename] diff后红色内容表示删除内容，绿色表示增加内容 ","date":"2024-01-02","objectID":"/posts/toolchains/:1:1","series":null,"tags":["Tech","Tools"],"title":"工具链","uri":"/posts/toolchains/#git本地操作"},{"categories":["Tech"],"content":" 常用高级操作下面是git的高级操作 shell /* 从其他分支获取文件，需要在想要获取文件的分支上执行 */ git restore --source \u003cotherbranch\u003e -- \u003cfilename/pathname/blob\u003e /* 我们使用checkout也能达到相同效果，并且会更简单 */ git checkout \u003cotherbranch\u003e -- \u003cfilename/pathname/blob\u003e /* 如果想要查看过去的某一版本又不想使用reset，可以使用checkout来临时查看 */ git checkout \u003ccommit-hash\u003e /* 退出时切换到对应分支即可 */ git checkout \u003cyour-branch\u003e /* 从其他分支获取commit，详见[阮一峰](https://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html) */ git cherry-pick \u003ccommitHash\u003e /* 以交互式方式(-i)打开commit编辑页面，可以编辑的commit数为n */ git rebase -i HEAD~n /* 编辑commit message */ git commit --amend /* 仅在暂存区中删除文件，保留工作区内容。可用于提交了不想提交的文件需要撤销时 */ git rm --cached [filename] ","date":"2024-01-02","objectID":"/posts/toolchains/:1:2","series":null,"tags":["Tech","Tools"],"title":"工具链","uri":"/posts/toolchains/#常用高级操作"},{"categories":["Tech"],"content":" Git远程操作 2024-01-02_18-19 可以配置.gitignore来不想被版本控制的文件，只需将文件或文件夹添加到.gitignore即可，语法支持如上 git /* eg git remote add origin git@github.com:1078249029/toyFreeRTOS.git */ git remote add \u003c远程仓库别名\u003e\u003c远程仓库地址\u003e //仓库别名缺省为origin /* 将本地分支与远程仓库的远程分支联系起来 * eg git push -u(upstream) origin main(远程分支与本地分支重名只写一个即可) */ git push -u \u003c远程仓库名\u003e\u003c远程分支名\u003e \u003c本地分支名\u003e /* 获取远程仓库名，分支名等信息 */ git remote -v /* 拉取远程仓库并自动合并 */ git pull \u003c远程仓库名\u003e\u003c远程分支名\u003e \u003c本地分支名\u003e /* 查看分支列表 */ git branch /* 图形化查看分支图 */ git log --graph --oneline --decorate --all /* 创建分支 */ git branch [branch-name] /* 切换分支 */ git switch [branch-name] /* 合并分支 */ git merge [branch-name] /* 将主分支文件同步到其他分支 */ git merge [主分支名称] //使用前需要切换到其他分支 /* 删除分支 */ git branch -d [branch-name] //删除已合并分支 git branch -D [branch-name] //删除未合并分支 /* 恢复某分支的状态 */ git checkout -b [branch-name] [commit-id] /* 从PR中取消提交某个已提交的文件 */ git switch master //切换到保留这个文件最初状态的分支 git checkout origin/master -- \u003cfilename\u003e //用最初的文件替换掉已提交文件 警告 merge时需要切换到主分支 merge后分支依然存在，除非手动删除分支 2024-01-02_21-52 git /* 当提交的PR被合并后，需要进行以下操作来同步上游仓库 */ /* 设置上游仓库 */ git remote add upstream https://github.com/original-owner/original-repo.git /* 切换到本地主分支并将上游主分支的更改同步到本地主分支，最后同步到远端主分支 */ git switch master git pull upstream master git push origin master /* 切换到本地开发分支上并将本地开发分支变基到本地主分支上，可能会产生冲突 */ git switch dev git rebase master /* 将本地开发分支上的更改同步到远端开发分支上 */ git push origin dev ","date":"2024-01-02","objectID":"/posts/toolchains/:1:3","series":null,"tags":["Tech","Tools"],"title":"工具链","uri":"/posts/toolchains/#git远程操作"},{"categories":["Tech"],"content":" GitFlow适用于团队水平适中的情况 五种分支: main hotfix release develop feature main 包含项目最新的稳定代码 hotfix 用于解决线上问题，从main分离出来 dev 用于开发测试 release 均来源于develop，测试稳定后发布到main，发现bug发布到dev 主要分支包括dev和main ","date":"2024-01-02","objectID":"/posts/toolchains/:1:4","series":null,"tags":["Tech","Tools"],"title":"工具链","uri":"/posts/toolchains/#gitflow"},{"categories":["Tech"],"content":" GitHub Flow适用于团队水平较高的情况 2024-01-03_11-01 整个项目只有两个分支，开发者从Master中branch一个分支用于开发，需要进行merge时发起一个Pull Request请求，待团队审核后再merge到Master ","date":"2024-01-02","objectID":"/posts/toolchains/:1:5","series":null,"tags":["Tech","Tools"],"title":"工具链","uri":"/posts/toolchains/#github-flow"},{"categories":["Tech"],"content":" GitHub配置Github的SSH密钥时，最好把密钥统一放在.ssh文件夹下(win下是C:\\Users\\你的用户名.ssh)，并且写好config文件来管理多份密钥 ","date":"2024-01-02","objectID":"/posts/toolchains/:1:6","series":null,"tags":["Tech","Tools"],"title":"工具链","uri":"/posts/toolchains/#github"},{"categories":["Tech"],"content":" Repo repo是什么？ repo是Google开发的用于管理Android版本库的一个工具，repo是使用Python对git进行了一定的封装，并不是用于取代git，它简化了对多个Git版本库的管理。用repo管理的版本库都需要使用git命令来进行操作。因此，使用repo工具之前，请先确保已经安装git 为什么要用repo？ 项目模块化/组件化之后各模块也作为独立的 Git 仓库从主项目里剥离了出去，各模块各自管理自己的版本。Android源码引用了很多开源项目，每一个子项目都是一个Git仓库，每个Git仓库都有很多分支版本，为了方便统一管理各个子项目的Git仓库，需要一个上层工具批量进行处理，因此repo诞生。 repo用于Android项目管理 ","date":"2024-01-02","objectID":"/posts/toolchains/:1:7","series":null,"tags":["Tech","Tools"],"title":"工具链","uri":"/posts/toolchains/#repo"},{"categories":["Tech"],"content":" Git实战——以RTThread为例为了能够与开发团队保持同步，我们对rtt项目进行fork，需要注意的是在fork时需要选择fork全部分支，这样才能使用长期维护或其他的版本 fork操作仅仅是在github上生成我们自己的仓库，但是本地还没有生成，因此我们需要执行 shell git clone my_github_fork 随后会在我们本地生成一个项目文件夹，我们进入这个rt-thread文件夹内，执行branch命令会发现这里仅有master分支。而远端仓库只有我们fork出来的rtt项目 2024-07-25_12-13 由于我们需要使用的是lts-v4.1.x分支，而这个分支与rtt项目的master分支是同步开发的，因此我们首先需要建立本地仓库与rtt官方仓库的联系，执行 shell git remote add 远程仓库的别名 远程仓库 在这里我们使用upstream作为别名 shell git remote add upstream git@github.com:RT-Thread/rt-thread.git 这样当我们执行git fetch upstream的时候就会与rtt官方仓库保持一致了 下面是建立联系后的样子 2024-07-25_12-16 我们最好还要同步一下分支状态 shell git fetch upstream 2024-07-25_12-22 这里我们就可以正式建立分支了 shell git branch 本地分支名 远程仓库别名/远程分支名 至此，我们的项目就可以进行开发了，之后同步官方仓库的状态可以使用 git fetch upstream，上传到我们自己的仓库使用 git push origin 如果遇到了本地需要新建文件但是该文件不能上传到云端，同时也不能修改.gitignore文件，因为这是项目所有人共有的。这就需要将其添加到exclude文件内了，具体位置在.git/info/exclude，将对应文件的相对项目文件夹的地址(也就是相对.git的地址)写入exclude文件内即可 使用这种方法的前提是新文件从来没有被git追踪，如果文件已经被追踪，可以使用下面的方式 c git update-index --assume-unchanged \u003cpath_to_file\u003e 该命令会忽略对应文件的任何更改，我们也不能对文件进行添加到暂存区和提交的操作。注意这里必须指定具体文件路径，不能指定使用\".“或者正则表达式所涵盖的文件 想要让git再次追踪文件: c git update-index --no-assume-unchanged \u003cpath/to/file\u003e 查看当前文件是否被git忽略 c git ls-files -v 文件前有\"h\"标记的就代表已经被忽略，即hide，带有\"H\"代表没有被被忽略，表示位于Head，带有\"M\"代表已经修改，但未提交，即Modify ","date":"2024-01-02","objectID":"/posts/toolchains/:1:8","series":null,"tags":["Tech","Tools"],"title":"工具链","uri":"/posts/toolchains/#git实战以rtthread为例"},{"categories":["Tech"],"content":" GCCgcc(g++) options -o 指定输出的文件名 -fexec-charset=GBK 指定运行时编码 -finput-charset=UTF-8 指定源文件编码 -fno-omit-frame-pointer 编译时不忽略栈指针寄存器，即保留栈指针寄存器来用于硬件栈回溯 -Wall 输出警告信息 -O(0-3) 指定代码优化等级(0为不优化) -I 指定文件目录来查找头文件(一般为./) -L 指定文件目录来查找库文件(一般为./) -v 输出编译的信息 预处理阶段 (-E，得到.i文件)（巧记：ESC，iso） 处理#include预编译指令，将被包含的文件直接插入到预编译指令的位置 处理所有的条件预编译指令，比如#if，#else，#endif，#ifdef等 预处理器将所有的#define删除，并且展开所有的宏定义 删除所有的注释 添加行号和文件标识，以便编译错误时提供错误或警告的行号 保留所有#pragma编译器指令 shell gcc -E -o hello.i hello.c 编译阶段 (-S，调用cc1程序得到.s文件) 将预处理后的file.i文件进行语法词法分析，翻译成文本文件file.s，里面储存了各种汇编指令 shell gcc -S -o hello.s hello.i 汇编阶段 (-c，调用ar程序得到.o文件，-c代表编译但不链接) 根据编译文件中的汇编码得到二进制机器码文件，生成各个段，生成符号表 shell gcc -c -o hello.o hello.s 链接阶段 (gcc file.o，调用collect2程序) 将链接文件链接到file.o文件中 静态链接：内存开销大，速度快。将所有需要的函数的二进制代码拷贝到可执行文件中去 动态链接：内存开销小，速度慢。不需要将所有需要的函数的二进制代码拷贝到可执行文件中去，而是记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统将这些动态库加载到内存中，然后当程序运行到指定代码时，去共享执行内存中找到已经加载动态库可执行代码，最终达到运行时链接的目的 shell gcc -M hello.c 打印hello.c的依赖 gcc -M -MF hello.d hello.c 输出hello.c的依赖到hello.d文件内 gcc -c -o hello.o hello.c -MD -MF hello.d 编译hello.c并输出依赖到hello.d文件 gcc -I /usr/hello 指定头文件目录 gcc -L /usr/hello 指定库文件目录 gcc -l /usr/hello/libm.so 指定哪个库文件 gcc -T /usr/hello/link.ld -o /usr/hello/hello.elf 指定使用哪个链接脚本生成可执行文件 objcopy hello.elf -O binary hello.bin 使用elf文件通过objcopy生成bin文件 linux-gcc默认最终的输出文件为elf类型，经过编译的.c文件是 .o文件(object，目标文件)，链接后的为.elf文件，但同时也可以指定输出.out文件，这是一种老的可执行文件格式 ","date":"2024-01-02","objectID":"/posts/toolchains/:2:0","series":null,"tags":["Tech","Tools"],"title":"工具链","uri":"/posts/toolchains/#gcc"},{"categories":["Tech"],"content":" GCC制作库文件制作静态库 shell gcc -o hello.o hello.c ar crs libhello.a hello.o 制作动态库 shell gcc -o hello.o hello.c gcc -shared -o libhello.so hello.o ","date":"2024-01-02","objectID":"/posts/toolchains/:2:1","series":null,"tags":["Tech","Tools"],"title":"工具链","uri":"/posts/toolchains/#gcc制作库文件"},{"categories":["Tech"],"content":" GDB shell gcc -g //编译时记录调试信息，否则无法调试 gdb 可执行文件 //调试可执行文件 gdb 可执行文件 core转储文件 //调试含有core转储文件的可执行文件 进入gdb后 回车默认重复上一条命令 r(run) 运行程序 quit 退出调试 l 查看源码 bt(backtrace) 查看调用栈 list 查看源代码及行号 b(break) 行号/函数名 在行号或函数名打断点 info b 查看打断点的位置 delet b 删除断点 n(next) 逐过程调试，但是不进入调用的函数内 s(step) 逐步调试，进入调用的函数内 c(continue) 继续运行 p(print) 表达式 打印变量或地址 watch 表达式 监视表达式的值，一旦变化，调试将会停在对应的行 shell 终端命令 调用终端命令 ","date":"2024-01-02","objectID":"/posts/toolchains/:3:0","series":null,"tags":["Tech","Tools"],"title":"工具链","uri":"/posts/toolchains/#gdb"},{"categories":["Tech"],"content":" Makefile 如何判断哪个文件被更改了？ 比较源文件与输出文件的时间，如果源文件更新的话，那就意味着源文件已经被修改了 makefile #makefile核心：规则 #目标：依赖1 依赖2... #[TAB]命令 #下列目标文件test由a.o b.o链接生成 test:a.o b.o gcc -o test a.o b.o #-c代表编译但不链接 a.o:a.c gcc -c -o a.o a.c b.o:b.c gcc -c -o b.o b.c 通配符： *： 任意字符，但对于目标文件，优先使用%代替* $：取值 @：目标值，@后加shell命令可以不显示命令但输出结果 $@：目标文件 $\u003c：第一个依赖文件 $^：所有依赖文件 $(shell 命令)可以执行shell命令 假想目标文件：.PHONY 用于当目标文件与make命令重名时使用，用法：在makefile文件末尾加上.PHONY: 命令 A = xxx 变量赋值 $(A) 变量取值 = 延时变量，makefile分析完成整个文档后才会对变量赋值，没有类似写程序时顺序执行的逻辑 := 即时变量，类似写程序时的顺序执行的关系，需要在当前行之前声明定义变量 ?= 若在此行之前就已经定义变量，则该语句无效，类似#ifndef += 附加，并不是加，而是根据变量原本状态是延时变量还是即时变量进行相加，是延时变量还是即时变量取决于前文 $(foreach var,list,text) 在list中的每一个var，都换为text $(filter pattern,text) 在text中取出符合pattern的值 $(filter-out pattern,text) 在text中取出不符合pattern的值 $(wildcard pattern) 在已存在的文件中取出符合pattern的值 $(patsubst pattern,replacement,$(var)) 在var中取出符合pattern的值，并替换为replacement CFLAGS 这个变量可以后加gcc的编译选项 ","date":"2024-01-02","objectID":"/posts/toolchains/:4:0","series":null,"tags":["Tech","Tools"],"title":"工具链","uri":"/posts/toolchains/#makefile"},{"categories":["Tech"],"content":" CMake待更新… 2024-03-15_11-43 ","date":"2024-01-02","objectID":"/posts/toolchains/:5:0","series":null,"tags":["Tech","Tools"],"title":"工具链","uri":"/posts/toolchains/#cmake"},{"categories":["Tech"],"content":"参考书籍：《FreeRTOS 内核实现与应用开发实战指南》 一个工程如果没有 main 函数是编译不成功的，因为系统在开始执行的时候首先执行启动文件里面的复位程序，复位程序里面会调用 C 库函数__main，__main 的作用是初始化好系统变量(将.data段从falsh拷贝到ram)，清零未初始化全局变量或静态变量(清.bss段)，设置堆栈等等。__main 最后会调用__rtentry，该函数主要负责初始化标准I/O以及异常处理，但最主要工作是设置入口函数，例如__rtentry 调用 main 函数，从而由汇编跳入到 C 的世界，这里面的 main 函数就需要我们手动编写，如果没有编写 main 函数，就会出现 main 函数没有定义的错误。 __rtentry 函数存在于armcc工具链中(如keil)，而gcc-arm就可能缺失(例如cubeide) ","date":"2024-01-01","objectID":"/posts/program/:0:0","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#"},{"categories":["Tech"],"content":" 项目","date":"2024-01-01","objectID":"/posts/program/:0:0","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#项目"},{"categories":["Tech"],"content":" FreeRTOS内核实现生成的startup_ARMCM3.s负责启动startup_ARMCM3.c负责时钟配置，本项目默认时钟为25M c /*---------------------------------------------------------------------------- Define clocks *----------------------------------------------------------------------------*/ #define XTAL ( 5000000UL) /* Oscillator frequency */ #define SYSTEM_CLOCK (5U * XTAL) 2024-01-02_10-16 对于这种多行宏定义，每行结尾要加 \\ 表示该行未结束 警告 若使用 \\ 表示该行未完结，务必注意 \\ 后不能加任何字符，尤其是空格或者Tab。报错如下 2024-01-02_12-05 2024-01-02_10-44 2024-01-02_11-04 左值不能进行类型转换，类型转换本质上是在寄存器内对原值进行位操作，得到的结果不放入内存，而左值是需要放进内存的，因此类型转换与左值冲突，若要类型转换，则需要对右值进行操作 警告 当一个a.c文件需要b.h，而b.h包含了c.h，且c.h也包含了b.h时，会发生编译冲突。表现为有未定义的类型或变量，详情参考博客园，解决办法是理清编译关系，去除重复包含的头文件 2024-01-03_13-26 栈由高地址向低地址增长，栈顶是第一个进栈的元素，栈底是最后一个进栈的元素 因为32位机的指令一般都是32位的，栈顶指针只需4字节对齐即可，但是考虑兼容浮点运算的64位操作则需要8字节。对齐完成后，栈顶指针即可确定位置，而后开辟空间 2024-01-03_16-01 项目的.c 与 .h文件可以不重名，位置可以不同，例如port.c文件放在\\freertos\\Source\\portable\\RVDS\\ARM_CM3，但是引用port.c内容的portable.h放在\\freertos\\Source\\include c /* 这行代码的意思是定义了TaskFunction_t类型的函数指针，参数和返回值都是void，这样就可以进行函数“赋值”，进而从Task1，Task2中抽象出TaskFunction_t这一类型了，并且使用起来很方便 */ typedef void (*TaskFunction_t)( void * ); /* 类似用法如下 */ void tech(void) { printf(\"tech dreamer\"); } //命名一个类型，那么这个时候func不可以直接调用，而是一个类型了 typedef void (*func)(); void main() { //定义一个可调用的指针变量（函数）：myfunc func myfunc; myfunc = \u0026tech; //\u0026可以不加 /* 下面两种方法体现了函数名和函数地址是一回事 */ myfunc(); //第一种调用方式，带参数也可以 (*myfunc)(); //第二种调用方式，带参数也可以 } ","date":"2024-01-01","objectID":"/posts/program/:1:0","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#freertos内核实现"},{"categories":["Tech"],"content":" 实现就绪链表 c typedef void (*TaskFunction_t)( void * );//将TaskFunction_t函数指针重定义为void*类型 //FreeRTOS中TaskFunction_t内部包含了一个栈顶指针，因此返回值为uint32型 警告 在FreeRTOS里TaskHandle_t是个TCB_t的指针 在toyFreeRTOS里TaskHandle_t是个void*类型的指针，使用时需要类型强转 设置任务栈时栈顶指针的移动 2024-01-13_13-36 2024-01-04_09-41 首先由外部函数prvInitialiseNewTask构造出的pxTopOfStack指针传入pxPortInitialiseStack函数，此时pxTopOfStack指针指向A位置，而后移动指针至B，C点并将xPSR，PC，LR的值依次写入栈顶，方便之后寄存器读取。之后设置R0为传入的参数，最后将指针下移至D并返回，从而使任务得到空闲堆栈的指针 ","date":"2024-01-01","objectID":"/posts/program/:1:1","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#实现就绪链表"},{"categories":["Tech"],"content":" 实现就绪链表 c typedef void (*TaskFunction_t)( void * );//将TaskFunction_t函数指针重定义为void*类型 //FreeRTOS中TaskFunction_t内部包含了一个栈顶指针，因此返回值为uint32型 警告 在FreeRTOS里TaskHandle_t是个TCB_t的指针 在toyFreeRTOS里TaskHandle_t是个void*类型的指针，使用时需要类型强转 设置任务栈时栈顶指针的移动 2024-01-13_13-36 2024-01-04_09-41 首先由外部函数prvInitialiseNewTask构造出的pxTopOfStack指针传入pxPortInitialiseStack函数，此时pxTopOfStack指针指向A位置，而后移动指针至B，C点并将xPSR，PC，LR的值依次写入栈顶，方便之后寄存器读取。之后设置R0为传入的参数，最后将指针下移至D并返回，从而使任务得到空闲堆栈的指针 ","date":"2024-01-01","objectID":"/posts/program/:1:1","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#设置任务栈时栈顶指针的移动"},{"categories":["Tech"],"content":" 实现调度器 2024-01-04_14-42 向量表最前面是MSP的地址 配置寄存器： c /* 对0xe000ed20地址处取值，此处为SHPR3寄存器，设置的是pendsv和systick优先级 */ #define portNVIC_SYSPRI2_REG *(( volatile uint32_t *) 0xe000ed20) /* 配置 PendSV 和 SysTick 的中断优先级为最低 */ portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI; //SHPR3寄存器被设置为 0x**FF **** portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI; //SHPR3寄存器被设置为 0xFFFF **** 开启第一个任务： c /* 通过查找SCB_VTOR最终将__initial_sp处的指令传到msp内，然后调用svc启动第一个任务 */ __asm void prvStartFirstTask( void ) { /* 当前栈按照8字节对齐 */ PRESERVE8 /* 将SCB_VTOR寄存器地址加载到R0，SCB_VTOR寄存器存储__initial_sp的地址， __initial_sp也是msp的地址，还是向量表的起始地址，因为CM3支持更改向量表的起始地址， 所以需要以下四条指令以重定位__initial_sp */ ldr r0, =0xE000ED08 /* 将__initial_sp的地址加载进r0,STM32的__initial_sp为0x0800 0000 */ ldr r0, [r0] /* 将__initial_sp中的值，也就是msp初始化的值加载到r0，可能是0x20005B30 */ ldr r0, [r0] /* 将上一步初始化__initial_sp在r0中的值加载到msp */ msr msp, r0 /* 开中断 */ cpsie i cpsie f /* 等待上面所有指令执行完成 */ dsb isb /* 调用SVC去启动第一个任务 */ svc 0 nop nop } /* 处理第一个任务的SVC */ __asm void vPortSVCHandler( void ) { extern pxCurrentTCB; PRESERVE8 ldr r3, =pxCurrentTCB //TCB_t volatile *pxCurrentTCB = NULL; ldr r1, [r3] //volatile StackType_t *pxTopOfStack; ldr r0, [r1] //r0 = *pxTopOfStack ldmia r0!, {r4-r11} msr psp, r0 isb mov r0, #0 msr basepri, r0 //开中断 orr r14, #0xd //设置LR的值 bx r14 //此处不会返回r14(LR),而是返回到任务堆栈，具体看CM3手册 } __asm void xPortPendSVHandler( void ) { extern pxCurrentTCB; extern vTaskSwitchContext; PRESERVE8 mrs r0, psp isb ldr r3, =pxCurrentTCB ldr r2, [r3] stmdb r0!, {r4-r11} str r0, [r2] stmdb sp!, {r3, r14} mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY msr basepri, r0 dsb isb bl vTaskSwitchContext mov r0, #0 msr basepri, r0 ldmia sp!, {r3, r14} ldr r1, [r3] ldr r0, [r1] ldmia r0!, {r4-r11} msr psp, r0 isb bx r14 //此处不会返回r14(LR),而是返回到任务堆栈 nop } 为什么需要PendSV？ pendsv是最低优先级的异常，常用于任务切换，这是为了保证系统实时性所提出的方法。在此之前，采用时间片流转的os经常遇到任务切换的时钟中断将其他中断打断的问题，甚至引发硬件错误。有了pendsv后，定时器中断被延迟到了普通中断之后(SysTick中断默认高优先级)，以此来保证普通中断的优先级，同时也不会忽略定时器中断。但是会引起上下文切换不精确的问题，通常情况下由pendsv引发的延时可以忽略，但在中断风暴中问题尤为严重 内核的优先级翻转 任务正常执行 调用svc(请求管理调用)的原因 用户与内核进行操作，但如需使用内核中资源时，需要通过SVC异常来触发内核异常，从而来获得特权模式，这才能执行内核代码 为什么需要SVC启动第一个任务 使用了os后，任务调度交给内核，因此不能同裸机一样使用任务函数来启动，必须通过内核的服务才能启动任务 相比pendsv，svc有什么特点 触发svc中断，其处理是及时的，若不及时会导致硬件fault。svc多用于权限切换或申请内核资源 更多关于pendsv与svc的内容，详见矜辰所致-infoq 2024-01-05_10-23 2024-01-05_10-23_1 警告 for循环无循环体时末尾加分号 实现调度器总结 调度器的实现 初始化任务步骤 调用创建静态任务函数 设置TCB指针和栈指针 调用创建新任务函数，传入Handle，函数名称，参数，栈的深度等参数 返回Handle 创建新任务函数操作： 获取栈顶地址并对齐 将任务名称复制到TCB中 设置container与owner(container指的是处于哪个链表，owner是自身的TCB) 调用初始化任务栈函数，并返回一个栈顶指针 将任务的自身地址传给Handle，这样可以通过Handle控制任务 初始化任务栈函数操作： 对栈指针之前的16位进行设置以便加载到CPU寄存器中 返回空闲堆栈的栈指针 开启第一个任务步骤(汇编)： 设置堆栈按8字节对齐 从SCB_VTOR取出向量表地址，进而获得msp的内容（即复位中断处理函数） 开中断 调用svc指令去获取硬件权限，从而执行svc中断服务程序，并启动第一个任务(svc替代了以前的swi也就是软中断指令) svc中断服务程序的操作： 将第一个任务的参数加载到寄存器，包括第一个函数的地址，形参，返回值 开中断，使用psp寄存器，返回到任务堆栈，这样就可以执行第一个，执行完毕后CPU等待执行下一个任务 上下文切换的操作： 总体与svc中断服务程序的操作类似，但是加上了将优先级载入到basepri的操作 设置好优先级后直接运行至跳转上下文 c 函数 最后开中断，使用psp寄存器，返回到任务堆栈，CPU可以执行下一个任务，调度器功能就实现了 具体任务切换过程参考资料 ","date":"2024-01-01","objectID":"/posts/program/:1:2","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#实现调度器"},{"categories":["Tech"],"content":" 实现调度器 2024-01-04_14-42 向量表最前面是MSP的地址 配置寄存器： c /* 对0xe000ed20地址处取值，此处为SHPR3寄存器，设置的是pendsv和systick优先级 */ #define portNVIC_SYSPRI2_REG *(( volatile uint32_t *) 0xe000ed20) /* 配置 PendSV 和 SysTick 的中断优先级为最低 */ portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI; //SHPR3寄存器被设置为 0x**FF **** portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI; //SHPR3寄存器被设置为 0xFFFF **** 开启第一个任务： c /* 通过查找SCB_VTOR最终将__initial_sp处的指令传到msp内，然后调用svc启动第一个任务 */ __asm void prvStartFirstTask( void ) { /* 当前栈按照8字节对齐 */ PRESERVE8 /* 将SCB_VTOR寄存器地址加载到R0，SCB_VTOR寄存器存储__initial_sp的地址， __initial_sp也是msp的地址，还是向量表的起始地址，因为CM3支持更改向量表的起始地址， 所以需要以下四条指令以重定位__initial_sp */ ldr r0, =0xE000ED08 /* 将__initial_sp的地址加载进r0,STM32的__initial_sp为0x0800 0000 */ ldr r0, [r0] /* 将__initial_sp中的值，也就是msp初始化的值加载到r0，可能是0x20005B30 */ ldr r0, [r0] /* 将上一步初始化__initial_sp在r0中的值加载到msp */ msr msp, r0 /* 开中断 */ cpsie i cpsie f /* 等待上面所有指令执行完成 */ dsb isb /* 调用SVC去启动第一个任务 */ svc 0 nop nop } /* 处理第一个任务的SVC */ __asm void vPortSVCHandler( void ) { extern pxCurrentTCB; PRESERVE8 ldr r3, =pxCurrentTCB //TCB_t volatile *pxCurrentTCB = NULL; ldr r1, [r3] //volatile StackType_t *pxTopOfStack; ldr r0, [r1] //r0 = *pxTopOfStack ldmia r0!, {r4-r11} msr psp, r0 isb mov r0, #0 msr basepri, r0 //开中断 orr r14, #0xd //设置LR的值 bx r14 //此处不会返回r14(LR),而是返回到任务堆栈，具体看CM3手册 } __asm void xPortPendSVHandler( void ) { extern pxCurrentTCB; extern vTaskSwitchContext; PRESERVE8 mrs r0, psp isb ldr r3, =pxCurrentTCB ldr r2, [r3] stmdb r0!, {r4-r11} str r0, [r2] stmdb sp!, {r3, r14} mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY msr basepri, r0 dsb isb bl vTaskSwitchContext mov r0, #0 msr basepri, r0 ldmia sp!, {r3, r14} ldr r1, [r3] ldr r0, [r1] ldmia r0!, {r4-r11} msr psp, r0 isb bx r14 //此处不会返回r14(LR),而是返回到任务堆栈 nop } 为什么需要PendSV？ pendsv是最低优先级的异常，常用于任务切换，这是为了保证系统实时性所提出的方法。在此之前，采用时间片流转的os经常遇到任务切换的时钟中断将其他中断打断的问题，甚至引发硬件错误。有了pendsv后，定时器中断被延迟到了普通中断之后(SysTick中断默认高优先级)，以此来保证普通中断的优先级，同时也不会忽略定时器中断。但是会引起上下文切换不精确的问题，通常情况下由pendsv引发的延时可以忽略，但在中断风暴中问题尤为严重 内核的优先级翻转 任务正常执行 调用svc(请求管理调用)的原因 用户与内核进行操作，但如需使用内核中资源时，需要通过SVC异常来触发内核异常，从而来获得特权模式，这才能执行内核代码 为什么需要SVC启动第一个任务 使用了os后，任务调度交给内核，因此不能同裸机一样使用任务函数来启动，必须通过内核的服务才能启动任务 相比pendsv，svc有什么特点 触发svc中断，其处理是及时的，若不及时会导致硬件fault。svc多用于权限切换或申请内核资源 更多关于pendsv与svc的内容，详见矜辰所致-infoq 2024-01-05_10-23 2024-01-05_10-23_1 警告 for循环无循环体时末尾加分号 实现调度器总结 调度器的实现 初始化任务步骤 调用创建静态任务函数 设置TCB指针和栈指针 调用创建新任务函数，传入Handle，函数名称，参数，栈的深度等参数 返回Handle 创建新任务函数操作： 获取栈顶地址并对齐 将任务名称复制到TCB中 设置container与owner(container指的是处于哪个链表，owner是自身的TCB) 调用初始化任务栈函数，并返回一个栈顶指针 将任务的自身地址传给Handle，这样可以通过Handle控制任务 初始化任务栈函数操作： 对栈指针之前的16位进行设置以便加载到CPU寄存器中 返回空闲堆栈的栈指针 开启第一个任务步骤(汇编)： 设置堆栈按8字节对齐 从SCB_VTOR取出向量表地址，进而获得msp的内容（即复位中断处理函数） 开中断 调用svc指令去获取硬件权限，从而执行svc中断服务程序，并启动第一个任务(svc替代了以前的swi也就是软中断指令) svc中断服务程序的操作： 将第一个任务的参数加载到寄存器，包括第一个函数的地址，形参，返回值 开中断，使用psp寄存器，返回到任务堆栈，这样就可以执行第一个，执行完毕后CPU等待执行下一个任务 上下文切换的操作： 总体与svc中断服务程序的操作类似，但是加上了将优先级载入到basepri的操作 设置好优先级后直接运行至跳转上下文 c 函数 最后开中断，使用psp寄存器，返回到任务堆栈，CPU可以执行下一个任务，调度器功能就实现了 具体任务切换过程参考资料 ","date":"2024-01-01","objectID":"/posts/program/:1:2","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#实现调度器总结"},{"categories":["Tech"],"content":" 临界段保护临界段就是在执行时不能被中断的代码段，典型的就是全局变量，系统时基 中断管理FreeRTOS中的中断管理通过汇编完成，对于关中断而言，其内部实现了两个中断函数，分别是能保存当前中断有返回值的函数，可以在中断中使用。另一个是不能保存当前中断无返回值的函数，不能在中断使用。 本质是操作basepri寄存器，大于等于basepri寄存器的值的中断会被屏蔽，小于则不会。但当basepri为0时，则不会屏蔽任何中断 关中断 c /* 不带返回值的关中断函数,不能嵌套,不能在中断里面使用 */ #define portDISABLE_INTERRUPTS() vPortRaiseBASEPRI() static portFORCE_INLINE void vPortRaiseBASEPRI( void ) { //中断号大于191的中断全部被屏蔽 uint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY; __asm { //将FreeRTOS最大优先级的中断加载到basepri寄存器中，这样会屏蔽FreeRTOS管理的所有中断 msr basepri, ulNewBASEPRI dsb isb } } /* 带返回值的关中断函数,可以嵌套,可以在中断里面使用 */ #define portSET_INTERRUPT_MASK_FROM_ISR() ulPortRaiseBASEPRI() static portFORCE_INLINE uint32_t ulPortRaiseBASEPRI( void ) { uint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY; __asm { mrs ulReturn, basepri //先对当前中断进行保存并返回 msr basepri, ulNewBASEPRI dsb isb } return ulReturn; } #endif /* PORTMACRO_H */ 开中断 c /* 不带中断保护的开中断函数，与portDISABLE_INTERRUPTS()成对使用 */ #define portENABLE_INTERRUPTS() vPortSetBASEPRI( 0 ) /* 带中断保护的开中断函数，与portSET_INTERRUPT_MASK_FROM_ISR()成对使用 */ #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x) vPortSetBASEPRI(x) void vPortSetBASEPRI( uint32_t ulBASEPRI ) { __asm { msr basepri, ulBASEPRI } } inline关键字与内联函数inline关键字用于C++，__inline，__forceinline既可用于C，也可以用于C++ 在程序中，如果在关键代码频繁调用某个函数，则会频繁的压栈出栈。为了提高效率，C语言提供了inline关键字来优化代码，例如在开关中断时需要inline关键字 标记有inline修饰符的函数，编译器会将该函数内容原封不动的放入引用处，这样就不会频繁的入栈出栈了。虽然inline减少了函数调用的开销，但会使代码膨胀。 c #include \u003cstdio.h\u003e //函数定义为inline即:内联函数 inline char* dbtest(int a) { return (i % 2 \u003e 0) ? \"奇\" : \"偶\"; } int main() { int i = 0; for (i=1; i \u003c 100; i++) { printf(\"i:%d 奇偶性:%s /n\", i, dbtest(i)); } } 更详细用法参考CSND inline，__inline，__forceinline等用法参考51CTO volatile限定左值时，即使类型相同右值也需要类型强转么？不需要，Keil编译器问题，但是可能会报warning甚至error，最好类型强转一下 ","date":"2024-01-01","objectID":"/posts/program/:1:3","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#临界段保护"},{"categories":["Tech"],"content":" 临界段保护临界段就是在执行时不能被中断的代码段，典型的就是全局变量，系统时基 中断管理FreeRTOS中的中断管理通过汇编完成，对于关中断而言，其内部实现了两个中断函数，分别是能保存当前中断有返回值的函数，可以在中断中使用。另一个是不能保存当前中断无返回值的函数，不能在中断使用。 本质是操作basepri寄存器，大于等于basepri寄存器的值的中断会被屏蔽，小于则不会。但当basepri为0时，则不会屏蔽任何中断 关中断 c /* 不带返回值的关中断函数,不能嵌套,不能在中断里面使用 */ #define portDISABLE_INTERRUPTS() vPortRaiseBASEPRI() static portFORCE_INLINE void vPortRaiseBASEPRI( void ) { //中断号大于191的中断全部被屏蔽 uint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY; __asm { //将FreeRTOS最大优先级的中断加载到basepri寄存器中，这样会屏蔽FreeRTOS管理的所有中断 msr basepri, ulNewBASEPRI dsb isb } } /* 带返回值的关中断函数,可以嵌套,可以在中断里面使用 */ #define portSET_INTERRUPT_MASK_FROM_ISR() ulPortRaiseBASEPRI() static portFORCE_INLINE uint32_t ulPortRaiseBASEPRI( void ) { uint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY; __asm { mrs ulReturn, basepri //先对当前中断进行保存并返回 msr basepri, ulNewBASEPRI dsb isb } return ulReturn; } #endif /* PORTMACRO_H */ 开中断 c /* 不带中断保护的开中断函数，与portDISABLE_INTERRUPTS()成对使用 */ #define portENABLE_INTERRUPTS() vPortSetBASEPRI( 0 ) /* 带中断保护的开中断函数，与portSET_INTERRUPT_MASK_FROM_ISR()成对使用 */ #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x) vPortSetBASEPRI(x) void vPortSetBASEPRI( uint32_t ulBASEPRI ) { __asm { msr basepri, ulBASEPRI } } inline关键字与内联函数inline关键字用于C++，__inline，__forceinline既可用于C，也可以用于C++ 在程序中，如果在关键代码频繁调用某个函数，则会频繁的压栈出栈。为了提高效率，C语言提供了inline关键字来优化代码，例如在开关中断时需要inline关键字 标记有inline修饰符的函数，编译器会将该函数内容原封不动的放入引用处，这样就不会频繁的入栈出栈了。虽然inline减少了函数调用的开销，但会使代码膨胀。 c #include //函数定义为inline即:内联函数 inline char* dbtest(int a) { return (i % 2 \u003e 0) ? \"奇\" : \"偶\"; } int main() { int i = 0; for (i=1; i \u003c 100; i++) { printf(\"i:%d 奇偶性:%s /n\", i, dbtest(i)); } } 更详细用法参考CSND inline，__inline，__forceinline等用法参考51CTO volatile限定左值时，即使类型相同右值也需要类型强转么？不需要，Keil编译器问题，但是可能会报warning甚至error，最好类型强转一下 ","date":"2024-01-01","objectID":"/posts/program/:1:3","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#中断管理"},{"categories":["Tech"],"content":" 临界段保护临界段就是在执行时不能被中断的代码段，典型的就是全局变量，系统时基 中断管理FreeRTOS中的中断管理通过汇编完成，对于关中断而言，其内部实现了两个中断函数，分别是能保存当前中断有返回值的函数，可以在中断中使用。另一个是不能保存当前中断无返回值的函数，不能在中断使用。 本质是操作basepri寄存器，大于等于basepri寄存器的值的中断会被屏蔽，小于则不会。但当basepri为0时，则不会屏蔽任何中断 关中断 c /* 不带返回值的关中断函数,不能嵌套,不能在中断里面使用 */ #define portDISABLE_INTERRUPTS() vPortRaiseBASEPRI() static portFORCE_INLINE void vPortRaiseBASEPRI( void ) { //中断号大于191的中断全部被屏蔽 uint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY; __asm { //将FreeRTOS最大优先级的中断加载到basepri寄存器中，这样会屏蔽FreeRTOS管理的所有中断 msr basepri, ulNewBASEPRI dsb isb } } /* 带返回值的关中断函数,可以嵌套,可以在中断里面使用 */ #define portSET_INTERRUPT_MASK_FROM_ISR() ulPortRaiseBASEPRI() static portFORCE_INLINE uint32_t ulPortRaiseBASEPRI( void ) { uint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY; __asm { mrs ulReturn, basepri //先对当前中断进行保存并返回 msr basepri, ulNewBASEPRI dsb isb } return ulReturn; } #endif /* PORTMACRO_H */ 开中断 c /* 不带中断保护的开中断函数，与portDISABLE_INTERRUPTS()成对使用 */ #define portENABLE_INTERRUPTS() vPortSetBASEPRI( 0 ) /* 带中断保护的开中断函数，与portSET_INTERRUPT_MASK_FROM_ISR()成对使用 */ #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x) vPortSetBASEPRI(x) void vPortSetBASEPRI( uint32_t ulBASEPRI ) { __asm { msr basepri, ulBASEPRI } } inline关键字与内联函数inline关键字用于C++，__inline，__forceinline既可用于C，也可以用于C++ 在程序中，如果在关键代码频繁调用某个函数，则会频繁的压栈出栈。为了提高效率，C语言提供了inline关键字来优化代码，例如在开关中断时需要inline关键字 标记有inline修饰符的函数，编译器会将该函数内容原封不动的放入引用处，这样就不会频繁的入栈出栈了。虽然inline减少了函数调用的开销，但会使代码膨胀。 c #include //函数定义为inline即:内联函数 inline char* dbtest(int a) { return (i % 2 \u003e 0) ? \"奇\" : \"偶\"; } int main() { int i = 0; for (i=1; i \u003c 100; i++) { printf(\"i:%d 奇偶性:%s /n\", i, dbtest(i)); } } 更详细用法参考CSND inline，__inline，__forceinline等用法参考51CTO volatile限定左值时，即使类型相同右值也需要类型强转么？不需要，Keil编译器问题，但是可能会报warning甚至error，最好类型强转一下 ","date":"2024-01-01","objectID":"/posts/program/:1:3","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#关中断"},{"categories":["Tech"],"content":" 临界段保护临界段就是在执行时不能被中断的代码段，典型的就是全局变量，系统时基 中断管理FreeRTOS中的中断管理通过汇编完成，对于关中断而言，其内部实现了两个中断函数，分别是能保存当前中断有返回值的函数，可以在中断中使用。另一个是不能保存当前中断无返回值的函数，不能在中断使用。 本质是操作basepri寄存器，大于等于basepri寄存器的值的中断会被屏蔽，小于则不会。但当basepri为0时，则不会屏蔽任何中断 关中断 c /* 不带返回值的关中断函数,不能嵌套,不能在中断里面使用 */ #define portDISABLE_INTERRUPTS() vPortRaiseBASEPRI() static portFORCE_INLINE void vPortRaiseBASEPRI( void ) { //中断号大于191的中断全部被屏蔽 uint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY; __asm { //将FreeRTOS最大优先级的中断加载到basepri寄存器中，这样会屏蔽FreeRTOS管理的所有中断 msr basepri, ulNewBASEPRI dsb isb } } /* 带返回值的关中断函数,可以嵌套,可以在中断里面使用 */ #define portSET_INTERRUPT_MASK_FROM_ISR() ulPortRaiseBASEPRI() static portFORCE_INLINE uint32_t ulPortRaiseBASEPRI( void ) { uint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY; __asm { mrs ulReturn, basepri //先对当前中断进行保存并返回 msr basepri, ulNewBASEPRI dsb isb } return ulReturn; } #endif /* PORTMACRO_H */ 开中断 c /* 不带中断保护的开中断函数，与portDISABLE_INTERRUPTS()成对使用 */ #define portENABLE_INTERRUPTS() vPortSetBASEPRI( 0 ) /* 带中断保护的开中断函数，与portSET_INTERRUPT_MASK_FROM_ISR()成对使用 */ #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x) vPortSetBASEPRI(x) void vPortSetBASEPRI( uint32_t ulBASEPRI ) { __asm { msr basepri, ulBASEPRI } } inline关键字与内联函数inline关键字用于C++，__inline，__forceinline既可用于C，也可以用于C++ 在程序中，如果在关键代码频繁调用某个函数，则会频繁的压栈出栈。为了提高效率，C语言提供了inline关键字来优化代码，例如在开关中断时需要inline关键字 标记有inline修饰符的函数，编译器会将该函数内容原封不动的放入引用处，这样就不会频繁的入栈出栈了。虽然inline减少了函数调用的开销，但会使代码膨胀。 c #include //函数定义为inline即:内联函数 inline char* dbtest(int a) { return (i % 2 \u003e 0) ? \"奇\" : \"偶\"; } int main() { int i = 0; for (i=1; i \u003c 100; i++) { printf(\"i:%d 奇偶性:%s /n\", i, dbtest(i)); } } 更详细用法参考CSND inline，__inline，__forceinline等用法参考51CTO volatile限定左值时，即使类型相同右值也需要类型强转么？不需要，Keil编译器问题，但是可能会报warning甚至error，最好类型强转一下 ","date":"2024-01-01","objectID":"/posts/program/:1:3","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#开中断"},{"categories":["Tech"],"content":" 临界段保护临界段就是在执行时不能被中断的代码段，典型的就是全局变量，系统时基 中断管理FreeRTOS中的中断管理通过汇编完成，对于关中断而言，其内部实现了两个中断函数，分别是能保存当前中断有返回值的函数，可以在中断中使用。另一个是不能保存当前中断无返回值的函数，不能在中断使用。 本质是操作basepri寄存器，大于等于basepri寄存器的值的中断会被屏蔽，小于则不会。但当basepri为0时，则不会屏蔽任何中断 关中断 c /* 不带返回值的关中断函数,不能嵌套,不能在中断里面使用 */ #define portDISABLE_INTERRUPTS() vPortRaiseBASEPRI() static portFORCE_INLINE void vPortRaiseBASEPRI( void ) { //中断号大于191的中断全部被屏蔽 uint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY; __asm { //将FreeRTOS最大优先级的中断加载到basepri寄存器中，这样会屏蔽FreeRTOS管理的所有中断 msr basepri, ulNewBASEPRI dsb isb } } /* 带返回值的关中断函数,可以嵌套,可以在中断里面使用 */ #define portSET_INTERRUPT_MASK_FROM_ISR() ulPortRaiseBASEPRI() static portFORCE_INLINE uint32_t ulPortRaiseBASEPRI( void ) { uint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY; __asm { mrs ulReturn, basepri //先对当前中断进行保存并返回 msr basepri, ulNewBASEPRI dsb isb } return ulReturn; } #endif /* PORTMACRO_H */ 开中断 c /* 不带中断保护的开中断函数，与portDISABLE_INTERRUPTS()成对使用 */ #define portENABLE_INTERRUPTS() vPortSetBASEPRI( 0 ) /* 带中断保护的开中断函数，与portSET_INTERRUPT_MASK_FROM_ISR()成对使用 */ #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x) vPortSetBASEPRI(x) void vPortSetBASEPRI( uint32_t ulBASEPRI ) { __asm { msr basepri, ulBASEPRI } } inline关键字与内联函数inline关键字用于C++，__inline，__forceinline既可用于C，也可以用于C++ 在程序中，如果在关键代码频繁调用某个函数，则会频繁的压栈出栈。为了提高效率，C语言提供了inline关键字来优化代码，例如在开关中断时需要inline关键字 标记有inline修饰符的函数，编译器会将该函数内容原封不动的放入引用处，这样就不会频繁的入栈出栈了。虽然inline减少了函数调用的开销，但会使代码膨胀。 c #include //函数定义为inline即:内联函数 inline char* dbtest(int a) { return (i % 2 \u003e 0) ? \"奇\" : \"偶\"; } int main() { int i = 0; for (i=1; i \u003c 100; i++) { printf(\"i:%d 奇偶性:%s /n\", i, dbtest(i)); } } 更详细用法参考CSND inline，__inline，__forceinline等用法参考51CTO volatile限定左值时，即使类型相同右值也需要类型强转么？不需要，Keil编译器问题，但是可能会报warning甚至error，最好类型强转一下 ","date":"2024-01-01","objectID":"/posts/program/:1:3","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#inline关键字与内联函数"},{"categories":["Tech"],"content":" 临界段保护临界段就是在执行时不能被中断的代码段，典型的就是全局变量，系统时基 中断管理FreeRTOS中的中断管理通过汇编完成，对于关中断而言，其内部实现了两个中断函数，分别是能保存当前中断有返回值的函数，可以在中断中使用。另一个是不能保存当前中断无返回值的函数，不能在中断使用。 本质是操作basepri寄存器，大于等于basepri寄存器的值的中断会被屏蔽，小于则不会。但当basepri为0时，则不会屏蔽任何中断 关中断 c /* 不带返回值的关中断函数,不能嵌套,不能在中断里面使用 */ #define portDISABLE_INTERRUPTS() vPortRaiseBASEPRI() static portFORCE_INLINE void vPortRaiseBASEPRI( void ) { //中断号大于191的中断全部被屏蔽 uint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY; __asm { //将FreeRTOS最大优先级的中断加载到basepri寄存器中，这样会屏蔽FreeRTOS管理的所有中断 msr basepri, ulNewBASEPRI dsb isb } } /* 带返回值的关中断函数,可以嵌套,可以在中断里面使用 */ #define portSET_INTERRUPT_MASK_FROM_ISR() ulPortRaiseBASEPRI() static portFORCE_INLINE uint32_t ulPortRaiseBASEPRI( void ) { uint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY; __asm { mrs ulReturn, basepri //先对当前中断进行保存并返回 msr basepri, ulNewBASEPRI dsb isb } return ulReturn; } #endif /* PORTMACRO_H */ 开中断 c /* 不带中断保护的开中断函数，与portDISABLE_INTERRUPTS()成对使用 */ #define portENABLE_INTERRUPTS() vPortSetBASEPRI( 0 ) /* 带中断保护的开中断函数，与portSET_INTERRUPT_MASK_FROM_ISR()成对使用 */ #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x) vPortSetBASEPRI(x) void vPortSetBASEPRI( uint32_t ulBASEPRI ) { __asm { msr basepri, ulBASEPRI } } inline关键字与内联函数inline关键字用于C++，__inline，__forceinline既可用于C，也可以用于C++ 在程序中，如果在关键代码频繁调用某个函数，则会频繁的压栈出栈。为了提高效率，C语言提供了inline关键字来优化代码，例如在开关中断时需要inline关键字 标记有inline修饰符的函数，编译器会将该函数内容原封不动的放入引用处，这样就不会频繁的入栈出栈了。虽然inline减少了函数调用的开销，但会使代码膨胀。 c #include //函数定义为inline即:内联函数 inline char* dbtest(int a) { return (i % 2 \u003e 0) ? \"奇\" : \"偶\"; } int main() { int i = 0; for (i=1; i \u003c 100; i++) { printf(\"i:%d 奇偶性:%s /n\", i, dbtest(i)); } } 更详细用法参考CSND inline，__inline，__forceinline等用法参考51CTO volatile限定左值时，即使类型相同右值也需要类型强转么？不需要，Keil编译器问题，但是可能会报warning甚至error，最好类型强转一下 ","date":"2024-01-01","objectID":"/posts/program/:1:3","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#volatile限定左值时即使类型相同右值也需要类型强转么"},{"categories":["Tech"],"content":" 空闲任务与阻塞延时的实现 为了能够自动进行任务调度，需要： 设置CPU重装器，设置主频并调用系统中断向量表提供的SysTic中断服务函数 提供一个函数，内部能够完成时基自增和任务延时自减**(后期会取消自减的设置，转而使用“闹钟”的思想)**，并将这个函数放入上一步的SysTick服务函数中，这样能够定时触发从而进行时基自增，在放入SysTick中时，还需要注意此函数前后需要开关中断以保证时基的实时性 将任务调度器函数vTaskSwitchContext重写，调度方式需要判定TCB中的任务延时，值为零，则触发SysTick中断服务函数，而后将任务放入就绪链表 为了加入IdleTask支持，需要： 在启动调度器函数 vTaskStartScheduler中加入空闲任务的启动，这需要设置IdleTask的TCB，栈，函数名称等参数，但不设置延时，因为CPU空闲时长不确定，设置完成后将其挂载到就绪列表 警告 注意不要在IdleTask中加入任何阻塞或者死循环，否则由于IdleTask没有设置延时且目前抢占式算法未完成，导致调度器将与IdleTask同一优先级的所有任务阻塞！！！ ","date":"2024-01-01","objectID":"/posts/program/:1:4","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#空闲任务与阻塞延时的实现"},{"categories":["Tech"],"content":" 支持多优先级CM内核有个计算前导零的指令，以此可以优化寻找最高优先级任务的方法 2024-01-12_10-19 主要原理是：找到一个32位变量的最高非零位，此位就是最高的有任务的链表的优先级(支持的最大优先级数目为32) 支持多优先级实现过程如下 将uxPriority添加到TCB及其相关的函数内使其支持优先级 之后在prvInitialiseNewTask函数内添加初始化优先级，并做判断使任务初始化的优先级大于等于configMAX_PRIORITIES退化成configMAX_PRIORITIES-1的优先级 在prvInitialiseTaskLists中初始化5个就绪链表，每个链表内的任务都有相同的优先级 在prvAddTaskToReadyList宏函数中完成将任务移就绪入链表的操作 记录当前优先级并将当前任务插入到获得的那个优先级链表的尾部 在prvAddNewTaskToReadyList函数中完成具体操作 如果pxCurrentTCB为空，意味着可能是第一次创建任务，则将传进来的pxNewTCB赋值给pxCurrentTCB，并且调用prvInitialiseTaskLists函数以创建任务链表 如果pxCurrentTCB不为空，则根据优先级将pxCurrentTCB设置为优先级最高的那个任务，可能是pxNewTCB也可能是pxCurrentTCB，这需要做好判定再赋值 最后调用prvAddTaskToReadyList ","date":"2024-01-01","objectID":"/posts/program/:1:5","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#支持多优先级"},{"categories":["Tech"],"content":" 任务延时列表的实现 首先初始化两条链表\u0026xDelayedTaskList1与\u0026xDelayedTaskList2，并将其赋址给pxDelayedTaskList和pxOverflowDelayedTaskList 在vTaskStartScheduler中初始化全局变量xNextTaskUnblockTime为最大值，这个变量表示下一次任务被唤醒的时刻，也就是所提到的“闹钟” 在vTaskDelay函数中插入prvAddCurrentTaskToDelayedList函数，prvAddCurrentTaskToDelayedList函数实现如下 将当前任务从就绪链表中移除，并检查移除任务后，就绪链表是否为空，若为空则将优先级位图上对应的位清除 记录xTimeToWake的值，它等于当前时钟加上vTaskDelay的参数，也就是闹钟值，与xNextTaskUnblockTime相等，但是为局部变量，并将此值设置为链表节点的排序值 比较xTimeToWake与xConstTickCount大小以判断是否闹钟溢出，溢出了就将当前任务移至pxOverflowDelayedTaskList链表，否则移至pxDelayedTaskList链表 然后更新xNextTaskUnblockTime使其等于xTimeToWake 在xTaskIncrementTick函数中判断延时任务是否到期，若到期且延时链表为空，则将xNextTaskUnblockTime设为最大值。若到期但延时链表不为空，则将延时链表中的每个节点的值xItemValue取出并与当前时刻做对比，若xItemValue大于当前时刻，则将xNextTaskUnblockTime更新为xItemValue，然后将任务从延时链表移入就绪链表 判断链表为空的方式： 调用uxListRemove时会返回pxList-\u003euxNumberOfItems，或者调用宏函数 FreeRTOS内部有两个延时链表，当系统时基计数器xTickCount没有溢出时，用一条链表(pxDelayedTaskList)，当xTickCount 溢出后，用另外一条链表(pxOverflowDelayedTaskList)。 c static void prvTaskExitError( void ) { /* 没有可供执行的任务时会停在这里，如果发生了这种情况，看一下空闲任务是否被执行 */ /* 函数停止在这里 */ for (;;); } ","date":"2024-01-01","objectID":"/posts/program/:1:6","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#任务延时列表的实现"},{"categories":["Tech"],"content":" 支持时间片 抢占式调度(configUSE_PREEMPTION)：高优先级任务可以打断低优先级任务 时间片流转(configUSE_TIME_SLICING)：同优先级任务之间每隔一定时间片进行任务切换 空闲任务让步(configIDLE_SHOULD_YIELD)：空闲任务与用户任务处于同一优先级时，空闲任务等待用户任务使用完CPU后才能获取资源 默认情况，FreeRTOS上面三个选项均开启 支持时间片的操作非常简单 分别在FreeRTOSConfig.h与FreeRTOS.h文件中引入configUSE_PREEMPTION和configUSE_TIME_SLICING两个宏，默认为1 修改xPortSysTickHandler函数，使得当xTaskIncrementTick返回值为pdTrue时才进行任务切换 修改xTaskIncrementTick函数，使得在延时链表中有任务被唤醒时，判断被唤醒的延时任务优先级与当前任务优先级，若被唤醒的延时任务优先级高则返回pdTrue，意味着进行任务切换 如果当就绪链表中任务数大于1，那么每进入xTaskIncrementTick函数就意味着过去了一个时间片，因此需要进行任务切换。注意在修改该函数时还需要判断上面两个宏是否为1 ","date":"2024-01-01","objectID":"/posts/program/:1:7","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#支持时间片"},{"categories":["Tech"],"content":" 自己实现 信号量 初始化Semaphore链表并设置Semaphore结构体的值 完成Take函数 检测当前Semaphore个数是否大于0，若大于0则关中断，Semaphore数量–，不大于零则说明没有Semaphore可供Take，所以需要进行任务切换 完成Give函数 Give函数简单很多，只需要归还Semaphore然后开中断，将任务管理权归还给调度器即可 队列 为了保证数据能在不同函数间传递，静态创建资源时需要在创建资源的函数内传入在main函数中预设的结构体或数组的地址，对于Queue来说，官方使用 xQueueCreateStatic( UBaseType_t uxQueueLength, UBaseType_t uxItemSize, uint8_t *pucQueueStorageBuffer, StaticQueue_t *pxQueueBuffer );函数来传参 在创建函数内还需要初始化Queue链表和结构体及其参数，最后返回一个void*类型的handle 创建环形缓存区来保存数据，做好数据发送和接收的准备工作 Buffer实际上是有一个head标志变量和一个tail标志变量的数组，发送数据时head++，接收数据时tail++，当head或tail等于数组结尾时需要把他们设置为数组开头 Buffer还要有检测是否为空的功能 队列发送函数QueueSend中，在发送数据前需要关中断，发送数据后开中断 队列接收函数QueueReceive中，也需要同QueueSend开关中断 静态创建和动态创建的区别静态创建因为需要防止函数退出时销毁数据和栈，因此需要传入指针，所需的内存大小以及需要保存相关结构的地址等条件 c // 示例代码 #define QUEUE_LENGTH 10 #define ITEM_SIZE sizeof( uint32_t ) // xQueueBuffer用来保存队列结构体，内部存储了队列的相关参数 StaticQueue_t xQueueBuffer; // ucQueueStorage 用来保存队列的数据 // 大小为:队列长度 * 数据大小 uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ]; void vATask( void *pvParameters ) { QueueHandle_t xQueue1; // 创建队列: 可以容纳QUEUE_LENGTH个数据,每个数据大小是ITEM_SIZE xQueue1 = xQueueCreateStatic( QUEUE_LENGTH, ITEM_SIZE, ucQueueStorage, \u0026xQueueBuffer ); } 动态存储使用malloc函数因此不需要传入指针，但是程序速度运行比静态分配慢且需要对内存进行管理 c BaseType_t QueueReceive(QueueHandle_t QueueHandle, void* const ReceiveData ) { Queue_t* QueueTemp; QueueTemp = (Queue_t*)QueueHandle; BaseType_t rtval = pdFALSE; portDISABLE_INTERRUPTS(); rtval = BufferReceive( ReceiveData, /* 只能使用QueueTemp这种中间变量做强制类型转换，如果写成 ((Queue_t*)QueueHandle)-\u003euxQueueLength则会找不到成员 而报错 */ QueueTemp-\u003euxQueueLength, QueueTemp-\u003euxItemSize, QueueTemp-\u003epvDataStore); portENABLE_INTERRUPTS(); return rtval; } ","date":"2024-01-01","objectID":"/posts/program/:1:8","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#自己实现"},{"categories":["Tech"],"content":" 自己实现 信号量 初始化Semaphore链表并设置Semaphore结构体的值 完成Take函数 检测当前Semaphore个数是否大于0，若大于0则关中断，Semaphore数量–，不大于零则说明没有Semaphore可供Take，所以需要进行任务切换 完成Give函数 Give函数简单很多，只需要归还Semaphore然后开中断，将任务管理权归还给调度器即可 队列 为了保证数据能在不同函数间传递，静态创建资源时需要在创建资源的函数内传入在main函数中预设的结构体或数组的地址，对于Queue来说，官方使用 xQueueCreateStatic( UBaseType_t uxQueueLength, UBaseType_t uxItemSize, uint8_t *pucQueueStorageBuffer, StaticQueue_t *pxQueueBuffer );函数来传参 在创建函数内还需要初始化Queue链表和结构体及其参数，最后返回一个void*类型的handle 创建环形缓存区来保存数据，做好数据发送和接收的准备工作 Buffer实际上是有一个head标志变量和一个tail标志变量的数组，发送数据时head++，接收数据时tail++，当head或tail等于数组结尾时需要把他们设置为数组开头 Buffer还要有检测是否为空的功能 队列发送函数QueueSend中，在发送数据前需要关中断，发送数据后开中断 队列接收函数QueueReceive中，也需要同QueueSend开关中断 静态创建和动态创建的区别静态创建因为需要防止函数退出时销毁数据和栈，因此需要传入指针，所需的内存大小以及需要保存相关结构的地址等条件 c // 示例代码 #define QUEUE_LENGTH 10 #define ITEM_SIZE sizeof( uint32_t ) // xQueueBuffer用来保存队列结构体，内部存储了队列的相关参数 StaticQueue_t xQueueBuffer; // ucQueueStorage 用来保存队列的数据 // 大小为:队列长度 * 数据大小 uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ]; void vATask( void *pvParameters ) { QueueHandle_t xQueue1; // 创建队列: 可以容纳QUEUE_LENGTH个数据,每个数据大小是ITEM_SIZE xQueue1 = xQueueCreateStatic( QUEUE_LENGTH, ITEM_SIZE, ucQueueStorage, \u0026xQueueBuffer ); } 动态存储使用malloc函数因此不需要传入指针，但是程序速度运行比静态分配慢且需要对内存进行管理 c BaseType_t QueueReceive(QueueHandle_t QueueHandle, void* const ReceiveData ) { Queue_t* QueueTemp; QueueTemp = (Queue_t*)QueueHandle; BaseType_t rtval = pdFALSE; portDISABLE_INTERRUPTS(); rtval = BufferReceive( ReceiveData, /* 只能使用QueueTemp这种中间变量做强制类型转换，如果写成 ((Queue_t*)QueueHandle)-\u003euxQueueLength则会找不到成员 而报错 */ QueueTemp-\u003euxQueueLength, QueueTemp-\u003euxItemSize, QueueTemp-\u003epvDataStore); portENABLE_INTERRUPTS(); return rtval; } ","date":"2024-01-01","objectID":"/posts/program/:1:8","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#信号量"},{"categories":["Tech"],"content":" 自己实现 信号量 初始化Semaphore链表并设置Semaphore结构体的值 完成Take函数 检测当前Semaphore个数是否大于0，若大于0则关中断，Semaphore数量–，不大于零则说明没有Semaphore可供Take，所以需要进行任务切换 完成Give函数 Give函数简单很多，只需要归还Semaphore然后开中断，将任务管理权归还给调度器即可 队列 为了保证数据能在不同函数间传递，静态创建资源时需要在创建资源的函数内传入在main函数中预设的结构体或数组的地址，对于Queue来说，官方使用 xQueueCreateStatic( UBaseType_t uxQueueLength, UBaseType_t uxItemSize, uint8_t *pucQueueStorageBuffer, StaticQueue_t *pxQueueBuffer );函数来传参 在创建函数内还需要初始化Queue链表和结构体及其参数，最后返回一个void*类型的handle 创建环形缓存区来保存数据，做好数据发送和接收的准备工作 Buffer实际上是有一个head标志变量和一个tail标志变量的数组，发送数据时head++，接收数据时tail++，当head或tail等于数组结尾时需要把他们设置为数组开头 Buffer还要有检测是否为空的功能 队列发送函数QueueSend中，在发送数据前需要关中断，发送数据后开中断 队列接收函数QueueReceive中，也需要同QueueSend开关中断 静态创建和动态创建的区别静态创建因为需要防止函数退出时销毁数据和栈，因此需要传入指针，所需的内存大小以及需要保存相关结构的地址等条件 c // 示例代码 #define QUEUE_LENGTH 10 #define ITEM_SIZE sizeof( uint32_t ) // xQueueBuffer用来保存队列结构体，内部存储了队列的相关参数 StaticQueue_t xQueueBuffer; // ucQueueStorage 用来保存队列的数据 // 大小为:队列长度 * 数据大小 uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ]; void vATask( void *pvParameters ) { QueueHandle_t xQueue1; // 创建队列: 可以容纳QUEUE_LENGTH个数据,每个数据大小是ITEM_SIZE xQueue1 = xQueueCreateStatic( QUEUE_LENGTH, ITEM_SIZE, ucQueueStorage, \u0026xQueueBuffer ); } 动态存储使用malloc函数因此不需要传入指针，但是程序速度运行比静态分配慢且需要对内存进行管理 c BaseType_t QueueReceive(QueueHandle_t QueueHandle, void* const ReceiveData ) { Queue_t* QueueTemp; QueueTemp = (Queue_t*)QueueHandle; BaseType_t rtval = pdFALSE; portDISABLE_INTERRUPTS(); rtval = BufferReceive( ReceiveData, /* 只能使用QueueTemp这种中间变量做强制类型转换，如果写成 ((Queue_t*)QueueHandle)-\u003euxQueueLength则会找不到成员 而报错 */ QueueTemp-\u003euxQueueLength, QueueTemp-\u003euxItemSize, QueueTemp-\u003epvDataStore); portENABLE_INTERRUPTS(); return rtval; } ","date":"2024-01-01","objectID":"/posts/program/:1:8","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#队列"},{"categories":["Tech"],"content":" 自己实现 信号量 初始化Semaphore链表并设置Semaphore结构体的值 完成Take函数 检测当前Semaphore个数是否大于0，若大于0则关中断，Semaphore数量–，不大于零则说明没有Semaphore可供Take，所以需要进行任务切换 完成Give函数 Give函数简单很多，只需要归还Semaphore然后开中断，将任务管理权归还给调度器即可 队列 为了保证数据能在不同函数间传递，静态创建资源时需要在创建资源的函数内传入在main函数中预设的结构体或数组的地址，对于Queue来说，官方使用 xQueueCreateStatic( UBaseType_t uxQueueLength, UBaseType_t uxItemSize, uint8_t *pucQueueStorageBuffer, StaticQueue_t *pxQueueBuffer );函数来传参 在创建函数内还需要初始化Queue链表和结构体及其参数，最后返回一个void*类型的handle 创建环形缓存区来保存数据，做好数据发送和接收的准备工作 Buffer实际上是有一个head标志变量和一个tail标志变量的数组，发送数据时head++，接收数据时tail++，当head或tail等于数组结尾时需要把他们设置为数组开头 Buffer还要有检测是否为空的功能 队列发送函数QueueSend中，在发送数据前需要关中断，发送数据后开中断 队列接收函数QueueReceive中，也需要同QueueSend开关中断 静态创建和动态创建的区别静态创建因为需要防止函数退出时销毁数据和栈，因此需要传入指针，所需的内存大小以及需要保存相关结构的地址等条件 c // 示例代码 #define QUEUE_LENGTH 10 #define ITEM_SIZE sizeof( uint32_t ) // xQueueBuffer用来保存队列结构体，内部存储了队列的相关参数 StaticQueue_t xQueueBuffer; // ucQueueStorage 用来保存队列的数据 // 大小为:队列长度 * 数据大小 uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ]; void vATask( void *pvParameters ) { QueueHandle_t xQueue1; // 创建队列: 可以容纳QUEUE_LENGTH个数据,每个数据大小是ITEM_SIZE xQueue1 = xQueueCreateStatic( QUEUE_LENGTH, ITEM_SIZE, ucQueueStorage, \u0026xQueueBuffer ); } 动态存储使用malloc函数因此不需要传入指针，但是程序速度运行比静态分配慢且需要对内存进行管理 c BaseType_t QueueReceive(QueueHandle_t QueueHandle, void* const ReceiveData ) { Queue_t* QueueTemp; QueueTemp = (Queue_t*)QueueHandle; BaseType_t rtval = pdFALSE; portDISABLE_INTERRUPTS(); rtval = BufferReceive( ReceiveData, /* 只能使用QueueTemp这种中间变量做强制类型转换，如果写成 ((Queue_t*)QueueHandle)-\u003euxQueueLength则会找不到成员 而报错 */ QueueTemp-\u003euxQueueLength, QueueTemp-\u003euxItemSize, QueueTemp-\u003epvDataStore); portENABLE_INTERRUPTS(); return rtval; } ","date":"2024-01-01","objectID":"/posts/program/:1:8","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#静态创建和动态创建的区别"},{"categories":["Tech"],"content":" 遇到的困难与学到的经验 编译关系复杂，各种头文件相互包含导致类型重定义或者定义冲突 理清编译关系，在项目之前做好文件规划，划分各文件的职责 注意头文件引用顺序 Keil编译器有问题，有时候类型符合的赋值编译器不通过，必须类型强转才可编译通过。再或者，虽然已经定义了条件编译但还是对循环引用的头文件报错，这时就需要考虑编译器的问题了，Keil失效的通常的现象和解决办法： 一般出现编译器问题的条件是：当一个错误卡住了很长时间，并且确定这段代码没有错误，而且当按照编译器的提示将这段代码彻底的进行修改后会爆出更多error，这时就可以考虑是编译器的问题了(在写下这篇文章两年后的视角来看，应该是右值类型转换时缺失volatile关键字) 2024-01-05_22-35 2024-01-05_22-36 2024-01-05_22-37 2024-01-05_22-33 所有可能的解决办法都失效了，可以考虑是Keil的问题 待补充 警告 c void prvIdleTask( void *p_arg ) { /* 永远不要在空闲任务里加入阻塞或者死循环！！！！！！！！！！！！！！！ 否则当其他任务优先级为0时，空闲任务会霸占整个时间片(没有设置时间片流转和抢占式调度的话)*/ // for( ;; ) // { // flagIdle = 1; // flag1 = 0; // flag2 = 0; // } } 因为在第十章已经实现支持多优先级了，且Task1，Task2优先级均大于0，因此此时空闲任务内可以加循环 遇到调不出来的Bug不要怕，解决方法如下 保持一个清醒的状态 快速定位问题的大概位置 在Bug大概位置处逐步调试 c void tickconst(int tick) { const int consttick = tick; printf(\"%d\\n\",consttick); } // void tickstatic(int tick) // { // static int statictick = tick;//static不能被变量赋值 // printf(\"%d\\n\",statictick); // } int main() { int i = 0; for(i=0; i\u003c10; i++) { tickconst(i);//const的值可以在定义的时候被修改，但不能在其他地方被修改，也就是说，const可以被变量赋值` } return 0; } 在时基函数调用时会用到 c /* 负责进入增加时基，任务时间自减的函数，定义在Config.h: #define xPortSysTickHandler SysTick_Handler 也就是按配置的重装器和主频来触发 */ void xPortSysTickHandler( void ) { uint32_t ISRreturn; /* 关中断 */ //使用的是能在中断中使用的函数会如何？无影响,第九章实验现象可以完成，但是因为SysTick优先级过低而无用 ISRreturn = portSET_INTERRUPT_MASK_FROM_ISR(); /* 更新系统时基 */ //xTaskIncrementTick(); xSemaphoreIncrementTick(); if(xTaskIncrementTick() != pdFALSE) { taskYIELD(); } /* 开中断 */ portCLEAR_INTERRUPT_MASK_FROM_ISR(ISRreturn); // vPortRaiseBASEPRI(); // xTaskIncrementTick(); // vPortClearBASEPRIFromISR(); } 核心的自增函数 c BaseType_t xTaskIncrementTick( void ) { TCB_t *pxTCB = NULL; // BaseType_t i = 0; TickType_t xItemValue; BaseType_t xSwitchRequired = pdFALSE; /* 更新系统时基计数器 xTickCount,xTickCount 是一个在 port.c 中定义的全局变量 */ const TickType_t xConstTickCount = xTickCount + 1;//常量赋值？是的，const可以被在定义时被变量赋值 xTickCount = xConstTickCount; ... } xTickCount与xConstTickCount变量相互依赖而不写成xTickCount++的原因是后者的写法可能会导致静态条件的出现，而前者即使没有加锁也可以保证xTickCount是原子加的 并且taskYIELD本质上也是操作PendSV c #define taskYIELD() portYIELD() /* 触发 PendSV,产生上下文切换 */ #define portYIELD() \\ { \\ portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \\ __dsb( portSY_FULL_READ_WRITE ); \\ __isb( portSY_FULL_READ_WRITE ); \\ } c #include \u003cstdio.h\u003e int a = 4; int b = 5; //宏定义地址交换会修改值，这是因为函数宏定义不会产生栈 #define swapdef(addra,addrb)\\ {\\ int *temp;\\ temp = a;\\ a = b;\\ b = temp;\\ } //地址交换不会修改值 void swapadd(int* a,int* b) { int* temp; temp = a; a = b; b = temp; } void swapnum(int* a,int* b) { int temp; temp = *a; *a = *b; *b = temp; } int main() { printf(\"原值=%d %d\\n\",a,b); swapdef(\u0026a,\u0026b); printf(\"宏地址交换=%d %d\\n\",a,b); swapadd(\u0026a,\u0026b); printf(\"函数地址交换=%d %d\\n\",a,b); swapnum(\u0026a,\u0026b); printf(\"指针地址解引用交换=%d %d\\n\",a,b); a = 6; printf(\"%d %d\\n\",a,b); return 0; } 2024-01-11_20-48 警告 堆栈太小可能会导致程序停止在HardFault int (*array)[20] 与 int *arrary[20]的不同前者代表一个指向具有20个整型元素数组的指针，后者代表一个具有20个指针元素的数组 宏定义函数 为什么要使用宏定义函数？ 宏定义函数可以在预编译阶段直接展开，省下了压栈出栈的资源 那他与内联函数的区别是什么？ 宏定义函数只做展开和替换，不检查参数类型。而内联函数需要检查参数类型 C99特性在keil中可以在“魔术棒”的C/C++设置C99模式，指定后可以在非全局作用域下定义不定长数组(vla) c #define ListNum 5//只能使用宏定义，变量赋值也不行 #define ItemNum 10 /* 不能在全局作用域下定义，同时也不能加static关键字 */ int arr[ListNum][ItemNum]; 不允许使用void数组 c void arr[20];//非法定义，因为无法知道开辟空间的大小 ","date":"2024-01-01","objectID":"/posts/program/:1:9","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#遇到的困难与学到的经验"},{"categories":["Tech"],"content":" 遇到的困难与学到的经验 编译关系复杂，各种头文件相互包含导致类型重定义或者定义冲突 理清编译关系，在项目之前做好文件规划，划分各文件的职责 注意头文件引用顺序 Keil编译器有问题，有时候类型符合的赋值编译器不通过，必须类型强转才可编译通过。再或者，虽然已经定义了条件编译但还是对循环引用的头文件报错，这时就需要考虑编译器的问题了，Keil失效的通常的现象和解决办法： 一般出现编译器问题的条件是：当一个错误卡住了很长时间，并且确定这段代码没有错误，而且当按照编译器的提示将这段代码彻底的进行修改后会爆出更多error，这时就可以考虑是编译器的问题了(在写下这篇文章两年后的视角来看，应该是右值类型转换时缺失volatile关键字) 2024-01-05_22-35 2024-01-05_22-36 2024-01-05_22-37 2024-01-05_22-33 所有可能的解决办法都失效了，可以考虑是Keil的问题 待补充 警告 c void prvIdleTask( void *p_arg ) { /* 永远不要在空闲任务里加入阻塞或者死循环！！！！！！！！！！！！！！！ 否则当其他任务优先级为0时，空闲任务会霸占整个时间片(没有设置时间片流转和抢占式调度的话)*/ // for( ;; ) // { // flagIdle = 1; // flag1 = 0; // flag2 = 0; // } } 因为在第十章已经实现支持多优先级了，且Task1，Task2优先级均大于0，因此此时空闲任务内可以加循环 遇到调不出来的Bug不要怕，解决方法如下 保持一个清醒的状态 快速定位问题的大概位置 在Bug大概位置处逐步调试 c void tickconst(int tick) { const int consttick = tick; printf(\"%d\\n\",consttick); } // void tickstatic(int tick) // { // static int statictick = tick;//static不能被变量赋值 // printf(\"%d\\n\",statictick); // } int main() { int i = 0; for(i=0; i\u003c10; i++) { tickconst(i);//const的值可以在定义的时候被修改，但不能在其他地方被修改，也就是说，const可以被变量赋值` } return 0; } 在时基函数调用时会用到 c /* 负责进入增加时基，任务时间自减的函数，定义在Config.h: #define xPortSysTickHandler SysTick_Handler 也就是按配置的重装器和主频来触发 */ void xPortSysTickHandler( void ) { uint32_t ISRreturn; /* 关中断 */ //使用的是能在中断中使用的函数会如何？无影响,第九章实验现象可以完成，但是因为SysTick优先级过低而无用 ISRreturn = portSET_INTERRUPT_MASK_FROM_ISR(); /* 更新系统时基 */ //xTaskIncrementTick(); xSemaphoreIncrementTick(); if(xTaskIncrementTick() != pdFALSE) { taskYIELD(); } /* 开中断 */ portCLEAR_INTERRUPT_MASK_FROM_ISR(ISRreturn); // vPortRaiseBASEPRI(); // xTaskIncrementTick(); // vPortClearBASEPRIFromISR(); } 核心的自增函数 c BaseType_t xTaskIncrementTick( void ) { TCB_t *pxTCB = NULL; // BaseType_t i = 0; TickType_t xItemValue; BaseType_t xSwitchRequired = pdFALSE; /* 更新系统时基计数器 xTickCount,xTickCount 是一个在 port.c 中定义的全局变量 */ const TickType_t xConstTickCount = xTickCount + 1;//常量赋值？是的，const可以被在定义时被变量赋值 xTickCount = xConstTickCount; ... } xTickCount与xConstTickCount变量相互依赖而不写成xTickCount++的原因是后者的写法可能会导致静态条件的出现，而前者即使没有加锁也可以保证xTickCount是原子加的 并且taskYIELD本质上也是操作PendSV c #define taskYIELD() portYIELD() /* 触发 PendSV,产生上下文切换 */ #define portYIELD() \\ { \\ portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \\ __dsb( portSY_FULL_READ_WRITE ); \\ __isb( portSY_FULL_READ_WRITE ); \\ } c #include int a = 4; int b = 5; //宏定义地址交换会修改值，这是因为函数宏定义不会产生栈 #define swapdef(addra,addrb)\\ {\\ int *temp;\\ temp = a;\\ a = b;\\ b = temp;\\ } //地址交换不会修改值 void swapadd(int* a,int* b) { int* temp; temp = a; a = b; b = temp; } void swapnum(int* a,int* b) { int temp; temp = *a; *a = *b; *b = temp; } int main() { printf(\"原值=%d %d\\n\",a,b); swapdef(\u0026a,\u0026b); printf(\"宏地址交换=%d %d\\n\",a,b); swapadd(\u0026a,\u0026b); printf(\"函数地址交换=%d %d\\n\",a,b); swapnum(\u0026a,\u0026b); printf(\"指针地址解引用交换=%d %d\\n\",a,b); a = 6; printf(\"%d %d\\n\",a,b); return 0; } 2024-01-11_20-48 警告 堆栈太小可能会导致程序停止在HardFault int (*array)[20] 与 int *arrary[20]的不同前者代表一个指向具有20个整型元素数组的指针，后者代表一个具有20个指针元素的数组 宏定义函数 为什么要使用宏定义函数？ 宏定义函数可以在预编译阶段直接展开，省下了压栈出栈的资源 那他与内联函数的区别是什么？ 宏定义函数只做展开和替换，不检查参数类型。而内联函数需要检查参数类型 C99特性在keil中可以在“魔术棒”的C/C++设置C99模式，指定后可以在非全局作用域下定义不定长数组(vla) c #define ListNum 5//只能使用宏定义，变量赋值也不行 #define ItemNum 10 /* 不能在全局作用域下定义，同时也不能加static关键字 */ int arr[ListNum][ItemNum]; 不允许使用void数组 c void arr[20];//非法定义，因为无法知道开辟空间的大小 ","date":"2024-01-01","objectID":"/posts/program/:1:9","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#int-array20-与-int-arrary20的不同"},{"categories":["Tech"],"content":" 遇到的困难与学到的经验 编译关系复杂，各种头文件相互包含导致类型重定义或者定义冲突 理清编译关系，在项目之前做好文件规划，划分各文件的职责 注意头文件引用顺序 Keil编译器有问题，有时候类型符合的赋值编译器不通过，必须类型强转才可编译通过。再或者，虽然已经定义了条件编译但还是对循环引用的头文件报错，这时就需要考虑编译器的问题了，Keil失效的通常的现象和解决办法： 一般出现编译器问题的条件是：当一个错误卡住了很长时间，并且确定这段代码没有错误，而且当按照编译器的提示将这段代码彻底的进行修改后会爆出更多error，这时就可以考虑是编译器的问题了(在写下这篇文章两年后的视角来看，应该是右值类型转换时缺失volatile关键字) 2024-01-05_22-35 2024-01-05_22-36 2024-01-05_22-37 2024-01-05_22-33 所有可能的解决办法都失效了，可以考虑是Keil的问题 待补充 警告 c void prvIdleTask( void *p_arg ) { /* 永远不要在空闲任务里加入阻塞或者死循环！！！！！！！！！！！！！！！ 否则当其他任务优先级为0时，空闲任务会霸占整个时间片(没有设置时间片流转和抢占式调度的话)*/ // for( ;; ) // { // flagIdle = 1; // flag1 = 0; // flag2 = 0; // } } 因为在第十章已经实现支持多优先级了，且Task1，Task2优先级均大于0，因此此时空闲任务内可以加循环 遇到调不出来的Bug不要怕，解决方法如下 保持一个清醒的状态 快速定位问题的大概位置 在Bug大概位置处逐步调试 c void tickconst(int tick) { const int consttick = tick; printf(\"%d\\n\",consttick); } // void tickstatic(int tick) // { // static int statictick = tick;//static不能被变量赋值 // printf(\"%d\\n\",statictick); // } int main() { int i = 0; for(i=0; i\u003c10; i++) { tickconst(i);//const的值可以在定义的时候被修改，但不能在其他地方被修改，也就是说，const可以被变量赋值` } return 0; } 在时基函数调用时会用到 c /* 负责进入增加时基，任务时间自减的函数，定义在Config.h: #define xPortSysTickHandler SysTick_Handler 也就是按配置的重装器和主频来触发 */ void xPortSysTickHandler( void ) { uint32_t ISRreturn; /* 关中断 */ //使用的是能在中断中使用的函数会如何？无影响,第九章实验现象可以完成，但是因为SysTick优先级过低而无用 ISRreturn = portSET_INTERRUPT_MASK_FROM_ISR(); /* 更新系统时基 */ //xTaskIncrementTick(); xSemaphoreIncrementTick(); if(xTaskIncrementTick() != pdFALSE) { taskYIELD(); } /* 开中断 */ portCLEAR_INTERRUPT_MASK_FROM_ISR(ISRreturn); // vPortRaiseBASEPRI(); // xTaskIncrementTick(); // vPortClearBASEPRIFromISR(); } 核心的自增函数 c BaseType_t xTaskIncrementTick( void ) { TCB_t *pxTCB = NULL; // BaseType_t i = 0; TickType_t xItemValue; BaseType_t xSwitchRequired = pdFALSE; /* 更新系统时基计数器 xTickCount,xTickCount 是一个在 port.c 中定义的全局变量 */ const TickType_t xConstTickCount = xTickCount + 1;//常量赋值？是的，const可以被在定义时被变量赋值 xTickCount = xConstTickCount; ... } xTickCount与xConstTickCount变量相互依赖而不写成xTickCount++的原因是后者的写法可能会导致静态条件的出现，而前者即使没有加锁也可以保证xTickCount是原子加的 并且taskYIELD本质上也是操作PendSV c #define taskYIELD() portYIELD() /* 触发 PendSV,产生上下文切换 */ #define portYIELD() \\ { \\ portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \\ __dsb( portSY_FULL_READ_WRITE ); \\ __isb( portSY_FULL_READ_WRITE ); \\ } c #include int a = 4; int b = 5; //宏定义地址交换会修改值，这是因为函数宏定义不会产生栈 #define swapdef(addra,addrb)\\ {\\ int *temp;\\ temp = a;\\ a = b;\\ b = temp;\\ } //地址交换不会修改值 void swapadd(int* a,int* b) { int* temp; temp = a; a = b; b = temp; } void swapnum(int* a,int* b) { int temp; temp = *a; *a = *b; *b = temp; } int main() { printf(\"原值=%d %d\\n\",a,b); swapdef(\u0026a,\u0026b); printf(\"宏地址交换=%d %d\\n\",a,b); swapadd(\u0026a,\u0026b); printf(\"函数地址交换=%d %d\\n\",a,b); swapnum(\u0026a,\u0026b); printf(\"指针地址解引用交换=%d %d\\n\",a,b); a = 6; printf(\"%d %d\\n\",a,b); return 0; } 2024-01-11_20-48 警告 堆栈太小可能会导致程序停止在HardFault int (*array)[20] 与 int *arrary[20]的不同前者代表一个指向具有20个整型元素数组的指针，后者代表一个具有20个指针元素的数组 宏定义函数 为什么要使用宏定义函数？ 宏定义函数可以在预编译阶段直接展开，省下了压栈出栈的资源 那他与内联函数的区别是什么？ 宏定义函数只做展开和替换，不检查参数类型。而内联函数需要检查参数类型 C99特性在keil中可以在“魔术棒”的C/C++设置C99模式，指定后可以在非全局作用域下定义不定长数组(vla) c #define ListNum 5//只能使用宏定义，变量赋值也不行 #define ItemNum 10 /* 不能在全局作用域下定义，同时也不能加static关键字 */ int arr[ListNum][ItemNum]; 不允许使用void数组 c void arr[20];//非法定义，因为无法知道开辟空间的大小 ","date":"2024-01-01","objectID":"/posts/program/:1:9","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#宏定义函数"},{"categories":["Tech"],"content":" 遇到的困难与学到的经验 编译关系复杂，各种头文件相互包含导致类型重定义或者定义冲突 理清编译关系，在项目之前做好文件规划，划分各文件的职责 注意头文件引用顺序 Keil编译器有问题，有时候类型符合的赋值编译器不通过，必须类型强转才可编译通过。再或者，虽然已经定义了条件编译但还是对循环引用的头文件报错，这时就需要考虑编译器的问题了，Keil失效的通常的现象和解决办法： 一般出现编译器问题的条件是：当一个错误卡住了很长时间，并且确定这段代码没有错误，而且当按照编译器的提示将这段代码彻底的进行修改后会爆出更多error，这时就可以考虑是编译器的问题了(在写下这篇文章两年后的视角来看，应该是右值类型转换时缺失volatile关键字) 2024-01-05_22-35 2024-01-05_22-36 2024-01-05_22-37 2024-01-05_22-33 所有可能的解决办法都失效了，可以考虑是Keil的问题 待补充 警告 c void prvIdleTask( void *p_arg ) { /* 永远不要在空闲任务里加入阻塞或者死循环！！！！！！！！！！！！！！！ 否则当其他任务优先级为0时，空闲任务会霸占整个时间片(没有设置时间片流转和抢占式调度的话)*/ // for( ;; ) // { // flagIdle = 1; // flag1 = 0; // flag2 = 0; // } } 因为在第十章已经实现支持多优先级了，且Task1，Task2优先级均大于0，因此此时空闲任务内可以加循环 遇到调不出来的Bug不要怕，解决方法如下 保持一个清醒的状态 快速定位问题的大概位置 在Bug大概位置处逐步调试 c void tickconst(int tick) { const int consttick = tick; printf(\"%d\\n\",consttick); } // void tickstatic(int tick) // { // static int statictick = tick;//static不能被变量赋值 // printf(\"%d\\n\",statictick); // } int main() { int i = 0; for(i=0; i\u003c10; i++) { tickconst(i);//const的值可以在定义的时候被修改，但不能在其他地方被修改，也就是说，const可以被变量赋值` } return 0; } 在时基函数调用时会用到 c /* 负责进入增加时基，任务时间自减的函数，定义在Config.h: #define xPortSysTickHandler SysTick_Handler 也就是按配置的重装器和主频来触发 */ void xPortSysTickHandler( void ) { uint32_t ISRreturn; /* 关中断 */ //使用的是能在中断中使用的函数会如何？无影响,第九章实验现象可以完成，但是因为SysTick优先级过低而无用 ISRreturn = portSET_INTERRUPT_MASK_FROM_ISR(); /* 更新系统时基 */ //xTaskIncrementTick(); xSemaphoreIncrementTick(); if(xTaskIncrementTick() != pdFALSE) { taskYIELD(); } /* 开中断 */ portCLEAR_INTERRUPT_MASK_FROM_ISR(ISRreturn); // vPortRaiseBASEPRI(); // xTaskIncrementTick(); // vPortClearBASEPRIFromISR(); } 核心的自增函数 c BaseType_t xTaskIncrementTick( void ) { TCB_t *pxTCB = NULL; // BaseType_t i = 0; TickType_t xItemValue; BaseType_t xSwitchRequired = pdFALSE; /* 更新系统时基计数器 xTickCount,xTickCount 是一个在 port.c 中定义的全局变量 */ const TickType_t xConstTickCount = xTickCount + 1;//常量赋值？是的，const可以被在定义时被变量赋值 xTickCount = xConstTickCount; ... } xTickCount与xConstTickCount变量相互依赖而不写成xTickCount++的原因是后者的写法可能会导致静态条件的出现，而前者即使没有加锁也可以保证xTickCount是原子加的 并且taskYIELD本质上也是操作PendSV c #define taskYIELD() portYIELD() /* 触发 PendSV,产生上下文切换 */ #define portYIELD() \\ { \\ portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \\ __dsb( portSY_FULL_READ_WRITE ); \\ __isb( portSY_FULL_READ_WRITE ); \\ } c #include int a = 4; int b = 5; //宏定义地址交换会修改值，这是因为函数宏定义不会产生栈 #define swapdef(addra,addrb)\\ {\\ int *temp;\\ temp = a;\\ a = b;\\ b = temp;\\ } //地址交换不会修改值 void swapadd(int* a,int* b) { int* temp; temp = a; a = b; b = temp; } void swapnum(int* a,int* b) { int temp; temp = *a; *a = *b; *b = temp; } int main() { printf(\"原值=%d %d\\n\",a,b); swapdef(\u0026a,\u0026b); printf(\"宏地址交换=%d %d\\n\",a,b); swapadd(\u0026a,\u0026b); printf(\"函数地址交换=%d %d\\n\",a,b); swapnum(\u0026a,\u0026b); printf(\"指针地址解引用交换=%d %d\\n\",a,b); a = 6; printf(\"%d %d\\n\",a,b); return 0; } 2024-01-11_20-48 警告 堆栈太小可能会导致程序停止在HardFault int (*array)[20] 与 int *arrary[20]的不同前者代表一个指向具有20个整型元素数组的指针，后者代表一个具有20个指针元素的数组 宏定义函数 为什么要使用宏定义函数？ 宏定义函数可以在预编译阶段直接展开，省下了压栈出栈的资源 那他与内联函数的区别是什么？ 宏定义函数只做展开和替换，不检查参数类型。而内联函数需要检查参数类型 C99特性在keil中可以在“魔术棒”的C/C++设置C99模式，指定后可以在非全局作用域下定义不定长数组(vla) c #define ListNum 5//只能使用宏定义，变量赋值也不行 #define ItemNum 10 /* 不能在全局作用域下定义，同时也不能加static关键字 */ int arr[ListNum][ItemNum]; 不允许使用void数组 c void arr[20];//非法定义，因为无法知道开辟空间的大小 ","date":"2024-01-01","objectID":"/posts/program/:1:9","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#c99特性"},{"categories":["Tech"],"content":" 遇到的困难与学到的经验 编译关系复杂，各种头文件相互包含导致类型重定义或者定义冲突 理清编译关系，在项目之前做好文件规划，划分各文件的职责 注意头文件引用顺序 Keil编译器有问题，有时候类型符合的赋值编译器不通过，必须类型强转才可编译通过。再或者，虽然已经定义了条件编译但还是对循环引用的头文件报错，这时就需要考虑编译器的问题了，Keil失效的通常的现象和解决办法： 一般出现编译器问题的条件是：当一个错误卡住了很长时间，并且确定这段代码没有错误，而且当按照编译器的提示将这段代码彻底的进行修改后会爆出更多error，这时就可以考虑是编译器的问题了(在写下这篇文章两年后的视角来看，应该是右值类型转换时缺失volatile关键字) 2024-01-05_22-35 2024-01-05_22-36 2024-01-05_22-37 2024-01-05_22-33 所有可能的解决办法都失效了，可以考虑是Keil的问题 待补充 警告 c void prvIdleTask( void *p_arg ) { /* 永远不要在空闲任务里加入阻塞或者死循环！！！！！！！！！！！！！！！ 否则当其他任务优先级为0时，空闲任务会霸占整个时间片(没有设置时间片流转和抢占式调度的话)*/ // for( ;; ) // { // flagIdle = 1; // flag1 = 0; // flag2 = 0; // } } 因为在第十章已经实现支持多优先级了，且Task1，Task2优先级均大于0，因此此时空闲任务内可以加循环 遇到调不出来的Bug不要怕，解决方法如下 保持一个清醒的状态 快速定位问题的大概位置 在Bug大概位置处逐步调试 c void tickconst(int tick) { const int consttick = tick; printf(\"%d\\n\",consttick); } // void tickstatic(int tick) // { // static int statictick = tick;//static不能被变量赋值 // printf(\"%d\\n\",statictick); // } int main() { int i = 0; for(i=0; i\u003c10; i++) { tickconst(i);//const的值可以在定义的时候被修改，但不能在其他地方被修改，也就是说，const可以被变量赋值` } return 0; } 在时基函数调用时会用到 c /* 负责进入增加时基，任务时间自减的函数，定义在Config.h: #define xPortSysTickHandler SysTick_Handler 也就是按配置的重装器和主频来触发 */ void xPortSysTickHandler( void ) { uint32_t ISRreturn; /* 关中断 */ //使用的是能在中断中使用的函数会如何？无影响,第九章实验现象可以完成，但是因为SysTick优先级过低而无用 ISRreturn = portSET_INTERRUPT_MASK_FROM_ISR(); /* 更新系统时基 */ //xTaskIncrementTick(); xSemaphoreIncrementTick(); if(xTaskIncrementTick() != pdFALSE) { taskYIELD(); } /* 开中断 */ portCLEAR_INTERRUPT_MASK_FROM_ISR(ISRreturn); // vPortRaiseBASEPRI(); // xTaskIncrementTick(); // vPortClearBASEPRIFromISR(); } 核心的自增函数 c BaseType_t xTaskIncrementTick( void ) { TCB_t *pxTCB = NULL; // BaseType_t i = 0; TickType_t xItemValue; BaseType_t xSwitchRequired = pdFALSE; /* 更新系统时基计数器 xTickCount,xTickCount 是一个在 port.c 中定义的全局变量 */ const TickType_t xConstTickCount = xTickCount + 1;//常量赋值？是的，const可以被在定义时被变量赋值 xTickCount = xConstTickCount; ... } xTickCount与xConstTickCount变量相互依赖而不写成xTickCount++的原因是后者的写法可能会导致静态条件的出现，而前者即使没有加锁也可以保证xTickCount是原子加的 并且taskYIELD本质上也是操作PendSV c #define taskYIELD() portYIELD() /* 触发 PendSV,产生上下文切换 */ #define portYIELD() \\ { \\ portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \\ __dsb( portSY_FULL_READ_WRITE ); \\ __isb( portSY_FULL_READ_WRITE ); \\ } c #include int a = 4; int b = 5; //宏定义地址交换会修改值，这是因为函数宏定义不会产生栈 #define swapdef(addra,addrb)\\ {\\ int *temp;\\ temp = a;\\ a = b;\\ b = temp;\\ } //地址交换不会修改值 void swapadd(int* a,int* b) { int* temp; temp = a; a = b; b = temp; } void swapnum(int* a,int* b) { int temp; temp = *a; *a = *b; *b = temp; } int main() { printf(\"原值=%d %d\\n\",a,b); swapdef(\u0026a,\u0026b); printf(\"宏地址交换=%d %d\\n\",a,b); swapadd(\u0026a,\u0026b); printf(\"函数地址交换=%d %d\\n\",a,b); swapnum(\u0026a,\u0026b); printf(\"指针地址解引用交换=%d %d\\n\",a,b); a = 6; printf(\"%d %d\\n\",a,b); return 0; } 2024-01-11_20-48 警告 堆栈太小可能会导致程序停止在HardFault int (*array)[20] 与 int *arrary[20]的不同前者代表一个指向具有20个整型元素数组的指针，后者代表一个具有20个指针元素的数组 宏定义函数 为什么要使用宏定义函数？ 宏定义函数可以在预编译阶段直接展开，省下了压栈出栈的资源 那他与内联函数的区别是什么？ 宏定义函数只做展开和替换，不检查参数类型。而内联函数需要检查参数类型 C99特性在keil中可以在“魔术棒”的C/C++设置C99模式，指定后可以在非全局作用域下定义不定长数组(vla) c #define ListNum 5//只能使用宏定义，变量赋值也不行 #define ItemNum 10 /* 不能在全局作用域下定义，同时也不能加static关键字 */ int arr[ListNum][ItemNum]; 不允许使用void数组 c void arr[20];//非法定义，因为无法知道开辟空间的大小 ","date":"2024-01-01","objectID":"/posts/program/:1:9","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#不允许使用void数组"},{"categories":["Tech"],"content":" 电子产品量产工具","date":"2024-01-01","objectID":"/posts/program/:2:0","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#电子产品量产工具"},{"categories":["Tech"],"content":" 调试经验 信息 善用printf和printk，尤其利用好 __FILE__，__FUNCTION__，__LINE__这三个宏 不要忽略编译器的警告，否则可能出现逻辑问题，在下图中，编译器的警告是“变量未初始化”，这是因为在错误的那行得到的是地址而不是值 2024-02-06_22-58 c /* 中间层，只进行数据的上报和汇总 */ static int InputGetEvent(pInputEvent pevent) { InputEvent event; int ret; pthread_mutex_lock(\u0026g_tMutex); if(GetEventBuf(\u0026event))//得到的不是InputEventbuf[iread]的数据，而是InputEventbuf[iread]的地址 { *pevent = event; pthread_mutex_unlock(\u0026g_tMutex); return 0; } /* ... */ } static int GetEventBuf(pInputEvent pEvent) { if(!DataEmpty()) { pEvent = \u0026InputEventbuf[iread];//错误，修改的只是栈中的pEvent，而对想要修改的pEvent没进行任何操作 //*pEvent = InputEventbuf[iread];//正确，通过地址的方式修改的pEvent iread = (iread + 1) % BUF_LEN; return 1; } else { return 0; } } ","date":"2024-01-01","objectID":"/posts/program/:2:1","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#调试经验"},{"categories":["Tech"],"content":" 头文件交叉包含解决办法解决办法：将引起交叉包含的那部分内容提取出来，统一放在common.h的文件中，然后再包含common.h并排除冲突的头文件即可 sscanf可以处理复杂字符串 c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e int main() { int day, year; char weekday[20], month[20], dtm[100]; strcpy( dtm, \"Saturday March 25 1989\" ); sscanf( dtm, \"%s %s %d %d\", weekday, month, \u0026day, \u0026year ); printf(\"%s %d, %d = %s\\n\", month, day, year, weekday ); return(0); } ","date":"2024-01-01","objectID":"/posts/program/:2:2","series":null,"tags":["Tech"],"title":"项目","uri":"/posts/program/#头文件交叉包含解决办法"},{"categories":["Tech"],"content":"一些嵌入式软件工程师常用的知识点，以体系结构，OS和编译器为主要内容 ","date":"2023-12-24","objectID":"/posts/miscs/:0:0","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#"},{"categories":["Tech"],"content":" 杂项","date":"2023-12-24","objectID":"/posts/miscs/:0:0","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#杂项"},{"categories":["Tech"],"content":" 硬件SOC: system on chip 电机会有死区电压，表现为电压很低时电机不能启动，死区电压约占额定电压的10%，此时需要给一PWM占空比最小值从而避免死区电压 2023-12-20_22-20 处于三相电PWM调功率中的开关器件(如IGBT)，换相时为防止三相电任意上半桥和下半桥同时开启导致短路，我们要给死区时间，一般会占整个周期的百分之几，但当PWM占空比极小时，死区时间就会产生很大影响，最终影响输出纹波 常量保存在Flash里，全局初始化非零的变量保存在SRAM的.data段内，静态变量或者全局初始化为零的变量保存在.bss段内。函数和函数内的局部变量保存在栈上需要注意的是，.bss段内部在运行时不一定始终保持为0。例如如下代码 c int a[10] = {1, 2}; // 全局数组，未初始化 → .bss int main() { int num； scanf(\"%d\", \u0026num); // 运行时输入赋值 if (num == 3) { a[5] = 4; // 运行时修改 } return 0; } 编译链接完成后，数组a的内存存放方式为：a[0]，a[1]存放在.data，a[2]~a[9]位于.bss段，当输入的num==3时，.bss段内的a[5]的值被更改为4 尽量把数据保存在栈上，这样防止产生内存安全问题，并且栈上访问数据速度更快 栈是从高地址向低地址增长，堆是从低地址向高地址增长 2024-04-09_15-12 2024-04-09_10-34 操作Flash前需要关中断 计算机底层是小端存储的原因是在C程序员眼里，小端更符合直觉，在不定长的int，char中可以相互转换而不改变变量值(变量长度小于int和char的最小值的情况下)，但是对于传输协议来说，大部分为定长字段传输，而大端存储更符合从左至右的阅读习惯，因此传输协议常使用大端 ","date":"2023-12-24","objectID":"/posts/miscs/:1:0","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#硬件"},{"categories":["Tech"],"content":" 编译器、C与内核","date":"2023-12-24","objectID":"/posts/miscs/:2:0","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#编译器c与内核"},{"categories":["Tech"],"content":" 编译器编译器通过前端处理将源文件转换为中间文件，这一步主要进行语法语义检查，而后通过优化器将中间文件进行代码优化，最后由后端将优化后的代码翻译成机器码 由于gcc的模块化处理的并不好，一个开源的编译器框架就诞生了，这就是LLVM。有了LLVM，我们就可以自己设计语言，只要把设计的语言转换为LLVM能识别的IR中间代码即可，剩下的LLVM会自动处理。Clang编译器就是通过LLVM框架开发出来的 ","date":"2023-12-24","objectID":"/posts/miscs/:2:1","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#编译器"},{"categories":["Tech"],"content":" GNU工具链GNU工具集：binutils tools，其中包括 readelf：查看二进制文件的各个段的信息 objdump：2进制转16进制，常用于反汇编，当然也可以用来查看文件信息 objcopy：段的复制 ","date":"2023-12-24","objectID":"/posts/miscs/:2:2","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#gnu工具链"},{"categories":["Tech"],"content":" GCC特性 结构体初始化在Linux内核中会经常看到如下结构体初始化方式： c static struct file_operations led_drv = { .owner = THIS_MODULE, .open = led_drv_open, .read = led_drv_read, .write = led_drv_write, .release = led_drv_close, }; 这里利用了GCC编译器的特性，即采用结构体位域的注册方式，当一个结构体有许多成员时这样注册可以避将所有成员都注册一遍，那样的话注册file_operations就太繁琐了 语句表达式({ /* do something */ })：语句表达式，其值等于最后一行代码 c #define MAX(X,Y) ({\\ int x=X;\\ int y=Y;\\ x\u003ey?x:y;}) MAX(X,Y)的值就是三目运算的结果 ","date":"2023-12-24","objectID":"/posts/miscs/:2:3","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#gcc特性"},{"categories":["Tech"],"content":" GCC特性 结构体初始化在Linux内核中会经常看到如下结构体初始化方式： c static struct file_operations led_drv = { .owner = THIS_MODULE, .open = led_drv_open, .read = led_drv_read, .write = led_drv_write, .release = led_drv_close, }; 这里利用了GCC编译器的特性，即采用结构体位域的注册方式，当一个结构体有许多成员时这样注册可以避将所有成员都注册一遍，那样的话注册file_operations就太繁琐了 语句表达式({ /* do something */ })：语句表达式，其值等于最后一行代码 c #define MAX(X,Y) ({\\ int x=X;\\ int y=Y;\\ x\u003ey?x:y;}) MAX(X,Y)的值就是三目运算的结果 ","date":"2023-12-24","objectID":"/posts/miscs/:2:3","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#结构体初始化"},{"categories":["Tech"],"content":" GCC特性 结构体初始化在Linux内核中会经常看到如下结构体初始化方式： c static struct file_operations led_drv = { .owner = THIS_MODULE, .open = led_drv_open, .read = led_drv_read, .write = led_drv_write, .release = led_drv_close, }; 这里利用了GCC编译器的特性，即采用结构体位域的注册方式，当一个结构体有许多成员时这样注册可以避将所有成员都注册一遍，那样的话注册file_operations就太繁琐了 语句表达式({ /* do something */ })：语句表达式，其值等于最后一行代码 c #define MAX(X,Y) ({\\ int x=X;\\ int y=Y;\\ x\u003ey?x:y;}) MAX(X,Y)的值就是三目运算的结果 ","date":"2023-12-24","objectID":"/posts/miscs/:2:3","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#语句表达式"},{"categories":["Tech"],"content":" 链接链接过程包括：地址和空间分配，符号决议和重定位 编译阶段时，具体的函数，变量地址并未确定，每个需要重定位的地方称为重定位入口，因此还需要链接器在链接阶段进行变量，函数的重定位，这样就可以获得程序的加载地址了 产生的.bss段在文件中并不占用可执行文件的空间，.bss只声明在运行程序时需要所占内存的大小，在运行阶段由加载器解析bss段后分配内存空间 2024-03-19_21-25 编译产生的文件被称为目标文件，其包括可执行文件(linux的elf，或者unix的out)，动态链接库文件以及静态链接库(这两位也是按可执行文件格式存储的) .comment保存的是编译器和系统版本信息，这些信息也是只读的 符号表的段：.symtab 链接时最后的exit()函数负责清理收尾工作，如果要自己重定位main函数入口的话，那么在程序最后就不能使用return了，否则会导致段错误 section header table位于文件最后，它记录了各个段的段名，段大小，偏移值等，可以用readelf或objdump来查看 静态链接静态链接重定位过程: 静态链接时，由于各个目标文件的各个段需要合并，因此在合并时需要对一些地址操作进行重定位。需要被重定位的代码被统一放在.rel.text段内，而需要被重定向的数据则需要被放在.rel.data段内，这两段也被称为重定位表。重定位时，在分配好目标文件的空间后，编译器会计算PC与需要重定位的数据或指令的地址偏移量，将计算的结果写入到重定位表后就可以找到对应的数据和地址了 在链接时还需要进强弱符号裁决，这时需要将弱符号放入COMMON块内，这个段放的是未知大小的数据。由于弱符号是声明但未初始化的符号，因此需要放入COMMON块内。当裁决完毕后，所有符号的大小都被确定了，这时放入COMMON块的如果是未初始化全局变量的弱符号，那么就会被放入bss段 在编译C++代码时，还需要做好重复代码消除和构造与析构的操作，在使用模板，虚函数表或者重载时会产生前者的问题，解决办法是在函数/模板名后加_参数类型来避免符号重名。对于构造与析构解决的方法是是加入.init与.fini段，这两个段里的代码会分别在main函数前后阶段执行 elf文件加载过程： 对于静态链接，OS首先调用fork来开辟一个新进程，然后使用execve来调用sys_execve，最后调用do_execve来进行elf文件的装载，下面是do_execve做的事 装载之前要判断elf文件前的魔数从而获得文件格式(待加载文件也有可能是#!开头的脚本文件) 对elf文件各段映射到内存中 初始化可执行文件的环境(调用.init和伴随文件传入的若干参数) 对于静态链接器来说，需要找到e_entry段从而获得可执行文件入口。对于动态链接来说，需要寻找动态链接.interp段从而找到动态链接器的路径(.interp段的内容是链接时被指定的，通过不同工具链个性化.interp段内容，这也是交叉编译工具链的核心原理) 这样当从do_execve函数返回时就得到了elf文件的入口 动态链接动态链接实际上是把链接过程从装载前推迟到了装载时 动态链接特点： 优点 占用空间小，支持cow 可以动态加载程序，这使得程序编写可以模块化，插件化，对于大型工程来说，这使得不同的子模块分别使用不同的语言成为可能 方便程序进行更新升级 缺点 由于每次运行程序都需要重新链接，因此程序性能受到损失，但是可以通过各种优化使得性能损失减少(优化后总损失约5%) 动态加载程序的地址空间中不仅有程序本身，还有依赖的其他动态库，C语言运行库(libc.so)以及动态链接器(ld-2.6.1.so) 有趣的是真正的动态链接器位于内核(或者lib/ld.x.y.z.so)，每个进程里的动态链接器是个软链接，而动态链接器本身是以静态链接的方式加载的 静态链接时的重定位称为链接时重定位，动态链接时重定位称为装载时重定位，也被称为基址重置(Rebasing) 装载时重定位和地址无关码为了实现代码之间的地址无关，即多个进程可以使用同一份内存中的代码(这会造成装载和指令取址的问题)，我们可以通过装载时重定位和地址无关码来解决 动态链接时代码装载时各个指令的地址无法确定，这样会给取指造成一定的困难，动态链接的解决办法是装载时才确定具体的指令地址 装载时重定位：类似于静态链接时的重定位功能，但简单很多。因为程序是整段加载进内存的，不需要考虑像编译阶段那样代码行数和地址操作的改变。所以只需要在地址上统一加上装载时的偏移即可。装载时重定位只考虑了指令和变量的地址安排，但指令具体的地址操作就无能为力了。比如想要取0x80002000地址，对于静态链接这是链接阶段就写好的，而一旦这个地址规定好就只能给一个进程使用了。动态链接的解决办法是让代码段里的代码与地址无关 地址无关码(PIC，Position-independent Code)：既然有的代码是与进程本身相关的，那么把这些代码分离出来的话剩下的代码不就与进程无关了么？这样就可以在进程中共享代码了。分离出来的代码放在哪？既然这部分代码与各自进程相关，那就放在对应进程的数据段。因此，在数据段中又分离出了一个新的段(.got，Global Offset Table)，这个段内放置了一个指向地址相关符号的数组，只要对里面元素进行解引用就可以找到符号地址了，这时操作由地址相关转化为地址无关(.got及其内部符号的位置是编译器规定且知晓的)。.got不仅可以保存本进程的地址相关码，也可以保存其他进程的地址相关码，这样就可以共享全局变量和函数了 由于动态链接会有一定的性能损失，这主要由工程内的大量函数引起(因为全局变量会增加模块耦合度，用的很少)，所以想办法降低模块的函数重定位消耗即可，因此我们还需要在PIC上做一定的改进 延迟绑定(PLT，Procedure Linkage Table)：本质上是在调用函数时才进行重定位和绑定。plt较为复杂，首先它有两个段.rel.plt与.plt，前者本质是个数据段，用于plt的重定向，里面放置了需要重定向的各种符号，.plt段本质是个代码段，用于检测符号是否初始化完成以及跳转到.got段。延迟绑定的过程如下： 程序需要调用函数时需要在.plt段内判断是否被初始化 若未被初始化则需要执行汇编操作，从.rel.plt中获得符号地址并绑定，具体的绑定结果放入.got段内(具体操作也是在.plt段内执行的) 若已经初始化则跳转到.got段内执行相关函数 程序加载后映射时如何使得内存占用最小 无论是动态加载还是静态加载，为了使得内存占用最小。unix将各个段的接壤处不做分割处理，仍然位于同一物理页，但是在映射到虚拟内存的过程中会被映射两次，这样其他程序就可以通过不同的虚拟内存地址找到同一块物理内存，从而可以节省物理内存了 内核模块文件.ko本质上也是动态加载的可重定位目标文件，与普通文件的区别是.ko文件运行在内核空间 强弱符号宅学部落 在一个程序中，无论是变量名，还是函数名，在编译器的眼里，就是一个符号而已。符号可以分为强符号和弱符号 强符号：函数名、初始化的全局变量名，如int i=10 弱符号：未初始化的全局变量名，如int i 对于同名强符号，链接阶段时会被报重定义错误，若强弱符号重名，编译器会优先选择强符号。若弱符号未被定义，则会被编译器初始化为0或NULL(并不严格保证)，因此此时的程序可以过编译链接，但是在运行时可能会得到不正确的结果或段错误 GNU C 通过 __atttribute__ 声明weak属性，可以将一个强符号转换为弱符号 c void __attribute__((weak)) func(void); int num __attribte__((weak); 编译阶段：编译器以源文件为单位，将每一个源文件编译为一个 .o 后缀的目标文件。每一个目标文件由代码段、数据段、符号表等组成 链接阶段：链接器将各个目标文件组装成一个大目标文件。链接器将各个目标文件中的代码段组装在一起，组成一个大的代码段；各个数据段组装在一起，组成一个大的数据段；各个符号表也会集中在一起，组成一个大的符号表。最后再将合并后的代码段、数据段、符号表等组合成一个大的目标文件 重定位：因为各个目标文件重新组装，各个目标文件中的变量、函数的地址都发生了变化，所以要重新修正这些函数、变量的地址，这个过程称为重定位 重定位结束后，就生成了可以在机器上运行的可执行程序 最早的编译器为了支持汇编语言和C的程序可以互相调用，规定了C语言符号前加“_”来避免与汇编语句重名。现代的GCC抛弃了这种做法，但是msvc却保留了。为了支持C++的重载，命名空间不同时支持同名函数的功能，编译器利用了函数名，参数列表和命名空间名称一起修饰符号，从而获得新的符号名 ","date":"2023-12-24","objectID":"/posts/miscs/:2:4","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#链接"},{"categories":["Tech"],"content":" 链接链接过程包括：地址和空间分配，符号决议和重定位 编译阶段时，具体的函数，变量地址并未确定，每个需要重定位的地方称为重定位入口，因此还需要链接器在链接阶段进行变量，函数的重定位，这样就可以获得程序的加载地址了 产生的.bss段在文件中并不占用可执行文件的空间，.bss只声明在运行程序时需要所占内存的大小，在运行阶段由加载器解析bss段后分配内存空间 2024-03-19_21-25 编译产生的文件被称为目标文件，其包括可执行文件(linux的elf，或者unix的out)，动态链接库文件以及静态链接库(这两位也是按可执行文件格式存储的) .comment保存的是编译器和系统版本信息，这些信息也是只读的 符号表的段：.symtab 链接时最后的exit()函数负责清理收尾工作，如果要自己重定位main函数入口的话，那么在程序最后就不能使用return了，否则会导致段错误 section header table位于文件最后，它记录了各个段的段名，段大小，偏移值等，可以用readelf或objdump来查看 静态链接静态链接重定位过程: 静态链接时，由于各个目标文件的各个段需要合并，因此在合并时需要对一些地址操作进行重定位。需要被重定位的代码被统一放在.rel.text段内，而需要被重定向的数据则需要被放在.rel.data段内，这两段也被称为重定位表。重定位时，在分配好目标文件的空间后，编译器会计算PC与需要重定位的数据或指令的地址偏移量，将计算的结果写入到重定位表后就可以找到对应的数据和地址了 在链接时还需要进强弱符号裁决，这时需要将弱符号放入COMMON块内，这个段放的是未知大小的数据。由于弱符号是声明但未初始化的符号，因此需要放入COMMON块内。当裁决完毕后，所有符号的大小都被确定了，这时放入COMMON块的如果是未初始化全局变量的弱符号，那么就会被放入bss段 在编译C++代码时，还需要做好重复代码消除和构造与析构的操作，在使用模板，虚函数表或者重载时会产生前者的问题，解决办法是在函数/模板名后加_参数类型来避免符号重名。对于构造与析构解决的方法是是加入.init与.fini段，这两个段里的代码会分别在main函数前后阶段执行 elf文件加载过程： 对于静态链接，OS首先调用fork来开辟一个新进程，然后使用execve来调用sys_execve，最后调用do_execve来进行elf文件的装载，下面是do_execve做的事 装载之前要判断elf文件前的魔数从而获得文件格式(待加载文件也有可能是#!开头的脚本文件) 对elf文件各段映射到内存中 初始化可执行文件的环境(调用.init和伴随文件传入的若干参数) 对于静态链接器来说，需要找到e_entry段从而获得可执行文件入口。对于动态链接来说，需要寻找动态链接.interp段从而找到动态链接器的路径(.interp段的内容是链接时被指定的，通过不同工具链个性化.interp段内容，这也是交叉编译工具链的核心原理) 这样当从do_execve函数返回时就得到了elf文件的入口 动态链接动态链接实际上是把链接过程从装载前推迟到了装载时 动态链接特点： 优点 占用空间小，支持cow 可以动态加载程序，这使得程序编写可以模块化，插件化，对于大型工程来说，这使得不同的子模块分别使用不同的语言成为可能 方便程序进行更新升级 缺点 由于每次运行程序都需要重新链接，因此程序性能受到损失，但是可以通过各种优化使得性能损失减少(优化后总损失约5%) 动态加载程序的地址空间中不仅有程序本身，还有依赖的其他动态库，C语言运行库(libc.so)以及动态链接器(ld-2.6.1.so) 有趣的是真正的动态链接器位于内核(或者lib/ld.x.y.z.so)，每个进程里的动态链接器是个软链接，而动态链接器本身是以静态链接的方式加载的 静态链接时的重定位称为链接时重定位，动态链接时重定位称为装载时重定位，也被称为基址重置(Rebasing) 装载时重定位和地址无关码为了实现代码之间的地址无关，即多个进程可以使用同一份内存中的代码(这会造成装载和指令取址的问题)，我们可以通过装载时重定位和地址无关码来解决 动态链接时代码装载时各个指令的地址无法确定，这样会给取指造成一定的困难，动态链接的解决办法是装载时才确定具体的指令地址 装载时重定位：类似于静态链接时的重定位功能，但简单很多。因为程序是整段加载进内存的，不需要考虑像编译阶段那样代码行数和地址操作的改变。所以只需要在地址上统一加上装载时的偏移即可。装载时重定位只考虑了指令和变量的地址安排，但指令具体的地址操作就无能为力了。比如想要取0x80002000地址，对于静态链接这是链接阶段就写好的，而一旦这个地址规定好就只能给一个进程使用了。动态链接的解决办法是让代码段里的代码与地址无关 地址无关码(PIC，Position-independent Code)：既然有的代码是与进程本身相关的，那么把这些代码分离出来的话剩下的代码不就与进程无关了么？这样就可以在进程中共享代码了。分离出来的代码放在哪？既然这部分代码与各自进程相关，那就放在对应进程的数据段。因此，在数据段中又分离出了一个新的段(.got，Global Offset Table)，这个段内放置了一个指向地址相关符号的数组，只要对里面元素进行解引用就可以找到符号地址了，这时操作由地址相关转化为地址无关(.got及其内部符号的位置是编译器规定且知晓的)。.got不仅可以保存本进程的地址相关码，也可以保存其他进程的地址相关码，这样就可以共享全局变量和函数了 由于动态链接会有一定的性能损失，这主要由工程内的大量函数引起(因为全局变量会增加模块耦合度，用的很少)，所以想办法降低模块的函数重定位消耗即可，因此我们还需要在PIC上做一定的改进 延迟绑定(PLT，Procedure Linkage Table)：本质上是在调用函数时才进行重定位和绑定。plt较为复杂，首先它有两个段.rel.plt与.plt，前者本质是个数据段，用于plt的重定向，里面放置了需要重定向的各种符号，.plt段本质是个代码段，用于检测符号是否初始化完成以及跳转到.got段。延迟绑定的过程如下： 程序需要调用函数时需要在.plt段内判断是否被初始化 若未被初始化则需要执行汇编操作，从.rel.plt中获得符号地址并绑定，具体的绑定结果放入.got段内(具体操作也是在.plt段内执行的) 若已经初始化则跳转到.got段内执行相关函数 程序加载后映射时如何使得内存占用最小 无论是动态加载还是静态加载，为了使得内存占用最小。unix将各个段的接壤处不做分割处理，仍然位于同一物理页，但是在映射到虚拟内存的过程中会被映射两次，这样其他程序就可以通过不同的虚拟内存地址找到同一块物理内存，从而可以节省物理内存了 内核模块文件.ko本质上也是动态加载的可重定位目标文件，与普通文件的区别是.ko文件运行在内核空间 强弱符号宅学部落 在一个程序中，无论是变量名，还是函数名，在编译器的眼里，就是一个符号而已。符号可以分为强符号和弱符号 强符号：函数名、初始化的全局变量名，如int i=10 弱符号：未初始化的全局变量名，如int i 对于同名强符号，链接阶段时会被报重定义错误，若强弱符号重名，编译器会优先选择强符号。若弱符号未被定义，则会被编译器初始化为0或NULL(并不严格保证)，因此此时的程序可以过编译链接，但是在运行时可能会得到不正确的结果或段错误 GNU C 通过 __atttribute__ 声明weak属性，可以将一个强符号转换为弱符号 c void __attribute__((weak)) func(void); int num __attribte__((weak); 编译阶段：编译器以源文件为单位，将每一个源文件编译为一个 .o 后缀的目标文件。每一个目标文件由代码段、数据段、符号表等组成 链接阶段：链接器将各个目标文件组装成一个大目标文件。链接器将各个目标文件中的代码段组装在一起，组成一个大的代码段；各个数据段组装在一起，组成一个大的数据段；各个符号表也会集中在一起，组成一个大的符号表。最后再将合并后的代码段、数据段、符号表等组合成一个大的目标文件 重定位：因为各个目标文件重新组装，各个目标文件中的变量、函数的地址都发生了变化，所以要重新修正这些函数、变量的地址，这个过程称为重定位 重定位结束后，就生成了可以在机器上运行的可执行程序 最早的编译器为了支持汇编语言和C的程序可以互相调用，规定了C语言符号前加“_”来避免与汇编语句重名。现代的GCC抛弃了这种做法，但是msvc却保留了。为了支持C++的重载，命名空间不同时支持同名函数的功能，编译器利用了函数名，参数列表和命名空间名称一起修饰符号，从而获得新的符号名 ","date":"2023-12-24","objectID":"/posts/miscs/:2:4","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#静态链接"},{"categories":["Tech"],"content":" 链接链接过程包括：地址和空间分配，符号决议和重定位 编译阶段时，具体的函数，变量地址并未确定，每个需要重定位的地方称为重定位入口，因此还需要链接器在链接阶段进行变量，函数的重定位，这样就可以获得程序的加载地址了 产生的.bss段在文件中并不占用可执行文件的空间，.bss只声明在运行程序时需要所占内存的大小，在运行阶段由加载器解析bss段后分配内存空间 2024-03-19_21-25 编译产生的文件被称为目标文件，其包括可执行文件(linux的elf，或者unix的out)，动态链接库文件以及静态链接库(这两位也是按可执行文件格式存储的) .comment保存的是编译器和系统版本信息，这些信息也是只读的 符号表的段：.symtab 链接时最后的exit()函数负责清理收尾工作，如果要自己重定位main函数入口的话，那么在程序最后就不能使用return了，否则会导致段错误 section header table位于文件最后，它记录了各个段的段名，段大小，偏移值等，可以用readelf或objdump来查看 静态链接静态链接重定位过程: 静态链接时，由于各个目标文件的各个段需要合并，因此在合并时需要对一些地址操作进行重定位。需要被重定位的代码被统一放在.rel.text段内，而需要被重定向的数据则需要被放在.rel.data段内，这两段也被称为重定位表。重定位时，在分配好目标文件的空间后，编译器会计算PC与需要重定位的数据或指令的地址偏移量，将计算的结果写入到重定位表后就可以找到对应的数据和地址了 在链接时还需要进强弱符号裁决，这时需要将弱符号放入COMMON块内，这个段放的是未知大小的数据。由于弱符号是声明但未初始化的符号，因此需要放入COMMON块内。当裁决完毕后，所有符号的大小都被确定了，这时放入COMMON块的如果是未初始化全局变量的弱符号，那么就会被放入bss段 在编译C++代码时，还需要做好重复代码消除和构造与析构的操作，在使用模板，虚函数表或者重载时会产生前者的问题，解决办法是在函数/模板名后加_参数类型来避免符号重名。对于构造与析构解决的方法是是加入.init与.fini段，这两个段里的代码会分别在main函数前后阶段执行 elf文件加载过程： 对于静态链接，OS首先调用fork来开辟一个新进程，然后使用execve来调用sys_execve，最后调用do_execve来进行elf文件的装载，下面是do_execve做的事 装载之前要判断elf文件前的魔数从而获得文件格式(待加载文件也有可能是#!开头的脚本文件) 对elf文件各段映射到内存中 初始化可执行文件的环境(调用.init和伴随文件传入的若干参数) 对于静态链接器来说，需要找到e_entry段从而获得可执行文件入口。对于动态链接来说，需要寻找动态链接.interp段从而找到动态链接器的路径(.interp段的内容是链接时被指定的，通过不同工具链个性化.interp段内容，这也是交叉编译工具链的核心原理) 这样当从do_execve函数返回时就得到了elf文件的入口 动态链接动态链接实际上是把链接过程从装载前推迟到了装载时 动态链接特点： 优点 占用空间小，支持cow 可以动态加载程序，这使得程序编写可以模块化，插件化，对于大型工程来说，这使得不同的子模块分别使用不同的语言成为可能 方便程序进行更新升级 缺点 由于每次运行程序都需要重新链接，因此程序性能受到损失，但是可以通过各种优化使得性能损失减少(优化后总损失约5%) 动态加载程序的地址空间中不仅有程序本身，还有依赖的其他动态库，C语言运行库(libc.so)以及动态链接器(ld-2.6.1.so) 有趣的是真正的动态链接器位于内核(或者lib/ld.x.y.z.so)，每个进程里的动态链接器是个软链接，而动态链接器本身是以静态链接的方式加载的 静态链接时的重定位称为链接时重定位，动态链接时重定位称为装载时重定位，也被称为基址重置(Rebasing) 装载时重定位和地址无关码为了实现代码之间的地址无关，即多个进程可以使用同一份内存中的代码(这会造成装载和指令取址的问题)，我们可以通过装载时重定位和地址无关码来解决 动态链接时代码装载时各个指令的地址无法确定，这样会给取指造成一定的困难，动态链接的解决办法是装载时才确定具体的指令地址 装载时重定位：类似于静态链接时的重定位功能，但简单很多。因为程序是整段加载进内存的，不需要考虑像编译阶段那样代码行数和地址操作的改变。所以只需要在地址上统一加上装载时的偏移即可。装载时重定位只考虑了指令和变量的地址安排，但指令具体的地址操作就无能为力了。比如想要取0x80002000地址，对于静态链接这是链接阶段就写好的，而一旦这个地址规定好就只能给一个进程使用了。动态链接的解决办法是让代码段里的代码与地址无关 地址无关码(PIC，Position-independent Code)：既然有的代码是与进程本身相关的，那么把这些代码分离出来的话剩下的代码不就与进程无关了么？这样就可以在进程中共享代码了。分离出来的代码放在哪？既然这部分代码与各自进程相关，那就放在对应进程的数据段。因此，在数据段中又分离出了一个新的段(.got，Global Offset Table)，这个段内放置了一个指向地址相关符号的数组，只要对里面元素进行解引用就可以找到符号地址了，这时操作由地址相关转化为地址无关(.got及其内部符号的位置是编译器规定且知晓的)。.got不仅可以保存本进程的地址相关码，也可以保存其他进程的地址相关码，这样就可以共享全局变量和函数了 由于动态链接会有一定的性能损失，这主要由工程内的大量函数引起(因为全局变量会增加模块耦合度，用的很少)，所以想办法降低模块的函数重定位消耗即可，因此我们还需要在PIC上做一定的改进 延迟绑定(PLT，Procedure Linkage Table)：本质上是在调用函数时才进行重定位和绑定。plt较为复杂，首先它有两个段.rel.plt与.plt，前者本质是个数据段，用于plt的重定向，里面放置了需要重定向的各种符号，.plt段本质是个代码段，用于检测符号是否初始化完成以及跳转到.got段。延迟绑定的过程如下： 程序需要调用函数时需要在.plt段内判断是否被初始化 若未被初始化则需要执行汇编操作，从.rel.plt中获得符号地址并绑定，具体的绑定结果放入.got段内(具体操作也是在.plt段内执行的) 若已经初始化则跳转到.got段内执行相关函数 程序加载后映射时如何使得内存占用最小 无论是动态加载还是静态加载，为了使得内存占用最小。unix将各个段的接壤处不做分割处理，仍然位于同一物理页，但是在映射到虚拟内存的过程中会被映射两次，这样其他程序就可以通过不同的虚拟内存地址找到同一块物理内存，从而可以节省物理内存了 内核模块文件.ko本质上也是动态加载的可重定位目标文件，与普通文件的区别是.ko文件运行在内核空间 强弱符号宅学部落 在一个程序中，无论是变量名，还是函数名，在编译器的眼里，就是一个符号而已。符号可以分为强符号和弱符号 强符号：函数名、初始化的全局变量名，如int i=10 弱符号：未初始化的全局变量名，如int i 对于同名强符号，链接阶段时会被报重定义错误，若强弱符号重名，编译器会优先选择强符号。若弱符号未被定义，则会被编译器初始化为0或NULL(并不严格保证)，因此此时的程序可以过编译链接，但是在运行时可能会得到不正确的结果或段错误 GNU C 通过 __atttribute__ 声明weak属性，可以将一个强符号转换为弱符号 c void __attribute__((weak)) func(void); int num __attribte__((weak); 编译阶段：编译器以源文件为单位，将每一个源文件编译为一个 .o 后缀的目标文件。每一个目标文件由代码段、数据段、符号表等组成 链接阶段：链接器将各个目标文件组装成一个大目标文件。链接器将各个目标文件中的代码段组装在一起，组成一个大的代码段；各个数据段组装在一起，组成一个大的数据段；各个符号表也会集中在一起，组成一个大的符号表。最后再将合并后的代码段、数据段、符号表等组合成一个大的目标文件 重定位：因为各个目标文件重新组装，各个目标文件中的变量、函数的地址都发生了变化，所以要重新修正这些函数、变量的地址，这个过程称为重定位 重定位结束后，就生成了可以在机器上运行的可执行程序 最早的编译器为了支持汇编语言和C的程序可以互相调用，规定了C语言符号前加“_”来避免与汇编语句重名。现代的GCC抛弃了这种做法，但是msvc却保留了。为了支持C++的重载，命名空间不同时支持同名函数的功能，编译器利用了函数名，参数列表和命名空间名称一起修饰符号，从而获得新的符号名 ","date":"2023-12-24","objectID":"/posts/miscs/:2:4","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#动态链接"},{"categories":["Tech"],"content":" 链接链接过程包括：地址和空间分配，符号决议和重定位 编译阶段时，具体的函数，变量地址并未确定，每个需要重定位的地方称为重定位入口，因此还需要链接器在链接阶段进行变量，函数的重定位，这样就可以获得程序的加载地址了 产生的.bss段在文件中并不占用可执行文件的空间，.bss只声明在运行程序时需要所占内存的大小，在运行阶段由加载器解析bss段后分配内存空间 2024-03-19_21-25 编译产生的文件被称为目标文件，其包括可执行文件(linux的elf，或者unix的out)，动态链接库文件以及静态链接库(这两位也是按可执行文件格式存储的) .comment保存的是编译器和系统版本信息，这些信息也是只读的 符号表的段：.symtab 链接时最后的exit()函数负责清理收尾工作，如果要自己重定位main函数入口的话，那么在程序最后就不能使用return了，否则会导致段错误 section header table位于文件最后，它记录了各个段的段名，段大小，偏移值等，可以用readelf或objdump来查看 静态链接静态链接重定位过程: 静态链接时，由于各个目标文件的各个段需要合并，因此在合并时需要对一些地址操作进行重定位。需要被重定位的代码被统一放在.rel.text段内，而需要被重定向的数据则需要被放在.rel.data段内，这两段也被称为重定位表。重定位时，在分配好目标文件的空间后，编译器会计算PC与需要重定位的数据或指令的地址偏移量，将计算的结果写入到重定位表后就可以找到对应的数据和地址了 在链接时还需要进强弱符号裁决，这时需要将弱符号放入COMMON块内，这个段放的是未知大小的数据。由于弱符号是声明但未初始化的符号，因此需要放入COMMON块内。当裁决完毕后，所有符号的大小都被确定了，这时放入COMMON块的如果是未初始化全局变量的弱符号，那么就会被放入bss段 在编译C++代码时，还需要做好重复代码消除和构造与析构的操作，在使用模板，虚函数表或者重载时会产生前者的问题，解决办法是在函数/模板名后加_参数类型来避免符号重名。对于构造与析构解决的方法是是加入.init与.fini段，这两个段里的代码会分别在main函数前后阶段执行 elf文件加载过程： 对于静态链接，OS首先调用fork来开辟一个新进程，然后使用execve来调用sys_execve，最后调用do_execve来进行elf文件的装载，下面是do_execve做的事 装载之前要判断elf文件前的魔数从而获得文件格式(待加载文件也有可能是#!开头的脚本文件) 对elf文件各段映射到内存中 初始化可执行文件的环境(调用.init和伴随文件传入的若干参数) 对于静态链接器来说，需要找到e_entry段从而获得可执行文件入口。对于动态链接来说，需要寻找动态链接.interp段从而找到动态链接器的路径(.interp段的内容是链接时被指定的，通过不同工具链个性化.interp段内容，这也是交叉编译工具链的核心原理) 这样当从do_execve函数返回时就得到了elf文件的入口 动态链接动态链接实际上是把链接过程从装载前推迟到了装载时 动态链接特点： 优点 占用空间小，支持cow 可以动态加载程序，这使得程序编写可以模块化，插件化，对于大型工程来说，这使得不同的子模块分别使用不同的语言成为可能 方便程序进行更新升级 缺点 由于每次运行程序都需要重新链接，因此程序性能受到损失，但是可以通过各种优化使得性能损失减少(优化后总损失约5%) 动态加载程序的地址空间中不仅有程序本身，还有依赖的其他动态库，C语言运行库(libc.so)以及动态链接器(ld-2.6.1.so) 有趣的是真正的动态链接器位于内核(或者lib/ld.x.y.z.so)，每个进程里的动态链接器是个软链接，而动态链接器本身是以静态链接的方式加载的 静态链接时的重定位称为链接时重定位，动态链接时重定位称为装载时重定位，也被称为基址重置(Rebasing) 装载时重定位和地址无关码为了实现代码之间的地址无关，即多个进程可以使用同一份内存中的代码(这会造成装载和指令取址的问题)，我们可以通过装载时重定位和地址无关码来解决 动态链接时代码装载时各个指令的地址无法确定，这样会给取指造成一定的困难，动态链接的解决办法是装载时才确定具体的指令地址 装载时重定位：类似于静态链接时的重定位功能，但简单很多。因为程序是整段加载进内存的，不需要考虑像编译阶段那样代码行数和地址操作的改变。所以只需要在地址上统一加上装载时的偏移即可。装载时重定位只考虑了指令和变量的地址安排，但指令具体的地址操作就无能为力了。比如想要取0x80002000地址，对于静态链接这是链接阶段就写好的，而一旦这个地址规定好就只能给一个进程使用了。动态链接的解决办法是让代码段里的代码与地址无关 地址无关码(PIC，Position-independent Code)：既然有的代码是与进程本身相关的，那么把这些代码分离出来的话剩下的代码不就与进程无关了么？这样就可以在进程中共享代码了。分离出来的代码放在哪？既然这部分代码与各自进程相关，那就放在对应进程的数据段。因此，在数据段中又分离出了一个新的段(.got，Global Offset Table)，这个段内放置了一个指向地址相关符号的数组，只要对里面元素进行解引用就可以找到符号地址了，这时操作由地址相关转化为地址无关(.got及其内部符号的位置是编译器规定且知晓的)。.got不仅可以保存本进程的地址相关码，也可以保存其他进程的地址相关码，这样就可以共享全局变量和函数了 由于动态链接会有一定的性能损失，这主要由工程内的大量函数引起(因为全局变量会增加模块耦合度，用的很少)，所以想办法降低模块的函数重定位消耗即可，因此我们还需要在PIC上做一定的改进 延迟绑定(PLT，Procedure Linkage Table)：本质上是在调用函数时才进行重定位和绑定。plt较为复杂，首先它有两个段.rel.plt与.plt，前者本质是个数据段，用于plt的重定向，里面放置了需要重定向的各种符号，.plt段本质是个代码段，用于检测符号是否初始化完成以及跳转到.got段。延迟绑定的过程如下： 程序需要调用函数时需要在.plt段内判断是否被初始化 若未被初始化则需要执行汇编操作，从.rel.plt中获得符号地址并绑定，具体的绑定结果放入.got段内(具体操作也是在.plt段内执行的) 若已经初始化则跳转到.got段内执行相关函数 程序加载后映射时如何使得内存占用最小 无论是动态加载还是静态加载，为了使得内存占用最小。unix将各个段的接壤处不做分割处理，仍然位于同一物理页，但是在映射到虚拟内存的过程中会被映射两次，这样其他程序就可以通过不同的虚拟内存地址找到同一块物理内存，从而可以节省物理内存了 内核模块文件.ko本质上也是动态加载的可重定位目标文件，与普通文件的区别是.ko文件运行在内核空间 强弱符号宅学部落 在一个程序中，无论是变量名，还是函数名，在编译器的眼里，就是一个符号而已。符号可以分为强符号和弱符号 强符号：函数名、初始化的全局变量名，如int i=10 弱符号：未初始化的全局变量名，如int i 对于同名强符号，链接阶段时会被报重定义错误，若强弱符号重名，编译器会优先选择强符号。若弱符号未被定义，则会被编译器初始化为0或NULL(并不严格保证)，因此此时的程序可以过编译链接，但是在运行时可能会得到不正确的结果或段错误 GNU C 通过 __atttribute__ 声明weak属性，可以将一个强符号转换为弱符号 c void __attribute__((weak)) func(void); int num __attribte__((weak); 编译阶段：编译器以源文件为单位，将每一个源文件编译为一个 .o 后缀的目标文件。每一个目标文件由代码段、数据段、符号表等组成 链接阶段：链接器将各个目标文件组装成一个大目标文件。链接器将各个目标文件中的代码段组装在一起，组成一个大的代码段；各个数据段组装在一起，组成一个大的数据段；各个符号表也会集中在一起，组成一个大的符号表。最后再将合并后的代码段、数据段、符号表等组合成一个大的目标文件 重定位：因为各个目标文件重新组装，各个目标文件中的变量、函数的地址都发生了变化，所以要重新修正这些函数、变量的地址，这个过程称为重定位 重定位结束后，就生成了可以在机器上运行的可执行程序 最早的编译器为了支持汇编语言和C的程序可以互相调用，规定了C语言符号前加“_”来避免与汇编语句重名。现代的GCC抛弃了这种做法，但是msvc却保留了。为了支持C++的重载，命名空间不同时支持同名函数的功能，编译器利用了函数名，参数列表和命名空间名称一起修饰符号，从而获得新的符号名 ","date":"2023-12-24","objectID":"/posts/miscs/:2:4","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#装载时重定位和地址无关码"},{"categories":["Tech"],"content":" 链接链接过程包括：地址和空间分配，符号决议和重定位 编译阶段时，具体的函数，变量地址并未确定，每个需要重定位的地方称为重定位入口，因此还需要链接器在链接阶段进行变量，函数的重定位，这样就可以获得程序的加载地址了 产生的.bss段在文件中并不占用可执行文件的空间，.bss只声明在运行程序时需要所占内存的大小，在运行阶段由加载器解析bss段后分配内存空间 2024-03-19_21-25 编译产生的文件被称为目标文件，其包括可执行文件(linux的elf，或者unix的out)，动态链接库文件以及静态链接库(这两位也是按可执行文件格式存储的) .comment保存的是编译器和系统版本信息，这些信息也是只读的 符号表的段：.symtab 链接时最后的exit()函数负责清理收尾工作，如果要自己重定位main函数入口的话，那么在程序最后就不能使用return了，否则会导致段错误 section header table位于文件最后，它记录了各个段的段名，段大小，偏移值等，可以用readelf或objdump来查看 静态链接静态链接重定位过程: 静态链接时，由于各个目标文件的各个段需要合并，因此在合并时需要对一些地址操作进行重定位。需要被重定位的代码被统一放在.rel.text段内，而需要被重定向的数据则需要被放在.rel.data段内，这两段也被称为重定位表。重定位时，在分配好目标文件的空间后，编译器会计算PC与需要重定位的数据或指令的地址偏移量，将计算的结果写入到重定位表后就可以找到对应的数据和地址了 在链接时还需要进强弱符号裁决，这时需要将弱符号放入COMMON块内，这个段放的是未知大小的数据。由于弱符号是声明但未初始化的符号，因此需要放入COMMON块内。当裁决完毕后，所有符号的大小都被确定了，这时放入COMMON块的如果是未初始化全局变量的弱符号，那么就会被放入bss段 在编译C++代码时，还需要做好重复代码消除和构造与析构的操作，在使用模板，虚函数表或者重载时会产生前者的问题，解决办法是在函数/模板名后加_参数类型来避免符号重名。对于构造与析构解决的方法是是加入.init与.fini段，这两个段里的代码会分别在main函数前后阶段执行 elf文件加载过程： 对于静态链接，OS首先调用fork来开辟一个新进程，然后使用execve来调用sys_execve，最后调用do_execve来进行elf文件的装载，下面是do_execve做的事 装载之前要判断elf文件前的魔数从而获得文件格式(待加载文件也有可能是#!开头的脚本文件) 对elf文件各段映射到内存中 初始化可执行文件的环境(调用.init和伴随文件传入的若干参数) 对于静态链接器来说，需要找到e_entry段从而获得可执行文件入口。对于动态链接来说，需要寻找动态链接.interp段从而找到动态链接器的路径(.interp段的内容是链接时被指定的，通过不同工具链个性化.interp段内容，这也是交叉编译工具链的核心原理) 这样当从do_execve函数返回时就得到了elf文件的入口 动态链接动态链接实际上是把链接过程从装载前推迟到了装载时 动态链接特点： 优点 占用空间小，支持cow 可以动态加载程序，这使得程序编写可以模块化，插件化，对于大型工程来说，这使得不同的子模块分别使用不同的语言成为可能 方便程序进行更新升级 缺点 由于每次运行程序都需要重新链接，因此程序性能受到损失，但是可以通过各种优化使得性能损失减少(优化后总损失约5%) 动态加载程序的地址空间中不仅有程序本身，还有依赖的其他动态库，C语言运行库(libc.so)以及动态链接器(ld-2.6.1.so) 有趣的是真正的动态链接器位于内核(或者lib/ld.x.y.z.so)，每个进程里的动态链接器是个软链接，而动态链接器本身是以静态链接的方式加载的 静态链接时的重定位称为链接时重定位，动态链接时重定位称为装载时重定位，也被称为基址重置(Rebasing) 装载时重定位和地址无关码为了实现代码之间的地址无关，即多个进程可以使用同一份内存中的代码(这会造成装载和指令取址的问题)，我们可以通过装载时重定位和地址无关码来解决 动态链接时代码装载时各个指令的地址无法确定，这样会给取指造成一定的困难，动态链接的解决办法是装载时才确定具体的指令地址 装载时重定位：类似于静态链接时的重定位功能，但简单很多。因为程序是整段加载进内存的，不需要考虑像编译阶段那样代码行数和地址操作的改变。所以只需要在地址上统一加上装载时的偏移即可。装载时重定位只考虑了指令和变量的地址安排，但指令具体的地址操作就无能为力了。比如想要取0x80002000地址，对于静态链接这是链接阶段就写好的，而一旦这个地址规定好就只能给一个进程使用了。动态链接的解决办法是让代码段里的代码与地址无关 地址无关码(PIC，Position-independent Code)：既然有的代码是与进程本身相关的，那么把这些代码分离出来的话剩下的代码不就与进程无关了么？这样就可以在进程中共享代码了。分离出来的代码放在哪？既然这部分代码与各自进程相关，那就放在对应进程的数据段。因此，在数据段中又分离出了一个新的段(.got，Global Offset Table)，这个段内放置了一个指向地址相关符号的数组，只要对里面元素进行解引用就可以找到符号地址了，这时操作由地址相关转化为地址无关(.got及其内部符号的位置是编译器规定且知晓的)。.got不仅可以保存本进程的地址相关码，也可以保存其他进程的地址相关码，这样就可以共享全局变量和函数了 由于动态链接会有一定的性能损失，这主要由工程内的大量函数引起(因为全局变量会增加模块耦合度，用的很少)，所以想办法降低模块的函数重定位消耗即可，因此我们还需要在PIC上做一定的改进 延迟绑定(PLT，Procedure Linkage Table)：本质上是在调用函数时才进行重定位和绑定。plt较为复杂，首先它有两个段.rel.plt与.plt，前者本质是个数据段，用于plt的重定向，里面放置了需要重定向的各种符号，.plt段本质是个代码段，用于检测符号是否初始化完成以及跳转到.got段。延迟绑定的过程如下： 程序需要调用函数时需要在.plt段内判断是否被初始化 若未被初始化则需要执行汇编操作，从.rel.plt中获得符号地址并绑定，具体的绑定结果放入.got段内(具体操作也是在.plt段内执行的) 若已经初始化则跳转到.got段内执行相关函数 程序加载后映射时如何使得内存占用最小 无论是动态加载还是静态加载，为了使得内存占用最小。unix将各个段的接壤处不做分割处理，仍然位于同一物理页，但是在映射到虚拟内存的过程中会被映射两次，这样其他程序就可以通过不同的虚拟内存地址找到同一块物理内存，从而可以节省物理内存了 内核模块文件.ko本质上也是动态加载的可重定位目标文件，与普通文件的区别是.ko文件运行在内核空间 强弱符号宅学部落 在一个程序中，无论是变量名，还是函数名，在编译器的眼里，就是一个符号而已。符号可以分为强符号和弱符号 强符号：函数名、初始化的全局变量名，如int i=10 弱符号：未初始化的全局变量名，如int i 对于同名强符号，链接阶段时会被报重定义错误，若强弱符号重名，编译器会优先选择强符号。若弱符号未被定义，则会被编译器初始化为0或NULL(并不严格保证)，因此此时的程序可以过编译链接，但是在运行时可能会得到不正确的结果或段错误 GNU C 通过 __atttribute__ 声明weak属性，可以将一个强符号转换为弱符号 c void __attribute__((weak)) func(void); int num __attribte__((weak); 编译阶段：编译器以源文件为单位，将每一个源文件编译为一个 .o 后缀的目标文件。每一个目标文件由代码段、数据段、符号表等组成 链接阶段：链接器将各个目标文件组装成一个大目标文件。链接器将各个目标文件中的代码段组装在一起，组成一个大的代码段；各个数据段组装在一起，组成一个大的数据段；各个符号表也会集中在一起，组成一个大的符号表。最后再将合并后的代码段、数据段、符号表等组合成一个大的目标文件 重定位：因为各个目标文件重新组装，各个目标文件中的变量、函数的地址都发生了变化，所以要重新修正这些函数、变量的地址，这个过程称为重定位 重定位结束后，就生成了可以在机器上运行的可执行程序 最早的编译器为了支持汇编语言和C的程序可以互相调用，规定了C语言符号前加“_”来避免与汇编语句重名。现代的GCC抛弃了这种做法，但是msvc却保留了。为了支持C++的重载，命名空间不同时支持同名函数的功能，编译器利用了函数名，参数列表和命名空间名称一起修饰符号，从而获得新的符号名 ","date":"2023-12-24","objectID":"/posts/miscs/:2:4","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#强弱符号"},{"categories":["Tech"],"content":" Linux中的OOP为了最大化实现代码复用和分层分离思想，我们可以采用OOP方法 封装对于设备树来说，为了统一管理成千上万种设备，内核采用了OOP的思想： 首先从所有设备中抽离出kobject对象，这个对象代表了任意一个设备，若干个设备被集合为同一种并被kset对象进行管理，下图中/sys目录下的每一种设备都是kset。因此对于sysfs子系统(也就是/sys目录)来说他有若干个kset组成 2024-04-10_16-31 2024-04-07_16-50 之后device结构体又对kobject进行了封装，但是在封装的过程中又引入了bus_type，device_driver等特性来支持总线设备驱动模型，这完美体现了OOP思想 2024-04-07_17-01 device只是对总线设备驱动模型的一次封装，对于具体的设备类型我们还需要再次封装来实例化device对象，例如对于USB设备驱动来说它有USB状态，速度等特性，因此有了下面的结构体 2024-04-07_17-03 总结： 2024-04-07_17-04 ","date":"2023-12-24","objectID":"/posts/miscs/:2:5","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#linux中的oop"},{"categories":["Tech"],"content":" Linux中的OOP为了最大化实现代码复用和分层分离思想，我们可以采用OOP方法 封装对于设备树来说，为了统一管理成千上万种设备，内核采用了OOP的思想： 首先从所有设备中抽离出kobject对象，这个对象代表了任意一个设备，若干个设备被集合为同一种并被kset对象进行管理，下图中/sys目录下的每一种设备都是kset。因此对于sysfs子系统(也就是/sys目录)来说他有若干个kset组成 2024-04-10_16-31 2024-04-07_16-50 之后device结构体又对kobject进行了封装，但是在封装的过程中又引入了bus_type，device_driver等特性来支持总线设备驱动模型，这完美体现了OOP思想 2024-04-07_17-01 device只是对总线设备驱动模型的一次封装，对于具体的设备类型我们还需要再次封装来实例化device对象，例如对于USB设备驱动来说它有USB状态，速度等特性，因此有了下面的结构体 2024-04-07_17-03 总结： 2024-04-07_17-04 ","date":"2023-12-24","objectID":"/posts/miscs/:2:5","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#封装"},{"categories":["Tech"],"content":" aliasGNU C 扩展了一个 alias 属性，这个属性很简单，主要用来给函数定义一个别名 c void __f(void) { printf(\"__f\\n\"); } void f() __attribute__((alias(\"__f\"))); int main(void) { f(); return 0; } 输出结果： c __f ","date":"2023-12-24","objectID":"/posts/miscs/:2:6","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#alias"},{"categories":["Tech"],"content":" typeofGNU C 扩展了一个关键字 typeof，用来获取一个变量或表达式的类型 c int main(void) { int i = 2; typeof(i) k = 6; int *p = \u0026k; typeof(p) q = \u0026i; printf(\"k = %d\\n\", k); printf(\"*p= %d\\n\", *p); printf(\"i = %d\\n\" ,i); printf(\"*q= %d\\n\", *q); return 0; } 输出结果： c k = 6 *p = 6 i = 2 *q = 2 有了typeof后就可以进行“泛型”编程了(虽然C标准不支持泛型) c //swap支持多种类型的a,b进行交换 //宏内部定义的变量不需要括号保护，输入的变量需要加括号来防止宏展开导致的运算优先级问题 #define swap(a, b) \\ do { \\ typeof(a) __tmp = (a); \\ (a) = (b); \\ (b) = __tmp; \\ } while (0) //内核中的typeof应用 #define min(x, y) ({ \\ typeof(x) _min1 = (x); \\ typeof(y) _min2 = (y); \\ //这里的\u0026_min1 == \u0026_min2两个地址进行比较的意思是：两个指针能够进行比较的前提是类型相同，类型不同的指针进行比较会报需要类型转换的warning，这样就可以通过比较操作来判断出入的参数类型是否相同了 \\ (void) (\u0026_min1 == \u0026_min2); \\ _min1 \u003c _min2 ? _min1 : _min2; }) #define max(x, y) ({ \\ typeof(x) _max1 = (x); \\ typeof(y) _max2 = (y); \\ (void) (\u0026_max1 == \u0026_max2); \\ _max1 \u003e _max2 ? _max1 : _max2; }) ","date":"2023-12-24","objectID":"/posts/miscs/:2:7","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#typeof"},{"categories":["Tech"],"content":" container_of 宏实现 c #define offsetof(TYPE, MEMBER) ((size_t) \u0026((TYPE *)0)-\u003eMEMBER) #define container_of(ptr, type, member) ({ \\ const typeof( ((type *)0)-\u003emember ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );}) ","date":"2023-12-24","objectID":"/posts/miscs/:2:8","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#container_of-宏实现"},{"categories":["Tech"],"content":" 内核中的符号导出EXPORT_SYMBOL()本质上是通过将符号单独放入一个段内来导出，并在导出的过程中使用__visible保持目标在当前编译文件中可见 The Linux Kernel Macro Journey — __visible 内核中常用的修饰符__used 和__visible也来源于gcc，前者代表即使程序中没有用到该符号也不要让gcc优化，方式运行时符号丢失，__visible代表可以被其他程序访问，用于导出符号 c #define __used __attribute__((__used__)) #define __visible __attribute__((__externally_visible__)) c #define __EXPORT_SYMBOL(sym, sec) \\ extern typeof(sym) sym; \\ __CRC_SYMBOL(sym, sec) \\ static const char __kstrtab_##sym[] \\ __attribute__((section(\"__ksymtab_strings\"), aligned(1))) \\ = VMLINUX_SYMBOL_STR(sym); \\ extern const struct kernel_symbol __ksymtab_##sym; \\ __visible const struct kernel_symbol __ksymtab_##sym \\ __used \\ __attribute__((section(\"___ksymtab\" sec \"+\" #sym), unused)) \\ = { (unsigned long)\u0026sym, __kstrtab_##sym } #define EXPORT_SYMBOL(sym) \\ __EXPORT_SYMBOL(sym, \"\") linux 内核中EXPORT_SYMBOL（）分析与实践 ","date":"2023-12-24","objectID":"/posts/miscs/:2:9","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#内核中的符号导出export_symbol"},{"categories":["Tech"],"content":" VDSOvdso(Virtual Dynamic Shared Object)，其本质是个.so文件 发展历程：当APP想要触发软件中断时intel平台会触发sysenter，而AMD也会提供自己的指令，但是这些指令与内核int80中断在实现上有很大区别，为了弥合这些差异，Linux推出了vsyscall机制，其本质是对上面指令的二次封装。但是由于vsyscall采用了固定加载的方式产生了安全的问题。因此Linux又进一步将vsyscall变为了动态加载的.so文件。至此，对于经常触发系统调用的gettimeofday()，time()和getcpu()等APP来说，vsyscall不仅解决了兼容性的问题，在后期还解决了int80中断性能低下的问题 vdso的出现还解决了glibc在内核中地位的问题，早期的glibc不仅要支持linux各版本还要支持bsd，hurd等os。glibc和linux两个项目都需要进行协调，这在linux内核发行版兼容性上产生了很大的问题，为此linux允许将glibc这个项目作为内核的一部分发行，但运行时为了防止内核膨胀就禁止其运行在内核空间。这样，在磁盘中并没有单独的glibc项目(因为已经随内核发行而被隐藏在内核内部了)，在运行时glibc为了避免内核膨胀而运行在用户态，同时glibc又管理着众多APP，因此glibc被加入了vdso使其在系统运行时就自动加载进用户空间 ","date":"2023-12-24","objectID":"/posts/miscs/:2:10","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#vdso"},{"categories":["Tech"],"content":" 自己的printf使用自己的printf可以方便的通过宏开关来设置是否打印调试信息，还可以设置打印级别 宅学部落 c #define DEBUG //打印开关 void __attribute__((format(printf,1,2))) LOG(char *fmt,...) { #ifdef DEBUG va_list args; //定义char*类型的指针args va_start(args,fmt); //根据参数fmt的地址，获取fmt后面参数的地址，并保存在args指针变量中 vprintf(fmt,args); //调用vprintf打印字符 va_end(args); //将args指针置空 #endif } int main(void) { int num = 0; LOG(\"I am litao, I have %d car\\n\", num); return 0; } ","date":"2023-12-24","objectID":"/posts/miscs/:2:11","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#自己的printf"},{"categories":["Tech"],"content":" arm汇编 标准指令B指令：无条件跳转，常用B LOOP代表跳转到LOOP，跳转范围32MB BEQ：两个值相等时跳转 BNE：两个值不相等时跳转 BL：带链接的跳转，跳转时会保存下一条指令到LR C语言中的指针操作，在汇编层次就是使用寄存器间接寻址实现的，即将寄存器中的值作为地址去访问内存 寄存器和内存之间传送指令使用LDR/STR，寄存器之间传送指令使用MOV 伪指令伪指令不是arm指令集中定义的标准指令，而是编译器厂商自定义的辅助指令 LDR伪指令：LDR R0，=0x80002000 由于arm指令操作码与操作数共享32位空间，操作码会挤压操作数的寻址空间，因而需要单独的伪指令来完成这一步骤，为了和arm本身的LDR指令区分开，LDR伪指令会在操作数前加“=”。因此LDR指令支持4GB寻址 ","date":"2023-12-24","objectID":"/posts/miscs/:2:12","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#arm汇编"},{"categories":["Tech"],"content":" arm汇编 标准指令B指令：无条件跳转，常用B LOOP代表跳转到LOOP，跳转范围32MB BEQ：两个值相等时跳转 BNE：两个值不相等时跳转 BL：带链接的跳转，跳转时会保存下一条指令到LR C语言中的指针操作，在汇编层次就是使用寄存器间接寻址实现的，即将寄存器中的值作为地址去访问内存 寄存器和内存之间传送指令使用LDR/STR，寄存器之间传送指令使用MOV 伪指令伪指令不是arm指令集中定义的标准指令，而是编译器厂商自定义的辅助指令 LDR伪指令：LDR R0，=0x80002000 由于arm指令操作码与操作数共享32位空间，操作码会挤压操作数的寻址空间，因而需要单独的伪指令来完成这一步骤，为了和arm本身的LDR指令区分开，LDR伪指令会在操作数前加“=”。因此LDR指令支持4GB寻址 ","date":"2023-12-24","objectID":"/posts/miscs/:2:12","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#标准指令"},{"categories":["Tech"],"content":" arm汇编 标准指令B指令：无条件跳转，常用B LOOP代表跳转到LOOP，跳转范围32MB BEQ：两个值相等时跳转 BNE：两个值不相等时跳转 BL：带链接的跳转，跳转时会保存下一条指令到LR C语言中的指针操作，在汇编层次就是使用寄存器间接寻址实现的，即将寄存器中的值作为地址去访问内存 寄存器和内存之间传送指令使用LDR/STR，寄存器之间传送指令使用MOV 伪指令伪指令不是arm指令集中定义的标准指令，而是编译器厂商自定义的辅助指令 LDR伪指令：LDR R0，=0x80002000 由于arm指令操作码与操作数共享32位空间，操作码会挤压操作数的寻址空间，因而需要单独的伪指令来完成这一步骤，为了和arm本身的LDR指令区分开，LDR伪指令会在操作数前加“=”。因此LDR指令支持4GB寻址 ","date":"2023-12-24","objectID":"/posts/miscs/:2:12","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#伪指令"},{"categories":["Tech"],"content":" 内建函数内建函数，顾名思义，就是编译器内部实现的函数。这些函数跟关键字一样，可以直接使用，无须像标准库函数那样要 #include 对应的头文件才能使用 内建函数的函数命名，通常以 __builtin 开头。这些函数主要在编译器内部使用，主要是为编译器服务的。内建函数的主要用途如下： 用来处理变长参数列表； 用来处理程序运行异常； 程序的编译优化、性能优化； 查看函数运行中的底层信息、堆栈信息等； C 标准库函数的内建版本 __builtin_expect(exp,c)内建函数 __builtin_expect 也常常用来编译优化。这个函数有两个参数，返回值就是其中一个参数，仍是 exp。这个函数的意义主要就是告诉编译器：参数 exp 的值为 c 的可能性很大。然后编译器可能就会根据这个提示信息，做一些分支预测上的代码优化 内核中的 likely 和 unlikelylikely与unlikely本质上是内建函数expect的应用 c #define likely(x) __builtin_expect(!!(x),1) #define unlikely(x) __builtin_expect(!!(x),0) ","date":"2023-12-24","objectID":"/posts/miscs/:2:13","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#内建函数"},{"categories":["Tech"],"content":" 内建函数内建函数，顾名思义，就是编译器内部实现的函数。这些函数跟关键字一样，可以直接使用，无须像标准库函数那样要 #include 对应的头文件才能使用 内建函数的函数命名，通常以 __builtin 开头。这些函数主要在编译器内部使用，主要是为编译器服务的。内建函数的主要用途如下： 用来处理变长参数列表； 用来处理程序运行异常； 程序的编译优化、性能优化； 查看函数运行中的底层信息、堆栈信息等； C 标准库函数的内建版本 __builtin_expect(exp,c)内建函数 __builtin_expect 也常常用来编译优化。这个函数有两个参数，返回值就是其中一个参数，仍是 exp。这个函数的意义主要就是告诉编译器：参数 exp 的值为 c 的可能性很大。然后编译器可能就会根据这个提示信息，做一些分支预测上的代码优化 内核中的 likely 和 unlikelylikely与unlikely本质上是内建函数expect的应用 c #define likely(x) __builtin_expect(!!(x),1) #define unlikely(x) __builtin_expect(!!(x),0) ","date":"2023-12-24","objectID":"/posts/miscs/:2:13","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#__builtin_expectexpc"},{"categories":["Tech"],"content":" 内建函数内建函数，顾名思义，就是编译器内部实现的函数。这些函数跟关键字一样，可以直接使用，无须像标准库函数那样要 #include 对应的头文件才能使用 内建函数的函数命名，通常以 __builtin 开头。这些函数主要在编译器内部使用，主要是为编译器服务的。内建函数的主要用途如下： 用来处理变长参数列表； 用来处理程序运行异常； 程序的编译优化、性能优化； 查看函数运行中的底层信息、堆栈信息等； C 标准库函数的内建版本 __builtin_expect(exp,c)内建函数 __builtin_expect 也常常用来编译优化。这个函数有两个参数，返回值就是其中一个参数，仍是 exp。这个函数的意义主要就是告诉编译器：参数 exp 的值为 c 的可能性很大。然后编译器可能就会根据这个提示信息，做一些分支预测上的代码优化 内核中的 likely 和 unlikelylikely与unlikely本质上是内建函数expect的应用 c #define likely(x) __builtin_expect(!!(x),1) #define unlikely(x) __builtin_expect(!!(x),0) ","date":"2023-12-24","objectID":"/posts/miscs/:2:13","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#内核中的-likely-和-unlikely"},{"categories":["Tech"],"content":" 内核中的内联函数在内核中常见的内联函数定义位于头文件中，这时我们可能会有一点疑惑：头文件如果包含定义的话，而包含头文件的源文件又是多个，这对于作用域是全局的函数来说是致命的，因为可能导致重定义错误 那么为什么还要把内联函数放在头文件中？这是因为inline关键字只对定义有效，而对声明无效，要想其他文件能够引用内联函数就必须将其定义在头文件中 那么怎么解决上述问题呢？为了防止重定义错误，我们只需要改变内联函数的作用范围就行了，因此我们可以加上关键字static。这就变成了我们在内核中经常看到的内联函数： c static inline void func(int, int) { //func body } ","date":"2023-12-24","objectID":"/posts/miscs/:2:14","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#内核中的内联函数"},{"categories":["Tech"],"content":" 编译后的产物elf文件：由elf文件头和bin格式的执行代码构成，内部包含段表以及调试信息，因此在获得bin文件后还要保留对应的elf文件，否则可能导致丢失源代码后无法调试。值得注意的是使用gcc -o3生成的elf文件不会生成调试信息，想要保留调试信息还需要添加-g选项：gcc -o3 -g hex文件：包含地址信息，相比bin而言添加了地址信息，类型信息以及校验和，但并未生成各段。虽然没有段的生成，但是仍然可以按段加载，这是因为内部含有地址信息，可以手工指定地址进行段加载。同时由于内部包含段的信息，因此可以直接烧录到硬件。需要注意的是，hex并不包含调试信息 bin文件：最直接的代码映像，只包含指令，不包含地址信息，所有地址均通过计算或指令寻址获得，可以直接烧录但需要指明烧录地址 axf文件：包含调试信息，该文件是arm出品的对标elf的文件格式，因此elf拥有的段以及段表，符号表等信息在axf文件中也可被找到，并针对arm平台做了优化 对于上述文件的区别需要从体系结构方面来理解： 首先是elf，对于linux专有的文件格式，elf会被加载器按段加载(虽然加载器的一部分工作已经被编译器所取代)，这样就需要有mmu硬件支持(mmu有支持按段加载的能力，可以进行权限判别，否则就需要使用然件加载器了，而这会造成效率问题).并且由于elf本质上是执行文件，其内部的执行段的代码和bin文件内容是一样的。也就是说，elf≈elf头+bin axf实际上是elf文件格式的变种，只是针对arm平台做了优化 hex可以理解为能够按段加载的bin，因此支持分段烧录，这也是各厂家的烧录器选择了hex的原因：要烧录的地址已经在烧录软件内部进行集成了，可以通过选择开发板来确定预设的烧录地址。由于按段加载的特性，hex文件可以用于bootloader bin则是最直接的运行文件，可以直接烧录到单片机上，但是由于没有段和地址信息，在烧录时需要指明烧录到flash的哪个位置，这也是需要在烧录软件或命令中指明地址的原因：esptool.py -b 115200 --before default_reset --after hard_reset write_flash --flash_mode dio --flash_size detect --flash_freq 80m 0x0 builtin_imgs/bootloader.bin 0x08000 builtin_imgs/partition-table.bin 0x010000 rtthread.bin ","date":"2023-12-24","objectID":"/posts/miscs/:2:15","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#编译后的产物"},{"categories":["Tech"],"content":" 程序文件与运行文件程序文件的区域(在嵌入式领域存储于flash上)： 代码区 数据区 常量区 通过链接将各种.o文件链接为程序文件，链接过程中，各个程序文件的相同段被分配在一起并且还要计算出在编译阶段时没有填充的虚拟地址，但在可执行文件中分配的.bss段不占用文件空间。bss虽然在可执行文件中不占用空间，但是我们依然可以使用readelf或者objdump来查看section header中.bss的大小，这也是程序运行时的bss段大小 运行文件的区域(存储于ram上)： 堆 栈 数据(.data/.bss) 代码 程序文件加载到RAM时会被OS分配页表项(PTE)，使得OS和MMU分配的物理地址能够与进程虚拟地址相对应。还需要注意的是，在加载过程中，不同进程的相同段也会如程序文件那般被统一分配在一起 因此为了能够在不同进程中相同的虚拟地址下访问不同的物理地址，OS是通过内核空间中不同进程的页表来访问物理地址的 为了防止黑客获取程序信息，内核本身，堆，栈，mmap区在每次机器启动时都会相对其标准地址有一个偏移。在程序运行时，黑客可以通过利用内存溢出而覆盖LR的漏洞来跳转到自己的函数中，或者直接修改got表来达到自己目的 ","date":"2023-12-24","objectID":"/posts/miscs/:2:16","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#程序文件与运行文件"},{"categories":["Tech"],"content":" 缺页异常当创建用户程序时只进行页表的复制而不进行页复制，当确实需要改变进程的内容时再进行页复制，此时会触发缺页中断。这被称为写时复制 ","date":"2023-12-24","objectID":"/posts/miscs/:2:17","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#缺页异常"},{"categories":["Tech"],"content":" kfifo","date":"2023-12-24","objectID":"/posts/miscs/:2:18","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#kfifo"},{"categories":["Tech"],"content":" 栈相关 栈大小Linux默认给每一个用户进程栈分配8MB大小的空间。栈的容量如果设置得过大，则会增加内存开销和启动时间；如果设置得过小，则程序超出栈设置的内存空间又容易发生栈溢出(Stack Overflow)，产生段错误，修改栈大小使用ulimit命令 Linux内核栈大小是固定的，默认为8k 函数栈与进程栈函数栈：保存了局部变量，函数参数，并预留一部分临时存储区 进程栈：保存了CPU寄存器，被打断的地址，任务现场。这是因为一个任务由多个函数构成，这些函数也会调用其他的函数，这一系列调用关系也就是一系列函数的栈帧组成了进程的栈 内核栈与用户栈两者都是进程栈并且维护的都是函数调用关系的一系列栈帧。不同之处在于，用户态无法访问内核栈，因此需要在内核态开辟一块空间来存储内核态的函数的调用关系。在arm中使用msp寄存器保存内核栈或中断栈的栈指针，psp保存用户栈或进程栈的栈指针 ","date":"2023-12-24","objectID":"/posts/miscs/:2:19","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#栈相关"},{"categories":["Tech"],"content":" 栈相关 栈大小Linux默认给每一个用户进程栈分配8MB大小的空间。栈的容量如果设置得过大，则会增加内存开销和启动时间；如果设置得过小，则程序超出栈设置的内存空间又容易发生栈溢出(Stack Overflow)，产生段错误，修改栈大小使用ulimit命令 Linux内核栈大小是固定的，默认为8k 函数栈与进程栈函数栈：保存了局部变量，函数参数，并预留一部分临时存储区 进程栈：保存了CPU寄存器，被打断的地址，任务现场。这是因为一个任务由多个函数构成，这些函数也会调用其他的函数，这一系列调用关系也就是一系列函数的栈帧组成了进程的栈 内核栈与用户栈两者都是进程栈并且维护的都是函数调用关系的一系列栈帧。不同之处在于，用户态无法访问内核栈，因此需要在内核态开辟一块空间来存储内核态的函数的调用关系。在arm中使用msp寄存器保存内核栈或中断栈的栈指针，psp保存用户栈或进程栈的栈指针 ","date":"2023-12-24","objectID":"/posts/miscs/:2:19","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#栈大小"},{"categories":["Tech"],"content":" 栈相关 栈大小Linux默认给每一个用户进程栈分配8MB大小的空间。栈的容量如果设置得过大，则会增加内存开销和启动时间；如果设置得过小，则程序超出栈设置的内存空间又容易发生栈溢出(Stack Overflow)，产生段错误，修改栈大小使用ulimit命令 Linux内核栈大小是固定的，默认为8k 函数栈与进程栈函数栈：保存了局部变量，函数参数，并预留一部分临时存储区 进程栈：保存了CPU寄存器，被打断的地址，任务现场。这是因为一个任务由多个函数构成，这些函数也会调用其他的函数，这一系列调用关系也就是一系列函数的栈帧组成了进程的栈 内核栈与用户栈两者都是进程栈并且维护的都是函数调用关系的一系列栈帧。不同之处在于，用户态无法访问内核栈，因此需要在内核态开辟一块空间来存储内核态的函数的调用关系。在arm中使用msp寄存器保存内核栈或中断栈的栈指针，psp保存用户栈或进程栈的栈指针 ","date":"2023-12-24","objectID":"/posts/miscs/:2:19","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#函数栈与进程栈"},{"categories":["Tech"],"content":" 栈相关 栈大小Linux默认给每一个用户进程栈分配8MB大小的空间。栈的容量如果设置得过大，则会增加内存开销和启动时间；如果设置得过小，则程序超出栈设置的内存空间又容易发生栈溢出(Stack Overflow)，产生段错误，修改栈大小使用ulimit命令 Linux内核栈大小是固定的，默认为8k 函数栈与进程栈函数栈：保存了局部变量，函数参数，并预留一部分临时存储区 进程栈：保存了CPU寄存器，被打断的地址，任务现场。这是因为一个任务由多个函数构成，这些函数也会调用其他的函数，这一系列调用关系也就是一系列函数的栈帧组成了进程的栈 内核栈与用户栈两者都是进程栈并且维护的都是函数调用关系的一系列栈帧。不同之处在于，用户态无法访问内核栈，因此需要在内核态开辟一块空间来存储内核态的函数的调用关系。在arm中使用msp寄存器保存内核栈或中断栈的栈指针，psp保存用户栈或进程栈的栈指针 ","date":"2023-12-24","objectID":"/posts/miscs/:2:19","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#内核栈与用户栈"},{"categories":["Tech"],"content":" 中断与不可重入函数因为中断函数返回时需要cpu恢复现场，此时中断函数返回地址、状态不确定，所以中断处理函数没有返回值。再由于中断函数被调用的时间地点无法确定，因此不能给中断函数传参 由于在中断中只保存了必要的寄存器，返回地址等少量数据，因此当在中断中访问其他区域的数据，如全局变量和静态变量时，程序的行为就会不可控。例如某些全局变量有锁，那么中断中访问这些变量的时间就不可确定，有可能造成中断丢失的现象 为了解决上述问题，我们将函数分为可重入函数和不可重入函数。可重入函数指的是在执行过程中可以被任意中断，不可重入函数指的是在执行过程中不可以被中断。同时在中断内也不能调用不可重入函数，满足下列要求之一的就被称为不可重入函数： 函数内部使用了全局变量或静态局部变量 函数返回值是一个全局变量或静态变量 函数内部调用了malloc()/free()函数 函数内部使用了标准I/O函数 函数内部调用了其他不可重入函数 值得注意的是，不可重入函数只在中断环境中才有讨论的意义。可我们在函数中总要使用全局变量的，这样的话大部分函数就是不可重入的了？有什么解决办法么？我们虽然不能解决在中断中不能使用不可重入函数这个问题，但是我们可以解决不可重入函数被中断的问题：加锁或者更为粗暴的关中断，虽然后者代价会很大(不能相应其他中断)。了解这些后对于为什么不能在中断中使用malloc就好理解了，malloc要维护一个全局的brk指针，这个指针位于glibc库中，这涉及全局变量，更何况malloc是耗时操作。虽然加锁后的malloc是线程安全的，它仍没有解决不可重入这一问题。对于标准IO函数来说来说，它不仅要维护相关的全局变量，这也是耗时操作，还有可能在中断中获取文件锁，这会造成死锁 从上面的结论可知，可重入函数一定是线程安全的，但是线程安全的不一定是可重入函数(例如持有互斥锁的线程就是不可重入的) ","date":"2023-12-24","objectID":"/posts/miscs/:2:20","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#中断与不可重入函数"},{"categories":["Tech"],"content":" 进程间通信对于不同进程间的通信，Linux有以下工具可以使用： 无名管道:只能用于具有亲缘关系的进程之间的通信 有名管道:任意两进程间通信 信号量:进程间同步,包括system V信号量、POSIX信号量 消息队列:数据传输,包括system V消息队列、POSIX消息队列 共享内存:数据传输,包括system V共享内存、POSIX共享内存 信号:主要用于进程间的异步通信 Linux新增API:signalfd、timerfd、eventfd Socket:套接字缓冲区,不同主机不同进程之间的通信 D-BUS:主要用于桌面应用程序之间的通信 ","date":"2023-12-24","objectID":"/posts/miscs/:2:21","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#进程间通信"},{"categories":["Tech"],"content":" 线程池和协程在一些频繁创建销毁线程的场景中，我们会产生额外的开销。而线程池就是为解决这一问题诞生的 一个线程池会首先创建很多线程，这些线程统一由管理线程的模块管理。当线程无任务时会被阻塞在线程池中，有任务时就会被调度器调度。这样我们就可以减少创建和销毁线程的开销了 虽然线程池技术极大的缓解了创建和销毁线程的开销，但是对于一些互联网开发领域，面对频繁，大量的互联网并发请求时，线程池就无能为力了。这就跟一家三口使用卫生间一样：如果每个人上厕所都要先申请锁，锁门，再开门，释放锁，时间久了会让人感觉很麻烦。一个更好的解决方法是上厕所时大家协商着来，这样就不用频繁地加锁、解锁了 协程就是按照这个思路实现的，将对共享资源的访问交给程序本身维护和控制，不再使用锁对共享资源互斥访问，无调度开销，执行效率会更高。协程一般适用在彼此熟悉的合作式多任务中，上下文切换成本低，更适合高并发请求的应用场景 从切换成本上看，进程的切换成本最大，协程 的切换成本最低。而从安全性上看，进程因为有内存管理保护反而最安全，一个进程崩溃了，操作系统会终止这个进程的运行，并不会影 响其他进程的正常运行，当然也不会影响到操作系统本身。 协程虽然上下文切换成本最低，但是也有缺陷，如无法利用多核CPU实现真正的并发。但这并不妨碍它在编程市场上的受欢迎程度，很多语言都开始支持使用协程编程：Python提供了yield/send协程编程接口，从Python3.5开始又新增了async/await接口。在C语言编程领域，虽然C语言本身并没有提供支持协程的机制，但目前市面上也有很多使用C/C++实现的协程库，用户可以通过库接口函数去实现协程编程 ","date":"2023-12-24","objectID":"/posts/miscs/:2:22","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#线程池和协程"},{"categories":["Tech"],"content":" ATPCS规则ATPCS规则定义了子程序函数调用规则 子程序间要通过寄存器R0~R3(可记作a0~a3)传递参数，当参数个数大于4时，剩余的参数使用父函数的堆栈来传递，参数地址位于父函数的末尾，因此传递时利用FP寄存器存储的值并向高地址偏移若干位来获得各参数值 子程序通过R0~R1返回结果 子程序中使用R4~R11(可记作v1~v8)来保存局部变量 R11作为调用过程中的临时寄存器，一般用来保存函数的栈帧基址，记作FP R13作为堆栈指针寄存器，一般记作SP R14作为链接寄存器，用来保存函数调用者的返回地址，记作LR R15作为程序计数器，总是指向当前正在取指的指令，记作PC ","date":"2023-12-24","objectID":"/posts/miscs/:2:23","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#atpcs规则"},{"categories":["Tech"],"content":" 生命周期与作用域全局变量的作用域如下 全局变量的作用域由文件来限定 可使用extern进行扩展，被其他文件引用 也可以使用static进行限制，只能在本文件中被引用 局部变量的作用域如下 局部变量的作用域由{}限定 可以使用static修饰局部变量来改变它们的存储属性(生命周期)，但不能改变其作用域 ","date":"2023-12-24","objectID":"/posts/miscs/:2:24","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#生命周期与作用域"},{"categories":["Tech"],"content":" 数据存储，溢出，读取与对齐小端存储：低数据位在低地址 内存中只有0和1，不区分符号位，是字符还是整型。只有等到使用printf解析时才会根据%来解析内存中的数据，根据不同的解析方式(%d，%u)会产生不同的结果 对于无符号数，数据溢出会从0重新开始，对于有符号数溢出则会产生一个ub 结构体进行数据对齐时会按照结构体内数据类型的最大成员的对齐模数进行对齐，如果最大成员的对齐模数超过编译器的对齐模数的话就按照编译器的对齐模数来确定结构体整体的对齐模数。例如，对于GCC来说，对齐模数是4，即使结构体内部有double类型的数据，结构体整体也会按照4字节进行对齐。当结构体内嵌其他结构体来说对齐方式会按照内嵌结构体内部成员的最大对齐模数来对齐整个结构体。也就是说，对于普通的多层结构体来说，大概率对齐模数是8或者编译器规定的最大对齐模数 size_t的一个优点是其大小跟随平台不同而不同，可以用来表征针对某平台的最大长度，因此它可以用来存储该平台地址或者开辟一个复制数据的变量而不担心溢出 对于指针来说既然指针大小不会改变那为什么还要指定指针的类型呢？ 方便编译时编译器的类型检查 不同类型指针的运算规则不一样 ","date":"2023-12-24","objectID":"/posts/miscs/:2:25","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#数据存储溢出读取与对齐"},{"categories":["Tech"],"content":" 声明与引用使用函数或者变量前必须声明，单文件编程时因为声明被定义和初始化代替了所以不需要考虑。但是当多文件编程时，如果没有声明而直接使用，编译器会自动在前面采用int类型进行声明，但这会造成隐式类型转换的问题 extern用于声明其他文件的变量，这主要是为了编译阶段的类型，语法语义的检查。因此当需要extern一个结构体时，我们首先需要在extern前面定义这个结构体，否则编译器就没有类型检查的参考了(跨文件的将变量替换是在链接阶段干的事) 前向引用：如果一个标识符在未声明完成之前，我们就对其引用，这被称为前向引用，一般的前向引用有如下特例： 隐式声明(C99/C11已被禁止) 语句标号(goto标号) 不完全类型 对于一般的链表如 c struct list_node{ int val; struct list_node *p; } 我们会产生这样的疑问：为什么可以在list_node结构体未定义完全时就在其内部声明了一个指针变量？这是因为除了常见的对象类型和函数类型外还有一个不完全类型。常见的不完全类型如下 void 未知大小的数组，如int a[] 未知内容的结构体或联合体类型，如上文中的链表 当进行不完全类型的前向引用时(如链表)，我们一般只关注参数类型，而忽略其大小，值或者具体实现。这是因为作为不完全类型，虽然他们是不完全的，但是大小，值或者具体实现已经确定了，只是因为某些原因我们不能确定它的类型。例如void就是我们不能确定类型时所给出的暂时的空类型。对于链表这个例子来说，不完全类型的前向引用是个指针，这个指针的大小是完全可以确定的，我们使用的只是这个指针的类型，因此能通过编译。但当链表改为如下时就会编译报错，因为编译器并不知道这个不完全类型的大小 c struct list_node{ int val; struct list_node node;//编译器没有办法知道list_node结构体的大小 } 在xyz.c包含其本身库文件xyz.h是为了检查定义与声明的一致性，防止编程时粗心产生错误 ","date":"2023-12-24","objectID":"/posts/miscs/:2:26","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#声明与引用"},{"categories":["Tech"],"content":" 指针与数组两指针相减的结果以数据类型的长度为单位 []运算符是通过*来实现的，例如a[n]==*(a+n) 数组名与指针的区别： 指针与数组名的类型不同，对于int a[5]来说，它的类型是int (*) [5] 数组名在不同场合有不同含义，当进行数组初始化时或者使用数组名和sizeof、取址运算符\u0026结合使用时，数组名表示的是数组类型，此时与指针有本质不同。在其他情况下，数组名都是一个右值，表示数组首元素的地址，但是可以与取指运算符*构成一个左值表达式，这时数组名就与指针很相似了 ","date":"2023-12-24","objectID":"/posts/miscs/:2:27","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#指针与数组"},{"categories":["Tech"],"content":" 编程习惯预防内存泄漏最好的方法就是：内存申请后及时地释放，两者要配对使用，内存释放后要及时将指针设置为NULL，使用内存指针前要进行非空判断 在内核进行宏定义时，我们会经常看到do{}while(0)的结构，这本质上是防止宏定义展开后与外部语句发生耦合。因此我们在这里需要的只有那个大括号，但是如果只使用大括号会造成语法错误(因为我们使用宏的时候会选择加分号)，这样宏展开后会在大括号末尾处加分号，虽然新的编译器会自动忽略分号但在老的编译器上就很可能报错 ","date":"2023-12-24","objectID":"/posts/miscs/:2:28","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#编程习惯"},{"categories":["Tech"],"content":" 好用的工具 内存工具内存泄漏检测：MTrace(linux系统自带) c //mtrace.c #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cmcheck.h\u003e int main (void) { mtrace();//开启跟踪 char *p，*q; p=(char *)malloc(8); q=(char *)malloc(8); strcpy(p,“hello”); strcpy(q,“world”); free(p); muntrace();//关闭跟踪 return 0; } 之后就可以通过运行后生成的日志文件mtrace.log来定位内存泄漏在程序中的位置啦，注意编译时带上-g 在实际工作中，如果你运气不好的话，有时候会遇到一种比段错误更头疼的错误:内存踩踏。内存踩踏如幽灵一般，比段错误更加隐蔽、更加难以定位，因为有时候内存踩踏并不会报错，然而你的程序却出现各种莫名其妙地运行错误。当你把代码看了一遍又一遍，找不出任何问题，甚至开始怀疑人生时，就要考虑内存踩踏了 内存踩踏监测：mprotect(系统API) c //mprotect.c #include \u003cstdio.h\u003e #include \u003csys/mman.h\u003e #include \u003cmalloc.h\u003e int main (void) { int *p; p = memalign(4096, 512); *p=100; printf(\"*p=%d\\n\", *p); mprotect(p，512, PROT_READ);//在p指针变量的后512个字节内检测内存踩踏，这段内存正常情况是只读的 *p= 200; printf(\"*p= %d\\n\", *p); free(p); return 0; } 内存检测神器：Valgrind 除了使用系统提供的各种API函数，我们还可以使用内存工具检测不同类型的内存错误。以Valgrind为例，不仅可以检测内存泄漏，还可以对程序进行各种性能分析、代码覆盖测试、堆栈分析及CPU的Cache命中率、丢失率分析等 Valgrind包含一套工具集，其中一个内存检测工具Memcheck可以对我们的内存进行内存覆盖、内存泄漏、内存越界检测 shell gcc -g mem_leak.c -o a.out valgrind --tool=memcheck ./a.out ","date":"2023-12-24","objectID":"/posts/miscs/:2:29","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#好用的工具"},{"categories":["Tech"],"content":" 好用的工具 内存工具内存泄漏检测：MTrace(linux系统自带) c //mtrace.c #include #include #include int main (void) { mtrace();//开启跟踪 char *p，*q; p=(char *)malloc(8); q=(char *)malloc(8); strcpy(p,“hello”); strcpy(q,“world”); free(p); muntrace();//关闭跟踪 return 0; } 之后就可以通过运行后生成的日志文件mtrace.log来定位内存泄漏在程序中的位置啦，注意编译时带上-g 在实际工作中，如果你运气不好的话，有时候会遇到一种比段错误更头疼的错误:内存踩踏。内存踩踏如幽灵一般，比段错误更加隐蔽、更加难以定位，因为有时候内存踩踏并不会报错，然而你的程序却出现各种莫名其妙地运行错误。当你把代码看了一遍又一遍，找不出任何问题，甚至开始怀疑人生时，就要考虑内存踩踏了 内存踩踏监测：mprotect(系统API) c //mprotect.c #include #include #include int main (void) { int *p; p = memalign(4096, 512); *p=100; printf(\"*p=%d\\n\", *p); mprotect(p，512, PROT_READ);//在p指针变量的后512个字节内检测内存踩踏，这段内存正常情况是只读的 *p= 200; printf(\"*p= %d\\n\", *p); free(p); return 0; } 内存检测神器：Valgrind 除了使用系统提供的各种API函数，我们还可以使用内存工具检测不同类型的内存错误。以Valgrind为例，不仅可以检测内存泄漏，还可以对程序进行各种性能分析、代码覆盖测试、堆栈分析及CPU的Cache命中率、丢失率分析等 Valgrind包含一套工具集，其中一个内存检测工具Memcheck可以对我们的内存进行内存覆盖、内存泄漏、内存越界检测 shell gcc -g mem_leak.c -o a.out valgrind --tool=memcheck ./a.out ","date":"2023-12-24","objectID":"/posts/miscs/:2:29","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#内存工具"},{"categories":["Tech"],"content":" 体系结构","date":"2023-12-24","objectID":"/posts/miscs/:3:0","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#体系结构"},{"categories":["Tech"],"content":" CMSIScmsis是arm同各芯片厂商，工具链供应商推出的涵盖大多数cortex-m处理器以及微控制器产品的软件框架，它为应用以及中间件开发者统一了接口。例如System_Init函数在nxp，st的sdk中的实现方式可能不同，但函数签名是相同的，这样在迁移芯片时就可以大大减少软件适配的工作量 cmsis包括cmsis-core，cmsis-dsp，cmsis-rtos，cmsis-driver，cmsis-svd，cmsis-dap等组件 各组件提供了符合规范的api，该规范由arm，芯片供应商(如nxp，stm)，工具链供应商(如gnu，iar，mdk)共同遵守。为了能够提高代码重用性，加快开发周期，若没有cmsis，芯片供应商需要自行开发编译器等工具链，os厂商需自行开发部分驱动及工具库 cmsis-svd与cmsis-dap就是这样的例子：若没有cmsis，每个芯片供应商都需与各工具链厂商协同开发调试适配器(dap)与监视器(svd) 核心的cmsis-core组件包含以下内容： 内核外设访问层：包括名称定义，地址定义，nvic以及systisck的辅助函数 设备外设访问层：寄存器名称定义，地址定义，外设驱动代码 外设访问函数：外设访问的可选辅助函数 代码例子如下 c #include \"vendor_device.h\" void main(){ //内核访问nvic，该nvic函数符合cmsis接口规范并由arm负责维护，位于\u003csystem_xyzdevice.h\u003e文件中 NVIC_SetPriority(UART1_IRQn, 0x0); } void UART1_IRQHandler{ //外设中断的命名是相关的，定义在特定设备的启动文件内，由芯片厂商(以stm为例)提供，位于stm32f1xx_startup.s中 //do something } ","date":"2023-12-24","objectID":"/posts/miscs/:3:1","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#cmsis"},{"categories":["Tech"],"content":" microcode维基 微指令(microcode)，又称微码，是在CISC结构下，执行一些功能复杂的指令时，所分解一系列相对简单的指令。相关的概念最早在1947年开始出现 ","date":"2023-12-24","objectID":"/posts/miscs/:3:2","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#microcode"},{"categories":["Tech"],"content":" 流水线冒险现在主流CPU有5级流水线：取指/预取，译码，执行，访问内存，写回。但是对于性能强劲的处理器，如Intel i7-3960X，它拥有16级流水线。深度超过5级流水线的被称为超深流水线 一旦预取指令失败，CPU就会丢失当前执行指令到预取指令间的所有指令，此时流水线就会发生停顿，我们称这种现象为流水线冒险 流水线冒险一般由于数据冒险(两个不同操作在相邻指令中用到了同一个寄存器)，控制冒险(跳转指令导致取指失败)组成，我们可以采用插入空指令的方式来避免数据冒险(这在超深流水线中很有用)，而对于控制冒险我们可以通过增加分支预测硬件，优化代码和编译优化的方式来避免 ","date":"2023-12-24","objectID":"/posts/miscs/:3:3","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#流水线冒险"},{"categories":["Tech"],"content":" 分支预测分支预测主要分为动态预测和静态预测，静态预测是通过优化代码和编译优化，如内核中的 likely 和 unlikely 宏就采用了静态预测的方法。动态预测指的是程序运行时的预测优化，这一般由预测算法来实现，常见的动态预测方式有1-bit动态预测、n-bit动态预测、下一行预测、双模态预测、局部分支预测、全局分支预测、融合分支预测、循环预测等 随着APP的大量涌现，分支预测的硬件结构也越来越复杂，在现代CPU版图上面积占比最大的是Cache，其次就是分支预测结构了 ","date":"2023-12-24","objectID":"/posts/miscs/:3:4","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#分支预测"},{"categories":["Tech"],"content":" 乱序执行除了前面提到的插入空指令来避免流水线冒险，我们更好的处理方式是将这些空指令替换为与流水线冒险无关的其他指令，这就是CPU的乱序执行 乱序执行由CPU硬件来保证 ","date":"2023-12-24","objectID":"/posts/miscs/:3:5","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#乱序执行"},{"categories":["Tech"],"content":" 多发射在执行阶段时CPU有不同的执行单元，例如乘法器，加法器，FPU等，为了能够充分利用这些资源，CPU采用了多发射并行执行指令的方法，每一时刻，CPU都在同时运行不同的执行单元，而每个执行单元也都有不同的取指器，译码器，因此这些准备工作也是并行执行的 2024-03-25_16-41 ","date":"2023-12-24","objectID":"/posts/miscs/:3:6","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#多发射"},{"categories":["Tech"],"content":" 总线 2024-03-25_19-52 2024-03-25_19-53 计算机一般采用两种编址方式：统一编址和独立编址。对于arm架构来说采用的是统一编址模式，这意味着CPU访问外设的内部寄存器就像访问RAM一样。而x86采用了独立编址模式，这意味着内存RAM和外部设备的寄存器独立编址，分别占用不同的地址空间，所以CPU访问外设内部寄存器需要单独的指令 ","date":"2023-12-24","objectID":"/posts/miscs/:3:7","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#总线"},{"categories":["Tech"],"content":" arm工作模式与寄存器 2024-03-25_21-23 对于arm而言，R0~R12属于通用寄存器，其他的属于特殊寄存器 R11(FR，Frame Register)：栈底指针寄存器，用来管理堆栈 R13(SP，Stack Pointer)：堆栈指针寄存器，保存了当前运行程序的栈顶 R14(LR，Link Register)：链接寄存器，保存了上一级函数的下一条指令，当子函数return时会将当前LR的值加载进PC R15(PC，Program Counter)：程序计数器，保存了当前取指的地址。对于3级流水线，32位处理器来说，PC比当前执行指令的地址快8字节 CPSR(Current Processor State Register)：当前状态寄存器 SPSR(Saved Processor State Register)：当前状态保存寄存器，当CPU从异常状态返回时会从SPSR寄存器中恢复原先的处理器状态，即将SPSR加载进CPSR从而切换到原来的工作模式继续运行 2024-03-25_21-31 在ARM所有的工作模式中，有一种工作模式比较特殊，即FIQ模式。为了快速响应中断，减少中断现场保护带来的时间开销，在FIQ工作模式下，ARM处理器有自己独享的R8~R12寄存器 ","date":"2023-12-24","objectID":"/posts/miscs/:3:8","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#arm工作模式与寄存器"},{"categories":["Tech"],"content":" 超线程技术超线程本质上是欺骗OS，让OS认为CPU有多个Core。一般处理器上的两个线程上下文切换需要20 000个时钟周期，而超线程处理器上的两个线程切换只需要1个时钟周期就可以了，使用此技术可以通过增加5%左右的芯片面积换来CPU 15%~30%的性能提升 在高并发的服务器场合下，使用超线程技术确实可以提升性能，但在一些对单核性能要求比较高的场合，如大型游戏，开启超线程反而会增加系统开销，影响性能 ","date":"2023-12-24","objectID":"/posts/miscs/:3:9","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#超线程技术"},{"categories":["Tech"],"content":" 启动方式在一个嵌入式系统中，很多人可能认为U-boot是系统上电运行的第一行代码，然而事实并非如此，CPU上电后会首先运行固化在CPU芯片内部的一小段代码，这片代码通常被称为ROMCODE，这部分代码的主要功能就是初始化存储器接口，建立存储映射。它首先会根据CPU管脚或eFuse值来判断系统的启动方式：从NOR Flash、NAND Flash启动还是从SD卡启动 2024-04-09_15-05 如果我们将U-boot代码“烧写”在NOR Flash上，设置系统从NORFlash启动，这段ROMCODE代码就会将NOR Flash映射到零地址，然后系统复位，CPU默认从零地址取代码执行，即从NOR Flash上开始执行U-boot指令 如果系统从NAND Flash或SD卡启动，通过上面的学习我们已经知道，除了SRAM和NOR Flash支持随机读写，可以直接运行代码，其他Flash设备是不支持代码直接运行的，因此我们只能将这些代码从NAND Flash或SD卡复制到内存执行。因为此时DDR SDRAM内存还没有被初始化，所以我们一般会先将NAND Flash或SD卡中的一部分代码(通常为前4KB)复制到芯片内部集成的SRAM中去执行，然后在这4KB代码中完成各种初始化、代码复制、重定位等工作，最后PC指针才会跳到DDRSDRAM内存中去运行 ","date":"2023-12-24","objectID":"/posts/miscs/:3:10","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#启动方式"},{"categories":["Tech"],"content":" 术语ISP：In System Programing(还有一种ISP指的是通信供应商) ，使用芯片厂商提供的bootloader以及专用接口(JTAG)进行程序烧录 IAP：In applicating Programing(重要技术，常与OTA搭配) ，应用软件自身通过预留的接口(串口或网口等)进行falsh程序烧写。在IAP程序中一般有两个程序，第一个代码只执行更新操作，第二段代码才是固件包，第二段代码需要通过第一段代码来烧录进flash，因此当破坏IAP，也就是第一段代码时需要返厂进行IAP程序的烧录，否则第二段程序无法正常执行 OTA：Over-the-Air Technology，通过无线网络进行固件包的下载，下载后的固件包交由IAP进行升级 OTG：通过U盘进行固件包的下载 FPU：浮点运算单元 .a (archive)文件，linux下的静态库，ar最初实际上是个压缩工具，他把.o文件压缩使得方便文件跨设备传输和管理 .so (shared object)文件，linux下的共享库 API (application programming interface，应用程序接口)，API定义了源代码和库之间的接口，因此源代码可以在支持这个API的任何系统中编译 ABI (application binary interface，应用二进制接口)，我们把符号修饰标准，变量内存布局，函数调用方式，等这些跟可执行代码二进制兼容性相关的内容称为ABI，支持ABI的系统和平台允许将在这个ABI系统上编译出来代码运行在另一台支持同样ABI标准的设备上，实现真正的跨平台运行 ub (undefined behavior，未定义行为) ISA (Instruction Set Architecture)：指令集架构 CRT (C Running Time，C运行库) 基类：父类的别称 虚函数、纯虚函数、抽象类与接口：虚函数是指使用virtual关键字修饰的函数。纯虚函数是指基类中不实现而子类中实现的虚函数。含有纯虚函数的类称为抽象类，在抽象类中允许定义数据成员。而对于接口来说，类中只有方法的实现而不包括数据成员，使用接口可以有效避免菱形继承的问题，即当产生多重继承也就是菱形继承的问题时，我们可以将其改为单继承，另一个继承关系采用接口实现，接口同时也促进了“组合”思想的发展 初始化与定义：初始化是指开辟内存的过程，定义是指赋值的过程 saas(Software as a Service，软件即服务)，常用于云计算云存储等行业，服务提供商将软件统一打包售卖，负责产品的运维升级等工作，类似于实体行业的交钥匙项目 haas(Hardware as a Service，硬件即服务)，常用于嵌入式等领域，服务提供商利用互联网将硬件资源打包售卖，负责硬件的维护工作，这样需求方无需一次性购买全部设备，采用这种按需购买的方式有助于提高设备利用率从而降低成本 框架：在应用开发的过程中我们会经常遇到重复性工作，比如在开发音视频播放软件，即时通讯软件，输入法软件或者游戏时我们会有对输入事件响应的需求。这种需求如果让应用程序开发者来处理就太低效了，为了进一步提高代码复用率我们就有了框架。例如专职负责输入事件响应的事件处理框架，专职负责显示的QT框架，专职负责音视频解编码的FFmpeg框架等 模块化编程：随着物联网的兴起和边缘计算的发展，嵌入式系统越来越复杂，也越来越碎片化，为了方便用户自行取舍某些功能，我们引入了模块化编程。比如对于流媒体产品来说，我们只需要Wifi，音视频，事件处理框架即可，而对于低功耗，Lora，USB模块则可以裁剪掉 开闭原则：对扩展行为开放源代码，对修改行为关闭源代码 ","date":"2023-12-24","objectID":"/posts/miscs/:4:0","series":null,"tags":["Tech"],"title":"杂项","uri":"/posts/miscs/#术语"},{"categories":["Tech"],"content":"本文为FreeRTOS的系统性学习的总结，内容包含简单API的使用和RTOS的原理介绍，参考视资料为b站的韦东山视频，内部并未优化排版。 ","date":"2023-12-24","objectID":"/posts/freertos/:0:0","series":null,"tags":["OS","Tech"],"title":"FreeRTOS","uri":"/posts/freertos/#"},{"categories":["Tech"],"content":" FreeRTOS使用静态创建任务函数的话，返回值就是句柄，因此，要想对静态函数创建出来的任务进行操作的话需要创建一个临时变量以记录其返回值 使用vTaskDelet函数要注意不要在自己的进程内部自杀，这样会导致空闲任务无法清理内存。只是由于当任务自杀时，上下文和栈都已经被销毁，强制任务切换会导致未定义行为，既然任务切换是非法的，那么也就切换不到空闲任务去清理内存了 2023-12-24_09-51 2023-12-19_15-36 TCB结构体内部包含函数指针，SP位置，优先级，函数名字，函数参数等，但并不包括函数的指针(用来执行本函数)，也不包括函数参数，CPU通过保存所有寄存器的值来保存这两项，保存的位置在该函数栈的顶部，其中R0，R1…保存了函数的参数(约定俗成)，R15(PC)保存了函数的指针来进行函数的跳转操作 优先级最大值只能取到最大值-1，高于这个值的会自动变为最大值-1 空闲任务(xIdleTask)是启动调度器时就自动创建的，空闲任务可以使用自带的钩子函数创建出来，也可以用来处理下列任务 执行一些低优先级的，后台的，需要连续执行的函数 进入省电模式 测量系统空闲时间 空闲任务的限制： 不能让空闲任务进入阻塞状态或者暂停状态 取消支持时间片流转会使优先级相同的其中一个任务在未被高优先级打断前始终霸占CPU，而另一个始终得不到执行 调度策略配置项 是否抢占(高优先级任务是否可以立即打断低优先级的执行) 允许抢占时，是否允许时间片流转(同一优先级任务执行时，是否允许相互打断执行) 允许抢占并且允许时间片流转时，是否允许空闲任务让步(空闲任务和用户任务在同一优先级时，空闲任务是否让出时间片) 博客园 2023-12-16_10-16 采用这种方式运行并发程序会导致Task3 Task4在将锁置为1之前就都已经进入if语句内部了，这就会导致概率性并发Bug 写队列函数xQueueSend与xQueueSendToBack是一样的，都是默认在队列尾部写入数据，而xQueueSendToFront则是在头部写入数据(头部就是pcReadFrom指针所指的地址，并不是队列的最右侧)，此时还需要将pcReadFrom指针减去一个ItemSize的地址才能获取当前数据 使用队列集并在队列里面写入数据时需要把任务的数据写在队列里，并由系统把队列的Handle写在队列集(Queue Set)里，因为读队列后系统自动删除数据，所以读一次Queue Set后返回的Queue只能读一次，不能读多次，普通的Queue也一样 二值信号量的Give函数会检测信号量是否为1，若为1则会返回失败，而Take函数则会检查信号量是否为0，并且可以设置阻塞时间 信号量不能是负值 创建二值型信号量时默认初始值是0，需要Give一下，互斥量则不需要 信号量：Semaphore 互斥量：Mutex 只有申请方和接收方有锁的情况下才会产生优先级反转，如果其中一方无锁则正常调度就不会产生优先级反转，解决优先级反转的办法是优先级继承 为了解决优先级反转的问题，互斥量引入了优先级继承，而信号量则没有，同时由于优先级继承是指任务中的优先级，因此对于中断来说无意义，并且在中断中使用互斥量可能会阻塞其他中断，因此中断中不可以使用互斥量。信号量的也有相同的原因导致其不能在中断中使用 互斥量不能在中断例程中使用的原因-博客园 死锁的原因有两种 A函数内部二次上锁，A将自己阻塞了但其他任务并不能解锁造成死锁: A获得了锁，A调用一个库函数，这个库函数需要获得上面那个锁，死锁发生 A依赖B的锁，B又依赖A的锁，此时会死锁 解决的办法是使用递归锁(Recursive Mutex)，采用了谁持有谁释放的方法 递归锁允许同一个线程多次获得锁，这样就可以防止第2种死锁 事件组要么等待事件中的某一个发生，要么等待事件中的所有都发生，不能等待事件中的指定某几个发生 2023-12-17_19-34 2023-12-17_19-38 2023-12-17_19-35_1 2023-12-17_19-35 2023-12-17_19-34_1 切换任务后是直接执行在任务中断处执行，一般为while(1)循环内继续执行，因此对于在循环外部的初始化变量一定小心，例如在while(1)外部定义了i，while(1)循环内部定义了for循环，使用的变量是前面的i，这样，当第一次while(1)循环结束后i的值为跳出循环的值，从本次循环开始，就不会再进入for内部了 任务通知是多对一的关系 对于任务通知来说，发送方发送的结果只有两种，要么成功要么失败，并不会等待，而对于接收方则有三种情况 2023-12-18_17-35 xQueueReceive()的调用次数与xEventGroupWaitBits()中的WaitForAllBits数量有关，如果WaitForAllBits是pdFalse时，则需要一个xQueueReceive()就够了，否则会造成从未赋值的中间变量中取数据的Bug，造成的现象是同时多个数据被写入队列时会产生数据并被xQueueReceive()读取多次，次数取决于并发的程序数量，不同时写入数据则会只覆盖队列中第一个数据，第二个数据始终被保留。而WaitForAllBits是pdTure时，则需要多个xQueueReceive()，这样才会有足够多的中间变量存储数据，而后被一次读走(具体实验可以看24_freertos_example_tasknotify_event_group) 使用任务通知构造轻量化事件组无法等待指定的某个任务，但是可以通过判断xTaskNotifyWait()中的pulNotificationValue值来进行等待某个指定任务 定时器函数在守护任务中被执行，每当产生Tick时定时器函数会比较当前Tick与预设Tick，并根据结果来执行回调函数(CallBackFun)，想要设置定时器函数的具体参数需要经过队列通信来完成 2023-12-19_17-09 调用如上函数时，如果不加static关键字会导致每次调用函数都会产生新的栈和新的cnt，这样cnt的值就不是理想的，如果初始化cnt为0，则每次都会打印0，也不符合逻辑，解决办法是使用static关键字来存储每次产生的cnt FreeRTOS对于中断会使用不同的ISR(Interrupt Service Routines)函数，这是为了保证ISR执行的时候不能处于阻塞状态，这样才能保证实时性 临界资源是指能够被多个进程共享，但是同一时间只能由一个进程访问的资源，因此是互斥的 用到syscall的中断可以通过调用系统函数被屏蔽掉(底层修改BASEPRI或其他寄存器)，这样即使是优先级比较低的中断也可以安心访问临界资源，CotexM3/M4调用syscall的中断位于中断向量表的191~255位，0~255位是可编程异常，-3~0位分别是复位、NMI(Non-Maskable Interrupt)、硬件错误，屏蔽中断本质上是屏蔽191号中断，从而间接将191~255中断屏蔽 在中断中调用中断恢复函数会将中断恢复至原来的状态，可能是中断开启也可能是中断屏蔽，而在任务中调用中断恢复宏则会将中断打开，因此，中断恢复函数有返回值 任务切换一定要给延时！尽量不要在定时器回调函数内部进行延时操作，因为硬件定时器回调函数是在中断中被执行的，软件定时器优先级很高，因此不要做耗时，延时操作 定时器守护任务优先级及其栈深度在Config文件内被定义，默认为4，要想抢占定时器回调函数注意修改配置 任务自杀后就永远不会被执行，除非被再次创建 编程时，一般的逻辑错误都容易解决。难以处理的是内存越界、栈溢出等 尽管并没有很好的方法检测内存越界，但是可以提供一些回调函数： 使用pvPortMalloc失败时，如果在FreeRTOSConfig.h里配置configUSE_MALLOC_FAILED_HOOK为1，会调用： c void vApplicationMallocFailedHook( void ); 在切换任务(vTaskSwitchContext)时调用taskCHECK_FOR_STACK_OVERFLOW来检测栈是否溢出，如果溢出会调用： c void vApplicationStackOverflowHook( TaskHandle_t xTask, char * pcTaskName ); 怎么判断栈溢出？有两种方法： 方法1：当前任务被切换出去之前，它的整个运行现场都被保存在栈里，这时很可能就是它对栈的使用到达了峰值的时刻 这方法很高效，但是并不精确。比如：任务在运行过程中调用的函数A大量地使用了栈，调用完函数A后还有其它操作，最后才被切换出去 方法2：创建任务时，它的栈被填入固定的值，比如：0xa5 检测栈里最后16字节的数据，如果不是0xa5的话表示栈即将、或者已经被用完了 没有方法1快速，但是也足够快 能捕获几乎所有的栈溢出 为什么是几乎所有？可能有些函数使用栈时，非常凑巧地把栈里最后16字节设置为0xa5：几乎不可能 简而言之，使用上面两个Hook函数需要配置Config.h，并要求自己实现Hook函数的功能(内存回收以防止malloc失败等) ","date":"2023-12-24","objectID":"/posts/freertos/:0:0","series":null,"tags":["OS","Tech"],"title":"FreeRTOS","uri":"/posts/freertos/#freertos"},{"categories":["Tech"],"content":" FreeRTOS的内部机制Arm架构汇编指令: 读指令 LDR (Load Register) LDR R0, [addr] 写指令 STR (Store Register) STR R0, [addr] 加指令 ADD ADD R0,R1,R2 //R0=R1+R2 PUSH指令本质是写指令， Push {R3,LR}把LR，R3 Push到内存中的栈，把LR放在高地址，R3放在低地址 CPU中重要的寄存器: SP(R13) 栈顶指针寄存器 LR(R14) 返回地址寄存器 PC(R15) 当前指令寄存器 CPSR(A64架构) 状态寄存器，LR是一种特殊的PC POP指令本质是读指令 POP {R3,LR} 栈可以用来保存现场，任务可以理解为函数+函数的栈 保存现场的三种情况 切换任务时，保存所有的寄存器 调用其他函数时，但由于前几个寄存器(R0,R1,R2…)被用来传参，因此不需要保存 硬件中断时，硬件会自动保存一部分寄存器，但是还需要软件保存一部分 栈的大小取决于局部变量的大小以及函数调用的深度，函数调用需要Push LR TCB结构体内部包含函数指针，SP位置，优先级，函数名字等，但并不包括函数的指针(用来执行本函数)，也不包括函数参数，CPU通过保存所有寄存器的值来保存这两项，保存的位置在该函数栈的顶部，其中R0，R1…保存了函数的参数(约定俗成)，R15(PC)保存了函数的指针，来进行函数的跳转操作 2023-12-30_10-48 申请堆栈的指令名为SPACE，这是在初始化文件里执行的 2023-12-24_21-33_1 main函数的栈是在STM32汇编文件文件中设置的，与芯片厂商相关，步骤如下 在内存中申请一段空间(首地址为__initial_sp，也是msp(Main_Stack_Pointer,也是sp)，同时会给中断函数的栈使用 然后转入向量表，找到__initial_sp 执行Reset_Handle，在Reset_Handle内部跳转到了main函数 一般情况下，没有必要使用PSP，除非是有os存在时，MSP用于os内核栈(或中断栈)的sp，而PSP用于thread级app栈的sp，这两个sp需严格分开 任务调度原理: 任务存在三个大类链表中，分别是ReadyList链表数组，DelayList，PendingList。当程序被阻塞时会被放入delaylist内，这时产生阻塞的一般是信号量take，延时函数，互斥锁等操作。当程序被挂起时会被放入pendinglist内，这时产生挂起行为的唯一的方法是调用vTaskSuspend函数，而想要解除挂起状态只能让其他程序调用vTaskResume函数。其中ReadyList链表数组按照优先级排列(0-4)共有五个链表，FreeRTOS会先从ReadyList中最高优先级的一个开始寻找任务并执行，当高优先级任务发生阻塞时会将其从ReadyList移到DelayList，这时就不会执行了，而是去找低优先级的任务去执行。当创建任务时，会有系统维护的指针指向当前创建的优先级最高的任务，因此，最后创建的任务总会先执行，然后再按前文所说按优先级高低依次执行其他任务 选要注意的是，当所有任务优先级为0时，最后创建的是IdleTask。因此指针最初指向的是空闲任务，由于的IdleTask并没有打印或者改变引脚状态的功能，溢出你程序“看起来”好像是从我们设置的Task开始运行的 2023-12-25_09-14 在整个任务调度的过程中利用的是任务的TCB结构体的内容 为防止写队列过程中发生调度导致失败，所以在写队列中需要互斥，这是通过关闭中断来实现的(任务调度本质上是定时器产生中断) 当任务A向队列写入数据时，会检查是否有其他任务正在等待该队列。若存在等待任务B且其条件（如数据长度、类型等）满足，则触发任务B就绪（从DelayList移回ReadyList），随后可能发生任务切换；若条件不满足，任务A会主动休眠以节省CPU资源——此时任务A不仅会从ReadyList移至DelayList，还会在队列的等待列表中注册自身（当有其他写队列的任务时A会被阻塞，这是就需要进行当前操作）。后续当其他任务向该队列写入数据时，会遍历等待列表并唤醒符合条件的任务（如任务A） 在使用队列读写数据时，首先关中断，之后读写数据，在读写之后还需要进行链表操作来调度和通知任务，最后再开中断 因此使用队列有两点好处 实现互斥 节省CPU资源，提高程序运行效率 队列要点 关中断实现互斥 环形缓冲区保存数据 链表实现休眠唤醒 内存中队列的构成: Queue_t(队列头)+Buffer(数据缓冲区)，队列头由队列结构体构成，内部包含xTaskWaitingToSend链表以及xTaskWaitingToReceive链表及其对应的指针，数据缓冲区大小 = ItemSize * Length xTaskWaitingToSend以及xTaskWaitingToReceive仅仅是为了记录哪个任务需要读写数据，真正的调度还需要去执行ReadyList与DelayList之间的操作，这样是为了防止在中断内部操作导致中断阻塞 critical: 临界区 读队列内核操作 2023-12-25_11-40 信号量是一种特殊的队列，它不传递数据，因此它只有Queue_t(队列头)，在Queue_t内部还有个链表用来记录Take失败的任务，以便之后唤醒 互斥量的优先级继承是通过高优先级任务的优先级赋值给低优先级任务完成的，在这之前还需要记录低优先级任务的优先级，这样才能保证Give互斥量之后回到原优先级 事件组某些位被设置后会唤醒事件组里通过位掩码设置的任务并将其移到ReadyList，然后每个任务依次检查是否符合执行条件，符合的执行 使用队列和信号量时为了防止其他任务干扰需要关调度器，同时为了防止其他中断任干扰也要关中断，但是关中断后再关调度器也就没有意义了，因此在其内部源码中只是关闭中断而已。而事件组只是关闭调度器即可，这是因为FreeRTOS不会在中断中使用事件组，本质原因是事件组的FromISR函数并没有实际切换任务，而是写一个链表，等待事件组的FromISR函数执行完毕后才会进行实际的任务切换，这样一旦设置事件组的某些位就不会在中断中唤醒所有任务了，否则会阻塞中断 任务通知能且只能点对点的唤醒任务，具体过程和前几种方法类似，都是先关中断，然后发通知的一方设置eaction的值，等通知的一方需要接受值，判断执行什么指令。之后由系统进行链表操作及状态转移，最后开中断 对于定时器任务， FreeRTOS的处理与其他操作系统不同。其他操作系统由硬件定时器(systick)出发形成软件定时器，在软件定时器内部直接调用待处理任务。而FreeRTOS认为，软件定时器也是中断，为了防止在中断内部直接处理任务会导致阻塞，因此采用了队列的方式处理任务，这与xTaskWaitingToSend以及xTaskWaitingToReceive在关中断内记录要更改的链表操作类似 定时器队列中，写队列一侧是systick，读队列一侧是守护任务。有趣的是创建Timer任务和启动Timer也是写队列，所以在函数xTimerStart(xTimer，xTicksToWait)中有两个参数，第二个参数给的就是当定时器队列满时是否接受等待 中断的优先级: systick服务于任务调度，pendsv服务于任务切换，其他的类似GPIO的中断用于业务，为了能够让业务正常执行，GPIO中断优先级最高，systick和pendsv优先级最低 2023-12-27_10-19 pendsv本质上是保存现场和任务切换的汇编代码 c taskENTER_CRITICAL(); /*访问临界资源，防止其他任务，ISR破坏*/ taskEXIT_CRITICAL(); ---------------------------- vTaskSuspendAll(); /*关闭调度器，防止其他任务破坏性访问*/ xTaskResumeAll(); 2023-12-30_09-55 可以通过116行将宏消除(因为宏未定义，编译器会消除宏) 2023-12-30_10-22 FreeRTOS的链表构成如上图，xList负责产生头xMINI_List_Item，并记录链表中信息(如元素个数，当前指针的位置)，xMINI_List_Item本身作为链表头，xList_Item产生节点。要注意xList_Item的pvOwner才是学习链表时的\"container\"(容器)，container内部有下一个Node，Node里面也有下一个的container，而对应Node节点的就是FreeRTOS的Item。此时的pxContainer是指向新加入元素的那个List的指针 有些芯片支持对指针取指赋值，有些芯片则根本不支持，考虑的原因是防止内存不对齐而引发错误，在使用malloc函数中需要注意 生成堆的操作就是申请一块全局数组 下面简单总结heap1-heap5： heap_1 - 最简单的实现形式，不支持Free内存 heap_2 - 允许内存Free，但不会合并free的内存块 heap_3 - 是malloc() 和free() 的抽象层，多加了线程安全措施 heap_4 - 合并free的块，避免碎片 heap_5 - 类似heap_4，增加了块内存段操作 heap1到heap5内存回收机制逐渐增强，一般常用heap4 heap_1.c里，只实现了pvPortMalloc函数，vPortFree函数","date":"2023-12-24","objectID":"/posts/freertos/:0:0","series":null,"tags":["OS","Tech"],"title":"FreeRTOS","uri":"/posts/freertos/#freertos的内部机制"},{"categories":["Tech"],"content":"本文是笔者研究生入学期间对C进行系统性复习总结而成的笔记，因此内部排版混乱，知识点散乱而不成系统，望读者谨慎参考 ","date":"2023-10-18","objectID":"/posts/c-review/:0:0","series":null,"tags":["Programing Language","Tech"],"title":"C复健计划","uri":"/posts/c-review/#"},{"categories":["Tech"],"content":" C复健计划printf函数无法打印多行字符串，若要打印多行字符串则需要在每行后加换行符\\n\\ \\n代表换行，\\n\\代表下一行是上一行的延续，如果改为\\n则会报错 变量名第一个字母不能是数字 ANSI C C99 C11 关键字数量分别是32 32+5 37+7 %11.2f代表输出11个占位符，其中浮点型输出到小数点后2位，如果%a.bf，其中b比a大，则直接输出到小数点后b位而忽略a的值 %x: 十六进制 (hex) %o: 八进制(oct) %d: 十进制(dec) 2023-09-19_08-38 2023-09-19_08-39 \" 代表 \" \\ 代表 \\ /* */代表多行注释 \u003c\u003e表示导入系统文件 ““表示导入自定义文件` Tab == 8个空格，或者4个空格 编译分为四步 预编译：宏定义展开，头文件展开，条件编译等，并将注释删除（条件编译是指根据系统位数，编译库的选择确定编译环境） 编译：将预编译后的文件生成汇编文件 汇编：将汇编文件生成为目标文件（二进制代码） 链接：把库链接到可执行程序中（预编译只是说明函数格式） 2023-09-22_08-5949 float 默认保留六位小数，%.2 表示保留小数点后两位（四舍五入） 常量定义方法（不能对值进行修改）：const 数据类型 常量名 = 值 或 数据类型 const 常量名 = 值 ( 在函数中定义的常量不安全，而全局常量则安全 )，# define 常量名 值。第一种不安全，利用指针可以修改 const 定义的值 十六进制用 0x 开头 八进制用 0 开头 C语言不支持定义二进制数 有符号数最高位是符号位，0 代表正数，1 代表负数 scanf(\"%d”,\u0026a); 不要加\\n %hd 短整型 %p 输出指针的地址 char ‘单个字母’ 此时 %c 打印字母 %d 打印ASC2码 %c 对应的变量如果是整型，则输出ASC2码所对的字符 0 的ASC2码是 48 A 65 a 97 小写字母 - 大写字母 == 32 科学计数法赋值: float a = 3.2e3 //3.2*1000 %e 以科学计数法表示数字 WORD 双字节 16bit DWORD (double word) 32bit 2023-09-27_09-3508 正数: 原码 == 反码 == 补码 负数: 反码 == 原码除符号位取反 补码 == 反码 + 1 (若最高位进位，则进位舍弃) 数据存储时，把 -0 定为区间最小值: 1111 1111 (-127) 1000 0000 (-128) 对于8bit数据，取值范围是: 2^7-1 ~ -2^7 %s 输出一个字符串，遇到\\0停止 \\0 代表字符串的结尾 printf(“hello\\0 word\\n”); 输出的只有hello scanf(\"%d,%d”,\u0026a,\u0026b); 键盘输入的时候应严格双引号中的格式输入，只能输入\"整数，整数\"不能输入\"整数 整数\"或其它格式 putchar getchar 只能对单个字符进行操作 2023-09-23_16-2638 2023-09-23_16-2611 2023-09-23_16-5554 2023-09-23_17-2827 2023-09-23_17-3207 所有非 0 的值都是真值 C语言浮点型数据不能取余 单目运算符优先级高于双目运算符 int a = 10; int b = 20; 则 a \u0026\u0026 b == 1 2023-09-25_10-4453 强制类型转换不考虑四舍五入，后果是损失精度，系统自动类型转换时也会损失精度 (int) a*b 是先将 a 损失精度，再计算结果 (int) (a*b)是先保留精度计算，再损失精度 表达式 ? 语句1 : 语句2 表达式为真，执行语句1，否则执行语句2 switch 中可加 default 并且 case 后要接 break for 循环可以有多个判断代码，需用 , 隔开，只要一个表达式不满足就跳出循环 goto FLAG; ………… FLAG: ………… 数组下标必须是常量，不能写为下例：int i = 10; int arr[i]; 当一个数组初始化（开辟内存空间）时，内部元素默认是乱码。只有当赋值时，默认才是0 eg： int arr[4] = {1}; //内部元素：1,0,0,0 int arr[4]; arr[0] = 1; //内部元素：1,数字,数字,数字 数字 0 等同于 \\0 但不等同于字符 ‘0’ char arr[] = “hello”; 此时arr数组共有6位（最后一位是\\0） char arr[5] = {‘h’,’e’,’l’,’l’,‘o’}; 此时只有六位，打印的时候到 o 不会停止，会继续打印乱码，所以char arr[n]的数组只能存储n-1个字符 scanf接收到空格或回车就代表接收的结束 gets() 与 scanf() 的区别是，get 能接收空格，scanf 则不能 sizeof() 测量字符串数组长度时包括 /0 strlen() 则不包括 函数返回值传给寄存器后内存中的函数会被销毁 函数声明: extern int fun_name( type a, type b ); == int fun_name( type a, type b ); == int fun_name( type , type ); 可以不用写在主函数之内 声明不需要内存 exit(); 在子函数中使用主函数也会退出 导入自己的头文件用 “myfile.h” #ifndef “myfile.h” #define 文件名 #endif char 占1个字节分配1个地址 int 占4个字节分配4个地址 win 存储方式是小端对齐 即 低位数据存在低位地址中 \u0026 是取址符号，是升维的 * 是取值符号，是降维 野指针: 指向某一个未知空间的指针变量 int const *p == const int* p 是给 p 赋值，不是给 p 指向的变量赋值 因为 const 离 “*”近 int* const p 是给 p 指向的变量赋值，不是给 p 赋值，因为 const 离 “p” 近 指针 +1 == 内存地址 +(sizeof(type 指针)) 数组做为函数参数时会退化为指针，损失数组的大小信息，所以需要额外的数组长度做为函数参数 p[-2] 等于当前指向某一数组的指针 p 向前数2个的那个元素 2个指针相减后的结果是步长，指针与指针不能相加 int* arr[3] 指针数组 arr[i] == *(arr+i) 一级指针加偏移量相当于跳过元素，二级指针加偏移量相当于跳过一维数组 2023-09-27_18-0028 2023-09-27_18-0047 2023-10-01_12-4448 2023-10-03_10-1645 2023-10-03_10-2054 2023-10-03_10-3451 ’ 字母 ’ 代表字母的ASCII码值，并可以用 %d 输出其值 while 是先判断后执行 2023-10-03_20-2457 主函数是程序的入口，是程序首先执行的函数 全局变量作用域 : 单个文件(表格错了)，其他文件调用时需要使用extern关键字来将全局变量作用域扩展到其他文件内： extern int a; 生命周期是从程序创建到程序销毁 全局变量可以与局部变量重名，调用时程序采用就近原则的方法来选择变量 静态局部变量在数据区存储，只会初始化一次并且发生在函数创建前，作用域 : 函数内部 生命周期 : 从程序创建到销毁 ( 作用域与局部变量一样，生命周期与全局变量一样 ) 静态全局变量作用域 : 只可在本文件中使用，但不能在其他文件中使用，生命周期 : 从程序创建到程序结束 2023-10-07_14-4543 2023-10-07_13-5845 定义函数默认是全局的，可以在其他文件中调用，静态函数只能在本文件中使用，即使在其他文件中声明也不能使用 即使没有声明也可以调用函数，但是在 vs 里转到定义功能不能使用 静态函数可以和全局函数重名 malloc 开辟的是连续的堆空间 2023-10-07_15-0913 2023-10-07_16-4537 2023-10-07_16-4817 2023-10-07_16-5929 2023-10-07_17-2152 栈由高地址向低地址增长，栈底是第一个进栈的数据，栈顶就是最后一个进栈的数据。 2023-10-08_19-2651 同理，申请0字节的空间也会报上述错误 2023-10-08_19-2937 下图报错原因是对 NULL 指针进行赋值操作。本质上由于68行函数开辟了一个堆空间同时创建形参p，在申请10个int大小的空间后fun08就被销毁了，同时销毁的还有形参p。相当于68行是废语句 2023-10-08_19-5338 free 空指针不会报错 结构体成员大小按最大结构体成员的倍数取，下图中， char name 的大小为 21( sizeof(name) ==21 )，但是偏移对齐过后为24 ( int的整数倍 ) 2023-10-09_11-3636 typedef 类型名 别名; struct 结构体类型名 {}; struct 结构体类型名 结构体名 = {}；//注意{}中的变量用 ; 隔开 结构体指针 -\u003e 成员 结构体变量 . 成员 联合体 union 所有数据共用一块内存空间，只能输出最后一次被赋值的成员 2023-10-09_16-5317 文件操作","date":"2023-10-18","objectID":"/posts/c-review/:0:0","series":null,"tags":["Programing Language","Tech"],"title":"C复健计划","uri":"/posts/c-review/#c复健计划"},{"categories":["Tech"],"content":"本文是笔者研究生入学期间对STM32进行系统性学习总结而成的笔记，可用作入门参考资料使用，主要参考资料为b站江协科技的STM32入门教程-2023版 ","date":"2023-10-18","objectID":"/posts/stm32/:0:0","series":null,"tags":["Tech","STM32"],"title":"STM32","uri":"/posts/stm32/#"},{"categories":["Tech"],"content":" STM32STM32 常用寄存器缩写: CR 控制寄存器 SR 状态寄存器 DR 数据寄存器 ST公司出品的Microcontroller(微控制器) Cortex-M内核，本文学习的是M3内核 供电电压 2.0V-3.6V(标准3.3V)，USB输出电压是5V AHB 先进高性能总线 APB 外设总线 内核的外设不需要开启时钟 复用输入指的是同一引脚默认有很多输入功能，需要对GPIO指定使用哪个功能(TIM4就无复用功能)，而重定义则是非默认功能，需要进行AFIO选择进而变为复用功能 2024-01-04_15-49 2023-10-16_22-3845 2023-10-13_16-2857 2023-10-13_17-0326 最小系统电路: 单独的芯片不能工作，需要连接最基本的电路，由这些电路组成的就是最小系统电路 ","date":"2023-10-18","objectID":"/posts/stm32/:0:0","series":null,"tags":["Tech","STM32"],"title":"STM32","uri":"/posts/stm32/#stm32"},{"categories":["Tech"],"content":" GPIORCC : 复位和时钟控制 GPIO(General Purpose Input Output)通用输入输出口 GPIO高低电平看外部输入输出,输入情况下,与外部电平极性相同.如果外部信号非常小,则为避免引入干扰源选择浮空输入,不清楚外部信号的情况下也选择浮空输入,输出情况下看外部负载电压要求 AIN是模拟输入专用模式，此时GPIO不输入输出，防止对外界信号干扰 AF_PP是复用推挽模式，片上外设使用这种模式 2023-10-14_16-5334 2023-10-14_16-5138 2023-10-15_09-3232 VDD 3.3V VSS 0V GPIO 控制流程：1.激活 RCC 时钟 2.使用 GPIO_Init 初始化 GPIO 函数 施密特触发器的作用是对外界信号进行滤波，规定上下限，使得当超过上限输出为1，低于下限输出为0，上下限之间输出不变，这样可以维持信号的稳定性 在输出模式下，输入也是有效的 ","date":"2023-10-18","objectID":"/posts/stm32/:1:0","series":null,"tags":["Tech","STM32"],"title":"STM32","uri":"/posts/stm32/#gpio"},{"categories":["Tech"],"content":" 中断NVIC (Nested Vectored Interrupt Controller) 嵌套中断向量控制器: 统一分配中断优先级和管理中断 响应优先级: 完成当前任务后进行响应优先级的任务 中断优先级: 立即结束当前任务并进行中断优先级任务(可以决定中断嵌套,抢占优先级高的可以进行中断嵌套) 两个优先级相同的情况下按中断号排队,所以并不是先来后到 NVIC 分组在整个项目中只需要执行一次 2023-10-17_08-4844 EXTI (external interrupt) 外部中断控制器 EXTI 负责监控GPIO的电平变化,当产生跳变时,EXTI向NVIC发送中断申请,经NVIC裁决优先级后执行中断程序 2023-10-16_13-5138 2023-10-16_15-0452 GPIO_EXTILineConfig(GPIO_PortSourceGPIOx,GPIO_PinSourcex) 是配置AFIO的函数，参数是GPIO的通道和引脚 ","date":"2023-10-18","objectID":"/posts/stm32/:2:0","series":null,"tags":["Tech","STM32"],"title":"STM32","uri":"/posts/stm32/#中断"},{"categories":["Tech"],"content":" 定时器TIM (timer) 定时器 TRGO(Trigger Out)定时器主模式，该模式下可以将触发信号传递给从定时器，并由从定时器执行动作，同时可以不用进中断就可以执行程序。 2023-10-18_13-4440 预分频器(PSC)对时钟频率进行分频,置0 不分频,置1 频率=原时钟频率/2 置2 频率=原时钟频率/3 等等，注意预分频器需要加 1,ARR加1的原因是ARR从 0 开始计数 CK_PSC是 72MHz 2023-10-18_14-4239 2023-10-18_14-4245 2024-01-23_12-12 2023-10-18_13-4450 OC(output compare) : 输出比较 PWM(pause width modulation) : 脉冲宽度调制 2023-10-18_20-4321 2023-10-18_20-5305 IC(Input Capture): 输入捕获 输入捕获每次CNT转运到CCR时需要清0,此时可以配置从模式,让硬件电路自动清零 2023-10-20_16-3336 FP(filter polarity)，滤波器极性选择 主模式:让定时器内部信号映射到TRGO引脚,用于触发别的外设 从模式:接受其他外设或自身的信号用于控制自身定时器的运行 2023-10-23_16-0729 2023-10-20_16-3416 使用PWMI测量PWM频率和占空比有两种方法：测频法和测周法。测频法是给定一闸门时间T，测量在T内的信号源产生的频率数量，这种方法适合测量高频信号，这很好理解：当信号频率足够低时，闸门时间可能要比待测信号的周期要短，这样就永远测不到信号源频率了。测周法是给定一采样频率f，当信号经过一个完整的周期时得到采样点数量，进而计算出信号源周期，该方法不适合测量高频信号 滤波器也是计数器,但不会改变信号原有的频率,原理是当有x个信号均为同一性质(高电平或低电平时)才滞后输出信号,x是给定的参数值 通道3,4不支持PWMI配置且不支持编码器 使用编码器时,定时器的其他功能就无法使用了 2023-10-20_18-0044 2023-10-23_19-5640 2023-12-22_10-22 TI1可以选择接到TI1FP1上也可以选择TI1FP2上，这样可以通过极性选择来计算出上升沿到下降沿的时间，这个功能可以在PWMI模式中体现 2023-10-20_22-4215 编码器会接管时钟,所以不需要TIM_InternalClockConfig() uint16_t 中比0小一位是65535，如果想变为-1需要把uint强制转换为int ","date":"2023-10-18","objectID":"/posts/stm32/:3:0","series":null,"tags":["Tech","STM32"],"title":"STM32","uri":"/posts/stm32/#定时器"},{"categories":["Tech"],"content":" ADCADC(Analog-Digital Converter) STM32 ADC是12位的 最大值4096 可以测量0-3.3V PWM是DAC的一种，具有功率损耗小的优点，常用来给大型直流电机调速，f103没有DAC外设 ADC数据来源于比较器的结果，其核心是未知的外界信号与芯片给定的信号进行比较，并用逐次逼近寄存器(SAR)采用二分法分割芯片信号，直至与外界信号相等，此时SAR的值即为外界信号值 规则组支持16通道，注入组支持4通道，但规则组只有一个数据寄存器，注入组有四个。这意味着当使用规则组时，它可以同时接受16个gpio的信号，但是由于只有一个数据寄存器，因此如果数据读取不及时，后一个gpio的数据会将前一个gpio的数据覆盖掉，极端情况下会丢失15个通道的数据，而注入组可以规避这个问题。使用规则组时可以申请DMA来帮助通道转换效率 EOC(End Of Convert) 规则组: EOC 注入组: JEOC 注意要开启RCC_ADC的时钟 2023-10-21_12-5239 通道数大于1扫描模式才有意义，转换是对循环而言 在连续转换模式下，会自动读取EOC的值，所以不需要手动写 while 判断是否转换完毕 2023-10-21_12-5301 2023-12-23_11-46 2023-12-23_11-46_1 2023-12-23_11-46_2 单次连续模式是针对某个通道，扫描非扫描模式针对所有通道 保持时间越长，越能抵抗毛刺信号的干扰 2023-10-21_13-0507 2023-10-21_13-0729 由于ADC数据寄存器有16位，但是ADC本身是12位，因此就有左右对齐的问题。ADC数据对齐方式一般选右对齐，这样可以快速获取数据，如果使用左对齐则需要将数据右移4位.左对齐是为了直接取出数据的高n位，方便裁剪分辨率，但是也可以通过右对齐然后读取出的数据进行右移的方式来操作分辨率 ","date":"2023-10-18","objectID":"/posts/stm32/:4:0","series":null,"tags":["Tech","STM32"],"title":"STM32","uri":"/posts/stm32/#adc"},{"categories":["Tech"],"content":" DMADMA(Direct Memory Access)直接存储器访问 STM32有1个DMA1,共7个通道,每个通道都是独立的DMA，都支持软件触发和特定的硬件触发。DMA虽然有多个通道,但是只有一条DMA总线,需要仲裁器进行仲裁,使优先级高的通过获得数据,通道号越小优先级越高 DMA中的软件触发和硬件触发不同与其他外设的软件触发和硬件触发，前者的软件触发意味着想要把数据最快的从一处搬到另一处而不考虑搬运的时机，当配置M2M结构体成员时就意味着使用软件触发了 ，硬件触发指的是当收到外部中断时才进行数据转运。因此如果是Flash到SRAM的数据搬运,应使用软件触发，此时数据运输速率最快,如果是外设到SRAM,应使用硬件触发，此时不需要以最快的速度转运数据,而是需要特定时机才触发。 DMA只操作存储器到存储器的数据搬运,上面提的外设到SRAM是指外设的存储器到SRAM 内核外设: NVIC SysTick DCode总线专门访问Flash 2023-10-22_11-5155 数据宽度参数 字节: 8位 半字: 16位 字: 32位 、 自动重装器决定传输计数器自减到0后是否恢复到初值,如果恢复到初值则为连续模式,否则为单次模式 软件触发不能与自动重装器同时使用,那样DMA就停不下来了 M2M位置1是软件触发,M2M置0是硬件触发 传输计数器等于0后需要将DMA_Cmd DISABLE,然后改变传输计数器的值,再DMA_Cmd ENABLE,DMA才能重新工作,简而言之,写传输计数器需要关闭DMA 小位数数据转移到大位数数据会在高位补0,大位数数据转移到小位数数据会舍弃高位 DMA和CPU对同一地址进行访问时,仲裁器会优先选择DMA进行访问(为了防止DMA数据丢失),但是也会为CPU保留一半的总线带宽 Flash存储编译后的C代码和常量数据 const定义的常量存储在Flash里 普通变量存储在SRAM里 ADC -\u003e DR 得到的是DR的值 \u0026ADC -\u003e DR得到的是DR的地址 ","date":"2023-10-18","objectID":"/posts/stm32/:5:0","series":null,"tags":["Tech","STM32"],"title":"STM32","uri":"/posts/stm32/#dma"},{"categories":["Tech"],"content":" UARTUSART支持同步异步传输，有时钟线，并对协议进行增强 UART仅支持异步传输，没有时钟线 2023-11-08_14-4250 全双工: 通信双方能够同时双向通信 一般两根通信线，一根发射一根接收 半双工: 通信双方同时只能有一方通信 单工：无论何时都只有一方能进行通信，另一方始终接收 全双工: 打电话 半双工: 对讲机 对讲机: 广播 差分信号抗干扰能力强，传输速度和距离会很高 硬件流控制: 当信息发送方向接收方发送数据太快时可能造成发送方发送的数据超出接收方的缓冲区大小从而导致阻塞，这是就需要引入硬件流控制来让接收方反馈缓冲区已满，停止发送数据的请求 I2C 和 SPI 有时钟线，所以是同步的传输方式 USART默认为低位先行 2023-12-23_11-25 2023-11-08_15-0206 RS232 1 0 位如此设置的原因是增加抗干扰能力 RS485 是差分信号，传输距离可达上千米 2023-11-08_15-1736 二进制调制情况下波特率 == 比特率 奇偶校验: 校验位补 0 或 1 使得数据位+校验位有偶数或奇数个 1 2023-11-08_17-0036 TXE(发送数据寄存器非空)与RXNE(接受移位寄存器非空)是TDR与RDR置位的 单片机的TX和RX与USB转串口模块的TX和RX要交叉连接 2023-11-08_17-1603 2023-11-08_17-1643 波特率除以16是因为采样时钟(fpclk)是以波特率的16倍频进行采样的，这是为了防止噪声对程序产生影响。其检测方法是在检测到起始位时(也就是下降沿)，后按波特率的16倍频进行采样，在第3，5，7次采样需要保证至少有两个0，否则就舍弃数据，之后在第8，9，10次采样时也需要保证至少有两个0，否则就意味着有噪声，硬件就会在NE寄存器内置1。在实际使用过程中我们只需要直接给出波特率就行 Odd 奇数 Even 偶数 2023-11-09_21-4348 固定包长适合载荷数据与包头包尾重复率高的情况，这样利于分割以及接收数据 2023-12-23_11-21 在发送数据时需要加上包头包尾(个人规定0xFF为包头，0xFE为包尾) 相比文本数据包，HEX数据包效率高，因为文本还需要编码译码的过程 2023-11-09_22-0509 HEX数据包接收运用了状态机的思想，通过不同的S的值控制进中断后的行为，进而执行相应的动作 ","date":"2023-10-18","objectID":"/posts/stm32/:6:0","series":null,"tags":["Tech","STM32"],"title":"STM32","uri":"/posts/stm32/#uart"},{"categories":["Tech"],"content":" I2CI2C(inter IC Bus) 同步协议需要时钟线来控制数据的读写，好处是对时钟要求不严格，不需要硬件电路的配合，而异步需要硬件电路产生准确的时钟信号才能通信。因此同步协议主打低端市场。同时，如果主机进入中断，异步协议就会接受到错误数据，产生的错误更隐蔽，而同步协议利用时钟线则会直接丢失数据，但也方便排查错误 第一个数据帧最低位0为写，1为读 2023-11-10_14-5525 2023-11-10_15-1740 I2C两根总线为避免主从设备同时输出造成电源短路现象(主机输出1从机输出0)，规定了SDA与SCL均采用开漏输出模式，这样，无论主从设备是否同时输出，均不会达到强上拉，而是在外接电阻R的作用下被限制为弱上拉，下拉模式不受影响。同时，在下拉状态中，多主机情况下可以进行I2C控制权的仲裁 2023-11-10_15-1740 2023-11-20_12-1845 2023-12-23_12-09 2023-11-10_15-5315 0表示应答 1表示非应答 SCL低电平变换SDA数据，高电平读取SDA数据 由于I2C对硬件要求不高，因此软件可以完全模拟I2C协议 2023-11-11_17-0558 2023-11-11_17-0623 硬件I2C与USART类似，都是通过TXE和RXNE寄存器控制数据收发，只不过I2C是高位先行，因此移位寄存器向左移位，而USART低位先行，是向右移位，这里的高低位先行指的是HEX数据的发送接收模式，正常的文本模式下仍按照人类的从左至右(从高到低)发送文本 7位寻址与10位寻址的区别是，10位寻址时前两个数据包是寻址，之后的是数据，而7位则是第一个数据包是寻址 EV(event): 事件，产生多个标志位 2023-11-13_15-5406 2023-11-13_15-5518 I2C在频率很高时，由于开漏模式弱上拉的作用，实际的SCL和SDA并不完美，当频率快到一定程度时，SCL的方波甚至会被压缩至三角波，为了给SDA传送数据时所需要的上拉一定时间，所以需要SCL低电平时占空比适当增加 由于I2C的弱上拉的作用，使得在标准模式下支持100KHz的信号，快速模式下也只能支持400KHz的信号 硬件I2C下，STM32默认为从模式 STM32的I2C被分为主从两种模式，每种模式又被分为发送和接受两种模式 2023-11-21_13-1436 2023-11-21_13-1509 硬件I2C接收模式下，要在发送最后一个字节前将STOP置1，并把Ack置0，这是因为停止位(EV7_1)配置位于接收数据之前，只有接受下个数据后，才能把之前设置的停止事件发送出去。而发送模式的停止事件(EV8_2)位于发送数据后，这种情况下就可以正常发送 ","date":"2023-10-18","objectID":"/posts/stm32/:7:0","series":null,"tags":["Tech","STM32"],"title":"STM32","uri":"/posts/stm32/#i2c"},{"categories":["Tech"],"content":" SPISPI(serial peripheral interface)，应用领域与I2C类似，都用来负责主控与外挂芯片之间的通信，支持一主多从但不支持多主机。通信模式为同步，全双工。与I2C区别在于，I2C耗费硬件资源最少，SPI实现功能最多. SPI有四根通信线，分别为SCK(serial clock)，MOSI(master output slave input)，MISO(master input slave output)，SS(slave select) SPI与I2C一样，均采用高位先行的传输模式 SPI没有应答机制，有几个从机就有几个SS线 由于所有从机的MISO都连接在一起，为了避免从机在推挽输出时互相影响导致短路，SPI规定当从机的SS没有被选中(置0)时，从机的MISO默认为高阻态，SS被选中时，MISO才被改为推挽输出。同时，主机输入为上拉输入(MISO)，主机输出为推挽(包括片选，时钟，MOSI) 从机输出引脚为推挽输出，从机输入引脚为浮空(片选未选中时) 或上拉(片选选中时) 理解SPI的另一种方式：CSDN 2023-12-23_16-38 2023-12-23_16-41 知乎 2023-11-14_16-1847 当波特率发生器产生时钟信号时，如果设置CPOL=0，CPHA=0,那么主机和从机就会在第一个时钟信号的上升沿采样并读取对方发来的信号并将其放在移位寄存器中，然后在第一个时钟信号的下降沿处将MSB(最右侧的数字)放到各自的引脚上 2023-11-14_17-0955 2023-11-14_17-1008 存储器划分 Block - Sector，并且整个存储空间全被划分成了Page 发送的3个字节组成的地址，最低位是页里的字节地址，高2个字节是页地址 由于结构特性，Flash的数据bit位只能由1变为0，不能由0变为1，因此写入数据前必须先擦除，将所有数据由0“擦除”至1，而后写入数据. 2023-11-14_19-4334 为了防止误操作，Flash使用前需要先写使能 事前等待就是把WaitBusy放在读写函数之前的位置，这样可以提高效率，但安全性会降低(因为程序在读写操作后可能会运行其他代码，这样可以节省时间，但安全性会降低，比如读写操作后再次进行类似读写的操作)，事后代码效率较低但安全性高。并且需要注意的是事前等待需要放在读写函数之前，但事后等待仅放在写函数后即可 写入不能跨页，读取能跨页，写入超过页的限制之后会从页头开始覆盖 SPI要想接收数据必须发送数据，因此可以发一些没用的数据(Dummy Data)给从机 ","date":"2023-10-18","objectID":"/posts/stm32/:8:0","series":null,"tags":["Tech","STM32"],"title":"STM32","uri":"/posts/stm32/#spi"},{"categories":["Tech"],"content":" BKP与RTC 2023-12-01_21-0209 UNIX时间戳默认从1970年1月1日开始，而有些C库默认为1900年开始 2023-12-01_21-0358 2023-12-01_21-0419 2023-12-01_21-0438 2023-12-23_17-26 HSE(高速外部时钟) RTC时钟优先选择LSE，因为频率为2^15^因而容易分频产生1Hz信号 2023-12-01_21-2350 2023-12-01_21-2355 ","date":"2023-10-18","objectID":"/posts/stm32/:9:0","series":null,"tags":["Tech","STM32"],"title":"STM32","uri":"/posts/stm32/#bkp与rtc"},{"categories":["Tech"],"content":" PWR只有外部中断才能唤醒STM32的停止模式，因此PVD，RTC，USB，ETH等可以通向EXTI中断 f103内部划分了很多供电区域，其中vdda专为模拟模块供电，电压2.4v-3.6v，vdd专为io供电，电压3.3v，电压cpu、内存及外设电压1.8v(外设在通过io与外部交互时才会显现3.3v)，其电源来源于vdd的电压调节器 2023-12-02_13-5934 2023-12-02_13-5301 2023-12-03_12-4826 2023-12-03_12-4853 2023-12-03_12-4910 从上到下越来越省电，但也越来越难被唤醒 系统进入停机模式时，HSI被选为系统时钟，此时系统主频8MHz，而正常情况下使用的是HSE*9=72MHz，因此会发生Running刷新不及时的现象，此时需要SystemInit来重新初始化时钟 待机模式唤醒后，程序从头开始执行，因此，不需要调用SystemInit ","date":"2023-10-18","objectID":"/posts/stm32/:10:0","series":null,"tags":["Tech","STM32"],"title":"STM32","uri":"/posts/stm32/#pwr"},{"categories":["Tech"],"content":" 看门狗看门狗负责复位程序 独立看门狗精度低，使用LSI时钟(40KHz)，窗口看门狗精度高，使用PCLK1的时钟(APB1的时钟，36MHz) 2023-12-03_12-1627 所谓的喂狗就是将12位重装计数器的值重装到12位递减计数器内，方式递减计数器归零产生溢出信号 键寄存器可以以理解为多位的控制寄存器，这样设计是为了防止外界干扰导致控制寄存器的某一位失效，假如这一位是喂狗的，那情况就会比较危险，因此设置键寄存器 2023-12-03_12-1833 2023-12-03_12-1854 2023-12-03_12-1925 2023-12-03_12-1945 早期唤醒中断可以进行保存数据，再次喂狗等紧急操作，以防止程序未被喂狗而复位 2023-12-03_12-2117 窗口时间即为进入WWDG最小的时间，并非通常意义的\"窗口\"时间 2023-12-03_12-2142 利用内部闪存编程时，当读取内部闪存时CPU会被暂停，因为程序放在闪存里，CPU运行的程序需要从闪存中取出，如果此时正在执行中断函数时中断会卡住一段时间 ","date":"2023-10-18","objectID":"/posts/stm32/:11:0","series":null,"tags":["Tech","STM32"],"title":"STM32","uri":"/posts/stm32/#看门狗"},{"categories":["Tech"],"content":" 启动文件详解野火Startup_file.html ","date":"2023-10-18","objectID":"/posts/stm32/:12:0","series":null,"tags":["Tech","STM32"],"title":"STM32","uri":"/posts/stm32/#启动文件详解"},{"categories":["Tech"],"content":"本文是笔者研究生入学期间vim进行系统性复习总结而成的笔记，因此内部排版混乱，知识点散乱而不成系统，望读者谨慎参考 ","date":"2023-10-18","objectID":"/posts/vim/:0:0","series":null,"tags":["Tech","Arch Linux"],"title":"Vim复健计划","uri":"/posts/vim/#"},{"categories":["Tech"],"content":" Vim复健计划命令模式 o 新建下一行并切换到编辑模式 O 新建上一行并切换到编辑模式 [n]x 包括光标的后n位剪切，若改为X，则是光标前n位但包括光标所在的字符 [n]yy 包括光标的后n行复制 [n]dd 包括光标的后n行剪切 [n]p 粘贴复制的内容n遍 D 包括光标的之后当前行的所有字符剪切 dG 包括光标的之后所有行剪切 J 将下一行合并到上一行，并用空格连接 . 执行上一次操作 Shift+I 光标移到行首并进入编辑模式 Shift+A 光标移到行尾并进入编辑模式 Ctrl+f 向下滚屏（可以用PageDown） Ctrl+b 向上滚屏（可以用PageUp） gg 光标移到第一行行首 G 光标移到最后一行行首 [n]gg 或[n]G 光标移到第n行行首 /内容 查找内容 n 转到下一个 N 转到上一个 ？ 查找上一次搜索的内容 （?内容 与 /内容 作用一样） /^内容 查找以内容开头的字符串 /内容$ 查找以内容结尾的字符串 /a…b 查找以a开头b结尾，中间有3个任意字符的字符串 :r 文件名 在光标下一行插入文件的内容 :%s/aaa/bbb/gc 全文中aaa被替换为bbb，替换时确认 % 全文 s 替换 g 当前行所有字符 c 确认 :set nu 显示行号 :set nonu 不显示行号 ","date":"2023-10-18","objectID":"/posts/vim/:0:0","series":null,"tags":["Tech","Arch Linux"],"title":"Vim复健计划","uri":"/posts/vim/#vim复健计划"},{"categories":["Industry"],"content":" 资本主义 100 年所创造的物质财富超过了以往一切时代的总和 —— 卡尔·马克思 ","date":"2023-02-07","objectID":"/posts/century-industry/:0:0","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#"},{"categories":["Industry"],"content":" 百年激荡","date":"2023-02-07","objectID":"/posts/century-industry/:0:0","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#百年激荡"},{"categories":["Industry"],"content":" 前工业时代为了阐述工业体系的奇特之处，我们必须回到广义的工业革命之前，也就是大概1600~1700年。尽管距离珍妮机的出现还有一段不短的时间，但在历史上的科技进步思潮来说，这一段时间，世界发展模式发生了重大变化。欧洲从黑暗的中世纪走了出来，攫取着五大洲的财富，美洲正在开荒，东亚的明王朝余威尚在，南亚印度莫卧儿王朝虽然即将走向分裂，但尚可维持统一，中东的奥斯曼帝国如日中天。更重要的是，对于后世影响极为深刻的发明发现在此时涌现。需要强调的是，这些发明发现连接了人类农业时代与工业时代，沟通了人类的理性认识与感性认识，尽管在不同地区这些特点有所不同，但不可否认的是这一段时间是人类进入定居农耕后绝无仅有的经历。就我个人观点而言，这一段时期的重要性甚至超过了由铜器时代发展到铁器时代的重要性，是仅次于工业革命的辉煌时期。下面列举几例这期间的科技爆点： 1596年中国李时珍《本草纲目》 1637年中国宋应星《天工开物》，同年法国笛卡尔创立解析几何. 1639年中国徐光启《农政全书》 1643年意大利托里拆利发现了大气压，11年后马德堡半球公开实验 1653年法国帕斯卡发现帕斯卡定律 1661年英国玻义耳提出元素定义,把化学确立为科学 1665年英国胡克首次用显微镜观察植物细胞 1670s年牛顿和莱布尼茨分别创立微积分 1676年丹麦勒麦证明光以有限速度传播 1676年法国马略特发现气体的玻义耳-马略特定律 1703年德国施塔尔将燃素说系统化 1712年英国纽可门制成第一架实用蒸汽机 ","date":"2023-02-07","objectID":"/posts/century-industry/:1:0","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#前工业时代"},{"categories":["Industry"],"content":" 前工业时代科技发明发现的特点 这些发明发现大多是全面性的，总结性的知识或者思想前卫的理论的非直接应用于生产性质的。 这些发明发现是农业时代的集大成之作，也是工业时代的先导。 这些发明发现彼此关联不大，即使有关联的因果关系也不明朗，甚至出现实际应用早于理论提出的现象。 这些发明发现最主要出现在东亚和欧洲，且两个地区的发明发现有着迥然不同的特点。而南亚次大陆，伊斯兰传统地区以及中亚的发明发现则很少，北非以南基本没有。 这些发明发现集中涌现，频度广度超过了此前任何时代。 ","date":"2023-02-07","objectID":"/posts/century-industry/:1:1","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#前工业时代科技发明发现的特点"},{"categories":["Industry"],"content":" 相关特点的解释工业革命之前人类首先要满足自己的生存需要，对于事物内在的联系和特点则不太关心，对其有深入研究的多是在社会中占据统治地位的人，他们占据了劳动产品的大多数，少数对事物发展原理有浓厚兴趣的人就成了古典的哲学家和博物学家。受限于知识经验的匮乏，他们的研究多是广博而不深入的，形成的知识经验体系也是框架式的指导性的哲学，所以不能产出深刻的本质理论且难以运用于生产。尽管研究的不彻底，但相关研究的基础是农业时代积攒千年的经验知识。因此，这种工业革命前期的研究具有全面性先导性的特点，且那时人们对庞大的农业手工业知识需要梳理，而因受战争瘟疫影响下人均资源较为丰富的社会环境也有助于人类科技的进一步发展，这两点就导致了发明发现的集中涌现。此时的农业时代的生产力远非之前各种时代所能比的，这样，各种发明发现出现如此的烈度也就不奇怪了。可理论不深刻的后果就是这些发明发现彼此是孤立的，那些这些哲学家和博物学家并没有发现他们之间的内在联系。当时的手工匠人还是依靠经验进行生产，比如，在制糖业中，搅糖师傅要依靠眼力和手感判断出糖的时机，烧火的师傅需要用皮肤和眼睛感受火炉温度的变化，尽管在随后的工业化进程中出现了专职搅拌蔗液的机器来取代制糖师傅，还有仅靠训练几天就看懂温度计的童工来取代烧火师傅，但是此时的生产还是应用高于理论，人们对温度，工艺经验和定量考察的联系认识不足。直有到了第二次工业革命科学家工程师群体才成为推进世界生产技术进步的重要力量，在此之前，成为一名手工匠人依然是普通人最好的出路。从农业社会的历史角度来看，传统的强势农业政权一共有三处，分别是位于地中海沿岸的欧洲，位于两河流域的中东以及地理位置较为封闭的东亚与南亚。其他的地区如中亚或者印度周围强敌环伺，不仅面临传统农业强权的竞争压力还面临着北方骑兵的威胁。对于中东来说，奥斯曼帝国建立后占据着东亚与欧洲沟通的必经之路，这时以国家的名义收过路费显然是收益率最高的方式。于是，本来可以凭借亚欧路上沟通进而搭上工业革命的浪潮的中东终于在欧洲人发现新航线之后落后了，而东亚和南亚本来作为新航线的目的地的打算也在哥伦布误打误撞的发现新大陆的现实下消失，在美洲种植甘蔗和香料远比亚洲容易得多，自此，中国和欧洲的科技模式发生了变化，彼此走向了不同的发展道路。 ","date":"2023-02-07","objectID":"/posts/century-industry/:1:2","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#相关特点的解释"},{"categories":["Industry"],"content":" 机器时代","date":"2023-02-07","objectID":"/posts/century-industry/:2:0","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#机器时代"},{"categories":["Industry"],"content":" 世界背景上述的发明发现彼此孤立，倘若没有煤铁，没有自迭代的加工技术的话我们大概率还会停留在比较发达的农业社会，经历着几百年的农业周期。但是，人类运气比较好，自从蒙古铁蹄踏破了亚欧大陆后，蒙古人带来了战争和瘟疫，也同时带来科技与生机。瘟疫战乱使欧洲的人口快速减少，破坏了传统基督文化削弱了教会势力。蒙古势力阻碍中欧交流的同时迫使西方开启大航海时代，间接促进了新大陆的发现。而传统教会势力的孱弱也给了文艺复兴一个绝佳的机会。 这样，绵延百年的战乱瘟疫所导致的中西欧劳动力匮乏与宗教势力的削弱，迫使了新科学的出现，新技术的应用以及新航线新大陆的发现。至此，一个空前的农业周期出现在欧洲，无尽的白银香料糖流入欧洲再流向中国。同时输入性通胀带来的无尽财富使得明政权不思进取，由外部环境导致的内部压力导致了千年来最严格的海禁，这更为欧洲带来了绝佳的机会，此时南亚的莫卧儿王朝也处在分裂中，这里有无限的劳动力和市场等着欧洲来攫取。随着航海时代的来临，荷兰由于其独特的国家模式，迅速的成为一支不可忽视的力量。在荷兰霸权的后期仍然可以组建一支14万人的雇佣兵部队与法国作战，而这时是1687年。但荷兰的霸权是必然的，原因有很多，例如过度投机的国家模式，狭小的国土与过少的人口。无论怎样，荷兰霸权不会永远持续下去，获胜者不管是英国法国还是普鲁士，这都不影响接下来发生的事。 ","date":"2023-02-07","objectID":"/posts/century-industry/:2:1","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#世界背景"},{"categories":["Industry"],"content":" 煤，铁和布早期的工业是分工细化的手工业，例如玻璃作坊有专职烧火的，专职制作玻璃液的，专职吹制玻璃的，纺织工场有专职煮棉的，专职纺线的，专职织布的。在手工业中，最枯燥，最耗费劳动力的莫非纺线和织布。早在珍妮机之前，英国人也在改良生产工具，但是珍妮机及其改进型的效率使得它的前辈都相形见绌。 对劳动力渴望的还有煤矿，自古以来，下矿都是一件极其耗费心力体力的事，劳动强度大，死亡率高。在奴隶制时代，也只有奴隶才下矿井，封建时代，就只有卖身奴，契约奴和战俘和囚犯才干这事。人们对煤的需求并不是天生的，但早期农业的燃料获取和战乱破坏了地表植被，人们不得不寻求更廉价更以获取的燃料来源。冶铁业比较发达的国家需要各种炭类来提供普通燃料达不到的高温，但是开采煤矿经常伴随渗水，一旦地下的含水层被打破，排水问题始终难以解决。在蒸汽机出现之前一般靠人力或者畜力运用机械排水，效率低耗时长。在纽可门发明第一台实用化的蒸汽机之后，排水的问题便被解决了。在此强调一点蒸汽机的材料是铁，燃料是煤，工质是水。但是这种类型的蒸汽机效率很低，但是无所谓，有了需求总会有人改进的。 煤矿里的另一个问题是运力。煤矿多于山上，道路崎岖运煤困难，早期的解决方案是用硬木做成木轨，马拉货车运煤。但是这种方式运力低下费用高昂：在机器时代马还是昂贵的牲畜。解决这一问题的是瓦特，尽管瓦特并没有做出蒸汽机车，但最早的蒸汽机车结构就是把瓦特的蒸汽机小型化搬上了轨道车。此时是1804年。这样，由煤（需要排水） — 铁（需要高温） — 机械加工技术 — 蒸汽机（需要能源和工质） — 煤（需要排水） 的工业循环就初步形成了。 但是这时的工业爆发还缺少一个临门一脚的条件 — 那就是能够发展上述循环的自迭代的功能。如果没有这个条件的话，这次的技术爆炸可能在人类历史上只不过是一轮非常不错的农业周期，最终农业政权还是会走向分裂，战争，导致人口减少，然后再次重启一个新的周期。然而这个条件是人类走向那时那刻的必要条件，没有它，人类绝不会造出蒸汽机，绝不会改进纺织机，也绝不会把荷兰拉下海上霸主的地位而这个条件就是以机床为代表的机械制造技术和熟练工人。蒸汽机的核心部件是气缸，要想做出不漏气又可滑移的气缸需要足够精密的机械加工技术。为了提高蒸汽机效率需要提高缸内气压，这又进一步对加工技术和材料提出了更高的要求，从而促进了发现品质更好的煤铁矿，改进更优良的工艺。此外，机床的制造也需要更精密的加工技术更优良的材料和更优秀的工人。 至此，煤（需要排水） — 铁（需要高温） — 机床（能够自迭代） — 蒸汽机（需要能源和工质） — 煤（需要排水） 的循环已经进化为 更多更好的煤（需要排水） — 更优质的铁（需要高温） — 更精密的机床（能够自迭代） — 性能更好的蒸汽机（需要能源和工质） — 比循环之初还要更多更好的煤（需要排水）。现在只要有一个动力让这个循环持续下去那么工业革命就到来了。那么是什么推动了这个循环呢？—— 是利润。 其实推动工业循环可以不是利润，例如初期的苏联采用了指令式的计划经济，那时推动工业循环的是忍受统治压力和竞争压力的技术官僚所推动的。但是在此时的欧洲，资本主义的奴隶贸易风头无两，因此相对于保守的封建主义，发展工业最成熟的工具只剩下资本主义了。利润的条件一旦满足，无论是何种产业，只要利用上述三个条件这个循环就会永无止境的运动下去。最早担当这一重任的产业是纺织和远洋物流。首先说纺织，上文提到，纺织业需要大量劳动力纺线织布，而有了瓦特蒸汽机车作为动力源，珍妮机便织出了巨量财富。又密又匀的机器布远非手工布所能比的。这样，依靠着全球殖民体系，在几十年的时间内英国机械纺织业便打垮了印度持续千年的繁荣手工纺织业。对于远洋物流来说，最早的动力是人力以及风力，而有了蒸汽机之后，船舶的航速航程便极大的提高，更重要的是在逆风条件下的船速稳定性也会显著提高，这不仅提高了民用货船的运输效率，而且还提高了海军和海盗的机动力。于是，物质信息流转速度显著提高，资本周转速度，利润积累速度显著变快，世界被更紧密的连接在了一起。进一步，由机器产生的更多的利润被用来扩大再生产，产生出比原来多得多的利润被再次用于投资，工业体系迎来了指数级别的增长。 第一次工业革命爆发了。 ","date":"2023-02-07","objectID":"/posts/century-industry/:2:2","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#煤铁和布"},{"categories":["Industry"],"content":" 工业革命的代价任何有利事物都有其相反面，这种相反面总给人类不利因素，这就是代价。工业革命作为人类历史上最为重大的事件，极大地便利了民众生活的同时也带来了极其惨痛的代价。欧洲人做梦也想不到，在爆发了两次工业革命的土地上竟然戏剧性的爆发了两次世界大战，在付出了上亿人生命之后把世界霸主的地位送给了美国，并且几乎是错失了第四次工业革命。除了战争外，在工业革命的早期，环境的破坏以及工作环境的恶化甚至让普通民众生活水平还不如农业时代，资本原始积累带来巨大的贫富差距，不合理的城市化政策让数以万计的贫民死于火灾和空气污染，频繁的经贸摩擦带来的政治甚至军事摩擦也为民族主义和世界大战埋下伏笔。 ","date":"2023-02-07","objectID":"/posts/century-industry/:2:3","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#工业革命的代价"},{"categories":["Industry"],"content":" 电气时代","date":"2023-02-07","objectID":"/posts/century-industry/:3:0","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#电气时代"},{"categories":["Industry"],"content":" 世界背景电气革命的源头实际上与机器革命爆发是同一时期的，早在1746年莱茵瓶就诞生了，而在1780年伽伐尼发现的电流更激起科学界的极大兴趣。直到1799年伏特堆诞生，真正意义上的的电力时代开启了。此时工业革命的先发地正处于增长的狂欢中，百年的殖民历程和数十年的工业积累让日不落帝国的赫赫威名响彻全球。但是第二次工业革命首先爆发在德国和美国。早在一战前，德国就已经完成了工业化的整合，凭借着优越的煤铁矿，德国在鲁尔区整合成了欧洲最大的煤钢联合企业，美国由于其得天独厚的自然资源和地理优势以及百年建设，在一战前建成了世界最大的工业国。同时，渴望劳动力与市场的为代表的同盟国与已瓜分完毕现存殖民地的协约国有着结构性矛盾，这一矛盾直接导致了一战的爆发。 ","date":"2023-02-07","objectID":"/posts/century-industry/:3:1","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#世界背景-1"},{"categories":["Industry"],"content":" 电气设备，内燃机及化学工程与科研人员第二次工业革命与上一次形式相同而内容不同。上一次工业革命的是以 蒸汽机 — 煤铁复合体 — 机床 — 蒸汽机 为循环的，这次是以 电气设备/内燃机 — 石油/电气寡头 — 机床 — 科学家 — 电气设备/内燃机 为循环的。这一循环比第一次周转更快，技术水平更高，初步展现了工业体系的复杂。 其中电气设备/内燃机为工业循环提供动力，电机的出现使得世界能源格局出现重大调整，人们不必以煤矿为中心建设经济，这直接导致之后的传统工业区衰落。实际上，这种能源格局的调整相比当时重要的电气发明并没有多么立竿见影，把电气设备抬上第二次工业革命宝座的是电子通讯设备。在电子通讯设备出现之前，人类传递信息的能力与传递宏观物质的能力是一样的，除了少部分用生物，光学等耗资巨大且消息传递不准确的途径外人类再也找不出其他更快速更准确的信息传递方式了。但是自从1837年电报诞生后，人类沟通全世界的雄心与日俱增。在仅仅11年后，世界第一条海底电缆横空出世，又过了8年，世界第一条跨洋电缆完工，而此时是1858年，距离我们熟知的近代史开端仅仅过去了18年。 19世纪中叶就有了内燃机的设想，只不过当时充当燃料的是煤气。随着石化工业的发展，一种在原油中占比巨大的燃料进入了人们的视野。早期机械工艺能力不过关，而汽油机结构复杂，因而第一台实用化的内燃机是用于发电和船用的结构简单的大型柴油机。归根结底，内燃机的原理与蒸汽机相同，只不过工质由水变为燃油。但是内燃机对材料和润滑的要求很高，对机械加工技术要求更甚。但材料依靠上次工业革命的铁基合金，润滑依靠石化工业，做到这两点都不难，唯一的问题是机加工技术，这一点需要足够的时间和市场来保证。 如果说体现第一次工业革命的化学水平是三酸两碱，那么第二次工业革命的代表化学产物就是代表实际应用的有机化学。此时的化学工程主要为机械产品服务，无论是钢材的冶炼，表面处理，硫化橡胶，还是工业油的生产，木质机械的化学处理，这些都占据了化学产品的大部分。少数其他行业如绝缘塑料，化肥，炸药，医药等产品，虽然在今天看来无比重要，但是在当时这些产品还未发展成熟且产量较低，少数的高产量成熟产品也主要被用于战争，典型的是炸药和医药。那时的发明家无论如何也想不到，为人类移山填海的炸药竟然被用来消灭人类自身，而检验救死扶伤的医药产品的最方便方式竟然是战争。无论如何，化学工业在这次工业革命中雨中春笋般的涌现出来，他将会在二战后迎来属于他的高潮。 科学家群体早在前工业时代就活跃于各个领域，但那时的科学家的研究主要依靠个人兴趣，并且大多涉猎广泛。大量直接应用于生产的科学研究发生在此次工业革命。第一次工业革命参与者主要是各种手工匠人，他们依靠经验来改进工艺和机器。这很容易理解，工业革命早期生产资料匮乏，没有足够的试验器具供科学家们研究，少数能靠大脑推理演绎得出可靠结论的都是万里挑一的天才。但自从此次工业革命以来，大量的质量优秀的仪器被开发出来，科学家们首次运用大量仪器以量的角度观察这个世界。更振奋人心的是，此时的原动机，机械加工设备和化工过程的复杂度抽象度远超第一次工业革命，这正需要科学家解密原理以更好的应用在生产过程中。并且从上述分析可知，这时 生产 — 科学家 — 生产 的循环也建立起来了，工业革命将继续以生产出超越以往所有世代物质财富的速度进行下去，甚至包括第一次工业革命。 ","date":"2023-02-07","objectID":"/posts/century-industry/:3:2","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#电气设备内燃机及化学工程与科研人员"},{"categories":["Industry"],"content":" 世界大战无论如何改进技术更新产品，工业循化的形式是不会发生根本变化的，但是工业循化的内容是会发生变化的，比如原动机由蒸汽机变为内燃机能源由蒸汽变为电力等，这是由于工业自迭代的本质所决定的。另一个不发生变化的是工业循环的动力。无论动力是什么，工业循环总是需要动力持续下去的，只不过现在的动力是利润。 产生利润，意味着必须要有劳动力和原材料把产品生产出来，然后再把产品拿到市场上交换，并且必须被交换成功，此时利润便产生了。因而，产生利润需要两点条件： 足够的劳动力，原材料和生产工具 能够成功交换即产品占有市场 一战前夕，殖民地被英法俄瓜分完毕，英国拿到了最肥美的运河，南亚，北非，南非和北美，法国获得了除英国外的绝大部分非洲，俄国得到了东亚，中亚，中东的一部分，以及东北欧的一部分。后发的以德国为代表的国家，因为落后了第一次工业革命而没有足够的殖民地。但在第二次工业革命中，工业的增长速度远远超过第一次工业革命，这样，德国在战前就超过了英国从而取得了欧洲最大工业国的地位，但足够的产品生产出来却又没有足够的市场致使利润无法收回。为了维持工业循环以保持足够的工业产能，防止被国际竞争压力中压溃，所以德国不得不发动战争。 经过上述分析，一战的爆发可以说是必然。只不过一战的爆发过于戏剧性，包括德国在内每个国家都想保持在第一次工业革命中原有的低烈度战争，可笑的是几乎所有国家都一方面告诫其他国家不要进行动员以保持有限的和平，另一方面惧怕其他国家的动员而又私下进行动员。于是原本不堪重负的工业循环就迅速转向服务于军工产品，而军工产品不直接作用于生产，它的利润是以敌对国家的战败为基础的，要想获得胜利必须在军工业的投资与敌对国家保持同等量级甚至超过对方。随着每个国家都在倍增军工业的投资，欧洲的局势迅速恶化，离大战爆发只差个火星。 这次战争让世人第一次看清工业化的战争的残酷，上千万受过工业化基本教育的士兵被派往战场，数百万标准化的栓动枪械源源不断的从工厂运往前线，几万公里铁路的修建只是为了赢得战争。在此次战争中战争的形式也发生了巨大转变，骑兵在机枪和炮弹的火力下难以突破防线，步兵的机动力受到极大阻碍，以战壕为为核心的绵延不断的多层防线便成为战争的最佳选择，上百万士兵在前进中失去生命仅仅为了十几公里。此外，多种新式战争机器在战争中也被首次运用，典型的是装载了内燃机的坦克和飞机，尽管作用有限，在工业产能的加持下产量迅速增长且下次战争中他们中的任何一个都会发挥更为巨大的作用。同时，新兴的化学工业也被运用在战争中，氯气的使用对这种绵延防线有巨大破坏，但是由于难以预测风向而运用较少。海军主要起保证贸易网的作用，主要作战舰艇是受巡洋舰保护的战列舰和潜艇。因德国开启无限制潜艇战之后误伤了美国客轮，这给美国下场留下了借口，随着美国下场，本就在作战兵力和自然资源都难以为继的同盟国更加雪上加霜。 历经四年的战争以德国战败为结束，原有的阿尔萨斯洛林被割给了法国，莱茵兰也被划为非军事地区，东部的土地被划给了波兰，实际上，德国的战败并未伤害到德国的核心利益，原本意图得到殖民地的德国仅仅是失去了一次机会。相比较协约国的处境就很尴尬，法国人付出了120万人死亡的代价仅仅得到了半个工业区和若有若无的战争赔款，更何况同盟国根本支付不起。英国人付出了90万人死亡的代价仅仅维持了表面的世界霸主地位，而德国付出了170万人死亡的便做到了重创英法联盟，并且顺便把俄国皇帝赶下了台。奥匈帝国被一分为二，匈牙利得到了梦寐以求的独立地位。俄国承受了不能承受的战争负担因此迅速走向分裂，最终退出了战争并且在战争结束后建立了世界第一个无产阶级政权。这次战争最大的受益国是美国和日本，前者大发战争财，后者得到了德国在东亚殖民地的主权以及喘息的时间。 这场终结一切战争的战争除了战争外终结了一切，风雨飘摇的德国经济得到了美国的注资，一代人的伤亡会将用一代人的时间来抚平，可仇恨不会。得到了注资的德国重新焕发经济活力，9年后德国经济恢复到战前状态。又过了一年，德国经济地位重新回到世界第二，欧洲第一的战前地位。对殖民地和原材料的渴望同时也夹杂了对英法的民族主义仇恨推动了德国再次走向世界大战。但是这次不同，随着德国进入莱茵兰，吞并奥地利，英国的绥靖政策使法国以及一系列小国彻底失望，强硬的协约国再也不复存在。此时，法国因为一战损失了一代人而不想发动总动员，发动总动员的前提是英国也对等总动员，但随着德国入侵波兰，英国的保独政策终于起效，法国也随之对德宣战。 这次战争的残酷是绝无仅有的，原本在一战中崭露头角的武器在二战中迅速发展。随着化学技术的提高多种新式炸药被研制出来，炸药的威力逐步增加，安全性和烟尘问题也得到一定改善。在化学技术迅猛发展的同时，传统的机械控制在二战时也达到顶峰，新式的火控系统让坦克和火炮成为新的陆战主力。而空军由于石化技术的提高和飞机整体设计的进步在战争中得到了广泛的应用。在海军方面，以巡洋舰，战列舰保护的航母是主要作战核心，这一配置打败了以战列舰为海战核心的作战思想。在陆战方面，内燃机的运用使陆军的机动力大幅提高。相比一战的弹性防御的堑壕战思想，二战的机动作战能够迅速将堑壕分隔包围，没有补给的堑壕战犹如瓮中之鳖。典型的案例是德国对抗法国，装备了内燃机的坦克和现代化的运输卡车使得德军能够绕道阿登森林直取巴黎，这100公里的行程仅仅用了2天，而一战时，这个数字是2个月。于是从入侵法国到法国投降，德国装甲部队仅用了6个星期就完成了这一壮举。电子设备的出现使得不同部队配合程度大幅提高，因此主动的，进攻式的作战策略占据上风。依靠无线电台，指挥部可在千里之外收到侦察机的信号，这使得战场范围迅速扩大。东线战场上，由于苏联战前准备不足，内部大清洗还有余波，因而战争前期迅速失去大部分土地和工业，好在两个五年计划给了苏联足够的工业实力，使得苏联培养了足够的士兵和技术干部。相比德国的资源匮乏走的技术路线，苏联合理利用资源走了一条数量路线，在人员装备方面量大压倒了质优。在斯大林格勒战役中，前期由于德军战斗经验和装备精良使德军迅速的推进到城内，而在城内，战争的废墟阻挡了德军现代化的坦克和空军部队，并且由于气候的严酷和补给的缺乏更使得德军单兵实力大大下降。终于，苏联的兵力优势以及顽强的抵抗斗志占了上风，德军在斯大林格勒遭到重大挫败。之后在库尔斯克会战中，成群的 T34 击败了 “虎式”“豹式”，量大管饱的炮火让德军吃尽苦头。从美国正式参战开始，德国就必定走向失败的道路，战前的美国工业实力是英法德的总和，控制的资源更是德国急缺的石油和橡胶。于是，二战的结束只是时间问题了。东亚战场上，日本的工业实力甚至没能超越意大利，中国的工业实力连日本都不如。因此亚洲战场不在本文叙述范围内。 ","date":"2023-02-07","objectID":"/posts/century-industry/:3:3","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#世界大战"},{"categories":["Industry"],"content":" 信息时代","date":"2023-02-07","objectID":"/posts/century-industry/:4:0","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#信息时代"},{"categories":["Industry"],"content":" 世界背景二战后，世界格局发生重大变化，传统的英帝国被打成废墟，德国被一分为二。美国依靠百万奴工和两次世界大战大发横财，苏联依靠计划经济抄底大萧条崛起。在东欧和东亚，苏联占据主导地位，在中西欧和美洲，美国占据主导地位。两极格局正式形成。从民用工业体系角度来看，美国在汽车，石化，食品，农业等产业占优，基础机械，基础化学更甚。而苏联在军事工业上占优，在枪炮坦，航空航天，纺织，基础材料加工，大宗原材料生产方面占优。但总体而言，苏联的生产效率是远不如美国的。 ","date":"2023-02-07","objectID":"/posts/century-industry/:4:1","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#世界背景-2"},{"categories":["Industry"],"content":" 核能，集成电路与传统专门工业的巅峰核能一个应用路线是用作武器。核武器的出现尤其是实战令各国震惊不已，特别是当核武器被无法控制战争的烈度的人类掌握时，核武器的威慑力就大大增加了。核不扩散条约于1968年被联大审议通过，尽管我们知道印度，巴基斯坦，朝鲜都“非法”拥有核武器。这使条约看起很可笑，但我们可以从这一点看出，核武器作为平衡国际国际实力的有效手段是可以被“允许的”，前提是要支付代价。这也是在委婉的表达：核武器并不能毁灭世界，甚至连毁灭人类都不可以。从目前的和武器数量来说：它最多只能把人类现有的中大型城市毁灭，广大的乡村地区不属于它的工作职责。 核能另一个路线是能源，它与第二次工业革命的成果结合就是核能发电。核裂变发电我这里先不谈，这种发电方式不仅没有什么前途而且在人类总发电量中只占很少一部分。与之对应的核聚变发电的方式被视作解决人类能源的最终方法，因为在已探明宇宙中氢元素丰度最高，按质量算约占宇宙可见物质的四分之三，而可供聚变的氘和氚在氢元素中约占十万分之三，也就是说哪怕是在人类宇宙航行时最可靠的能源来源依然是核聚变。合适的聚变温度应在5千万-2亿度，因此现在聚变发电的难点在于控制高温粒子流不把容器打穿，而保护容器的难点在于研发恰当的材料以及提供快速准确的控制方式。可控核聚变作为庞大的系统工程，其实施难度，应用可行性远超前人预料，在通往解决人类能源问题的道路上我们还要准备过渡方案。 但在这里需要强调的是，核聚变作为人类可能的终极能源并不能解决人类社会一切矛盾。一种比较广泛的观点是，廉价的能源有助于人类到达“理想国”。但是不幸的是，包括能源突破在内没有哪项技术是真正的帮助完成这种最终的理想社会的。一千年之前人们把理想社会的实现建立在农业和水利工程的技术进步上，五百年的人认为繁荣和平的航海贸易就能建成人间天堂，到了一百年之前，理想社会就变成了苏维埃和全国电气化。如今只不过是把可控核聚变这层皮给披上去而已，无视了其他因素有尤其是社会因素的重要作用。对于建成理想社会的相关问题我的想法还不成熟，需要时间的磨练，我打算日后再谈。 ","date":"2023-02-07","objectID":"/posts/century-industry/:4:2","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#核能集成电路与传统专门工业的巅峰"},{"categories":["Industry"],"content":" 集成电路考虑到集成电路的极端重要性，我这里有必要单开一节来论述集成电路。 集成电路的出现反映了人类对于计算的需求，自从第二次工业革命以来，人类对于客观世界的认识由质的层面飞跃到量的层面。等待着科学家和工程师们的是无穷尽的客观条件所决定的各种物化参数，这种计算复杂量远远超过传统查表计算和计算尺计算的能力，新的计算工具呼之欲出。最早担任这一重任的是机械式计算机，这种计算机早在二战时期便已大规模应用，具体原理就是利用机械运动来做出能够进行基本计算的零件，进而由这些零件和其他辅助计算的部分组成整体式的机械计算机。无论是密码破译，核定经济，计算强度、产率，还是计算弹道，船舶运行参数，设计飞行器等老式的计算机都有大规模的应用。但是这种计算机有着价格昂贵，速度慢，难以维护等缺点，因此在真空管出现后被迅速取代。 早期的真空管也称阴极射线管，其主要结构是一个内部含有电子放射源和收集电子装置的真空管，并且在放射源和收集装置之间还有与真空管外部相连的可以收集电子的回路。这样，只要持续给放射源供电，放射源就会发出电子，这些电子经过未导通的电子回路可以到达收集装置，但如果电子回路被导通，放射电子就会优先被收集电子的回路所吸引，电子就不能到达收集装置。我们把发射源叫做发射极，收集装置叫做集电极，收集电子的回路叫做基级，这样用基极就可以控制集电极的导通与否了。 有了基本的真空管和二极管，我们可以做成基本门电路，有了基本门电路后，我们还能做出复杂的逻辑电路。例如，可由四个与非门组成的JK触发器进一步组成T触发器，从而实现计数功能，计数的位数由JK触发器的个数决定，若再由若干门电路和二极管便可组成译码器，使得计数器可以将结果显示在十进制的数码显示管上。有了复杂电路后人们就可以应用于生产和科研，比如新的电子式的显示设备取代了机械式的数字显示设备。 集成电路复杂的逻辑首先被用在设计计算机上。高速，高可靠性，结构简单的电子式计算机迅速赢得美国军方的青睐。随着晶体管的小型化和MOS管的诞生，集成电路迅速小型化，使其可以装在飞机，坦克，火炮上。集成电路除了被制成计算机，还被广泛用于自动化控制上。早期的控制原件多采用机械式原理，结构庞大成本很高，当集成电路被小型化后，传统的机械式控制迅速被电气式取代，较低的成本高速的计算性能使得工业生产率大幅提高。在新世纪后，集成电路产业的迅速发展催生了互联网， 信息终端设备，工业自动化，信息处理软件等新兴行业，创造了惊人物质财富。 ","date":"2023-02-07","objectID":"/posts/century-industry/:4:3","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#集成电路"},{"categories":["Industry"],"content":" 传统专门工业的巅峰二战后的废墟并不能阻挡人们重建家园的愿望，消灭了过剩产品和社会不稳定因素的二战虽然给人类造成了永久的创伤但另一方面也促进了人类科技的蓬勃发展，在和平的历史条件下进步缓慢的重工业在二战中迅速发展，同时各个传统工业门类迅速分化。例如机械这个传统工业门类在二战中与控制领域结合，产生了坦克火炮控制系统，并且同领域的航天也衍生出了飞行控制系统。机械领域与化学领域结合，诞生了高品质合金钢，表面处理工艺。在二战后期，由于战后重建的需要，机械与土木结合促进了工程机械大爆发等等。我们可以看到，这种专业门类的深入化和细分化颇有预见性的为接下来70年的工业化道路指明了方向。 集成电路出现后各门类工业模式发生了变化，它在取代了原有领域的部分产品的基础上也推动了自己的发展。例如，老式的气动管道物流传输系统被广泛用于医院，传媒和政府机关部门。但是及时，准确，易维护，投资低的电子式信息系统成了最新选择，除了少数对物流要求颇高的应用场合还在维持运行，绝大部分的气动管道系统在之后的电子设备大发展的时代被迅速抛弃。这种变化也是那时工业发展变化的一个缩影：代表着先进生产力的，能够节约劳动力的电子式系统占据了绝大部分发展通道，而催生出这一产业的机械化学和材料等产业却只能停留在改进工艺，探索物质新的组织方式这种古板的发展道路上。这种发展模式让人不得不联想第一次工业革命早期，那时传统的第一产业已经达到了发展的巅峰，它们无法再带领人类继续提高生产力了，只有剥削自己榨出足够的剩余农产品帮助工业成长，才能在此之后依靠工业获得足够的发展机会。两种情形对比来看，这实在让人唏嘘。 但总之，无论人类喜不喜欢，这种潮流还会持续下去的，拥抱变化的人努力地活着，墨守成规的人寂静的死去。新式的计算机结合工业的技术在80年代诞生，世纪末已经有了一部分应用，在下个世纪初的头十年是这种技术迅速发展的阶段。 在最后我还要强调一件事，那就是我写在文章开头的那句话：“资本主义 100 年所创造的物质财富超过了以往一切时代的总和。”马克思这句话并不准确，资本主义除了传统的工商业资本主义的形式外，还有农业的，宗教的，军事的等等，作为工具的资本主义是不会创造出如此的丰富的物质世界。我个人更喜欢把这句话改写成这样：“大工业生产 100 年所创造的物质财富超过了以往一切时代的总和”。并且这句话在此时依然是成立的，二战的消耗虽然庞大但而工业发展和恢复的速度更为迅速，这种迅速使得人类在此之前一切物质的生产和消耗都相形见绌。在二战中西欧70%的工业被摧毁，而各国50年代初的经济便达到了战前水平，此时离二战结束不过5年。 ","date":"2023-02-07","objectID":"/posts/century-industry/:4:4","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#传统专门工业的巅峰"},{"categories":["Industry"],"content":" 总结新世纪前后的工业是我想要论述的重点，但碍于篇幅且本文行文较为抽象，与叙述新世纪的工业模式变化需要详实的数据的情况不，因此关于具体阐释世纪前后的工业变化将另开一文。虽然本文缺失了现代工业发展模式，但强调工业脉络目的已然达成，我们可以从上文总结出工业的特点，这并不妨碍我们所归纳结论的准确性和全面性。这些特点是我从大学四年的学习中获得的经验所总结出来的，我会在力求准确的基础上保证尽量简洁。详细解释将会发在本系列的下篇文章。 ","date":"2023-02-07","objectID":"/posts/century-industry/:0:0","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#总结"},{"categories":["Industry"],"content":" 工业的特点 1 工业需要自迭代系统，自我循环的结构和推动循环的动力。 工业的增长脱离了人力畜力的限制，打破了农业社会发展上限。 工业极度渴望增长，且增长的速度和带来的矛盾前所未有。 现代的工业与资本主义绑定，于是逐利和过剩也成了其根本标志。 经过百年发展，工业中的不同行业分化极其严重，生产过程极其复杂。 工业时代的社会也有危机，并且这种危机不仅频繁破坏性还更大。 满足需求新的工业产品收益丰厚，但产品改良到一定程度收益会下降。 本节不定期更新 ↩︎ ","date":"2023-02-07","objectID":"/posts/century-industry/:1:0","series":null,"tags":["Industry,Mechanic,History"],"title":"百年工业","uri":"/posts/century-industry/#工业的特点"},{"categories":[""],"content":"本文测试 Markdown，网页排版及渲染 ","date":"2023-01-19","objectID":"/posts/test1/:0:0","series":null,"tags":[""],"title":"测试","uri":"/posts/test1/#"},{"categories":[""],"content":" 一级标题","date":"2023-01-19","objectID":"/posts/test1/:0:0","series":null,"tags":[""],"title":"测试","uri":"/posts/test1/#一级标题"},{"categories":[""],"content":" 二级标题","date":"2023-01-19","objectID":"/posts/test1/:1:0","series":null,"tags":[""],"title":"测试","uri":"/posts/test1/#二级标题"},{"categories":[""],"content":" 三级标题斜体 重点 删除 无序列表 1 无序列表 2 有序列表 1 有序列表 2 链接：百度 图片：Arch Linux 脚注1 上标^上标^ 下标下标 分割线 引用1 引用2 引用2.1 引用2.2 C #include\u003cstdio.h\u003e int main() { printf(\"代码测试\"); } 高亮 脚注内容 ↩︎ ","date":"2023-01-19","objectID":"/posts/test1/:1:1","series":null,"tags":[""],"title":"测试","uri":"/posts/test1/#三级标题"},{"categories":[""],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. ","date":"2023-01-02","objectID":"/posts/hello-world/:0:0","series":null,"tags":[""],"title":"Hello World","uri":"/posts/hello-world/#"},{"categories":[""],"content":" Quick Start","date":"2023-01-02","objectID":"/posts/hello-world/:1:0","series":null,"tags":[""],"title":"Hello World","uri":"/posts/hello-world/#quick-start"},{"categories":[""],"content":" Create a new post bash $ hexo new \"My New Post\" More info: Writing ","date":"2023-01-02","objectID":"/posts/hello-world/:1:1","series":null,"tags":[""],"title":"Hello World","uri":"/posts/hello-world/#create-a-new-post"},{"categories":[""],"content":" Run server bash $ hexo server More info: Server ","date":"2023-01-02","objectID":"/posts/hello-world/:1:2","series":null,"tags":[""],"title":"Hello World","uri":"/posts/hello-world/#run-server"},{"categories":[""],"content":" Generate static files bash $ hexo generate More info: Generating ","date":"2023-01-02","objectID":"/posts/hello-world/:1:3","series":null,"tags":[""],"title":"Hello World","uri":"/posts/hello-world/#generate-static-files"},{"categories":[""],"content":" Deploy to remote sites bash $ hexo deploy More info: Deployment ","date":"2023-01-02","objectID":"/posts/hello-world/:1:4","series":null,"tags":[""],"title":"Hello World","uri":"/posts/hello-world/#deploy-to-remote-sites"}]