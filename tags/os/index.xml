<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>OS - 标签 - 吾铭子</title>
        <link>https://1078249029.github.io/tags/os/</link>
        <description>OS - 标签 - 吾铭子</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>1078249029@qq.com (吾铭子)</managingEditor>
            <webMaster>1078249029@qq.com (吾铭子)</webMaster><lastBuildDate>Sat, 19 Oct 2024 10:50:25 &#43;0800</lastBuildDate><atom:link href="https://1078249029.github.io/tags/os/" rel="self" type="application/rss+xml" /><item>
    <title>移植ESP32SPI驱动至rtthread教程</title>
    <link>https://1078249029.github.io/posts/planting-esp32spi-to-rtthread/</link>
    <pubDate>Sat, 19 Oct 2024 10:50:25 &#43;0800</pubDate><author>
        <name>吾铭子</name>
    </author><guid>https://1078249029.github.io/posts/planting-esp32spi-to-rtthread/</guid>
    <description><![CDATA[<h1 id="移植esp32spi驱动至rt-thread" class="headerLink">
    <a href="#%e7%a7%bb%e6%a4%8desp32spi%e9%a9%b1%e5%8a%a8%e8%87%b3rt-thread" class="header-mark"></a>移植ESP32SPI驱动至RT-Thread</h1><p>本文是博主移植驱动工作的总结，详细介绍了移植过程以及遇到的问题及其解决方案，希望对各位有帮助。同时，代码已进入<a href="https://github.com/RT-Thread/rt-thread/pull/9513" target="_blank" rel="noopener noreferrer">RT-Thread主线</a>。博文同时发表在个人博客<a href="wumingzi.top" rel="">wumingzi.top</a></p>
<p>本文主要使用、查阅了以下资料：</p>
<ul>
<li>参考书籍 RT-Thread设备驱动开发指南，ESP32官方文档</li>
<li>硬件 ESP32-C3-DevKitM-1，W25Q64</li>
</ul>
<h2 id="系统平台搭建" class="headerLink">
    <a href="#%e7%b3%bb%e7%bb%9f%e5%b9%b3%e5%8f%b0%e6%90%ad%e5%bb%ba" class="header-mark"></a>系统平台搭建</h2><p>具体的硬件连线不必多说，参考<a href="https://docs.espressif.com/projects/esp-dev-kits/zh_CN/latest/esp32c3/esp32-c3-devkitm-1/user_guide.html#id9" target="_blank" rel="noopener noreferrer">ESP32C3官方开发板的原理图</a>即可，交叉编译环境可以参考博主的这篇文章<a href="https://club.rt-thread.org/ask/article/cf9ff0733112d936.html" target="_blank" rel="noopener noreferrer">ESP32C3环境搭建教程</a>，代码编辑器我使用了vscode+clang的搭配方式，不采用微软的C/C++插件的原因是在编写驱动时vscode发生过多次闪退的情况，并且代码提示和高亮补全残缺，相关配置可自行参考网上</p>
<h2 id="代码参考" class="headerLink">
    <a href="#%e4%bb%a3%e7%a0%81%e5%8f%82%e8%80%83" class="header-mark"></a>代码参考</h2><p>我们可以参考其他芯片的SPI驱动代码来编写，个人参考了GD32和STM32的代码，GD32的驱动代码会简单很多，STM32会更复杂一些</p>
<h2 id="修改kconfig与sconscript文件" class="headerLink">
    <a href="#%e4%bf%ae%e6%94%b9kconfig%e4%b8%8esconscript%e6%96%87%e4%bb%b6" class="header-mark"></a>修改Kconfig与SConscript文件</h2><p>Kconfig指定了系统资源，使得我们可以通过menuconfig来选择配置系统。Kconfig原理可以看<a href="https://www.rt-thread.org/document/site/#/development-tools/build-config-system/Kconfig?id=kconfig" target="_blank" rel="noopener noreferrer">官方文档</a>，简而言之，我们可以通过menuconfig的tui界面来配置Kconfig从而生成.config文件，而后再由系统解析.config文件最后生成rtconfig.h文件来指定系统宏的值从而配置系统。但当前Kconfg并不支持SPI驱动，因此我们需要新增Kconfig选项。</p>
<p>Kconfig的风格与厂商，开发者个人相关。例如有的厂商会习惯将引脚配置项放在板上菜单中，并将功能配置项放在片上外设菜单中 ，而有的厂商会将两者都混放在片上外设菜单或BSP菜单中。前者代表是ESP32和GD32，后者代表是STM32</p>
<p>新增的代码如下</p>
<div class="code-block highlight is-open show-line-numbers  tw-group tw-my-2">
  <div class="
    
    tw-flex 
    tw-flex-row
    tw-flex-1 
    tw-justify-between 
    tw-w-full tw-bg-bgColor-secondary
    ">      
    <button 
      class="
        code-block-button
        tw-mx-2 
        tw-flex
        tw-flex-row
        tw-flex-1"
      aria-hidden="true">
          <div class="group-[.is-open]:tw-rotate-90 tw-transition-[transform] tw-duration-500 tw-ease-in-out print:!tw-hidden tw-w-min tw-h-min tw-my-1 tw-mx-1"><svg class="icon"
    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"/></svg></div>
          <p class="tw-select-none !tw-my-1">Kconfig</p>]]></description>
</item><item>
    <title>Linux深入</title>
    <link>https://1078249029.github.io/posts/linux-advanced/</link>
    <pubDate>Fri, 23 Feb 2024 11:44:04 &#43;0800</pubDate><author>
        <name>吾铭子</name>
    </author><guid>https://1078249029.github.io/posts/linux-advanced/</guid>
    <description><![CDATA[<p>Linux驱动深入</p>
<!-- more -->
<h1 id="linux深入" class="headerLink">
    <a href="#linux%e6%b7%b1%e5%85%a5" class="header-mark"></a>Linux深入</h1><h2 id="内联汇编" class="headerLink">
    <a href="#%e5%86%85%e8%81%94%e6%b1%87%e7%bc%96" class="header-mark"></a>内联汇编</h2><p>为了保证效率或者使用特殊指令(如原子操作)时需要使用汇编，使用方法是：单独将汇编代码放在.S文件中，在C函数中使用extern声明之后就可以使用汇编文件里的函数了</p>
<p>对于内联汇编需要使用__asm___关键字修饰函数

<figure><a class="lightgallery" href="/vx_images/30092012266713.png" title="2024-02-13_12-19" data-thumbnail="/vx_images/30092012266713.png" data-sub-html="<h2> </h2><p>2024-02-13_12-19</p>"><img   src='/vx_images/30092012266713.png'   alt="2024-02-13_12-19" height="731" width="1062"></a><figcaption class="image-caption">2024-02-13_12-19</figcaption>
    </figure></p>
<h2 id="同步互斥的深入" class="headerLink">
    <a href="#%e5%90%8c%e6%ad%a5%e4%ba%92%e6%96%a5%e7%9a%84%e6%b7%b1%e5%85%a5" class="header-mark"></a>同步互斥的深入</h2><p>在单核CPU上关中断开中断是可以实现同步互斥的，但是在多核CPU上开关中断不能保证其他CPU不会修改临界变量</p>
<h3 id="原子操作" class="headerLink">
    <a href="#%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c" class="header-mark"></a>原子操作</h3><p>对于ARMv6之前的内核，通过关中断恢复中断来实现原子操作，但是在v6之后(包括v6)，由于arm支持SMP(多核CPU)，因此不能简单的使用开关中断来实现原子操作，而是使用ldrex，strex汇编语句来实现，其根本原理是在要ldr数据上打上标记，在要str的数据上消除标记，根据能否消除标记而返回不同的值，根据值来判断是否申请资源成功，不成功的话则再次重复，直到能申请资源为止</p>
<p>
<figure><a class="lightgallery" href="/vx_images/333854115259382.png" title="2024-02-13_15-41" data-thumbnail="/vx_images/333854115259382.png" data-sub-html="<h2> </h2><p>2024-02-13_15-41</p>"><img   src='/vx_images/333854115259382.png'   alt="2024-02-13_15-41" height="1096" width="1809"></a><figcaption class="image-caption">2024-02-13_15-41</figcaption>
    </figure></p>
<h2 id="锁" class="headerLink">
    <a href="#%e9%94%81" class="header-mark"></a>锁</h2><h3 id="自旋锁" class="headerLink">
    <a href="#%e8%87%aa%e6%97%8b%e9%94%81" class="header-mark"></a>自旋锁</h3><p>自旋锁无法休眠，当一段临界区被加上自旋锁时，如果CPU0与CPU1都竞争临界区只有CPU0获得资源的话，那么CPU1不会休眠而是会反复请求资源(当写程序时，在进中断时也要加自旋锁来防止其他CPU打断当前CPU执行irq)，因此，使用自旋锁时临界区代码要尽量精简(5行左右)，且不能休眠</p>
<p>自旋锁在 <strong>单核系统(UP)</strong> 还可以用来禁止调度防止抢占，对于不同的自旋锁他有不同的防止抢占方式，比如对于最普通的spin_lock()而言，他只能关闭调度，而对于spin_lock_irq()而言，它可以关闭中断</p>
<p>自旋锁的实现：每个自旋锁上都有当前任务编号，和当前任务编号+1的下一个任务编号，内核会检查想要申请资源的自旋锁任务编号与当前自旋锁下一个任务编号是否相同，相同的话则获得锁，否则wfe休眠一段时间</p>
<h3 id="睡眠锁" class="headerLink">
    <a href="#%e7%9d%a1%e7%9c%a0%e9%94%81" class="header-mark"></a>睡眠锁</h3><p>睡眠锁有mutex和semaphore两种</p>
<p>对于信号量来说，它可以休眠，因此对于临界区代码可以比自旋锁复杂很多，信号量用于多进程间访问同步和互斥，而互斥锁用于保护某个临界资源</p>
<p>在信号量结构体中，需要用到自旋锁</p>
<p>semaphore的实现：semaphore结构体中有spinlock，还有个count和wait_list，当使用spinlock_up获取semaphore时，首先需要获得spinlock，如果成功获得则需要让count++，否则把自己挂载到wait_list上</p>
<p>mutex的实现：与semaphore类似，但是由于追求效率会更为复杂，里面配置了宏开关来优化效率，通过宏可以选择等待mutex的线程是否休眠(休眠开销太大)。当进入临界区获取资源时也可以自动判断使用fastpath还是slowpath</p>
<p>fastpath与slowpath：
当一段临界区代码很短且需要mutex时，这时大概率会出现线程不需要等待而直接获取资源，并且解锁时也不需要唤醒其他线程，这种情况称为fastpath，而需要等待获取资源且需要唤醒其他线程称为slowpath，两个的选择取决于mutex结构体中的count(是个原子变量)，count值为1时表示unlocked，此时其他线程可以获得锁，count值为0时代表locked，需要解锁，但是当前执行任务的线程解锁后不需要唤醒其他任务此时为fastpath，当count值为-1时，代表当前任务解锁后还需要唤醒其他线程，这时是slowpath</p>
<p>mutex的实现比semaphore更复杂，这是因为mutex追求更高的效率，在写驱动程序的时候尽量使用mutex</p>
<h2 id="usart" class="headerLink">
    <a href="#usart" class="header-mark"></a>USART</h2><p>访问虚拟终端中的<strong>前台</strong>终端：/dev/tty0
访问当前程序运行的终端(考虑真实的USART等终端)：/dev/tty (不会输出信息到其他tty)</p>
<p>在驱动模块崩溃时可以查看LR来找到崩溃的函数
当驱动程序错误时，可以使用<strong>strace  -o  log.txt ./exe</strong>可以在log.txt里获得系统调用</p>
<h3 id="printk" class="headerLink">
    <a href="#printk" class="header-mark"></a>printk</h3><p>printk后面可以加上打印级别，如果不指定打印级别则会默认打印级别，当console设置的打印级别低于内核级别时则不会打印printk。如果想在多个控制台打印时，可以在设备树或者uboot指定console=tty0，console=tty1，但是只有最后指定的console会收到串口信息。实际上，uboot也是通过修改设备树来实现更改打印终端的</p>
<div class="code-block highlight is-open show-line-numbers  tw-group tw-my-2">
  <div class="
    
    tw-flex 
    tw-flex-row
    tw-flex-1 
    tw-justify-between 
    tw-w-full tw-bg-bgColor-secondary
    ">      
    <button 
      class="
        code-block-button
        tw-mx-2 
        tw-flex
        tw-flex-row
        tw-flex-1"
      aria-hidden="true">
          <div class="group-[.is-open]:tw-rotate-90 tw-transition-[transform] tw-duration-500 tw-ease-in-out print:!tw-hidden tw-w-min tw-h-min tw-my-1 tw-mx-1"><svg class="icon"
    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"/></svg></div>
          <p class="tw-select-none !tw-my-1">shell</p>]]></description>
</item><item>
    <title>Linux内核</title>
    <link>https://1078249029.github.io/posts/linux-kernel/</link>
    <pubDate>Wed, 21 Feb 2024 16:55:40 &#43;0800</pubDate><author>
        <name>吾铭子</name>
    </author><guid>https://1078249029.github.io/posts/linux-kernel/</guid>
    <description><![CDATA[<p>date: 2024-4-10 9:48:30</p>
<h1 id="linux内核基础" class="headerLink">
    <a href="#linux%e5%86%85%e6%a0%b8%e5%9f%ba%e7%a1%80" class="header-mark"></a>Linux内核基础</h1><p><strong>本文阐述系统为x86体系架构，idt，gdt，tss，系统启动引导过程均以x86架构为蓝本，arm可能不适用</strong></p>
<!-- more -->
<h2 id="linux内核体系结构" class="headerLink">
    <a href="#linux%e5%86%85%e6%a0%b8%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84" class="header-mark"></a>Linux内核体系结构</h2><p>nmi(not mask interrupt)不可屏蔽中断
系统启动时会读取RTC并赋值给jiffies
内核中定时器使用链表进行管理</p>
<p>每个进程都有LDT(局部描述符)，即代码段和数据段。单处理器系统只有一个GDT，而在多处理器系统中每个CPU都有一个GDT，GDT(全局描述符)是各个寄存器地址</p>
<p>IDT(中断描述符表)，其作用也类似于中断向量表，只是其中每个中断描述符项中除了含有中断服务程序地址以外，还包含有关<strong>特权级</strong>和<strong>描述符类别</strong>等信息
<a href="https://blog.csdn.net/yxc135/article/details/8734452" target="_blank" rel="noopener noreferrer">中断向量表和中断描述符表IDT-CSDN</a></p>
<p><a href="https://blog.csdn.net/ybxuwei/article/details/80657461" target="_blank" rel="noopener noreferrer">linux分段-CSDN</a></p>
<p>
<figure><a class="lightgallery" href="/vx_images/373000621257049.png" title="2024-02-22_21-06" data-thumbnail="/vx_images/373000621257049.png" data-sub-html="<h2> </h2><p>2024-02-22_21-06</p>"><img   src='/vx_images/373000621257049.png'   alt="2024-02-22_21-06" height="628" width="778"></a><figcaption class="image-caption">2024-02-22_21-06</figcaption>
    </figure></p>
<p>TSS(任务状态段)就是特殊寄存器 + 通用寄存器的信息</p>
<p>
<figure><a class="lightgallery" href="/vx_images/56405009258689.png" title="2024-02-22_09-49" data-thumbnail="/vx_images/56405009258689.png" data-sub-html="<h2> </h2><p>2024-02-22_09-49</p>"><img   src='/vx_images/56405009258689.png'   alt="2024-02-22_09-49" height="1070" width="1903"></a><figcaption class="image-caption">2024-02-22_09-49</figcaption>
    </figure></p>
<h3 id="fork的实现" class="headerLink">
    <a href="#fork%e7%9a%84%e5%ae%9e%e7%8e%b0" class="header-mark"></a>fork的实现</h3><ul>
<li>申请内存空间</li>
<li>把父进程的task_struct拷贝到子进程的task_struct并重新设置</li>
<li>设置进程状态为可运行，返回pid</li>
</ul>
<p>需要注意的是fork出的子进程的文件描述符比父进程大1，这也是Linux基础文章中现象的实现</p>
<p>
<figure><a class="lightgallery" href="/vx_images/402763010246556.png" title="2024-02-22_10-28" data-thumbnail="/vx_images/402763010246556.png" data-sub-html="<h2> </h2><p>2024-02-22_10-28</p>"><img   src='/vx_images/402763010246556.png'   alt="2024-02-22_10-28" height="1079" width="1144"></a><figcaption class="image-caption">2024-02-22_10-28</figcaption>
    </figure></p>
<h3 id="进程调度" class="headerLink">
    <a href="#%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6" class="header-mark"></a>进程调度</h3><p>在0.11内核中，进程调度分为调度和切换两个步骤，调度负责将用完时间片的进程挂起，并将进程的状态位改为暂停状态，切换时为了效率采用汇编，它的作用是将那些设置状态位的进程加载进CPU寄存器中，即执行上下文切换的功能</p>
<h3 id="进程销毁" class="headerLink">
    <a href="#%e8%bf%9b%e7%a8%8b%e9%94%80%e6%af%81" class="header-mark"></a>进程销毁</h3><p>以syscall_和do_开头的基本上是系统调用，即中断服务函数</p>
<ul>
<li>内核的销毁流程
<ul>
<li>进入do_exit函数
<ul>
<li>首先释放数据段和代码段占用的内存</li>
<li>关闭进程打开的所有文件，对当前的目录和i节点进行同步</li>
<li>如果进程是个会话头进程，则会终止会话中的所有进程</li>
<li>改变进程运行状态为TASK_ZOMBIE，并且向父进程发送SIGCHLD信号，do_exit函数执行完毕</li>
</ul>
</li>
<li>在父进程中进行最后的处理工作，父进程运行子进程的时候一般都会运行wait或waitpid这两个函数(父进程等待某个子进程终止的函数)，当父进程收到SIGCHLD信号时会终止僵死状态的子进程
<ul>
<li>首先父进程会把子进程的运行时间(utime,stime)累加到自己的进程变量中，把要销毁的子进程的进程描述结构体进行释放，置空任务数组中的子进程任务槽</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>
<figure><a class="lightgallery" href="/vx_images/231530512266722.png" title="2024-02-22_12-05" data-thumbnail="/vx_images/231530512266722.png" data-sub-html="<h2> </h2><p>2024-02-22_12-05</p>"><img   src='/vx_images/231530512266722.png'   alt="2024-02-22_12-05" height="609" width="2090"></a><figcaption class="image-caption">2024-02-22_12-05</figcaption>
    </figure></p>
<h2 id="linux内核启动引导" class="headerLink">
    <a href="#linux%e5%86%85%e6%a0%b8%e5%90%af%e5%8a%a8%e5%bc%95%e5%af%bc" class="header-mark"></a>Linux内核启动引导</h2><h3 id="操作系统的启动" class="headerLink">
    <a href="#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%90%af%e5%8a%a8" class="header-mark"></a>操作系统的启动</h3><p>Linux启动时的硬件信息是由bootloader传进来的</p>
<ul>
<li>Linux启动流程
<ul>
<li>首先由BIOS/bootloader进行一系列的硬件初始化和参数设置，并把bootsect.s从硬盘中某个固定地址搬到内存中的某个固定地址，需要注意在内核初始化需要关中断来防止初始化被中断。</li>
<li>bootsect.s将setup.s代码从磁盘中加载到紧接着bootsect.s的地方，最后跳转到setup.s中运行</li>
<li>setup.s负责将bootloader传进来的信息进行解析，关中断并加载system模块，使system模块正好覆盖bootsect.s(关中断是为了防止覆盖bootsect.s的代码后系统不能处理中断而导致崩溃)。设置LDT，GDT，IDT，而后设置中断芯片，进入到保护模式(svc32)运行，在代码的最后会跳转到head.s(0x00000000)执行</li>
<li>head.s加载内核运行时的各数据段寄存器，并重新设置IDT(防止被数据区覆盖)，设置内存对齐以及分页，最后跳转到main.c开始运行，系统启动完成</li>
</ul>
</li>
<li>Linux在启动的时候是如何拿到硬件参数的
<ul>
<li>通过bootloader加载传入的参数(_atags_pointer)，这个参数是一块指向存有硬件信息内存的首地址的指针，通过这个指针就可以获得硬件参数</li>
</ul>
</li>
<li>Linux在初始化运行中都做了什么
<ul>
<li>进行硬件的初始化(就是下文中各种段的设置)，fork出0号进程</li>
</ul>
</li>
</ul>
<p>
<figure><a class="lightgallery" href="/vx_images/577701316251700.png" title="2024-02-22_16-13" data-thumbnail="/vx_images/577701316251700.png" data-sub-html="<h2> </h2><p>2024-02-22_16-13</p>"><img   src='/vx_images/577701316251700.png'   alt="2024-02-22_16-13" height="943" width="2260"></a><figcaption class="image-caption">2024-02-22_16-13</figcaption>
    </figure></p>]]></description>
</item><item>
    <title>Linux基础</title>
    <link>https://1078249029.github.io/posts/linux-basics/</link>
    <pubDate>Tue, 23 Jan 2024 18:18:18 &#43;0800</pubDate><author>
        <name>吾铭子</name>
    </author><guid>https://1078249029.github.io/posts/linux-basics/</guid>
    <description><![CDATA[<p>基础的Linux应用与驱动开发</p>
<!-- more -->
<h1 id="linux" class="headerLink">
    <a href="#linux" class="header-mark"></a>Linux</h1><h2 id="linux基础" class="headerLink">
    <a href="#linux%e5%9f%ba%e7%a1%80" class="header-mark"></a>Linux基础</h2><p>shell负责解析命令，当用户在shell中输入命令时，根据输入的结果，shell根据PATH环境变量的位置找到相应的程序执行，因此可以通过将.o文件复制到PATH来直接在任何目录下执行程序，否则只能使用绝对路径或相对路径的方式来执行</p>
<p>[]代表可选参数 &lt;&gt;代表必选参数</p>
<h3 id="linux基础命令与操作" class="headerLink">
    <a href="#linux%e5%9f%ba%e7%a1%80%e5%91%bd%e4%bb%a4%e4%b8%8e%e6%93%8d%e4%bd%9c" class="header-mark"></a>Linux基础命令与操作</h3><p>. 当前目录 .. 上一级目录 - 切换前上一次的目录</p>
<div class="code-block highlight is-open show-line-numbers  tw-group tw-my-2">
  <div class="
    
    tw-flex 
    tw-flex-row
    tw-flex-1 
    tw-justify-between 
    tw-w-full tw-bg-bgColor-secondary
    ">      
    <button 
      class="
        code-block-button
        tw-mx-2 
        tw-flex
        tw-flex-row
        tw-flex-1"
      aria-hidden="true">
          <div class="group-[.is-open]:tw-rotate-90 tw-transition-[transform] tw-duration-500 tw-ease-in-out print:!tw-hidden tw-w-min tw-h-min tw-my-1 tw-mx-1"><svg class="icon"
    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"/></svg></div>
          <p class="tw-select-none !tw-my-1">shell</p>]]></description>
</item><item>
    <title>FreeRTOS</title>
    <link>https://1078249029.github.io/posts/freertos/</link>
    <pubDate>Sun, 24 Dec 2023 10:06:40 &#43;0800</pubDate><author>
        <name>吾铭子</name>
    </author><guid>https://1078249029.github.io/posts/freertos/</guid>
    <description><![CDATA[<h1 id="freertos" class="headerLink">
    <a href="#freertos" class="header-mark"></a>FreeRTOS</h1><p>使用静态创建任务函数的话，返回值就是句柄，因此，要想对静态函数创建出来的任务进行操作的话需要创建一个临时变量以记录其返回值
使用vTaskDelet函数要注意不要在自己的进程内部自杀，这样会导致空闲任务无法清理内存</p>
<!-- more -->
<p>
<figure><a class="lightgallery" href="/vx_images/520675109231265.png" title="2023-12-24_09-51" data-thumbnail="/vx_images/520675109231265.png" data-sub-html="<h2> </h2><p>2023-12-24_09-51</p>"><img   src='/vx_images/520675109231265.png'   alt="2023-12-24_09-51" height="1215" width="1058"></a><figcaption class="image-caption">2023-12-24_09-51</figcaption>
    </figure></p>
<p>
<figure><a class="lightgallery" href="/vx_images/261583815249686.png" title="2023-12-19_15-36" data-thumbnail="/vx_images/261583815249686.png" data-sub-html="<h2> </h2><p>2023-12-19_15-36</p>"><img   src='/vx_images/261583815249686.png'   alt="2023-12-19_15-36" height="1271" width="1568"></a><figcaption class="image-caption">2023-12-19_15-36</figcaption>
    </figure>
TCB结构体内部包含函数指针，SP位置，优先级，函数名字，函数参数等，但并不包括函数的指针(用来执行本函数)，也不包括函数参数，CPU通过保存所有寄存器的值来保存这两项，保存的位置在该函数栈的顶部，其中R0，R1&hellip;保存了函数的参数(约定俗成)，R15(PC)保存了函数的指针，来进行函数的跳转操作
优先级最大值只能取到最大值-1，高于这个值的会自动变为最大值-1
空闲任务(xIdleTask)是启动调度器时就自动创建的，空闲任务可以使用自带的钩子函数创建出来，也可以用来处理下列任务</p>
<ol>
<li>执行一些低优先级的，后台的，需要连续执行的函数</li>
<li>进入省电模式</li>
<li>测量系统空闲时间</li>
</ol>
<p>空闲任务的限制： 不能让空闲任务进入阻塞状态或者暂停状态
取消支持时间片流转会使优先级相同的其中一个任务在未被高优先级打断前始终霸占CPU
调度策略配置项</p>
<ol>
<li>是否抢占(高优先级任务是否可以立即打断低优先级的执行)</li>
<li>允许抢占时，是否允许时间片流转(同一优先级任务执行时，是否允许相互打断执行)</li>
<li>允许抢占并且允许时间片流转时，是否允许空闲任务让步(空闲任务和用户任务在同一优先级时，空闲任务是否让出时间片) <br>
<a href="https://www.cnblogs.com/weidongshan/p/15624113.html" target="_blank" rel="noopener noreferrer">博客园</a></li>
</ol>
<p>
<figure><a class="lightgallery" href="/vx_images/24251810231257.png" title="2023-12-16_10-16" data-thumbnail="/vx_images/24251810231257.png" data-sub-html="<h2> </h2><p>2023-12-16_10-16</p>"><img   src='/vx_images/24251810231257.png'   alt="2023-12-16_10-16" height="1055" width="1697"></a><figcaption class="image-caption">2023-12-16_10-16</figcaption>
    </figure>
采用这种方式运行并发程序会导致Task3 Task4在将锁置为1之前就都已经进入if语句内部了，这就会导致概率性并发Bug
写队列函数xQueueSend与xQueueSendToBack是一样的，都是默认在队列尾部写入数据，而xQueueSendToFront则是在头部写入数据(头部就是pcReadFrom指针所指的地址，并不是队列的最右侧)，此时还需要将pcReadFrom指针减去一个ItemSize的地址
使用队列集并在队列里面写入数据时会把任务的数据写在队列里，并把任务的Handle写在队列集(Queue Set)里，读一次Queue Set后返回的Queue只能读一次，不能读多次，普通的Queue也一样因为读队列后系统自动删除数据
二值信号量的Give函数会检测信号量是否为1，若为1则会返回失败，而Take函数则会检查信号量是否为0，并且可以设置阻塞时间
信号量不能是负值
创建二值型信号量时默认初始值是0，需要Give一下，互斥量则不需要
信号量：Semaphore    互斥量：Mutex
只有申请方和接收方有锁的情况下才会产生优先级反转，如果其中一方无锁则正常调度就不会产生优先级反转，解决优先级反转的办法是优先级继承
为了解决优先级反转的问题，互斥量引入了优先级继承，而信号量则没有，同时由于优先级继承是指任务中的优先级，因此对于中断来说无意义。因此中断中不可以使用互斥量<a href="https://www.cnblogs.com/hanyli/p/17272577.html" target="_blank" rel="noopener noreferrer">互斥量不能在中断例程中使用的原因-博客园</a></p>
<p>死锁的原因有两种</p>
<ol>
<li>A函数内部二次上锁，A将自己阻塞了但其他任务并不能解锁造成死锁: A获得了锁，A调用一个库函数，这个库函数需要获得上面那个锁，死锁发生</li>
<li>A依赖B的锁，B又依赖A的锁，此时会死锁
解决的办法是使用递归锁(Recursive Mutex)，采用了谁持有谁释放的方法<br>
也就是说递归锁允许同一个线程多次获得锁，这样就可以防止第2种死锁</li>
</ol>
<p>事件组要么等待事件中的某一个发生，要么等待事件中的所有都发生，不能等待事件中的指定某几个发生

<figure><a class="lightgallery" href="/vx_images/28523719231258.png" title="2023-12-17_19-34" data-thumbnail="/vx_images/28523719231258.png" data-sub-html="<h2> </h2><p>2023-12-17_19-34</p>"><img   src='/vx_images/28523719231258.png'   alt="2023-12-17_19-34" height="831" width="832"></a><figcaption class="image-caption">2023-12-17_19-34</figcaption>
    </figure>

<figure><a class="lightgallery" href="/vx_images/2063919250386.png" title="2023-12-17_19-38" data-thumbnail="/vx_images/2063919250386.png" data-sub-html="<h2> </h2><p>2023-12-17_19-38</p>"><img   src='/vx_images/2063919250386.png'   alt="2023-12-17_19-38" height="498" width="1277"></a><figcaption class="image-caption">2023-12-17_19-38</figcaption>
    </figure>
![2023-12-17_19-34_1](/vx_images/280143719249684.png =300x)

<figure><a class="lightgallery" href="/vx_images/371893719237551.png" title="2023-12-17_19-35" data-thumbnail="/vx_images/371893719237551.png" data-sub-html="<h2> </h2><p>2023-12-17_19-35</p>]]></description>
</item></channel>
</rss>
