<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Tech - 标签 - 吾铭子</title>
        <link>https://1078249029.github.io/tags/tech/</link>
        <description>Tech - 标签 - 吾铭子</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>1078249029@qq.com (吾铭子)</managingEditor>
            <webMaster>1078249029@qq.com (吾铭子)</webMaster><lastBuildDate>Wed, 01 Jan 2025 15:22:46 &#43;0800</lastBuildDate><atom:link href="https://1078249029.github.io/tags/tech/" rel="self" type="application/rss+xml" /><item>
    <title>RISC-V</title>
    <link>https://1078249029.github.io/posts/risc-v/</link>
    <pubDate>Wed, 01 Jan 2025 15:22:46 &#43;0800</pubDate><author>
        <name>吾铭子</name>
    </author><guid>https://1078249029.github.io/posts/risc-v/</guid>
    <description><![CDATA[<h1 id="riscv" class="headerLink">
    <a href="#riscv" class="header-mark"></a>RISCV</h1><h2 id="前置知识" class="headerLink">
    <a href="#%e5%89%8d%e7%bd%ae%e7%9f%a5%e8%af%86" class="header-mark"></a>前置知识</h2><p>ISA: 指令集架构，是底层硬件向上层软件提供的一层接口规范。ISA的出现使得软件开发者不必关心具体的硬件电路结构
ISA定义了如下方面</p>
<ul>
<li>基本数据类型(byte,word,halfword)</li>
<li>寄存器</li>
<li>指令</li>
<li>寻址模式</li>
<li>异常和中断</li>
<li>……</li>
</ul>
<p>微架构：硬件对指令集架构的实现，注意功耗，发热，速度，成本等制造的问题</p>
<p>ISA的宽度与指令宽度无关，它指的是通用寄存器的宽度</p>
<p>riscv灵感来自于mips，mips最初是斯坦福大学教授的产品，后来由于经营问题失败，该教授也是riscv之父</p>
<h2 id="riscv的isa基本情况" class="headerLink">
    <a href="#riscv%e7%9a%84isa%e5%9f%ba%e6%9c%ac%e6%83%85%e5%86%b5" class="header-mark"></a>RISCV的ISA基本情况</h2><p>riscv由一个基本指令集+若干个可选的扩展指令集组成，基本指令集永远不会变，</p>
<p><strong>riscv每条指令宽度32位(虽然有16位的压缩指令集)，但是并没有64位宽的指令。这是由于无论是riscv32还是riscv64都只有32个通用寄存器，区别在于寄存器的位宽是32位还是64位，因此控制这32个寄存器只需要5个位宽的索引就够了，因此riscv只有32位宽的指令，尽管只有32位宽的指令，我们还可以通过LUI以及ADDI指令灵活访问超过4GB内存大小的地址</strong></p>
<p>基本整数指令集(I)：唯一要求强制实现的指令集，其他指令集都是扩展模块
扩展指令集：M(整数乘法指令集)，A(原子指令集)，F(浮点指令集)，D(双精度指令集)，C(压缩指令集)
特定组合：IMAFD被称为通用组合，用G表示
RV64I：64位的riscv整数指令集，兼容RV32I</p>
<p>压缩指令集是为了提高指令密度出现的。有时arm的一条指令可以执行两个操作，例如LDP和STP内存存储指令，但是在riscv中需要两条指令才能完成: 一条负责执行加载/存储内存数据，另一条负责修改基地址。而这直接导致了编译同一份代码，riscv生成的机器码指令多于arm，这不仅需要更大的存储空间同时还会降低缓存命中率。因此riscv使用16位宽指令代替32位宽的指令产生了RVC指令集，RVC可用于RV32，RV64，RV128上</p>
<p>riscv定义了一32个通用寄存器x0&hellip;x31，以及一个pc。pc与arm和x86的不同，它无法在编程中访问</p>
<ul>
<li>对RV32I/64I/128I都一样</li>
<li>RV32E将32个寄存器缩减为16以满足嵌入式场景</li>
<li>如果要支持FD模块则需要额外的32个浮点寄存器</li>
</ul>
<p>hart(hardware thread)：为了防止超线程概念被混淆，riscv标准规定了hart概念，一个hart对应的就是一个超线程</p>
<p>riscv规定了三个特权级：machine supervisor user，三个特权级权限依次降低
特权级别的区分在于他们分别有各自的csr(control and state)寄存器，高特权级别可以访问低级别的csr</p>
<p>物理内存保护和虚拟内存：</p>
<ul>
<li>物理内存保护类似x86的实模式，在machine模式中可以指定user模式下可以访问的内存空间及其权限。这样就完成了分段的概念</li>
<li>虚拟内存需要supervisor和mmu的支持</li>
</ul>
<p>异常与中断：尽管在之前已经多次学习了这两个概念，但是在riscv规范中还有不同之处</p>
<ul>
<li>当程序触发异常时，cpu会跳转到异常处理程序，这个处理程序由开发者自行编写，当处理程序执行完毕后<strong>跳回到发生异常的代码重新执行</strong></li>
<li>当触发中断时，cpu会跳转到中断处理程序，这个处理程序由开发者自行编写，当处理程序执行完毕后<strong>跳回到发生中断的下一行代码执行</strong></li>
</ul>
<p>elf文件主要有四类：</p>
<ul>
<li>.o</li>
<li>.out</li>
<li>.so</li>
<li>核心转储core文件</li>
</ul>
<p>elf文件大致内容如下

<figure><a class="lightgallery" href="/vx_images/78955821256435.png" title="2025-01-01_21-57" data-thumbnail="/vx_images/78955821256435.png" data-sub-html="<h2> </h2><p>2025-01-01_21-57</p>"><img   src='/vx_images/78955821256435.png'   alt="2025-01-01_21-57" height="1599" width="2560"></a><figcaption class="image-caption">2025-01-01_21-57</figcaption>
    </figure>
elf header指定了该elf文件的基本内容，包括编译器，可运行的架构等内容，program header table指定了运行时该以何种方式加载进内存。section header table表示了该文件链接时是如何生成的。不将这些section直接加载进内存的原因是这些段需要内存对齐，一旦对齐会浪费很多空间。因此program header table将相似的section作为segment来将其加载进内存</p>
<p>由于elf文件内有许多运行代码时不需要的调试信息，我们可以生成.bin文件来删除这些信息</p>
<h2 id="riscv汇编" class="headerLink">
    <a href="#riscv%e6%b1%87%e7%bc%96" class="header-mark"></a>RISCV汇编</h2><p><strong>下面的指令均以RV32I为例</strong></p>
<p>汇编程序语法与编译器有很大关系，在gnu工具链上的汇编程序在llvm可能不会运行</p>
<p>riscv汇编的结构：
[label:][operation][comment]</p>
<ul>
<li>label：gnu汇编中，任何以冒号为结尾的标识符都被视作标号，label可以被视为地址</li>
<li>operation：
<ul>
<li>instruction：直接对应机器指令的汇编指令</li>
<li>pseudo-instruction：一条伪指令可以产生多条机器指令</li>
<li>directive：以&quot;.&ldquo;用来控制汇编器处理代码的指令</li>
<li>macro：采用.macro自定义的宏</li>
</ul>
</li>
<li>comment：注释，常用# ; //</li>
</ul>
<p>指令长度ILEN：32bits(RV32I)
指令对齐IALIGN：32bits(RV32I)
指令在内存中按小端序排列</p>]]></description>
</item><item>
    <title>Rust</title>
    <link>https://1078249029.github.io/posts/rust/</link>
    <pubDate>Sun, 15 Dec 2024 11:43:24 &#43;0800</pubDate><author>
        <name>吾铭子</name>
    </author><guid>https://1078249029.github.io/posts/rust/</guid>
    <description><![CDATA[<h1 id="rust" class="headerLink">
    <a href="#rust" class="header-mark"></a>Rust</h1><h2 id="前期准备" class="headerLink">
    <a href="#%e5%89%8d%e6%9c%9f%e5%87%86%e5%a4%87" class="header-mark"></a>前期准备</h2><h3 id="环境搭建" class="headerLink">
    <a href="#%e7%8e%af%e5%a2%83%e6%90%ad%e5%bb%ba" class="header-mark"></a>环境搭建</h3><p>可选ide/插件式编辑器:  rustrover(jet brains)/rust-analyzer(rust foundation)+vscode</p>
<p>访问<a href="https://www.rust-lang.org/tools/install" target="_blank" rel="noopener noreferrer">rust官网</a>来获取下载链接，windows采用msvc编译链，在使用msvc之前需要先下载<code>Visual Studio C++ Build tools</code>。其它平台浏览器会自动识别并提供下载方式</p>
<h3 id="创建项目" class="headerLink">
    <a href="#%e5%88%9b%e5%bb%ba%e9%a1%b9%e7%9b%ae" class="header-mark"></a>创建项目</h3><div class="code-block highlight is-open show-line-numbers  tw-group tw-my-2">
  <div class="
    
    tw-flex 
    tw-flex-row
    tw-flex-1 
    tw-justify-between 
    tw-w-full tw-bg-bgColor-secondary
    ">      
    <button 
      class="
        code-block-button
        tw-mx-2 
        tw-flex
        tw-flex-row
        tw-flex-1"
      aria-hidden="true">
          <div class="group-[.is-open]:tw-rotate-90 tw-transition-[transform] tw-duration-500 tw-ease-in-out print:!tw-hidden tw-w-min tw-h-min tw-my-1 tw-mx-1"><svg class="icon"
    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"/></svg></div>
          <p class="tw-select-none !tw-my-1">shell</p>]]></description>
</item><item>
    <title>移植ESP32SPI驱动至rtthread教程</title>
    <link>https://1078249029.github.io/posts/planting-esp32spi-to-rtthread/</link>
    <pubDate>Sat, 19 Oct 2024 10:50:25 &#43;0800</pubDate><author>
        <name>吾铭子</name>
    </author><guid>https://1078249029.github.io/posts/planting-esp32spi-to-rtthread/</guid>
    <description><![CDATA[<h1 id="移植esp32spi驱动至rt-thread" class="headerLink">
    <a href="#%e7%a7%bb%e6%a4%8desp32spi%e9%a9%b1%e5%8a%a8%e8%87%b3rt-thread" class="header-mark"></a>移植ESP32SPI驱动至RT-Thread</h1><p>本文是博主移植驱动工作的总结，详细介绍了移植过程以及遇到的问题及其解决方案，希望对各位有帮助。同时，代码已进入<a href="https://github.com/RT-Thread/rt-thread/pull/9513" target="_blank" rel="noopener noreferrer">RT-Thread主线</a>。博文同时发表在个人博客<a href="wumingzi.top" rel="">wumingzi.top</a></p>
<p>本文主要使用、查阅了以下资料：</p>
<ul>
<li>参考书籍 RT-Thread设备驱动开发指南，ESP32官方文档</li>
<li>硬件 ESP32-C3-DevKitM-1，W25Q64</li>
</ul>
<h2 id="系统平台搭建" class="headerLink">
    <a href="#%e7%b3%bb%e7%bb%9f%e5%b9%b3%e5%8f%b0%e6%90%ad%e5%bb%ba" class="header-mark"></a>系统平台搭建</h2><p>具体的硬件连线不必多说，参考<a href="https://docs.espressif.com/projects/esp-dev-kits/zh_CN/latest/esp32c3/esp32-c3-devkitm-1/user_guide.html#id9" target="_blank" rel="noopener noreferrer">ESP32C3官方开发板的原理图</a>即可，交叉编译环境可以参考博主的这篇文章<a href="https://club.rt-thread.org/ask/article/cf9ff0733112d936.html" target="_blank" rel="noopener noreferrer">ESP32C3环境搭建教程</a>，代码编辑器我使用了vscode+clang的搭配方式，不采用微软的C/C++插件的原因是在编写驱动时vscode发生过多次闪退的情况，并且代码提示和高亮补全残缺，相关配置可自行参考网上</p>
<h2 id="代码参考" class="headerLink">
    <a href="#%e4%bb%a3%e7%a0%81%e5%8f%82%e8%80%83" class="header-mark"></a>代码参考</h2><p>我们可以参考其他芯片的SPI驱动代码来编写，个人参考了GD32和STM32的代码，GD32的驱动代码会简单很多，STM32会更复杂一些</p>
<h2 id="修改kconfig与sconscript文件" class="headerLink">
    <a href="#%e4%bf%ae%e6%94%b9kconfig%e4%b8%8esconscript%e6%96%87%e4%bb%b6" class="header-mark"></a>修改Kconfig与SConscript文件</h2><p>Kconfig指定了系统资源，使得我们可以通过menuconfig来选择配置系统。Kconfig原理可以看<a href="https://www.rt-thread.org/document/site/#/development-tools/build-config-system/Kconfig?id=kconfig" target="_blank" rel="noopener noreferrer">官方文档</a>，简而言之，我们可以通过menuconfig的tui界面来配置Kconfig从而生成.config文件，而后再由系统解析.config文件最后生成rtconfig.h文件来指定系统宏的值从而配置系统。但当前Kconfg并不支持SPI驱动，因此我们需要新增Kconfig选项。</p>
<p>Kconfig的风格与厂商，开发者个人相关。例如有的厂商会习惯将引脚配置项放在板上菜单中，并将功能配置项放在片上外设菜单中 ，而有的厂商会将两者都混放在片上外设菜单或BSP菜单中。前者代表是ESP32和GD32，后者代表是STM32</p>
<p>新增的代码如下</p>
<div class="code-block highlight is-open show-line-numbers  tw-group tw-my-2">
  <div class="
    
    tw-flex 
    tw-flex-row
    tw-flex-1 
    tw-justify-between 
    tw-w-full tw-bg-bgColor-secondary
    ">      
    <button 
      class="
        code-block-button
        tw-mx-2 
        tw-flex
        tw-flex-row
        tw-flex-1"
      aria-hidden="true">
          <div class="group-[.is-open]:tw-rotate-90 tw-transition-[transform] tw-duration-500 tw-ease-in-out print:!tw-hidden tw-w-min tw-h-min tw-my-1 tw-mx-1"><svg class="icon"
    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"/></svg></div>
          <p class="tw-select-none !tw-my-1">Kconfig</p>]]></description>
</item><item>
    <title>nginx反向代理trojan与rsshub</title>
    <link>https://1078249029.github.io/posts/using-nginx-for-trojan-and-rsshub/</link>
    <pubDate>Sat, 19 Oct 2024 10:48:46 &#43;0800</pubDate><author>
        <name>吾铭子</name>
    </author><guid>https://1078249029.github.io/posts/using-nginx-for-trojan-and-rsshub/</guid>
    <description><![CDATA[<h1 id="nginx反向代理trojan与rsshub" class="headerLink">
    <a href="#nginx%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86trojan%e4%b8%8ersshub" class="header-mark"></a>nginx反向代理trojan与rsshub</h1><p>最终效果：外网通过rss.domin.top访问rsshub服务，通过free.domin.top访问trojan服务，通过free.domin.top/admin访问trojan-web管理服务。内部使用docker隔离包括nginx在内的所有服务</p>
<h2 id="前置准备" class="headerLink">
    <a href="#%e5%89%8d%e7%bd%ae%e5%87%86%e5%a4%87" class="header-mark"></a>前置准备</h2><h3 id="购买服务器及域名" class="headerLink">
    <a href="#%e8%b4%ad%e4%b9%b0%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%8f%8a%e5%9f%9f%e5%90%8d" class="header-mark"></a>购买服务器及域名</h3><p>可以从主流的服务器提供商购买服务器以及域名，我选择的服务器厂商是雨云(国际厂商可以选择racknerd或VMISS)，域名提供商是namesilo</p>
<p>购买完毕后需要在国内DNS解析服务器上绑定ip与域名，可以选择腾讯DNS解析服务。绑定格式如下，需要注意的是我这里使用的二级域名需要额外在namesilo生成

<figure><a class="lightgallery" href="/vx_images/555814913252497.png" title="2024-10-19_13-49" data-thumbnail="/vx_images/555814913252497.png" data-sub-html="<h2> </h2><p>2024-10-19_13-49</p>"><img   src='/vx_images/555814913252497.png'   alt="2024-10-19_13-49" height="1479" width="2239"></a><figcaption class="image-caption">2024-10-19_13-49</figcaption>
    </figure></p>
<p>
<figure><a class="lightgallery" href="/vx_images/355505213270377.png" title="2024-10-19_13-52" data-thumbnail="/vx_images/355505213270377.png" data-sub-html="<h2> </h2><p>2024-10-19_13-52</p>"><img   src='/vx_images/355505213270377.png'   alt="2024-10-19_13-52" height="1481" width="2236"></a><figcaption class="image-caption">2024-10-19_13-52</figcaption>
    </figure>
这里记录值改为ip地址即可</p>
<h3 id="初始化服务器" class="headerLink">
    <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96%e6%9c%8d%e5%8a%a1%e5%99%a8" class="header-mark"></a>初始化服务器</h3><p>我的系统是Ubuntu22.04，预安装宝塔面板。安装系统完成并进入宝塔面板后，需要下载docker</p>
<h2 id="正式搭建" class="headerLink">
    <a href="#%e6%ad%a3%e5%bc%8f%e6%90%ad%e5%bb%ba" class="header-mark"></a>正式搭建</h2><h3 id="部署nginx容器" class="headerLink">
    <a href="#%e9%83%a8%e7%bd%b2nginx%e5%ae%b9%e5%99%a8" class="header-mark"></a>部署nginx容器</h3><p>我这里使用的是<a href="https://hub.docker.com/_/nginx/tags" target="_blank" rel="noopener noreferrer">dockerhub上的官方版本</a></p>
<p>首先拉取镜像到本地</p>
<div class="code-block highlight is-open show-line-numbers  tw-group tw-my-2">
  <div class="
    
    tw-flex 
    tw-flex-row
    tw-flex-1 
    tw-justify-between 
    tw-w-full tw-bg-bgColor-secondary
    ">      
    <button 
      class="
        code-block-button
        tw-mx-2 
        tw-flex
        tw-flex-row
        tw-flex-1"
      aria-hidden="true">
          <div class="group-[.is-open]:tw-rotate-90 tw-transition-[transform] tw-duration-500 tw-ease-in-out print:!tw-hidden tw-w-min tw-h-min tw-my-1 tw-mx-1"><svg class="icon"
    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"/></svg></div>
          <p class="tw-select-none !tw-my-1">shell</p>]]></description>
</item><item>
    <title>计算机网络</title>
    <link>https://1078249029.github.io/posts/computer-network/</link>
    <pubDate>Mon, 22 Apr 2024 15:49:01 &#43;0800</pubDate><author>
        <name>吾铭子</name>
    </author><guid>https://1078249029.github.io/posts/computer-network/</guid>
    <description><![CDATA[<p>本文从OSI网络模型出发介绍计算机网络，并涉及多种有关计算机网络的应用。需要注意的是本文有较为浓厚的学术界气息，对于具体的协议使用本文不阐述</p>
<!-- more -->
<h1 id="计算机网络" class="headerLink">
    <a href="#%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c" class="header-mark"></a>计算机网络</h1><h2 id="分组交换与线路交换" class="headerLink">
    <a href="#%e5%88%86%e7%bb%84%e4%ba%a4%e6%8d%a2%e4%b8%8e%e7%ba%bf%e8%b7%af%e4%ba%a4%e6%8d%a2" class="header-mark"></a>分组交换与线路交换</h2><p>线路交换：早期通信设备所采用的方式，这种方法通过时分，频分等手段将一条宽带分成若干个通讯链路从而使多个设备同时且独享的通信，这种通讯方式适合电话或者早期互联网</p>
<p>随着互联网的发展设备数爆炸式增长，这暴露了线路交换允许同时通信的设备数少的缺点。即当双方通信时，虽然会进行频分或者时分，但是这会占用双方通信时经过的所有路由</p>
<p>分组交换：双方通信时，会在通信的每个路由上开一个buffer来缓存数据，并用两路由之间全部带宽来传输数据。这样就解决了线路交换的缺点。分时交换只会占用传输数据时彼此相邻的两个路由，当buffer里的数据传送完毕后发送方会释放资源。分组交换虽然有这种好处，但这是以延时和丢包为代价的，因为这种传输本身就会增加延时，并且当多个主机同时经过同个路由时就会因为传输队列已满导致丢包</p>
<h2 id="接入互联网" class="headerLink">
    <a href="#%e6%8e%a5%e5%85%a5%e4%ba%92%e8%81%94%e7%bd%91" class="header-mark"></a>接入互联网</h2><h3 id="无线方式接入" class="headerLink">
    <a href="#%e6%97%a0%e7%ba%bf%e6%96%b9%e5%bc%8f%e6%8e%a5%e5%85%a5" class="header-mark"></a>无线方式接入</h3><p>wlans：常用于建筑物内，代表：wifi</p>
<p>广域无线接入：任何有基站信号的范围，代表：4G</p>
<h2 id="协议层次" class="headerLink">
    <a href="#%e5%8d%8f%e8%ae%ae%e5%b1%82%e6%ac%a1" class="header-mark"></a>协议层次</h2><p>对于不同的TCP应用(如webnet，ftp，telnet)，他们是通过socket接口来下发报文至TCP的</p>
<p>
<img   src='/vx_images/129152910256147.png'   alt="129152910256147.png" height="733" width="1002"></p>
<p>对于链路层设备(交换机)，他是把源主机发来的数据解封装2次到链路层后获得链路层的信息来进行转发的。而对于网络层设备(路由器)，是把源主机发来的数据解封装3次到网络层后获得网络层的信息来进行转发的。对于目标主机，他是解封装5次从而获得数据</p>
<p>
<img   src='/vx_images/415065510251901.png'   alt="415065510251901.png" height="734" width="972"></p>
<h2 id="应用层" class="headerLink">
    <a href="#%e5%ba%94%e7%94%a8%e5%b1%82" class="header-mark"></a>应用层</h2><h3 id="socket套接字" class="headerLink">
    <a href="#socket%e5%a5%97%e6%8e%a5%e5%ad%97" class="header-mark"></a>socket套接字</h3><p>socket的优点在于它通过ip地址，端口号等信息统一向OS注册了一个整数，使得每次发报文时不需要重复指定ip地址，端口号等信息。这简化了传输信息的步骤，并且便于OS管理。更重要的是有了socket之后我们就可以进行多进程操作了，这在网络服务器中被称为<strong>多路复用</strong>，由于可能有多个客户端对服务器同时发起请求，因此有必要让一个端口支持多个客户端会话，那么怎么区分这些会话从而让信息发送到指定应用和客户端呢？那就是通过socket值的不同来判断，而socket是根据源ip和端口号不同而不同的</p>
<p>对于使用TCP传输层协议的应用而言，我们需要指定本机ip及端口号，目的ip及端口号，而对于使用UDP传输层协议的应用而言，我们只需要指定目的ip及端口号就够了。但是现代的操作系统会将本地ip及端口号隐藏在socket操作中，所以无论是TCP还是UDP，仅需要指定目的ip及端口号就够了</p>
<p>
<img   src='/vx_images/18374216269781.png'   alt="18374216269781.png" height="771" width="1025"></p>
<p>TCP以及UDP都是明文传输的，为了改进TCP的安全性，SSL协议提供了加密的TCP连接。对于SSL，现阶段并没有明确究竟是属于应用层还是传输层，但是它的层次依然是高于TCP的，采用了SSL的http服务被称为https</p>
<h3 id="http" class="headerLink">
    <a href="#http" class="header-mark"></a>http</h3><p>http：超文本传输协议</p>
<p>使用TCP协议不会区分报文的界限，这件事是由应用来做的，但是http则会区分</p>
<p>http协议本身是无状态的，这意味着他不会存储客户端状态，例如某用户的历史记录，用户信息等数据。但是我们可以通过加入cookie这种补丁来解决这个问题.无状态的优点是操作简单方便，同一链路容纳的服务器数量大</p>
<p>cookie是一个存储登陆信息的内容，客户端首次访问服务器时服务器会在内部分配一个cookie并发给客户端，等客户端需要再次登陆时只需要把cookie发送给服务器即可，此时服务器会将客户端发来的cookie与内部的数据库进行比对从而确定是哪个用户发来的请求</p>
<p>当链路的流量强度很大时可以通过在本地建立缓存服务器来缓解，根据二八定律和局部性原理，大部分流量被本地缓存服务器处理，少部分通过Internet被源服务器处理。这种方法会减少带宽的成本</p>
<h3 id="ftp" class="headerLink">
    <a href="#ftp" class="header-mark"></a>ftp</h3><p>ftp适用于客户端服务器模式的文件传输</p>
<p>ftp：根据TCP协议与服务器21号端口建立连接，采用明文传输，因此会暴露用户名和密码。在21号端口建立的是控制连接，用于发送命令。真正的数据传送是由ftp服务器向客户端发起的，服务器会向客户端20号端口建立连接从而传输文件</p>
<h3 id="email" class="headerLink">
    <a href="#email" class="header-mark"></a>email</h3><p>用户代理软件：email客户端软件(outlook)是email应用的用户代理，http客户端软件(firefox)是web应用的用户代理，ftp客户端软件(filezilla)是ftp应用的用户代理。我们是通过客户端软件(用户代理)来跟服务器打交道的，不是直接跟服务器打交道的</p>
<p>
<img   src='/vx_images/397560120267385.png'   alt="397560120267385.png" height="721" width="924"></p>
<p>email使用SMTP协议通过25号端口上传邮件到服务器，之后邮件服务器会进行同步</p>
<p>email使用POP或者IMAP协议进行邮件的下载，IMAP协议有更多的功能，例如它允许用户在服务器组织邮箱目录</p>
<h3 id="dns" class="headerLink">
    <a href="#dns" class="header-mark"></a>dns</h3><p>
<img   src='/vx_images/475695509264888.png'   alt="475695509264888.png" height="791" width="1136"></p>
<p>TTL：缓存时间，当本地dns没有记录某个ip与域名的对应关系时，本地dns会向权威名字服务器进行查询，查询到结果后会缓存在本地并保留一段时间，当超过这个时间后没有再次查询的请求，本地dns就会把这条记录删除。这是为了保证一致性并节省空间</p>
<h3 id="p2p" class="headerLink">
    <a href="#p2p" class="header-mark"></a>p2p</h3><p>非结构化的p2p：不指定p2p网络结构是什么样子的，例如环状，星状网络等</p>
<p>一般而言，非结构化p2p网络网络分为集中化目录式，完全分布式以及混合式</p>
<ul>
<li>集中化目录式：有一台服务器维护资源表，这个表可以提供资源与对应peer的关系，想要请求资源时必须查询这个表，迅雷属于这种</li>
<li>完全分布式：所有资源完全分布在用户手中，用户申请资源时需要对邻居节点进行泛洪操作从而遍历整个p2p网络。值得注意的是用户获得最早的邻居节点来源于下载软件时软件自带的经常活跃的peer的ip地址，因此这种方法有一定的不可靠性，同时由于进行泛洪操作也会对网络造成压力</li>
<li>混合式：上述两种方法的混合，peer加入某一个用户组组成的洪流中，bt属于这种</li>
</ul>
<p>bittorrent：为了提高上传用户保种的积极性，bt应运而生。用户想要获得资源时需要到p2p搜索引擎上找到对应资源，资源内部有tracker文件。如果用户获得了tracker文件就会知道都有哪些peer维护这个文件，这样我们就可以下载这个文件了。当下载时文件会被分成很多文件块，并生成文件位图来表示当前peer是否持有文件块，这些文件块会从那些你曾经给予他们文件支持的那些peer中优先得到，这基于一种算法：上传者会将流量分为三份，前两份来给予曾经帮助过他的peer，最后一份用来随机给陌生用户，这样不仅保证了用户忠诚还有拉新作用。那些在线且文件完整的节点被称为torrent(种子)，否则被称为吸血鬼</p>
<h3 id="cdn" class="headerLink">
    <a href="#cdn" class="header-mark"></a>cdn</h3><p>cdn是将内容存储在离用户较近的服务器，这不仅降低延迟提高了用户舒适度而且还减轻了源服务器压力</p>
<p>当用户请求音视频资源时，用户主机会向dns进行请求，而后dns会返回一个cdn的dns网址或ip，我们用户再解析这个cdn的dns网址就会得到具体的cdn的ip，这里面就有我们申请的资源。cdn的dns主要起一个重定向的作用，这也是为了负载均衡和优化考虑</p>
<h2 id="传输层" class="headerLink">
    <a href="#%e4%bc%a0%e8%be%93%e5%b1%82" class="header-mark"></a>传输层</h2><p>ip(网络层)提供的服务是不可靠的，因此需要tcp/udp(传输层)来提供可靠的传输</p>
<h3 id="tcp" class="headerLink">
    <a href="#tcp" class="header-mark"></a>tcp</h3><p>
<img   src='/vx_images/483952310246130.png'   alt="483952310246130.png" height="693" width="923"></p>
<p>
<img   src='/vx_images/177303610268570.png'   alt="177303610268570.png" height="1439" width="1884"></p>
<h4 id="三次握手与四次挥手" class="headerLink">
    <a href="#%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e4%b8%8e%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b" class="header-mark"></a>三次握手与四次挥手</h4><p>建立连接时仅仅两次握手(建立请求-应答回复)是不够的，因为握手时有可能由于延时过大导致客户端重发建立请求从而出现半连接。这样我们就需要双方均发出两次建立请求才可，即：客户端建立请求-&gt;服务器端应答回复-&gt;服务器端建立请求-&gt;客户端应答回复。在发出请求时发出的是随机的同步码，同步码的作用是告知对方哪个数据传输有误从而方便重传，例如92.8的同步码代表92号到99号的字节都已经接收到了，发送方需要从第100个字节处开始传。而在建立请求的第二步和第三步可以统一用一条报文发出，这样就演变成了现在的的三次挥手</p>
<p>断开连接时也类似建立连接，那为什么断开连接就需要四次挥手呢？这是因为在接受来自客户端断开连接请求时的报文上面常常载有数据，服务器端需要对这些数据进行处理，这一过程是耗时的，假如服务器真的想合并第二步第三步使其变成三次挥手，这就可能导致客户端没有收到服务器的ack从而重发连接断开请求。因此断开连接常常需要四次挥手。而建立连接时没有数据解析的需求，我们就可以将服务器端的应答回复和建立请求统一成一步</p>
<h4 id="流量控制" class="headerLink">
    <a href="#%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6" class="header-mark"></a>流量控制</h4><p>通过协议内部报文标志位从而使网络核心层的路由和边缘层的主机进行通信，路由器进行标志位置位时意味着网络有些拥堵，此时会使边缘层的主机发送速率减半从而防止网络拥堵，这样就进行了流量控制。当网络拥堵时丢包率和延迟也会增加，上述操作不仅减少了网络拥堵同时也改善了丢包率和延迟，这也进行了延时控制</p>
<p>上面操作的缺点：路由向主机发送报文时耗费资源且也容易丢包，这在网络拥堵时也会加重拥堵。因此我们应该从边缘侧来推测网络是否拥堵从而解决这个缺点。我们通常根据下述情况来判断是否网络拥堵：</p>
<ul>
<li>客户端收到服务端3次重发的ack：这可能是网络拥挤造成的，也可能是服务器端缓冲区不足从而进行流量控制造成的</li>
<li>客户端发出的数据包超时：这很有可能是网络拥挤造成的</li>
</ul>
<h2 id="网络层" class="headerLink">
    <a href="#%e7%bd%91%e7%bb%9c%e5%b1%82" class="header-mark"></a>网络层</h2><p>路由位于网络层，决定数据报怎么转发，即通过路由表计算来算出具体的路由
交换机位于数据链路层，只是进行单纯的数据转发，通过路由器算出的路由来进行转发</p>
<p>网络层还可以对数据报进行许多动作：泛洪，block，转发路径，修改某些字段，这些特性仅在sdn(软件定义网络)转发方式中才支持，对于传统方式则不支持</p>
<h3 id="ip" class="headerLink">
    <a href="#ip" class="header-mark"></a>ip</h3><p>
<img   src='/vx_images/478644610263707.png'   alt="478644610263707.png" height="808" width="1085"></p>
<p>在子网内部，只有纯交换机的连接而没有路由器的连接，互联网是以网络为单位而进行的路由表计算，到达对应网络后再进行那个网络下子网的路由表计算从而找到子网的子网，这样就可以遍历整个互联网了。由于计算路由表时是按ip地址进行匹配的，一般而言同一个区域的ip地址前若干位大致相同，我们可以通过这一特性将其他区域的ip地址划分到有相同前缀ip的路由表下，这样我们就会加快查找效率。这种技术我们称为路由聚集</p>
<p>特殊约定：0.0.0.0的地址代指本主机地址，1.1.1.1的地址代表广播地址，127.x.x.x代表回路地址，代表本主机，192.168.x.x代表内网地址</p>
<h4 id="子网掩码" class="headerLink">
    <a href="#%e5%ad%90%e7%bd%91%e6%8e%a9%e7%a0%81" class="header-mark"></a>子网掩码</h4><p>为了方便路由器获得主机号和网络号从而做路由运算，ip地址按照一定格式被分为A类，B类，C类地址，A类指的类似255.x.x.x的地址，其子网可容纳6m个主机，B类地址指的是类似255.255.x.x的地址，其子网可容纳65534个设备，C类地址类似，但只能容纳254个设备。如果按子网主机数量来看，大部分厂商需要设备数量处于数百到数千的范围，这样按类划分网络就失去意义了。为了解决这个问题，我们采用了无类地址的方法：设计一个子网掩码，使得路由器再进行路由运算之前先做子网掩码的与运算，从而获得对应的网络号和主机号。这样就可以通过网络号做路由运算找到相应子网，通过主机号在子网中找到对应主机，在表示中有如下例子：200.235.21.15/23，代表前23位是网络号，后9位是主机号</p>
<h3 id="nat" class="headerLink">
    <a href="#nat" class="header-mark"></a>nat</h3><p>nat(网络地址转换)：通过路由器来软件模拟一个新的端口号，从而解决ip地址不足的问题。当内网设备向外网服务器发出请求时，路由器会根据内网设备的内网ip和端口号来生成一个新的端口号并记录在路由表中，发送的时候需要将内网ip转换到外网ip，端口号更改为生成的端口号。这样当外部的资源返回时就可以根据这个路由表来找到真实的内网主机ip和端口号了</p>
<h3 id="隧道技术" class="headerLink">
    <a href="#%e9%9a%a7%e9%81%93%e6%8a%80%e6%9c%af" class="header-mark"></a>隧道技术</h3><p>ipv6的产生解决了ipv4地址不足的问题，但是同时也带来了兼容性的问题。我们可以在ipv6网络边缘层的网关处设置ipv4/v6双栈协议来解决这个问题，具体原理是在网关路由器处将ipv6的信息二次打包为ipv4的信息，这样我们可以将ipv6的报文在ipv4的网络中传输到另一处ipv6的子网内部。这种技术在ipv4的内部构成了像隧道一样结构，因此我们称这种技术为隧道技术</p>
<h3 id="sdn" class="headerLink">
    <a href="#sdn" class="header-mark"></a>sdn</h3><p>sdn的具体模型是：有一个中央服务器跑一个网络操作系统，当需要改变网络功能或者对网络进行其他操作时网络操作系统会自动进行路由表计算并部署到分组交换机中，这样我们就可以通过集中式部署而对网络进行自定义的改造了，改造后的网络在收发数据时不需要中央服务器和网络操作系统的介入，这时报文路由完全靠分组交换机实现</p>
<p>使用sdn后不仅可以大大提高网络弹性，而且isp只需要购买分组交换机这一种设备就可以了，不需要之前的路由器和交换机</p>
<h2 id="路由与路由协议" class="headerLink">
    <a href="#%e8%b7%af%e7%94%b1%e4%b8%8e%e8%b7%af%e7%94%b1%e5%8d%8f%e8%ae%ae" class="header-mark"></a>路由与路由协议</h2><p>早期路由通过内存来收发信息，现在的路由通过CPU总线结构来收发信息，这样带宽会更大(30Gbps+)，足以满足企业需求</p>
<p>路由协议主要采用BGP协议，其分为外部协议eBGP和内部协议iBGP。外部协议注重策略，内部协议注重性能，例如外部协议以国家，公司为单位，因此需要考虑经济，政治上的原因。内部协议类似内网，由于有多个路由器需要内部协议维护，因此更需要考虑效率。由于采用了网络层次和路由聚集，因此我们可以很轻松的找到对应主机。当一个新的主机上线时，我们需要通过当前子网的网关来通告其他的网关，其他的网关再依次算出路由表并且通知内部的子路由，这样一个网络就建立起来了</p>
<h2 id="链路层" class="headerLink">
    <a href="#%e9%93%be%e8%b7%af%e5%b1%82" class="header-mark"></a>链路层</h2><p>计算机广域网采用点对点连接，这是出于物理上的成本考虑的(中美海底电缆之间并没有连接其他任何国家)。而对局域网来说采用多点连接，这样可以保证效率。但是局域网采用多点连接的同时也会引入一个问题：两个主机同时请求造成冲突怎么办，这种冲突我们称为多点访问冲突</p>
<p>链路层传输报文的单位是帧，传输的时候需要加上mac地址，交换机是按照mac地址工作的</p>
<p>链路层服务：流量控制，纠错码，错误检测，全双工半双工</p>
<p>CRC：循环冗余校验码，用来校验信息是否出错</p>
<p>交换机或者路由一般不组成环状结构，因为这会引发广播风暴，但是为了防止链路出现问题(光缆被挖断)，我们需要冗余一条链路以组成环状。这根线路平时不使用，仅在特殊情况下使用，这样既避免了广播风暴问题又解决了线路损坏的问题</p>
<p>数据在子网中传输时需要用到链路层的技术，如arp(存储ip地址，mac地址与端口的表)，交换机等，数据在子网间传输的时候需要用到网络层的技术(ip，路由器等)</p>
<h3 id="csmaca以太网技术" class="headerLink">
    <a href="#csmaca%e4%bb%a5%e5%a4%aa%e7%bd%91%e6%8a%80%e6%9c%af" class="header-mark"></a>CSMA/CA(以太网技术)</h3><p>ap：无线接入点，一般为路由器或基站</p>
<p>当两个无线设备同时对同一个ap点发送信号时就会叠加电磁波引发冲突，因为ap无法判断这是一个设备发过来的还是多个设备发过来的信号。但我们可以通过无线设备上的电磁波传感器就可以判断是否有其他设备发送无线信号，并以此作为冲突检测的工具</p>
<p>802.11(wlan)的CSMA/CA方法：当信道忙时，发送方等待信道空闲后给一个自减的随机值，等到随机值减到0时再次尝试发送。假如在随机值自减的过程中发送方发现信道又忙，那就等待信道空闲时再次选一个随机值。对于接收方来说，当帧正确时会给一个ack</p>
<p>CSMA/CA在高负载情况下会有效率低下的问题，但是这个问题可以引入交换机来解决(交换机可以只监听两个端口)</p>
<h3 id="mac地址" class="headerLink">
    <a href="#mac%e5%9c%b0%e5%9d%80" class="header-mark"></a>mac地址</h3><p>在节点和节点间的数据传递过程中交换机并不能识别ip地址，我们需要通过ip地址解析协议(arp协议)来知道下一跳的mac地址以及对应端口，这样交换机的网卡才知道如何发送数据给其他交换机或目标主机</p>
<p>mac地址由IEEE管理和分配，制造商购入mac地址空间来保证其唯一性</p>
<p>当路由器需要发数据给子网内部设备时，我们需要查询arp表。如果没有查到目标ip对应的mac地址和端口，路由器就会进行广播，对应的设备就会进行回应并把自己的mac地址和端口发送给路由器，之后路由器将这个mac地址加入arp表中缓存起来。当查询到mac地址时路由器会直接把数据发送出去，经过若干跳后到达目标主机</p>
<h3 id="lan以太网" class="headerLink">
    <a href="#lan%e4%bb%a5%e5%a4%aa%e7%bd%91" class="header-mark"></a>lan(以太网)</h3><p>总线型网络：类似于cpu总线，多个设备挂载到总线上，两端挂载吸收器，这样可以吸收反射的电磁波，防止CSMA/CA技术下设备回声。但是当总线某处出现破损时会造成信号回声，导致任何设备发送数据时都会发现总线忙</p>
<p>集线器(hub)：克服总线型网络的缺点，将总线长度大大缩减并放于金属制容器内(hub)，使得设备回声只发生在某个设备与集线器的线路上，不会影响整个总线从而利于排障。缺点是通信时类似广播，不能控制每个设备的端口单独发送数据，因此使用CSMA/CA技术后会导致高负载工况效率低下，因为每个端口相互影响，在高负载情况下端口只能等待其他端口发送完成才能使用总线，这样就不能进行总线的复用了</p>]]></description>
</item><item>
    <title>Linux深入</title>
    <link>https://1078249029.github.io/posts/linux-advanced/</link>
    <pubDate>Fri, 23 Feb 2024 11:44:04 &#43;0800</pubDate><author>
        <name>吾铭子</name>
    </author><guid>https://1078249029.github.io/posts/linux-advanced/</guid>
    <description><![CDATA[<p>Linux驱动深入</p>
<!-- more -->
<h1 id="linux深入" class="headerLink">
    <a href="#linux%e6%b7%b1%e5%85%a5" class="header-mark"></a>Linux深入</h1><h2 id="内联汇编" class="headerLink">
    <a href="#%e5%86%85%e8%81%94%e6%b1%87%e7%bc%96" class="header-mark"></a>内联汇编</h2><p>为了保证效率或者使用特殊指令(如原子操作)时需要使用汇编，使用方法是：单独将汇编代码放在.S文件中，在C函数中使用extern声明之后就可以使用汇编文件里的函数了</p>
<p>对于内联汇编需要使用__asm___关键字修饰函数

<figure><a class="lightgallery" href="/vx_images/30092012266713.png" title="2024-02-13_12-19" data-thumbnail="/vx_images/30092012266713.png" data-sub-html="<h2> </h2><p>2024-02-13_12-19</p>"><img   src='/vx_images/30092012266713.png'   alt="2024-02-13_12-19" height="731" width="1062"></a><figcaption class="image-caption">2024-02-13_12-19</figcaption>
    </figure></p>
<h2 id="同步互斥的深入" class="headerLink">
    <a href="#%e5%90%8c%e6%ad%a5%e4%ba%92%e6%96%a5%e7%9a%84%e6%b7%b1%e5%85%a5" class="header-mark"></a>同步互斥的深入</h2><p>在单核CPU上关中断开中断是可以实现同步互斥的，但是在多核CPU上开关中断不能保证其他CPU不会修改临界变量</p>
<h3 id="原子操作" class="headerLink">
    <a href="#%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c" class="header-mark"></a>原子操作</h3><p>对于ARMv6之前的内核，通过关中断恢复中断来实现原子操作，但是在v6之后(包括v6)，由于arm支持SMP(多核CPU)，因此不能简单的使用开关中断来实现原子操作，而是使用ldrex，strex汇编语句来实现，其根本原理是在要ldr数据上打上标记，在要str的数据上消除标记，根据能否消除标记而返回不同的值，根据值来判断是否申请资源成功，不成功的话则再次重复，直到能申请资源为止</p>
<p>
<figure><a class="lightgallery" href="/vx_images/333854115259382.png" title="2024-02-13_15-41" data-thumbnail="/vx_images/333854115259382.png" data-sub-html="<h2> </h2><p>2024-02-13_15-41</p>"><img   src='/vx_images/333854115259382.png'   alt="2024-02-13_15-41" height="1096" width="1809"></a><figcaption class="image-caption">2024-02-13_15-41</figcaption>
    </figure></p>
<h2 id="锁" class="headerLink">
    <a href="#%e9%94%81" class="header-mark"></a>锁</h2><h3 id="自旋锁" class="headerLink">
    <a href="#%e8%87%aa%e6%97%8b%e9%94%81" class="header-mark"></a>自旋锁</h3><p>自旋锁无法休眠，当一段临界区被加上自旋锁时，如果CPU0与CPU1都竞争临界区只有CPU0获得资源的话，那么CPU1不会休眠而是会反复请求资源(当写程序时，在进中断时也要加自旋锁来防止其他CPU打断当前CPU执行irq)，因此，使用自旋锁时临界区代码要尽量精简(5行左右)，且不能休眠</p>
<p>自旋锁在 <strong>单核系统(UP)</strong> 还可以用来禁止调度防止抢占，对于不同的自旋锁他有不同的防止抢占方式，比如对于最普通的spin_lock()而言，他只能关闭调度，而对于spin_lock_irq()而言，它可以关闭中断</p>
<p>自旋锁的实现：每个自旋锁上都有当前任务编号，和当前任务编号+1的下一个任务编号，内核会检查想要申请资源的自旋锁任务编号与当前自旋锁下一个任务编号是否相同，相同的话则获得锁，否则wfe休眠一段时间</p>
<h3 id="睡眠锁" class="headerLink">
    <a href="#%e7%9d%a1%e7%9c%a0%e9%94%81" class="header-mark"></a>睡眠锁</h3><p>睡眠锁有mutex和semaphore两种</p>
<p>对于信号量来说，它可以休眠，因此对于临界区代码可以比自旋锁复杂很多，信号量用于多进程间访问同步和互斥，而互斥锁用于保护某个临界资源</p>
<p>在信号量结构体中，需要用到自旋锁</p>
<p>semaphore的实现：semaphore结构体中有spinlock，还有个count和wait_list，当使用spinlock_up获取semaphore时，首先需要获得spinlock，如果成功获得则需要让count++，否则把自己挂载到wait_list上</p>
<p>mutex的实现：与semaphore类似，但是由于追求效率会更为复杂，里面配置了宏开关来优化效率，通过宏可以选择等待mutex的线程是否休眠(休眠开销太大)。当进入临界区获取资源时也可以自动判断使用fastpath还是slowpath</p>
<p>fastpath与slowpath：
当一段临界区代码很短且需要mutex时，这时大概率会出现线程不需要等待而直接获取资源，并且解锁时也不需要唤醒其他线程，这种情况称为fastpath，而需要等待获取资源且需要唤醒其他线程称为slowpath，两个的选择取决于mutex结构体中的count(是个原子变量)，count值为1时表示unlocked，此时其他线程可以获得锁，count值为0时代表locked，需要解锁，但是当前执行任务的线程解锁后不需要唤醒其他任务此时为fastpath，当count值为-1时，代表当前任务解锁后还需要唤醒其他线程，这时是slowpath</p>
<p>mutex的实现比semaphore更复杂，这是因为mutex追求更高的效率，在写驱动程序的时候尽量使用mutex</p>
<h2 id="usart" class="headerLink">
    <a href="#usart" class="header-mark"></a>USART</h2><p>访问虚拟终端中的<strong>前台</strong>终端：/dev/tty0
访问当前程序运行的终端(考虑真实的USART等终端)：/dev/tty (不会输出信息到其他tty)</p>
<p>在驱动模块崩溃时可以查看LR来找到崩溃的函数
当驱动程序错误时，可以使用<strong>strace  -o  log.txt ./exe</strong>可以在log.txt里获得系统调用</p>
<h3 id="printk" class="headerLink">
    <a href="#printk" class="header-mark"></a>printk</h3><p>printk后面可以加上打印级别，如果不指定打印级别则会默认打印级别，当console设置的打印级别低于内核级别时则不会打印printk。如果想在多个控制台打印时，可以在设备树或者uboot指定console=tty0，console=tty1，但是只有最后指定的console会收到串口信息。实际上，uboot也是通过修改设备树来实现更改打印终端的</p>
<div class="code-block highlight is-open show-line-numbers  tw-group tw-my-2">
  <div class="
    
    tw-flex 
    tw-flex-row
    tw-flex-1 
    tw-justify-between 
    tw-w-full tw-bg-bgColor-secondary
    ">      
    <button 
      class="
        code-block-button
        tw-mx-2 
        tw-flex
        tw-flex-row
        tw-flex-1"
      aria-hidden="true">
          <div class="group-[.is-open]:tw-rotate-90 tw-transition-[transform] tw-duration-500 tw-ease-in-out print:!tw-hidden tw-w-min tw-h-min tw-my-1 tw-mx-1"><svg class="icon"
    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"/></svg></div>
          <p class="tw-select-none !tw-my-1">shell</p>]]></description>
</item><item>
    <title>Linux内核</title>
    <link>https://1078249029.github.io/posts/linux-kernel/</link>
    <pubDate>Wed, 21 Feb 2024 16:55:40 &#43;0800</pubDate><author>
        <name>吾铭子</name>
    </author><guid>https://1078249029.github.io/posts/linux-kernel/</guid>
    <description><![CDATA[<p>date: 2024-4-10 9:48:30</p>
<h1 id="linux内核基础" class="headerLink">
    <a href="#linux%e5%86%85%e6%a0%b8%e5%9f%ba%e7%a1%80" class="header-mark"></a>Linux内核基础</h1><p><strong>本文阐述系统为x86体系架构，idt，gdt，tss，系统启动引导过程均以x86架构为蓝本，arm可能不适用</strong></p>
<!-- more -->
<h2 id="linux内核体系结构" class="headerLink">
    <a href="#linux%e5%86%85%e6%a0%b8%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84" class="header-mark"></a>Linux内核体系结构</h2><p>nmi(not mask interrupt)不可屏蔽中断
系统启动时会读取RTC并赋值给jiffies
内核中定时器使用链表进行管理</p>
<p>每个进程都有LDT(局部描述符)，即代码段和数据段。单处理器系统只有一个GDT，而在多处理器系统中每个CPU都有一个GDT，GDT(全局描述符)是各个寄存器地址</p>
<p>IDT(中断描述符表)，其作用也类似于中断向量表，只是其中每个中断描述符项中除了含有中断服务程序地址以外，还包含有关<strong>特权级</strong>和<strong>描述符类别</strong>等信息
<a href="https://blog.csdn.net/yxc135/article/details/8734452" target="_blank" rel="noopener noreferrer">中断向量表和中断描述符表IDT-CSDN</a></p>
<p><a href="https://blog.csdn.net/ybxuwei/article/details/80657461" target="_blank" rel="noopener noreferrer">linux分段-CSDN</a></p>
<p>
<figure><a class="lightgallery" href="/vx_images/373000621257049.png" title="2024-02-22_21-06" data-thumbnail="/vx_images/373000621257049.png" data-sub-html="<h2> </h2><p>2024-02-22_21-06</p>"><img   src='/vx_images/373000621257049.png'   alt="2024-02-22_21-06" height="628" width="778"></a><figcaption class="image-caption">2024-02-22_21-06</figcaption>
    </figure></p>
<p>TSS(任务状态段)就是特殊寄存器 + 通用寄存器的信息</p>
<p>
<figure><a class="lightgallery" href="/vx_images/56405009258689.png" title="2024-02-22_09-49" data-thumbnail="/vx_images/56405009258689.png" data-sub-html="<h2> </h2><p>2024-02-22_09-49</p>"><img   src='/vx_images/56405009258689.png'   alt="2024-02-22_09-49" height="1070" width="1903"></a><figcaption class="image-caption">2024-02-22_09-49</figcaption>
    </figure></p>
<h3 id="fork的实现" class="headerLink">
    <a href="#fork%e7%9a%84%e5%ae%9e%e7%8e%b0" class="header-mark"></a>fork的实现</h3><ul>
<li>申请内存空间</li>
<li>把父进程的task_struct拷贝到子进程的task_struct并重新设置</li>
<li>设置进程状态为可运行，返回pid</li>
</ul>
<p>需要注意的是fork出的子进程的文件描述符比父进程大1，这也是Linux基础文章中现象的实现</p>
<p>
<figure><a class="lightgallery" href="/vx_images/402763010246556.png" title="2024-02-22_10-28" data-thumbnail="/vx_images/402763010246556.png" data-sub-html="<h2> </h2><p>2024-02-22_10-28</p>"><img   src='/vx_images/402763010246556.png'   alt="2024-02-22_10-28" height="1079" width="1144"></a><figcaption class="image-caption">2024-02-22_10-28</figcaption>
    </figure></p>
<h3 id="进程调度" class="headerLink">
    <a href="#%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6" class="header-mark"></a>进程调度</h3><p>在0.11内核中，进程调度分为调度和切换两个步骤，调度负责将用完时间片的进程挂起，并将进程的状态位改为暂停状态，切换时为了效率采用汇编，它的作用是将那些设置状态位的进程加载进CPU寄存器中，即执行上下文切换的功能</p>
<h3 id="进程销毁" class="headerLink">
    <a href="#%e8%bf%9b%e7%a8%8b%e9%94%80%e6%af%81" class="header-mark"></a>进程销毁</h3><p>以syscall_和do_开头的基本上是系统调用，即中断服务函数</p>
<ul>
<li>内核的销毁流程
<ul>
<li>进入do_exit函数
<ul>
<li>首先释放数据段和代码段占用的内存</li>
<li>关闭进程打开的所有文件，对当前的目录和i节点进行同步</li>
<li>如果进程是个会话头进程，则会终止会话中的所有进程</li>
<li>改变进程运行状态为TASK_ZOMBIE，并且向父进程发送SIGCHLD信号，do_exit函数执行完毕</li>
</ul>
</li>
<li>在父进程中进行最后的处理工作，父进程运行子进程的时候一般都会运行wait或waitpid这两个函数(父进程等待某个子进程终止的函数)，当父进程收到SIGCHLD信号时会终止僵死状态的子进程
<ul>
<li>首先父进程会把子进程的运行时间(utime,stime)累加到自己的进程变量中，把要销毁的子进程的进程描述结构体进行释放，置空任务数组中的子进程任务槽</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>
<figure><a class="lightgallery" href="/vx_images/231530512266722.png" title="2024-02-22_12-05" data-thumbnail="/vx_images/231530512266722.png" data-sub-html="<h2> </h2><p>2024-02-22_12-05</p>"><img   src='/vx_images/231530512266722.png'   alt="2024-02-22_12-05" height="609" width="2090"></a><figcaption class="image-caption">2024-02-22_12-05</figcaption>
    </figure></p>
<h2 id="linux内核启动引导" class="headerLink">
    <a href="#linux%e5%86%85%e6%a0%b8%e5%90%af%e5%8a%a8%e5%bc%95%e5%af%bc" class="header-mark"></a>Linux内核启动引导</h2><h3 id="操作系统的启动" class="headerLink">
    <a href="#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%90%af%e5%8a%a8" class="header-mark"></a>操作系统的启动</h3><p>Linux启动时的硬件信息是由bootloader传进来的</p>
<ul>
<li>Linux启动流程
<ul>
<li>首先由BIOS/bootloader进行一系列的硬件初始化和参数设置，并把bootsect.s从硬盘中某个固定地址搬到内存中的某个固定地址，需要注意在内核初始化需要关中断来防止初始化被中断。</li>
<li>bootsect.s将setup.s代码从磁盘中加载到紧接着bootsect.s的地方，最后跳转到setup.s中运行</li>
<li>setup.s负责将bootloader传进来的信息进行解析，关中断并加载system模块，使system模块正好覆盖bootsect.s(关中断是为了防止覆盖bootsect.s的代码后系统不能处理中断而导致崩溃)。设置LDT，GDT，IDT，而后设置中断芯片，进入到保护模式(svc32)运行，在代码的最后会跳转到head.s(0x00000000)执行</li>
<li>head.s加载内核运行时的各数据段寄存器，并重新设置IDT(防止被数据区覆盖)，设置内存对齐以及分页，最后跳转到main.c开始运行，系统启动完成</li>
</ul>
</li>
<li>Linux在启动的时候是如何拿到硬件参数的
<ul>
<li>通过bootloader加载传入的参数(_atags_pointer)，这个参数是一块指向存有硬件信息内存的首地址的指针，通过这个指针就可以获得硬件参数</li>
</ul>
</li>
<li>Linux在初始化运行中都做了什么
<ul>
<li>进行硬件的初始化(就是下文中各种段的设置)，fork出0号进程</li>
</ul>
</li>
</ul>
<p>
<figure><a class="lightgallery" href="/vx_images/577701316251700.png" title="2024-02-22_16-13" data-thumbnail="/vx_images/577701316251700.png" data-sub-html="<h2> </h2><p>2024-02-22_16-13</p>"><img   src='/vx_images/577701316251700.png'   alt="2024-02-22_16-13" height="943" width="2260"></a><figcaption class="image-caption">2024-02-22_16-13</figcaption>
    </figure></p>]]></description>
</item><item>
    <title>Linux基础</title>
    <link>https://1078249029.github.io/posts/linux-basics/</link>
    <pubDate>Tue, 23 Jan 2024 18:18:18 &#43;0800</pubDate><author>
        <name>吾铭子</name>
    </author><guid>https://1078249029.github.io/posts/linux-basics/</guid>
    <description><![CDATA[<p>基础的Linux应用与驱动开发</p>
<!-- more -->
<h1 id="linux" class="headerLink">
    <a href="#linux" class="header-mark"></a>Linux</h1><h2 id="linux基础" class="headerLink">
    <a href="#linux%e5%9f%ba%e7%a1%80" class="header-mark"></a>Linux基础</h2><p>shell负责解析命令，当用户在shell中输入命令时，根据输入的结果，shell根据PATH环境变量的位置找到相应的程序执行，因此可以通过将.o文件复制到PATH来直接在任何目录下执行程序，否则只能使用绝对路径或相对路径的方式来执行</p>
<p>[]代表可选参数 &lt;&gt;代表必选参数</p>
<h3 id="linux基础命令与操作" class="headerLink">
    <a href="#linux%e5%9f%ba%e7%a1%80%e5%91%bd%e4%bb%a4%e4%b8%8e%e6%93%8d%e4%bd%9c" class="header-mark"></a>Linux基础命令与操作</h3><p>. 当前目录 .. 上一级目录 - 切换前上一次的目录</p>
<div class="code-block highlight is-open show-line-numbers  tw-group tw-my-2">
  <div class="
    
    tw-flex 
    tw-flex-row
    tw-flex-1 
    tw-justify-between 
    tw-w-full tw-bg-bgColor-secondary
    ">      
    <button 
      class="
        code-block-button
        tw-mx-2 
        tw-flex
        tw-flex-row
        tw-flex-1"
      aria-hidden="true">
          <div class="group-[.is-open]:tw-rotate-90 tw-transition-[transform] tw-duration-500 tw-ease-in-out print:!tw-hidden tw-w-min tw-h-min tw-my-1 tw-mx-1"><svg class="icon"
    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"/></svg></div>
          <p class="tw-select-none !tw-my-1">shell</p>]]></description>
</item><item>
    <title>C&#43;&#43;</title>
    <link>https://1078249029.github.io/posts/cpp/</link>
    <pubDate>Sun, 14 Jan 2024 09:37:21 &#43;0800</pubDate><author>
        <name>吾铭子</name>
    </author><guid>https://1078249029.github.io/posts/cpp/</guid>
    <description><![CDATA[<p>本文较为详细地介绍了C++的语法和使用中需要注意的点，还介绍了STL库和Modern C++，甚至涉及C++20的部分新特性。在最后，我们大致的介绍了C++常用的设计模式</p>
<!-- more -->
<h1 id="c" class="headerLink">
    <a href="#c" class="header-mark"></a>C++</h1><h2 id="从c到c" class="headerLink">
    <a href="#%e4%bb%8ec%e5%88%b0c" class="header-mark"></a>从C到C++</h2><h3 id="new和delete" class="headerLink">
    <a href="#new%e5%92%8cdelete" class="header-mark"></a>new和delete</h3><p>尽管C++11引入了智能指针，但是为了兼容老程序，new和delete的方法也应值得注意</p>
<ul>
<li>C原生的melloc与free使用起来较为复杂，需要根据返回值来判断下一步做什么</li>
<li>C原生的melloc与free也只进行内存申请但不进行对象实例化，也就是说C仅仅返回内存地址的指针，而C++返回的是一块特定类型的指针</li>
<li>更重要的是C++在调用new时会自动执行对象的构造函数，C原生的melloc与free则不支持</li>
</ul>
<p>在使用delete回收数组时需要告诉他数组的类型</p>
<div class="code-block highlight is-open show-line-numbers  tw-group tw-my-2">
  <div class="
    
    tw-flex 
    tw-flex-row
    tw-flex-1 
    tw-justify-between 
    tw-w-full tw-bg-bgColor-secondary
    ">      
    <button 
      class="
        code-block-button
        tw-mx-2 
        tw-flex
        tw-flex-row
        tw-flex-1"
      aria-hidden="true">
          <div class="group-[.is-open]:tw-rotate-90 tw-transition-[transform] tw-duration-500 tw-ease-in-out print:!tw-hidden tw-w-min tw-h-min tw-my-1 tw-mx-1"><svg class="icon"
    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"/></svg></div>
          <p class="tw-select-none !tw-my-1">cpp</p>]]></description>
</item><item>
    <title>Python</title>
    <link>https://1078249029.github.io/posts/python/</link>
    <pubDate>Sun, 14 Jan 2024 09:37:13 &#43;0800</pubDate><author>
        <name>吾铭子</name>
    </author><guid>https://1078249029.github.io/posts/python/</guid>
    <description><![CDATA[<h1 id="python" class="headerLink">
    <a href="#python" class="header-mark"></a>Python</h1><h2 id="python基础" class="headerLink">
    <a href="#python%e5%9f%ba%e7%a1%80" class="header-mark"></a>Python基础</h2><h3 id="解释器与编译器" class="headerLink">
    <a href="#%e8%a7%a3%e9%87%8a%e5%99%a8%e4%b8%8e%e7%bc%96%e8%af%91%e5%99%a8" class="header-mark"></a>解释器与编译器</h3><p>解释器输出运行的结果
编译器输出编译的文件</p>
<p>字面量：写在代码中的值，可以被分为整数，浮点数，字符串，元组，列表等
python的单引号和双引号意义相同，但是使用单引号可以打出双引号，但不能打出单引号。使用双引号则反之，如果想使用单引号打出单引号，则需要加上反斜杠代表转义字符</p>
<!-- more -->
<h3 id="注释的写法" class="headerLink">
    <a href="#%e6%b3%a8%e9%87%8a%e7%9a%84%e5%86%99%e6%b3%95" class="header-mark"></a>注释的写法</h3><div class="code-block highlight is-open show-line-numbers  tw-group tw-my-2">
  <div class="
    
    tw-flex 
    tw-flex-row
    tw-flex-1 
    tw-justify-between 
    tw-w-full tw-bg-bgColor-secondary
    ">      
    <button 
      class="
        code-block-button
        tw-mx-2 
        tw-flex
        tw-flex-row
        tw-flex-1"
      aria-hidden="true">
          <div class="group-[.is-open]:tw-rotate-90 tw-transition-[transform] tw-duration-500 tw-ease-in-out print:!tw-hidden tw-w-min tw-h-min tw-my-1 tw-mx-1"><svg class="icon"
    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"/></svg></div>
          <p class="tw-select-none !tw-my-1">py</p>]]></description>
</item></channel>
</rss>
