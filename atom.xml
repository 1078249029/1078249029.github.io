<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吾铭子</title>
  
  
  <link href="https://wumingzi.top/atom.xml" rel="self"/>
  
  <link href="https://wumingzi.top/"/>
  <updated>2024-01-23T03:31:53.987Z</updated>
  <id>https://wumingzi.top/</id>
  
  <author>
    <name>吾铭子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python</title>
    <link href="https://wumingzi.top/2024/01/23/Python/"/>
    <id>https://wumingzi.top/2024/01/23/Python/</id>
    <published>2024-01-23T03:31:53.000Z</published>
    <updated>2024-01-23T03:31:53.987Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://wumingzi.top/2024/01/23/%E9%A1%B9%E7%9B%AE/"/>
    <id>https://wumingzi.top/2024/01/23/%E9%A1%B9%E7%9B%AE/</id>
    <published>2024-01-23T03:31:41.855Z</published>
    <updated>2024-01-23T03:38:25.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="FreeRTOS内核实现"><a href="#FreeRTOS内核实现" class="headerlink" title="FreeRTOS内核实现"></a>FreeRTOS内核实现</h2><p>参考书籍：《FreeRTOS 内核实现与应用开发实战指南》  </p><blockquote><p>一个工程如果没有 main 函数是编译不成功的,会出错。因为系统在开始执行的时候先执行启动文件里面的复位程序,复位程序里面会调用 C 库函数__main,__main 的作用是初始化好系统变量,如全局变量,只读的,可读可写的等等。__main 最后会调用__rtentry,再由__rtentry 调用 main 函数,从而由汇编跳入到 C 的世界,这里面的 main 函数就需要我们手动编写,如果没有编写 main 函数,就会出现 main 函数没有定义的错误。  </p></blockquote><p>生成的startup_ARMCM3.s负责启动startup_ARMCM3.c负责时钟配置，本项目默认的时钟为25M </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">  Define clocks</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  XTAL            ( 5000000UL)      <span class="comment">/* Oscillator frequency */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  SYSTEM_CLOCK    (5U * XTAL)</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">![<span class="number">2024</span><span class="number">-01</span><span class="number">-02</span>_10<span class="number">-16</span>](vx_images/<span class="number">419821610240143.</span>png)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">对于这种多行宏定义，每行结尾要加 \ 表示该行未结束</span><br><span class="line">  </span><br><span class="line">::: alert-danger</span><br><span class="line">若使用 \ 表示该行未完结务必注意 \ 后不能加任何字符，尤其是空格或者Tab。报错如下![<span class="number">2024</span><span class="number">-01</span><span class="number">-02</span>_12<span class="number">-05</span>](vx_images/<span class="number">481670512259271.</span>png)</span><br><span class="line">:::</span><br><span class="line">    </span><br><span class="line">![<span class="number">2024</span><span class="number">-01</span><span class="number">-02</span>_10<span class="number">-44</span>](vx_images/<span class="number">400010311258569.</span>png)</span><br><span class="line">  </span><br><span class="line">![<span class="number">2024</span><span class="number">-01</span><span class="number">-02</span>_11<span class="number">-04</span>](vx_images/<span class="number">7600511266602.</span>png)</span><br><span class="line">  </span><br><span class="line">左值不能进行类型转换，类型转换本质上是在寄存器内对原值进行位操作，得到的结果不放入内存，而左值是需要放进内存的，因此类型转换与左值冲突，若要类型转换，则需要对右值进行操作</span><br><span class="line"></span><br><span class="line">:::alert-danger</span><br><span class="line">当一个a.c文件需要b.h，而b.h包含了c.h，且c.h也包含了b.h时，会发生编译冲突。表现为有未定义的类型或变量，详情参考[博客园](https:<span class="comment">//www.cnblogs.com/skullboyer/p/8891579.html)，解决办法是理清编译关系，去除重复包含的头文件</span></span><br><span class="line">![<span class="number">2024</span><span class="number">-01</span><span class="number">-03</span>_13<span class="number">-26</span>](vx_images/<span class="number">211612613258570.</span>png)</span><br><span class="line">:::  </span><br><span class="line"></span><br><span class="line">栈由高地址向低地址增长，栈顶是第一个进栈的元素，栈底是最后一个进栈的元素</span><br><span class="line">因为<span class="number">32</span>位机一般指令都是<span class="number">32</span>位的，栈顶指针只需<span class="number">4</span>字节对齐即可，但是考虑兼容浮点运算的<span class="number">64</span>位操作则需要<span class="number">8</span>字节。对齐完成后，栈顶指针即可确定位置，而后开辟空间  </span><br><span class="line"></span><br><span class="line">![<span class="number">2024</span><span class="number">-01</span><span class="number">-03</span>_16<span class="number">-01</span>](vx_images/<span class="number">151190216246437.</span>png)</span><br><span class="line">项目的.c 与 .h文件可以不重名，位置可以不同，例如port.c文件放在\freertos\Source\portable\RVDS\ARM_CM3，但是引用port.c内容的portable.h放在\freertos\Source\include    </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="comment">/* 这行代码的意思是定义了TaskFunction_t类型的函数指针，参数和返回值都是void，这样就可以进行函数“赋值”，进而从Task1，Task2中抽象出TaskFunction_t这一类型了，并且使用起来很方便 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (*TaskFunction_t)( <span class="type">void</span> * );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类似用法如下 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> tech(<span class="type">void</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;tech dreamer&quot;</span>); &#125;</span><br><span class="line"><span class="comment">//命名一个类型，那么这个时候func不可以直接调用，而是一个类型了</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (*func)();</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个可调用的指针变量（函数）：myfunc</span></span><br><span class="line">    func myfunc;</span><br><span class="line">    myfunc = &amp;tech; <span class="comment">//&amp;可以不加</span></span><br><span class="line">    <span class="comment">/* 下面两种方法体现了函数名和函数地址是一回事 */</span></span><br><span class="line">    myfunc();         <span class="comment">//第一种调用方式，带参数也可以</span></span><br><span class="line">    (*myfunc)();      <span class="comment">//第二种调用方式，带参数也可以</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现就绪链表"><a href="#实现就绪链表" class="headerlink" title="实现就绪链表"></a>实现就绪链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*TaskFunction_t)</span><span class="params">( <span class="type">void</span> * )</span>;<span class="comment">//将TaskFunction_t函数指针重定义为void*类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//FreeRTOS中TaskFunction_t内部包含了一个栈顶指针，因此返回值为uint32型</span></span><br></pre></td></tr></table></figure><p>:::alert&#x3D;info<br>在FreeRTOS里TaskHandle_t是个TCB_t的指针<br>在toyFreeRTOS里TaskHandle_t是个void*类型的指针，使用时需要类型强转<br>:::  </p><h4 id="设置任务栈时栈顶指针的移动"><a href="#设置任务栈时栈顶指针的移动" class="headerlink" title="设置任务栈时栈顶指针的移动"></a>设置任务栈时栈顶指针的移动</h4><p><img src="/vx_images/434673613240154.png" alt="2024-01-13_13-36"></p><p><img src="/vx_images/386434109258571.png" alt="2024-01-04_09-41">  </p><p>首先由外部函数prvInitialiseNewTask构造出的pxTopOfStack指针传入pxPortInitialiseStack函数，此时pxTopOfStack指针指向A位置，而后移动指针至B，C点从而将xPSR，PC，LR的值依次写入栈顶，方便之后寄存器读取。配置好自动加载到寄存器的内容后再将指针下移至D并返回，从而使任务得到空闲堆栈的指针  </p><h3 id="实现调度器"><a href="#实现调度器" class="headerlink" title="实现调度器"></a>实现调度器</h3><p><img src="/vx_images/5864314266604.png" alt="2024-01-04_14-42"><br>向量表最前面是MSP的地址</p><p>配置寄存器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 对0xe000ed20地址处取值，此处为SHPR3寄存器，设置的是pendsv和systick优先级 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portNVIC_SYSPRI2_REG*(( volatile uint32_t *) 0xe000ed20) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置 PendSV 和 SysTick 的中断优先级为最低 */</span></span><br><span class="line"> portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;<span class="comment">//SHPR3寄存器被设置为 0x**FF ****</span></span><br><span class="line"> portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;<span class="comment">//SHPR3寄存器被设置为 0xFFFF ****</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开启第一个任务：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 通过查找SCB_VTOR最终将__initial_sp处的指令传到msp内，然后调用svc启动第一个任务 */</span></span><br><span class="line">__asm <span class="type">void</span> <span class="title function_">prvStartFirstTask</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 当前栈按照8字节对齐 */</span></span><br><span class="line">PRESERVE8</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将SCB_VTOR寄存器地址加载到R0，SCB_VTOR寄存器存储__initial_sp的地址，</span></span><br><span class="line"><span class="comment">__initial_sp也是msp的地址，还是向量表的起始地址，因为CM3支持更改向量表的起始地址，</span></span><br><span class="line"><span class="comment">所以需要以下四条指令以重定位__initial_sp */</span></span><br><span class="line">ldr r0, =<span class="number">0xE000ED08</span></span><br><span class="line"><span class="comment">/* 将__initial_sp的地址加载进r0,STM32的__initial_sp为0x0800 0000 */</span></span><br><span class="line">ldr r0, [r0]</span><br><span class="line"><span class="comment">/* 将__initial_sp中的值，也就是msp初始化的值加载到r0，可能是0x20005B30 */</span></span><br><span class="line">ldr r0, [r0]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将上一步初始化__initial_sp在r0中的值加载到msp */</span></span><br><span class="line">msr msp, r0</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 开中断 */</span></span><br><span class="line">cpsie i</span><br><span class="line">cpsie f</span><br><span class="line"><span class="comment">/* 等待上面所有指令执行完成 */</span></span><br><span class="line">dsb</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用SVC去启动第一个任务 */</span></span><br><span class="line">svc <span class="number">0</span></span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__asm <span class="type">void</span> vPortSVCHandler( <span class="type">void</span> )</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">extern</span> pxCurrentTCB;</span><br><span class="line"> PRESERVE8</span><br><span class="line"> ldr r3, =pxCurrentTCB    <span class="comment">//TCB_t volatile *pxCurrentTCB = NULL;</span></span><br><span class="line"> ldr r1, [r3]             <span class="comment">//volatile StackType_t *pxTopOfStack;</span></span><br><span class="line"> ldr r0, [r1]             <span class="comment">//r0 = *pxTopOfStack</span></span><br><span class="line"> ldmia r0!, &#123;r4-r11&#125;</span><br><span class="line"> msr psp, r0</span><br><span class="line"> isb</span><br><span class="line"> mov r0, #<span class="number">0</span></span><br><span class="line"> msr basepri, r0<span class="comment">//开中断</span></span><br><span class="line"> orr r14, #<span class="number">0xd</span><span class="comment">//设置LR的值</span></span><br><span class="line"> bx r14<span class="comment">//此处不会返回r14(LR),而是返回到任务堆栈，具体看CM3手册</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> __asm <span class="type">void</span> xPortPendSVHandler( <span class="type">void</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> pxCurrentTCB;</span><br><span class="line"><span class="keyword">extern</span> vTaskSwitchContext;</span><br><span class="line"></span><br><span class="line">PRESERVE8</span><br><span class="line"></span><br><span class="line">mrs r0, psp</span><br><span class="line">isb</span><br><span class="line">ldr r3, =pxCurrentTCB</span><br><span class="line">ldr r2, [r3]</span><br><span class="line">stmdb r0!, &#123;r4-r11&#125;</span><br><span class="line">str r0, [r2]</span><br><span class="line">stmdb sp!, &#123;r3, r14&#125;</span><br><span class="line">mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY</span><br><span class="line">msr basepri, r0</span><br><span class="line">dsb</span><br><span class="line">isb</span><br><span class="line">bl vTaskSwitchContext</span><br><span class="line">mov r0, #<span class="number">0</span></span><br><span class="line">msr basepri, r0</span><br><span class="line">ldmia sp!, &#123;r3, r14&#125;</span><br><span class="line">ldr r1, [r3]</span><br><span class="line">ldr r0, [r1]</span><br><span class="line">ldmia r0!, &#123;r4-r11&#125;</span><br><span class="line">msr psp, r0</span><br><span class="line">isb</span><br><span class="line">bx r14<span class="comment">//此处不会返回r14(LR),而是返回到任务堆栈</span></span><br><span class="line">nop</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>为什么需要PendSV？<ul><li>为了保证外部中断能够马上执行，防止出现类似“优先级翻转”的情况</li></ul></li></ul><p><img src="/vx_images/241410816255828.png" alt="“内核的优先级翻转”">  </p><p><img src="/vx_images/295570916251582.png" alt="任务正常执行">  </p><ul><li>调用svc(请求管理调用)的原因<ul><li>用户与内核进行操作，但如需使用内核中资源时，需要通过SVC异常来触发内核异常，从而来获得特权模式，这才能执行内核代码</li></ul></li><li>为什么需要SVC启动第一个任务？<ul><li>使用了os后，任务调度交给内核，因此不能同裸机一样使用任务函数来启动，必须通过内核的服务才能启动任务</li></ul></li></ul><p><img src="/vx_images/555312310258572.png" alt="2024-01-05_10-23"></p><p><img src="/vx_images/334622310240146.png" alt="2024-01-05_10-23_1"></p><p>:::alert-danger<br>for循环无循环体时末尾加分号<br>:::  </p><h4 id="实现调度器总结"><a href="#实现调度器总结" class="headerlink" title="实现调度器总结"></a>实现调度器总结</h4><p><img src="/vx_images/363240921259275.png" alt="调度器的实现"></p><ul><li><p>初始化任务步骤</p><ul><li><p>调用创建静态任务函数</p><ul><li>设置TCB指针和栈指针</li><li>调用创建新任务函数，传入Handle，函数名称，参数，栈的深度等参数</li><li>返回Handle</li></ul></li><li><p>创建新任务函数操作：</p><ul><li>获取栈顶地址并对齐</li><li>将任务名称复制到TCB中</li><li>设置container与owner(container指的是处于哪个链表，owner是自身的TCB)</li><li>调用初始化任务栈函数，并返回一个栈顶指针</li><li>将任务的自身地址传给Handle，这样可以通过Handle控制任务</li></ul></li><li><p>初始化任务栈函数操作：</p><ul><li>对栈指针之前的16位进行设置以便加载到CPU寄存器中</li><li>返回空闲堆栈的栈指针</li></ul></li><li><p>开启第一个任务步骤(汇编)：</p><ul><li>设置堆栈按8字节对齐</li><li>从SCB_VTOR取出向量表地址，进而获得msp的内容（msp中的第一条指令是哪来的？）</li><li>开中断</li><li>调用svc指令去获取硬件权限，从而执行svc中断服务程序，并启动第一个任务(svc替代了以前的swi也就是软中断指令)</li></ul></li><li><p>svc中断服务程序的操作：</p><ul><li>将第一个任务的参数加载到寄存器，包括第一个函数的地址，形参，返回值</li><li>开中断，使用psp寄存器，返回到任务堆栈，这样第一个任务就执行完了，CPU等待执行下一个任务</li></ul></li></ul></li><li><p>上下文切换的操作：      </p><ul><li>总体与svc中断服务程序的操作类似，但是加上了将优先级载入到basepri的操作</li><li>设置好优先级后直接运行至跳转上下文 c 函数</li><li>最后开中断，使用psp寄存器，返回到任务堆栈，CPU等待执行下一个任务，调度器功能就实现了</li></ul></li></ul><p><a href="http://bbs.eeworld.com.cn/thread-617606-1-1.html">具体任务切换过程参考资料</a></p><h3 id="临界段保护"><a href="#临界段保护" class="headerlink" title="临界段保护"></a>临界段保护</h3><p>临界段就是在执行时不能被中断的代码段，典型的就是全局变量，系统时基</p><h4 id="中断管理"><a href="#中断管理" class="headerlink" title="中断管理"></a>中断管理</h4><p>FreeRTOS中的中断管理通过汇编完成，对于关中断而言，其内部实现了两个中断函数，分别是能保存当前中断有返回值的函数，可以在中断中使用。另一个是不能保存当前中断无返回值的函数，不能在中断使用。  本质是操作basepri寄存器，大于等于basepri寄存器的值的中断会被屏蔽，小于则不会。但当basepri为0时，则不会屏蔽任何中断</p><h4 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a>关中断</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不带返回值的关中断函数,不能嵌套,不能在中断里面使用 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portDISABLE_INTERRUPTS() vPortRaiseBASEPRI()</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortRaiseBASEPRI</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//中断号大于191的中断全部被屏蔽</span></span><br><span class="line"><span class="type">uint32_t</span> ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;    </span><br><span class="line"></span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将FreeRTOS最大优先级的中断加载到basepri寄存器中，这样会屏蔽FreeRTOS管理的所有中断</span></span><br><span class="line"></span><br><span class="line">msr basepri, ulNewBASEPRI    </span><br><span class="line">dsb</span><br><span class="line">isb</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 带返回值的关中断函数,可以嵌套,可以在中断里面使用 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portSET_INTERRUPT_MASK_FROM_ISR() ulPortRaiseBASEPRI()</span></span><br><span class="line">ulPortRaiseBASEPRI( <span class="type">void</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY; </span><br><span class="line"></span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mrs ulReturn, basepri    <span class="comment">//先对当前中断进行保存并返回</span></span><br><span class="line">msr basepri, ulNewBASEPRI</span><br><span class="line">dsb</span><br><span class="line">isb</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ulReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* PORTMACRO_H */</span></span></span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 开中断  </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不带中断保护的开中断函数，与portDISABLE_INTERRUPTS()成对使用 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portENABLE_INTERRUPTS() vPortSetBASEPRI( 0 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 带中断保护的开中断函数，与portSET_INTERRUPT_MASK_FROM_ISR()成对使用 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portCLEAR_INTERRUPT_MASK_FROM_ISR(x) vPortSetBASEPRI(x) </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortSetBASEPRI</span><span class="params">( <span class="type">uint32_t</span> ulBASEPRI )</span> </span><br><span class="line">&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">msr basepri, ulBASEPRI</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="inline关键字与内联函数"><a href="#inline关键字与内联函数" class="headerlink" title="inline关键字与内联函数"></a>inline关键字与内联函数</h4><p>inline关键字用于C++，__inline，__forceinline既可用于C，也可以用于C++</p><p>在程序中，如果在关键代码频繁调用某个函数，则会频繁的压栈出栈。为了<strong>提高效率</strong>，C语言提供了inline关键字来优化代码，例如在开关中断时需要inline关键字  </p><p>inline的原理是，将某个函数内容原封不动的放入引用处，这样就不会频繁的入栈出栈了。inline减少了函数调用的开销，但使代码膨胀。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//函数定义为inline即:内联函数  </span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">char</span>* <span class="title function_">dbtest</span><span class="params">(<span class="type">int</span> a)</span> </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">return</span> (i % <span class="number">2</span> &gt; <span class="number">0</span>) ? <span class="string">&quot;奇&quot;</span> : <span class="string">&quot;偶&quot;</span>;  </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i &lt; <span class="number">100</span>; i++) </span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i:%d    奇偶性:%s /n&quot;</span>, i, dbtest(i));      </span><br><span class="line">&#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更详细用法参考<a href="https://blog.csdn.net/jackailson/article/details/114781887">CSND</a>  </p><p>inline，__inline，__forceinline等用法参考<a href="https://blog.51cto.com/u_15614325/5272494">51CTO</a></p><h4 id="volatile作为左值时，即使类型相同右值也需要类型强转么？"><a href="#volatile作为左值时，即使类型相同右值也需要类型强转么？" class="headerlink" title="volatile作为左值时，即使类型相同右值也需要类型强转么？"></a>volatile作为左值时，即使类型相同右值也需要类型强转么？</h4><p>不需要，Keil编译器问题，但是可能会报warning甚至error，最好类型强转一下</p><h3 id="空闲任务与阻塞延时的实现"><a href="#空闲任务与阻塞延时的实现" class="headerlink" title="空闲任务与阻塞延时的实现"></a>空闲任务与阻塞延时的实现</h3><ul><li><p>为了能够自动进行任务调度，需要：</p><ul><li>设置CPU重装器，设置主频并调用系统中断向量表提供的SysTic中断服务函数</li><li>提供一个函数，内部能够完成时基自增和任务延时自减**(后期会取消自减的设置，转而使用“<a href="#clock">闹钟</a>”的思想)**，并将这个函数放入上一步的SysTick服务函数中，这样能够定时触发从而进行时基自增，在放入SysTick中时，还需要注意此函数前后需要开关中断以保证时基的实时性</li><li>将任务调度器函数<code>vTaskSwitchContext</code>重写，调度方式需要判定TCB中的任务延时，值为零，则触发SysTic中断服务函数，而后将任务放入就绪链表</li></ul></li><li><p>为了加入IdleTask支持，需要：</p><ul><li>在启动调度器函数 vTaskStartScheduler中加入空闲任务的启动，这需要设置IdleTask的TCB，栈，函数名称等参数，但<strong>不设置延时</strong>，因为CPU空闲时长不确定，设置完成后将其挂载到就绪列表</li></ul></li></ul><p>:::alert-danger<br>注意不要在IdleTask中加入任何阻塞或者死循环，否则由于IdleTask没有设置延时，会将同一优先级的所有任务阻塞！！！<br>:::</p><h3 id="支持多优先级"><a href="#支持多优先级" class="headerlink" title="支持多优先级"></a>支持多优先级</h3><p>CM内核有个计算前导零的指令，以此可以优化寻找最高优先级任务的方法<br><img src="/vx_images/100532010240153.png" alt="2024-01-12_10-19">  </p><p>主要原理是：找到一个32位变量的最高非零位，此位就是最高的有任务的链表的优先级<br>支持多优先级实现过程如下</p><ul><li>将<code>uxPriority</code>添加到TCB及其相关的函数内使其支持优先级</li><li>之后在<code>prvInitialiseNewTask</code>函数内添加初始化优先级，并做判断使任务初始化优先级大于等于<code>configMAX_PRIORITIES</code>的退化成<code>configMAX_PRIORITIES-1</code></li><li>在<code>prvInitialiseTaskLists</code>中初始化5个就绪链表</li><li>在<code>prvAddTaskToReadyList</code>宏函数中完成将任务移就绪入链表的操作<ul><li>记录当前优先级并将当前任务插入到获得的那个优先级链表的尾部</li></ul></li><li><strong>在<code>prvAddNewTaskToReadyList</code>函数</strong>中完成具体操作<ul><li>如果<code>pxCurrentTCB</code>为空，意味着可能是第一次创建任务，则将传进来的<code>pxNewTCB</code>赋值给<code>pxCurrentTCB</code>，并且调用<code>prvInitialiseTaskLists</code>函数以创建任务链表</li><li>如果<code>pxCurrentTCB</code>不为空，则根据优先级将<code>pxCurrentTCB</code>设置为优先级最高的那个任务，可能是<code>pxNewTCB</code>也可能是<code>pxCurrentTCB</code>，这需要做好判定再赋值</li><li>最后调用<code>prvAddTaskToReadyList</code></li></ul></li></ul><h3 id="任务延时列表的实现"><a href="#任务延时列表的实现" class="headerlink" title="任务延时列表的实现"></a>任务延时列表的实现</h3><ul><li><p>首先初始化两条链表<code>&amp;xDelayedTaskList1</code>与<code>&amp;xDelayedTaskList2</code>，并将其赋址给<code>pxDelayedTaskList</code>和<code>pxOverflowDelayedTaskList</code></p></li><li><p>在<code>vTaskStartScheduler</code>中初始化全局变量<code>xNextTaskUnblockTime</code>为最大值，这个变量表示下一次任务被唤醒的时刻，也就是所提到的“<span id="clock"><strong>闹钟</strong></span>”</p></li><li><p>在<code>vTaskDelay</code>函数中插入<code>prvAddCurrentTaskToDelayedList</code>函数，<code>prvAddCurrentTaskToDelayedList</code>函数实现如下</p><ul><li>将当前任务从就绪链表中移除，并检查移除任务后，就绪链表是否为空，若为空则将优先级位图上对应的位清除</li><li>记录<code>xTimeToWake</code>的值，它等于当前时钟加上<code>vTaskDelay</code>的参数，也就是<code>闹钟值</code>，与<code>xNextTaskUnblockTime</code>相等，但是为局部变量，并将此值设置为链表节点的排序值</li><li>比较<code>xTimeToWake</code>与<code>xConstTickCount</code>大小以判断是否闹钟溢出，溢出了就将当前任务移至<code>pxOverflowDelayedTaskList</code>链表，否则移至<code>pxDelayedTaskList</code>链表</li><li>然后更新<code>xNextTaskUnblockTime</code>使其等于<code>xTimeToWake</code></li></ul></li><li><p>在<code>xTaskIncrementTick</code>函数中判断延时任务是否到期，若到期且延时链表为空，则将<code>xNextTaskUnblockTime</code>设为最大值。若到期但延时链表不为空，则将延时链表中的每个节点的值<code>xItemValue</code>取出并与当前时刻做对比，若<code>xItemValue</code>大于当前时刻，则将<code>xNextTaskUnblockTime</code>更新为<code>xItemValue</code>，然后将任务从延时链表移入就绪链表</p></li><li><p>判断链表为空的方式：</p><ul><li>调用<code>uxListRemove</code>时会返回<code>pxList-&gt;uxNumberOfItems</code>，或者调用宏函数</li></ul></li></ul><p>FreeRTOS内部有两个延时链表，当系统时基计数器xTickCount没有溢出时，用一条链表(<code>pxDelayedTaskList</code>)，当xTickCount 溢出后，用另外一条链表(<code>pxOverflowDelayedTaskList</code>)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvTaskExitError</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 没有可供执行的任务时会停在这里，如果发生了这种情况，看一下空闲任务是否被执行 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数停止在这里 */</span></span><br><span class="line"><span class="keyword">for</span> (;;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="支持时间片"><a href="#支持时间片" class="headerlink" title="支持时间片"></a>支持时间片</h3><ul><li>抢占式调度(configUSE_PREEMPTION)：高优先级任务可以打断低优先级任务<ul><li>时间片流转(configUSE_TIME_SLICING)：同优先级任务之间每隔一定时间片进行任务切换<ul><li>空闲任务让步(configIDLE_SHOULD_YIELD)：空闲任务与用户任务处于同一优先级时，空闲任务等待用户任务使用完CPU后才能获取资源</li></ul></li></ul></li></ul><p>默认情况，FreeRTOS上面三个选项均开启</p><ul><li>支持时间片的操作非常简单<ul><li>分别在<code>FreeRTOSConfig.h</code>与<code>FreeRTOS.h</code>文件中引入<code>configUSE_PREEMPTION</code>和<code>configUSE_TIME_SLICING</code>两个宏，默认为1</li><li>修改<code>xPortSysTickHandler</code>函数，使得当<code>xTaskIncrementTick</code>返回值为<code>pdTrue</code>时才进行任务切换</li><li>修改<code>xTaskIncrementTick</code>函数，使得在延时链表中有任务被唤醒时，判断被唤醒的延时任务优先级与当前任务优先级，若被唤醒的延时任务优先级高则返回<code>pdTrue</code>，意味着进行任务切换</li><li>如果当就绪链表中任务数大于1，那么每进入<code>xTaskIncrementTick</code>函数就意味着过去了一个时间片，因此需要进行任务切换。注意在修改该函数时还需要判断上面两个宏是否为1</li></ul></li></ul><h3 id="自己实现"><a href="#自己实现" class="headerlink" title="自己实现"></a>自己实现</h3><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul><li>初始化Semaphore链表并设置Semaphore结构体的值</li><li>完成Take函数<ul><li>检测当前Semaphore个数是否大于0，若大于0则关中断，Semaphore数量–，不大于零则说明没有Semaphore可供Take，所以需要进行任务切换</li></ul></li><li>完成Give函数<ul><li>Give函数简单很多，只需要归还Semaphore然后开中断，将任务管理权归还给调度器即可</li></ul></li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul><li>为了保证数据能在不同函数间传递，静态创建资源时需要在创建资源的函数内传入在main函数中预设的结构体或数组的地址，对于Queue来说，官方使用<br> <code>xQueueCreateStatic(    UBaseType_t uxQueueLength,                       UBaseType_t uxItemSize,                       uint8_t *pucQueueStorageBuffer,                       StaticQueue_t *pxQueueBuffer    );</code>函数来传参</li><li>在创建函数内还需要初始化Queue链表和结构体及其参数，最后返回一个void*类型的handle</li><li>创建环形缓存区来保存数据，做好数据发送和接收的准备工作<ul><li>Buffer实际上是有一个head标志变量和一个tail标志变量的数组，发送数据时head++，接收数据时tail++，当head或tail等于数组结尾时需要把他们设置为数组开头</li><li>Buffer还要有检测是否为空的功能</li></ul></li><li>队列发送函数<code>QueueSend</code>中，在发送数据前需要关中断，发送数据后开中断</li><li>队列接收函数<code>QueueReceive</code>中，也需要同<code>QueueSend</code>开关中断</li></ul><h5 id="静态创建和动态创建的区别"><a href="#静态创建和动态创建的区别" class="headerlink" title="静态创建和动态创建的区别"></a>静态创建和动态创建的区别</h5><p>静态创建因为需要防止函数退出时销毁数据和栈，因此需要传入指针，所需的内存大小以及需要保存相关结构的地址等条件  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_LENGTH 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ITEM_SIZE sizeof( uint32_t )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// xQueueBuffer用来保存队列结构体，内部存储了队列的相关参数</span></span><br><span class="line">StaticQueue_t xQueueBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ucQueueStorage 用来保存队列的数据</span></span><br><span class="line"><span class="comment">// 大小为:队列长度 * 数据大小</span></span><br><span class="line"><span class="type">uint8_t</span> ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vATask</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">    QueueHandle_t xQueue1;</span><br><span class="line">    <span class="comment">// 创建队列: 可以容纳QUEUE_LENGTH个数据,每个数据大小是ITEM_SIZE</span></span><br><span class="line">    xQueue1 = xQueueCreateStatic( QUEUE_LENGTH,</span><br><span class="line">                                ITEM_SIZE,</span><br><span class="line">                                ucQueueStorage,</span><br><span class="line">                                &amp;xQueueBuffer );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>动态存储使用malloc函数因此不需要传入指针，但是程序速度运行比静态分配慢还需要对内存进行管理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">QueueReceive</span><span class="params">(QueueHandle_t QueueHandle, </span></span><br><span class="line"><span class="params"><span class="type">void</span>* <span class="type">const</span> ReceiveData )</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Queue_t* QueueTemp;</span><br><span class="line">QueueTemp = (Queue_t*)QueueHandle;</span><br><span class="line">BaseType_t rtval = pdFALSE;</span><br><span class="line">portDISABLE_INTERRUPTS();</span><br><span class="line">rtval = BufferReceive( ReceiveData,</span><br><span class="line"><span class="comment">/* 只能使用QueueTemp这种中间变量做强制类型转换，如果写成</span></span><br><span class="line"><span class="comment">((Queue_t*)QueueHandle)-&gt;uxQueueLength则会找不到成员</span></span><br><span class="line"><span class="comment">而报错 */</span></span><br><span class="line">QueueTemp-&gt;uxQueueLength,</span><br><span class="line">QueueTemp-&gt;uxItemSize,</span><br><span class="line">QueueTemp-&gt;pvDataStore);</span><br><span class="line">portENABLE_INTERRUPTS();</span><br><span class="line"><span class="keyword">return</span> rtval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遇到的困难与学到的经验"><a href="#遇到的困难与学到的经验" class="headerlink" title="遇到的困难与学到的经验"></a>遇到的困难与学到的经验</h3><ul><li><p>编译关系复杂，各种头文件相互包含导致类型重定义或者定义冲突</p><ul><li>理清编译关系，在项目之前做好文件规划，划分各文件的职责</li><li>注意头文件引用顺序</li><li>待补充</li></ul></li><li><p>Keil编译器有问题，有时候类型符合的赋值编译器不通过，必须类型强转才可编译通过。再或者，虽然已经定义了条件编译但还是对循环引用的头文件报错，这时就需要考虑编译器的问题了，Keil失效的通常的现象和解决办法：</p><ul><li>一般出现编译器问题的条件是：当一个错误卡住了很长时间，并且确定这段代码没有错误，而且当按照编译器的提示将这段代码彻底的进行修改后会爆出更多error，这时就可以考虑是编译器的问题了</li><li><img src="/vx_images/548533722266605.png" alt="2024-01-05_22-35"></li><li><img src="/vx_images/278363822259274.png" alt="2024-01-05_22-36"></li><li><img src="/vx_images/341003822255829.png" alt="2024-01-05_22-37"></li><li><img src="/vx_images/129063322246439.png" alt="2024-01-05_22-33"></li><li>所有可能的解决办法都失效了，可以考虑是Keil的问题</li><li>待补充</li></ul></li></ul><p>::: alert-danger   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">prvIdleTask</span><span class="params">( <span class="type">void</span> *p_arg )</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 永远不要在空闲任务里加入阻塞或者死循环！！！！！！！！！！！！！！！</span></span><br><span class="line"><span class="comment">否则当其他任务优先级为0时，空闲任务会霸占整个时间片(没有设置时间片流转和抢占式调度的话)*/</span></span><br><span class="line"><span class="comment">//for( ;; )</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//flagIdle = 1;</span></span><br><span class="line"><span class="comment">//flag1 = 0;</span></span><br><span class="line"><span class="comment">//flag2 = 0;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">因为在第十章已经实现支持多优先级了，且Task1，Task2优先级均大于<span class="number">0</span>，因此此时空闲任务内可以加循环</span><br><span class="line">:::    </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">* 遇到调不出来的Bug不要怕，解决方法如下</span><br><span class="line">    * 保持一个清醒的状态</span><br><span class="line">    * 快速定位问题的大概位置</span><br><span class="line">    * 在Bug大概位置处**逐步**调试</span><br><span class="line">    </span><br><span class="line">```c</span><br><span class="line"><span class="type">void</span> <span class="title function_">tickconst</span><span class="params">(<span class="type">int</span> tick)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> consttick = tick;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,consttick);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void tickstatic(int tick)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     static int statictick = tick;//static不能被变量赋值</span></span><br><span class="line"><span class="comment">//     printf(&quot;%d\n&quot;,statictick);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tickconst(i);<span class="comment">//const的值可以在定义的时候被修改，但不能在其他地方被修改，也就是说，const可以被变量赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">在时基函数调用时会用到</span><br><span class="line">![<span class="number">2024</span><span class="number">-01</span><span class="number">-11</span>_19<span class="number">-53</span>](vx_images/<span class="number">350415319240152.</span>png)  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//宏定义地址交换会修改值，这是因为函数宏定义不会产生栈</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swapdef(addra,addrb)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">    int *temp;\</span></span><br><span class="line"><span class="meta">    temp = a;\</span></span><br><span class="line"><span class="meta">    a = b;\</span></span><br><span class="line"><span class="meta">    b = temp;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//地址交换不会修改值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swapadd</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swapnum</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原值=%d %d\n&quot;</span>,a,b);</span><br><span class="line">    swapdef(&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;宏地址交换=%d %d\n&quot;</span>,a,b);</span><br><span class="line">    swapadd(&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;函数地址交换=%d %d\n&quot;</span>,a,b);</span><br><span class="line">    swapnum(&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;指针地址解引用交换=%d %d\n&quot;</span>,a,b);</span><br><span class="line">    a = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/vx_images/175724820240152.png" alt="2024-01-11_20-48">    </p><p>:::alert-info<br>堆栈太小可能会导致程序停止在HardFault<br>:::</p><h4 id="int-array-20-与-int-arrary-20-的不同"><a href="#int-array-20-与-int-arrary-20-的不同" class="headerlink" title="int (*array)[20] 与 int *arrary[20]的不同"></a>int (*array)[20] 与 int *arrary[20]的不同</h4><p>前者代表一个指向具有20个整型元素数组的<strong>指针</strong>，后者代表一个具有20个指针元素的<strong>数组</strong></p><h4 id="宏定义函数"><a href="#宏定义函数" class="headerlink" title="宏定义函数"></a>宏定义函数</h4><ul><li>为什么要使用宏定义函数？<ul><li>宏定义函数可以在预编译阶段直接展开，省下了压栈出栈的资源</li><li>那他与内联函数的区别是什么？<ul><li>宏定义函数只做展开和替换，不检查参数类型。而内联函数需要检查参数类型</li></ul></li></ul></li></ul><h4 id="C99特性"><a href="#C99特性" class="headerlink" title="C99特性"></a>C99特性</h4><p>在keil中可以在“魔术棒”的C&#x2F;C++设置C99模式，指定后可以在<strong>非全局</strong>作用域下定义不定长数组  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ListNum 5<span class="comment">//只能使用宏定义，变量赋值也不行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ItemNum 10</span></span><br><span class="line"><span class="comment">/* 不能在全局作用域下定义，同时也不能加static关键字 */</span></span><br><span class="line"><span class="type">int</span> arr[ListNum][ItemNum];</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">#### 不允许使用<span class="type">void</span>数组  </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="type">void</span> arr[<span class="number">20</span>];<span class="comment">//非法定义，因为无法知道开辟空间的大小</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;项目&quot;&gt;&lt;a href=&quot;#项目&quot; class=&quot;headerlink&quot; title=&quot;项目&quot;&gt;&lt;/a&gt;项目&lt;/h1&gt;&lt;h2 id=&quot;FreeRTOS内核实现&quot;&gt;&lt;a href=&quot;#FreeRTOS内核实现&quot; class=&quot;headerlink&quot; title=&quot;F</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>杂项</title>
    <link href="https://wumingzi.top/2024/01/23/%E6%9D%82%E9%A1%B9/"/>
    <id>https://wumingzi.top/2024/01/23/%E6%9D%82%E9%A1%B9/</id>
    <published>2024-01-23T03:31:32.000Z</published>
    <updated>2024-01-23T03:31:32.400Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>工具链</title>
    <link href="https://wumingzi.top/2024/01/23/%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
    <id>https://wumingzi.top/2024/01/23/%E5%B7%A5%E5%85%B7%E9%93%BE/</id>
    <published>2024-01-23T03:31:23.000Z</published>
    <updated>2024-01-23T03:31:23.903Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://wumingzi.top/2024/01/23/FreeRTOS/"/>
    <id>https://wumingzi.top/2024/01/23/FreeRTOS/</id>
    <published>2024-01-23T03:31:04.515Z</published>
    <updated>2024-01-23T03:33:06.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="FreeRTOS内核实现"><a href="#FreeRTOS内核实现" class="headerlink" title="FreeRTOS内核实现"></a>FreeRTOS内核实现</h2><p>参考书籍：《FreeRTOS 内核实现与应用开发实战指南》  </p><blockquote><p>一个工程如果没有 main 函数是编译不成功的,会出错。因为系统在开始执行的时候先执行启动文件里面的复位程序,复位程序里面会调用 C 库函数__main,__main 的作用是初始化好系统变量,如全局变量,只读的,可读可写的等等。__main 最后会调用__rtentry,再由__rtentry 调用 main 函数,从而由汇编跳入到 C 的世界,这里面的 main 函数就需要我们手动编写,如果没有编写 main 函数,就会出现 main 函数没有定义的错误。  </p></blockquote><p>生成的startup_ARMCM3.s负责启动startup_ARMCM3.c负责时钟配置，本项目默认的时钟为25M </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">  Define clocks</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  XTAL            ( 5000000UL)      <span class="comment">/* Oscillator frequency */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  SYSTEM_CLOCK    (5U * XTAL)</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">![<span class="number">2024</span><span class="number">-01</span><span class="number">-02</span>_10<span class="number">-16</span>](vx_images/<span class="number">419821610240143.</span>png =<span class="number">600</span>x)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">对于这种多行宏定义，每行结尾要加 \ 表示该行未结束</span><br><span class="line">  </span><br><span class="line">::: alert-danger</span><br><span class="line">若使用 \ 表示该行未完结务必注意 \ 后不能加任何字符，尤其是空格或者Tab。报错如下![<span class="number">2024</span><span class="number">-01</span><span class="number">-02</span>_12<span class="number">-05</span>](vx_images/<span class="number">481670512259271.</span>png =<span class="number">600</span>x)</span><br><span class="line">:::</span><br><span class="line">    </span><br><span class="line">![<span class="number">2024</span><span class="number">-01</span><span class="number">-02</span>_10<span class="number">-44</span>](vx_images/<span class="number">400010311258569.</span>png =<span class="number">600</span>x)</span><br><span class="line">  </span><br><span class="line">![<span class="number">2024</span><span class="number">-01</span><span class="number">-02</span>_11<span class="number">-04</span>](vx_images/<span class="number">7600511266602.</span>png =<span class="number">600</span>x)</span><br><span class="line">  </span><br><span class="line">左值不能进行类型转换，类型转换本质上是在寄存器内对原值进行位操作，得到的结果不放入内存，而左值是需要放进内存的，因此类型转换与左值冲突，若要类型转换，则需要对右值进行操作</span><br><span class="line"></span><br><span class="line">:::alert-danger</span><br><span class="line">当一个a.c文件需要b.h，而b.h包含了c.h，且c.h也包含了b.h时，会发生编译冲突。表现为有未定义的类型或变量，详情参考[博客园](https:<span class="comment">//www.cnblogs.com/skullboyer/p/8891579.html)，解决办法是理清编译关系，去除重复包含的头文件</span></span><br><span class="line">![<span class="number">2024</span><span class="number">-01</span><span class="number">-03</span>_13<span class="number">-26</span>](vx_images/<span class="number">211612613258570.</span>png =<span class="number">600</span>x)</span><br><span class="line">:::  </span><br><span class="line"></span><br><span class="line">栈由高地址向低地址增长，栈顶是第一个进栈的元素，栈底是最后一个进栈的元素</span><br><span class="line">因为<span class="number">32</span>位机一般指令都是<span class="number">32</span>位的，栈顶指针只需<span class="number">4</span>字节对齐即可，但是考虑兼容浮点运算的<span class="number">64</span>位操作则需要<span class="number">8</span>字节。对齐完成后，栈顶指针即可确定位置，而后开辟空间  </span><br><span class="line"></span><br><span class="line">![<span class="number">2024</span><span class="number">-01</span><span class="number">-03</span>_16<span class="number">-01</span>](vx_images/<span class="number">151190216246437.</span>png =<span class="number">600</span>x)</span><br><span class="line">项目的.c 与 .h文件可以不重名，位置可以不同，例如port.c文件放在\freertos\Source\portable\RVDS\ARM_CM3，但是引用port.c内容的portable.h放在\freertos\Source\include    </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="comment">/* 这行代码的意思是定义了TaskFunction_t类型的函数指针，参数和返回值都是void，这样就可以进行函数“赋值”，进而从Task1，Task2中抽象出TaskFunction_t这一类型了，并且使用起来很方便 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (*TaskFunction_t)( <span class="type">void</span> * );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类似用法如下 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> tech(<span class="type">void</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;tech dreamer&quot;</span>); &#125;</span><br><span class="line"><span class="comment">//命名一个类型，那么这个时候func不可以直接调用，而是一个类型了</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (*func)();</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个可调用的指针变量（函数）：myfunc</span></span><br><span class="line">    func myfunc;</span><br><span class="line">    myfunc = &amp;tech; <span class="comment">//&amp;可以不加</span></span><br><span class="line">    <span class="comment">/* 下面两种方法体现了函数名和函数地址是一回事 */</span></span><br><span class="line">    myfunc();         <span class="comment">//第一种调用方式，带参数也可以</span></span><br><span class="line">    (*myfunc)();      <span class="comment">//第二种调用方式，带参数也可以</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现就绪链表"><a href="#实现就绪链表" class="headerlink" title="实现就绪链表"></a>实现就绪链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*TaskFunction_t)</span><span class="params">( <span class="type">void</span> * )</span>;<span class="comment">//将TaskFunction_t函数指针重定义为void*类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//FreeRTOS中TaskFunction_t内部包含了一个栈顶指针，因此返回值为uint32型</span></span><br></pre></td></tr></table></figure><p>:::alert&#x3D;info<br>在FreeRTOS里TaskHandle_t是个TCB_t的指针<br>在toyFreeRTOS里TaskHandle_t是个void*类型的指针，使用时需要类型强转<br>:::  </p><h4 id="设置任务栈时栈顶指针的移动"><a href="#设置任务栈时栈顶指针的移动" class="headerlink" title="设置任务栈时栈顶指针的移动"></a>设置任务栈时栈顶指针的移动</h4><p>![2024-01-13_13-36](vx_images&#x2F;434673613240154.png &#x3D;600x)</p><p>![2024-01-04_09-41](vx_images&#x2F;386434109258571.png &#x3D;600x)  </p><p>首先由外部函数prvInitialiseNewTask构造出的pxTopOfStack指针传入pxPortInitialiseStack函数，此时pxTopOfStack指针指向A位置，而后移动指针至B，C点从而将xPSR，PC，LR的值依次写入栈顶，方便之后寄存器读取。配置好自动加载到寄存器的内容后再将指针下移至D并返回，从而使任务得到空闲堆栈的指针  </p><h3 id="实现调度器"><a href="#实现调度器" class="headerlink" title="实现调度器"></a>实现调度器</h3><p>![2024-01-04_14-42](vx_images&#x2F;5864314266604.png &#x3D;600x)<br>向量表最前面是MSP的地址</p><p>配置寄存器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 对0xe000ed20地址处取值，此处为SHPR3寄存器，设置的是pendsv和systick优先级 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portNVIC_SYSPRI2_REG*(( volatile uint32_t *) 0xe000ed20) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置 PendSV 和 SysTick 的中断优先级为最低 */</span></span><br><span class="line"> portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;<span class="comment">//SHPR3寄存器被设置为 0x**FF ****</span></span><br><span class="line"> portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;<span class="comment">//SHPR3寄存器被设置为 0xFFFF ****</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开启第一个任务：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 通过查找SCB_VTOR最终将__initial_sp处的指令传到msp内，然后调用svc启动第一个任务 */</span></span><br><span class="line">__asm <span class="type">void</span> <span class="title function_">prvStartFirstTask</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 当前栈按照8字节对齐 */</span></span><br><span class="line">PRESERVE8</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将SCB_VTOR寄存器地址加载到R0，SCB_VTOR寄存器存储__initial_sp的地址，</span></span><br><span class="line"><span class="comment">__initial_sp也是msp的地址，还是向量表的起始地址，因为CM3支持更改向量表的起始地址，</span></span><br><span class="line"><span class="comment">所以需要以下四条指令以重定位__initial_sp */</span></span><br><span class="line">ldr r0, =<span class="number">0xE000ED08</span></span><br><span class="line"><span class="comment">/* 将__initial_sp的地址加载进r0,STM32的__initial_sp为0x0800 0000 */</span></span><br><span class="line">ldr r0, [r0]</span><br><span class="line"><span class="comment">/* 将__initial_sp中的值，也就是msp初始化的值加载到r0，可能是0x20005B30 */</span></span><br><span class="line">ldr r0, [r0]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将上一步初始化__initial_sp在r0中的值加载到msp */</span></span><br><span class="line">msr msp, r0</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 开中断 */</span></span><br><span class="line">cpsie i</span><br><span class="line">cpsie f</span><br><span class="line"><span class="comment">/* 等待上面所有指令执行完成 */</span></span><br><span class="line">dsb</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用SVC去启动第一个任务 */</span></span><br><span class="line">svc <span class="number">0</span></span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__asm <span class="type">void</span> vPortSVCHandler( <span class="type">void</span> )</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">extern</span> pxCurrentTCB;</span><br><span class="line"> PRESERVE8</span><br><span class="line"> ldr r3, =pxCurrentTCB    <span class="comment">//TCB_t volatile *pxCurrentTCB = NULL;</span></span><br><span class="line"> ldr r1, [r3]             <span class="comment">//volatile StackType_t *pxTopOfStack;</span></span><br><span class="line"> ldr r0, [r1]             <span class="comment">//r0 = *pxTopOfStack</span></span><br><span class="line"> ldmia r0!, &#123;r4-r11&#125;</span><br><span class="line"> msr psp, r0</span><br><span class="line"> isb</span><br><span class="line"> mov r0, #<span class="number">0</span></span><br><span class="line"> msr basepri, r0<span class="comment">//开中断</span></span><br><span class="line"> orr r14, #<span class="number">0xd</span><span class="comment">//设置LR的值</span></span><br><span class="line"> bx r14<span class="comment">//此处不会返回r14(LR),而是返回到任务堆栈，具体看CM3手册</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> __asm <span class="type">void</span> xPortPendSVHandler( <span class="type">void</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> pxCurrentTCB;</span><br><span class="line"><span class="keyword">extern</span> vTaskSwitchContext;</span><br><span class="line"></span><br><span class="line">PRESERVE8</span><br><span class="line"></span><br><span class="line">mrs r0, psp</span><br><span class="line">isb</span><br><span class="line">ldr r3, =pxCurrentTCB</span><br><span class="line">ldr r2, [r3]</span><br><span class="line">stmdb r0!, &#123;r4-r11&#125;</span><br><span class="line">str r0, [r2]</span><br><span class="line">stmdb sp!, &#123;r3, r14&#125;</span><br><span class="line">mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY</span><br><span class="line">msr basepri, r0</span><br><span class="line">dsb</span><br><span class="line">isb</span><br><span class="line">bl vTaskSwitchContext</span><br><span class="line">mov r0, #<span class="number">0</span></span><br><span class="line">msr basepri, r0</span><br><span class="line">ldmia sp!, &#123;r3, r14&#125;</span><br><span class="line">ldr r1, [r3]</span><br><span class="line">ldr r0, [r1]</span><br><span class="line">ldmia r0!, &#123;r4-r11&#125;</span><br><span class="line">msr psp, r0</span><br><span class="line">isb</span><br><span class="line">bx r14<span class="comment">//此处不会返回r14(LR),而是返回到任务堆栈</span></span><br><span class="line">nop</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>为什么需要PendSV？<ul><li>为了保证外部中断能够马上执行，防止出现类似“优先级翻转”的情况</li></ul></li></ul><p>![“内核的优先级翻转”](vx_images&#x2F;241410816255828.png &#x3D;600x)  </p><p>![任务正常执行](vx_images&#x2F;295570916251582.png &#x3D;600x)  </p><ul><li>调用svc(请求管理调用)的原因<ul><li>用户与内核进行操作，但如需使用内核中资源时，需要通过SVC异常来触发内核异常，从而来获得特权模式，这才能执行内核代码</li></ul></li><li>为什么需要SVC启动第一个任务？<ul><li>使用了os后，任务调度交给内核，因此不能同裸机一样使用任务函数来启动，必须通过内核的服务才能启动任务</li></ul></li></ul><p>![2024-01-05_10-23](vx_images&#x2F;555312310258572.png &#x3D;300x)</p><p>![2024-01-05_10-23_1](vx_images&#x2F;334622310240146.png &#x3D;300x)</p><p>:::alert-danger<br>for循环无循环体时末尾加分号<br>:::  </p><h4 id="实现调度器总结"><a href="#实现调度器总结" class="headerlink" title="实现调度器总结"></a>实现调度器总结</h4><p>![调度器的实现](vx_images&#x2F;363240921259275.png &#x3D;600x)</p><ul><li><p>初始化任务步骤</p><ul><li><p>调用创建静态任务函数</p><ul><li>设置TCB指针和栈指针</li><li>调用创建新任务函数，传入Handle，函数名称，参数，栈的深度等参数</li><li>返回Handle</li></ul></li><li><p>创建新任务函数操作：</p><ul><li>获取栈顶地址并对齐</li><li>将任务名称复制到TCB中</li><li>设置container与owner(container指的是处于哪个链表，owner是自身的TCB)</li><li>调用初始化任务栈函数，并返回一个栈顶指针</li><li>将任务的自身地址传给Handle，这样可以通过Handle控制任务</li></ul></li><li><p>初始化任务栈函数操作：</p><ul><li>对栈指针之前的16位进行设置以便加载到CPU寄存器中</li><li>返回空闲堆栈的栈指针</li></ul></li><li><p>开启第一个任务步骤(汇编)：</p><ul><li>设置堆栈按8字节对齐</li><li>从SCB_VTOR取出向量表地址，进而获得msp的内容（msp中的第一条指令是哪来的？）</li><li>开中断</li><li>调用svc指令去获取硬件权限，从而执行svc中断服务程序，并启动第一个任务(svc替代了以前的swi也就是软中断指令)</li></ul></li><li><p>svc中断服务程序的操作：</p><ul><li>将第一个任务的参数加载到寄存器，包括第一个函数的地址，形参，返回值</li><li>开中断，使用psp寄存器，返回到任务堆栈，这样第一个任务就执行完了，CPU等待执行下一个任务</li></ul></li></ul></li><li><p>上下文切换的操作：      </p><ul><li>总体与svc中断服务程序的操作类似，但是加上了将优先级载入到basepri的操作</li><li>设置好优先级后直接运行至跳转上下文 c 函数</li><li>最后开中断，使用psp寄存器，返回到任务堆栈，CPU等待执行下一个任务，调度器功能就实现了</li></ul></li></ul><p><a href="http://bbs.eeworld.com.cn/thread-617606-1-1.html">具体任务切换过程参考资料</a></p><h3 id="临界段保护"><a href="#临界段保护" class="headerlink" title="临界段保护"></a>临界段保护</h3><p>临界段就是在执行时不能被中断的代码段，典型的就是全局变量，系统时基</p><h4 id="中断管理"><a href="#中断管理" class="headerlink" title="中断管理"></a>中断管理</h4><p>FreeRTOS中的中断管理通过汇编完成，对于关中断而言，其内部实现了两个中断函数，分别是能保存当前中断有返回值的函数，可以在中断中使用。另一个是不能保存当前中断无返回值的函数，不能在中断使用。  本质是操作basepri寄存器，大于等于basepri寄存器的值的中断会被屏蔽，小于则不会。但当basepri为0时，则不会屏蔽任何中断</p><h4 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a>关中断</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不带返回值的关中断函数,不能嵌套,不能在中断里面使用 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portDISABLE_INTERRUPTS() vPortRaiseBASEPRI()</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortRaiseBASEPRI</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//中断号大于191的中断全部被屏蔽</span></span><br><span class="line"><span class="type">uint32_t</span> ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;    </span><br><span class="line"></span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将FreeRTOS最大优先级的中断加载到basepri寄存器中，这样会屏蔽FreeRTOS管理的所有中断</span></span><br><span class="line"></span><br><span class="line">msr basepri, ulNewBASEPRI    </span><br><span class="line">dsb</span><br><span class="line">isb</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 带返回值的关中断函数,可以嵌套,可以在中断里面使用 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portSET_INTERRUPT_MASK_FROM_ISR() ulPortRaiseBASEPRI()</span></span><br><span class="line">ulPortRaiseBASEPRI( <span class="type">void</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY; </span><br><span class="line"></span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mrs ulReturn, basepri    <span class="comment">//先对当前中断进行保存并返回</span></span><br><span class="line">msr basepri, ulNewBASEPRI</span><br><span class="line">dsb</span><br><span class="line">isb</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ulReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* PORTMACRO_H */</span></span></span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 开中断  </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不带中断保护的开中断函数，与portDISABLE_INTERRUPTS()成对使用 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portENABLE_INTERRUPTS() vPortSetBASEPRI( 0 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 带中断保护的开中断函数，与portSET_INTERRUPT_MASK_FROM_ISR()成对使用 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portCLEAR_INTERRUPT_MASK_FROM_ISR(x) vPortSetBASEPRI(x) </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortSetBASEPRI</span><span class="params">( <span class="type">uint32_t</span> ulBASEPRI )</span> </span><br><span class="line">&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">msr basepri, ulBASEPRI</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="inline关键字与内联函数"><a href="#inline关键字与内联函数" class="headerlink" title="inline关键字与内联函数"></a>inline关键字与内联函数</h4><p>inline关键字用于C++，__inline，__forceinline既可用于C，也可以用于C++</p><p>在程序中，如果在关键代码频繁调用某个函数，则会频繁的压栈出栈。为了<strong>提高效率</strong>，C语言提供了inline关键字来优化代码，例如在开关中断时需要inline关键字  </p><p>inline的原理是，将某个函数内容原封不动的放入引用处，这样就不会频繁的入栈出栈了。inline减少了函数调用的开销，但使代码膨胀。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//函数定义为inline即:内联函数  </span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">char</span>* <span class="title function_">dbtest</span><span class="params">(<span class="type">int</span> a)</span> </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">return</span> (i % <span class="number">2</span> &gt; <span class="number">0</span>) ? <span class="string">&quot;奇&quot;</span> : <span class="string">&quot;偶&quot;</span>;  </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i &lt; <span class="number">100</span>; i++) </span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i:%d    奇偶性:%s /n&quot;</span>, i, dbtest(i));      </span><br><span class="line">&#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更详细用法参考<a href="https://blog.csdn.net/jackailson/article/details/114781887">CSND</a>  </p><p>inline，__inline，__forceinline等用法参考<a href="https://blog.51cto.com/u_15614325/5272494">51CTO</a></p><h4 id="volatile作为左值时，即使类型相同右值也需要类型强转么？"><a href="#volatile作为左值时，即使类型相同右值也需要类型强转么？" class="headerlink" title="volatile作为左值时，即使类型相同右值也需要类型强转么？"></a>volatile作为左值时，即使类型相同右值也需要类型强转么？</h4><p>不需要，Keil编译器问题，但是可能会报warning甚至error，最好类型强转一下</p><h3 id="空闲任务与阻塞延时的实现"><a href="#空闲任务与阻塞延时的实现" class="headerlink" title="空闲任务与阻塞延时的实现"></a>空闲任务与阻塞延时的实现</h3><ul><li><p>为了能够自动进行任务调度，需要：</p><ul><li>设置CPU重装器，设置主频并调用系统中断向量表提供的SysTic中断服务函数</li><li>提供一个函数，内部能够完成时基自增和任务延时自减**(后期会取消自减的设置，转而使用“<a href="#clock">闹钟</a>”的思想)**，并将这个函数放入上一步的SysTick服务函数中，这样能够定时触发从而进行时基自增，在放入SysTick中时，还需要注意此函数前后需要开关中断以保证时基的实时性</li><li>将任务调度器函数<code>vTaskSwitchContext</code>重写，调度方式需要判定TCB中的任务延时，值为零，则触发SysTic中断服务函数，而后将任务放入就绪链表</li></ul></li><li><p>为了加入IdleTask支持，需要：</p><ul><li>在启动调度器函数 vTaskStartScheduler中加入空闲任务的启动，这需要设置IdleTask的TCB，栈，函数名称等参数，但<strong>不设置延时</strong>，因为CPU空闲时长不确定，设置完成后将其挂载到就绪列表</li></ul></li></ul><p>:::alert-danger<br>注意不要在IdleTask中加入任何阻塞或者死循环，否则由于IdleTask没有设置延时，会将同一优先级的所有任务阻塞！！！<br>:::</p><h3 id="支持多优先级"><a href="#支持多优先级" class="headerlink" title="支持多优先级"></a>支持多优先级</h3><p>CM内核有个计算前导零的指令，以此可以优化寻找最高优先级任务的方法<br>![2024-01-12_10-19](vx_images&#x2F;100532010240153.png &#x3D;600x)  </p><p>主要原理是：找到一个32位变量的最高非零位，此位就是最高的有任务的链表的优先级<br>支持多优先级实现过程如下</p><ul><li>将<code>uxPriority</code>添加到TCB及其相关的函数内使其支持优先级</li><li>之后在<code>prvInitialiseNewTask</code>函数内添加初始化优先级，并做判断使任务初始化优先级大于等于<code>configMAX_PRIORITIES</code>的退化成<code>configMAX_PRIORITIES-1</code></li><li>在<code>prvInitialiseTaskLists</code>中初始化5个就绪链表</li><li>在<code>prvAddTaskToReadyList</code>宏函数中完成将任务移就绪入链表的操作<ul><li>记录当前优先级并将当前任务插入到获得的那个优先级链表的尾部</li></ul></li><li><strong>在<code>prvAddNewTaskToReadyList</code>函数</strong>中完成具体操作<ul><li>如果<code>pxCurrentTCB</code>为空，意味着可能是第一次创建任务，则将传进来的<code>pxNewTCB</code>赋值给<code>pxCurrentTCB</code>，并且调用<code>prvInitialiseTaskLists</code>函数以创建任务链表</li><li>如果<code>pxCurrentTCB</code>不为空，则根据优先级将<code>pxCurrentTCB</code>设置为优先级最高的那个任务，可能是<code>pxNewTCB</code>也可能是<code>pxCurrentTCB</code>，这需要做好判定再赋值</li><li>最后调用<code>prvAddTaskToReadyList</code></li></ul></li></ul><h3 id="任务延时列表的实现"><a href="#任务延时列表的实现" class="headerlink" title="任务延时列表的实现"></a>任务延时列表的实现</h3><ul><li><p>首先初始化两条链表<code>&amp;xDelayedTaskList1</code>与<code>&amp;xDelayedTaskList2</code>，并将其赋址给<code>pxDelayedTaskList</code>和<code>pxOverflowDelayedTaskList</code></p></li><li><p>在<code>vTaskStartScheduler</code>中初始化全局变量<code>xNextTaskUnblockTime</code>为最大值，这个变量表示下一次任务被唤醒的时刻，也就是所提到的“<span id="clock"><strong>闹钟</strong></span>”</p></li><li><p>在<code>vTaskDelay</code>函数中插入<code>prvAddCurrentTaskToDelayedList</code>函数，<code>prvAddCurrentTaskToDelayedList</code>函数实现如下</p><ul><li>将当前任务从就绪链表中移除，并检查移除任务后，就绪链表是否为空，若为空则将优先级位图上对应的位清除</li><li>记录<code>xTimeToWake</code>的值，它等于当前时钟加上<code>vTaskDelay</code>的参数，也就是<code>闹钟值</code>，与<code>xNextTaskUnblockTime</code>相等，但是为局部变量，并将此值设置为链表节点的排序值</li><li>比较<code>xTimeToWake</code>与<code>xConstTickCount</code>大小以判断是否闹钟溢出，溢出了就将当前任务移至<code>pxOverflowDelayedTaskList</code>链表，否则移至<code>pxDelayedTaskList</code>链表</li><li>然后更新<code>xNextTaskUnblockTime</code>使其等于<code>xTimeToWake</code></li></ul></li><li><p>在<code>xTaskIncrementTick</code>函数中判断延时任务是否到期，若到期且延时链表为空，则将<code>xNextTaskUnblockTime</code>设为最大值。若到期但延时链表不为空，则将延时链表中的每个节点的值<code>xItemValue</code>取出并与当前时刻做对比，若<code>xItemValue</code>大于当前时刻，则将<code>xNextTaskUnblockTime</code>更新为<code>xItemValue</code>，然后将任务从延时链表移入就绪链表</p></li><li><p>判断链表为空的方式：</p><ul><li>调用<code>uxListRemove</code>时会返回<code>pxList-&gt;uxNumberOfItems</code>，或者调用宏函数</li></ul></li></ul><p>FreeRTOS内部有两个延时链表，当系统时基计数器xTickCount没有溢出时，用一条链表(<code>pxDelayedTaskList</code>)，当xTickCount 溢出后，用另外一条链表(<code>pxOverflowDelayedTaskList</code>)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvTaskExitError</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 没有可供执行的任务时会停在这里，如果发生了这种情况，看一下空闲任务是否被执行 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数停止在这里 */</span></span><br><span class="line"><span class="keyword">for</span> (;;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="支持时间片"><a href="#支持时间片" class="headerlink" title="支持时间片"></a>支持时间片</h3><ul><li>抢占式调度(configUSE_PREEMPTION)：高优先级任务可以打断低优先级任务<ul><li>时间片流转(configUSE_TIME_SLICING)：同优先级任务之间每隔一定时间片进行任务切换<ul><li>空闲任务让步(configIDLE_SHOULD_YIELD)：空闲任务与用户任务处于同一优先级时，空闲任务等待用户任务使用完CPU后才能获取资源</li></ul></li></ul></li></ul><p>默认情况，FreeRTOS上面三个选项均开启</p><ul><li>支持时间片的操作非常简单<ul><li>分别在<code>FreeRTOSConfig.h</code>与<code>FreeRTOS.h</code>文件中引入<code>configUSE_PREEMPTION</code>和<code>configUSE_TIME_SLICING</code>两个宏，默认为1</li><li>修改<code>xPortSysTickHandler</code>函数，使得当<code>xTaskIncrementTick</code>返回值为<code>pdTrue</code>时才进行任务切换</li><li>修改<code>xTaskIncrementTick</code>函数，使得在延时链表中有任务被唤醒时，判断被唤醒的延时任务优先级与当前任务优先级，若被唤醒的延时任务优先级高则返回<code>pdTrue</code>，意味着进行任务切换</li><li>如果当就绪链表中任务数大于1，那么每进入<code>xTaskIncrementTick</code>函数就意味着过去了一个时间片，因此需要进行任务切换。注意在修改该函数时还需要判断上面两个宏是否为1</li></ul></li></ul><h3 id="自己实现"><a href="#自己实现" class="headerlink" title="自己实现"></a>自己实现</h3><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul><li>初始化Semaphore链表并设置Semaphore结构体的值</li><li>完成Take函数<ul><li>检测当前Semaphore个数是否大于0，若大于0则关中断，Semaphore数量–，不大于零则说明没有Semaphore可供Take，所以需要进行任务切换</li></ul></li><li>完成Give函数<ul><li>Give函数简单很多，只需要归还Semaphore然后开中断，将任务管理权归还给调度器即可</li></ul></li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul><li>为了保证数据能在不同函数间传递，静态创建资源时需要在创建资源的函数内传入在main函数中预设的结构体或数组的地址，对于Queue来说，官方使用<br> <code>xQueueCreateStatic(    UBaseType_t uxQueueLength,                       UBaseType_t uxItemSize,                       uint8_t *pucQueueStorageBuffer,                       StaticQueue_t *pxQueueBuffer    );</code>函数来传参</li><li>在创建函数内还需要初始化Queue链表和结构体及其参数，最后返回一个void*类型的handle</li><li>创建环形缓存区来保存数据，做好数据发送和接收的准备工作<ul><li>Buffer实际上是有一个head标志变量和一个tail标志变量的数组，发送数据时head++，接收数据时tail++，当head或tail等于数组结尾时需要把他们设置为数组开头</li><li>Buffer还要有检测是否为空的功能</li></ul></li><li>队列发送函数<code>QueueSend</code>中，在发送数据前需要关中断，发送数据后开中断</li><li>队列接收函数<code>QueueReceive</code>中，也需要同<code>QueueSend</code>开关中断</li></ul><h5 id="静态创建和动态创建的区别"><a href="#静态创建和动态创建的区别" class="headerlink" title="静态创建和动态创建的区别"></a>静态创建和动态创建的区别</h5><p>静态创建因为需要防止函数退出时销毁数据和栈，因此需要传入指针，所需的内存大小以及需要保存相关结构的地址等条件  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_LENGTH 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ITEM_SIZE sizeof( uint32_t )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// xQueueBuffer用来保存队列结构体，内部存储了队列的相关参数</span></span><br><span class="line">StaticQueue_t xQueueBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ucQueueStorage 用来保存队列的数据</span></span><br><span class="line"><span class="comment">// 大小为:队列长度 * 数据大小</span></span><br><span class="line"><span class="type">uint8_t</span> ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vATask</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">    QueueHandle_t xQueue1;</span><br><span class="line">    <span class="comment">// 创建队列: 可以容纳QUEUE_LENGTH个数据,每个数据大小是ITEM_SIZE</span></span><br><span class="line">    xQueue1 = xQueueCreateStatic( QUEUE_LENGTH,</span><br><span class="line">                                ITEM_SIZE,</span><br><span class="line">                                ucQueueStorage,</span><br><span class="line">                                &amp;xQueueBuffer );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>动态存储使用malloc函数因此不需要传入指针，但是程序速度运行比静态分配慢还需要对内存进行管理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">QueueReceive</span><span class="params">(QueueHandle_t QueueHandle, </span></span><br><span class="line"><span class="params"><span class="type">void</span>* <span class="type">const</span> ReceiveData )</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Queue_t* QueueTemp;</span><br><span class="line">QueueTemp = (Queue_t*)QueueHandle;</span><br><span class="line">BaseType_t rtval = pdFALSE;</span><br><span class="line">portDISABLE_INTERRUPTS();</span><br><span class="line">rtval = BufferReceive( ReceiveData,</span><br><span class="line"><span class="comment">/* 只能使用QueueTemp这种中间变量做强制类型转换，如果写成</span></span><br><span class="line"><span class="comment">((Queue_t*)QueueHandle)-&gt;uxQueueLength则会找不到成员</span></span><br><span class="line"><span class="comment">而报错 */</span></span><br><span class="line">QueueTemp-&gt;uxQueueLength,</span><br><span class="line">QueueTemp-&gt;uxItemSize,</span><br><span class="line">QueueTemp-&gt;pvDataStore);</span><br><span class="line">portENABLE_INTERRUPTS();</span><br><span class="line"><span class="keyword">return</span> rtval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遇到的困难与学到的经验"><a href="#遇到的困难与学到的经验" class="headerlink" title="遇到的困难与学到的经验"></a>遇到的困难与学到的经验</h3><ul><li><p>编译关系复杂，各种头文件相互包含导致类型重定义或者定义冲突</p><ul><li>理清编译关系，在项目之前做好文件规划，划分各文件的职责</li><li>注意头文件引用顺序</li><li>待补充</li></ul></li><li><p>Keil编译器有问题，有时候类型符合的赋值编译器不通过，必须类型强转才可编译通过。再或者，虽然已经定义了条件编译但还是对循环引用的头文件报错，这时就需要考虑编译器的问题了，Keil失效的通常的现象和解决办法：</p><ul><li>一般出现编译器问题的条件是：当一个错误卡住了很长时间，并且确定这段代码没有错误，而且当按照编译器的提示将这段代码彻底的进行修改后会爆出更多error，这时就可以考虑是编译器的问题了</li><li>![2024-01-05_22-35](vx_images&#x2F;548533722266605.png &#x3D;600x)</li><li>![2024-01-05_22-36](vx_images&#x2F;278363822259274.png &#x3D;600x)</li><li>![2024-01-05_22-37](vx_images&#x2F;341003822255829.png &#x3D;600x)</li><li>![2024-01-05_22-33](vx_images&#x2F;129063322246439.png &#x3D;300x)</li><li>所有可能的解决办法都失效了，可以考虑是Keil的问题</li><li>待补充</li></ul></li></ul><p>::: alert-danger   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">prvIdleTask</span><span class="params">( <span class="type">void</span> *p_arg )</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 永远不要在空闲任务里加入阻塞或者死循环！！！！！！！！！！！！！！！</span></span><br><span class="line"><span class="comment">否则当其他任务优先级为0时，空闲任务会霸占整个时间片(没有设置时间片流转和抢占式调度的话)*/</span></span><br><span class="line"><span class="comment">//for( ;; )</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//flagIdle = 1;</span></span><br><span class="line"><span class="comment">//flag1 = 0;</span></span><br><span class="line"><span class="comment">//flag2 = 0;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">因为在第十章已经实现支持多优先级了，且Task1，Task2优先级均大于<span class="number">0</span>，因此此时空闲任务内可以加循环</span><br><span class="line">:::    </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">* 遇到调不出来的Bug不要怕，解决方法如下</span><br><span class="line">    * 保持一个清醒的状态</span><br><span class="line">    * 快速定位问题的大概位置</span><br><span class="line">    * 在Bug大概位置处**逐步**调试</span><br><span class="line">    </span><br><span class="line">```c</span><br><span class="line"><span class="type">void</span> <span class="title function_">tickconst</span><span class="params">(<span class="type">int</span> tick)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> consttick = tick;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,consttick);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void tickstatic(int tick)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     static int statictick = tick;//static不能被变量赋值</span></span><br><span class="line"><span class="comment">//     printf(&quot;%d\n&quot;,statictick);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tickconst(i);<span class="comment">//const的值可以在定义的时候被修改，但不能在其他地方被修改，也就是说，const可以被变量赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">在时基函数调用时会用到</span><br><span class="line">![<span class="number">2024</span><span class="number">-01</span><span class="number">-11</span>_19<span class="number">-53</span>](vx_images/<span class="number">350415319240152.</span>png =<span class="number">600</span>x)  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//宏定义地址交换会修改值，这是因为函数宏定义不会产生栈</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swapdef(addra,addrb)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">    int *temp;\</span></span><br><span class="line"><span class="meta">    temp = a;\</span></span><br><span class="line"><span class="meta">    a = b;\</span></span><br><span class="line"><span class="meta">    b = temp;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//地址交换不会修改值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swapadd</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swapnum</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原值=%d %d\n&quot;</span>,a,b);</span><br><span class="line">    swapdef(&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;宏地址交换=%d %d\n&quot;</span>,a,b);</span><br><span class="line">    swapadd(&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;函数地址交换=%d %d\n&quot;</span>,a,b);</span><br><span class="line">    swapnum(&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;指针地址解引用交换=%d %d\n&quot;</span>,a,b);</span><br><span class="line">    a = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![2024-01-11_20-48](vx_images&#x2F;175724820240152.png &#x3D;600x)    </p><p>:::alert-info<br>堆栈太小可能会导致程序停止在HardFault<br>:::</p><h4 id="int-array-20-与-int-arrary-20-的不同"><a href="#int-array-20-与-int-arrary-20-的不同" class="headerlink" title="int (*array)[20] 与 int *arrary[20]的不同"></a>int (*array)[20] 与 int *arrary[20]的不同</h4><p>前者代表一个指向具有20个整型元素数组的<strong>指针</strong>，后者代表一个具有20个指针元素的<strong>数组</strong></p><h4 id="宏定义函数"><a href="#宏定义函数" class="headerlink" title="宏定义函数"></a>宏定义函数</h4><ul><li>为什么要使用宏定义函数？<ul><li>宏定义函数可以在预编译阶段直接展开，省下了压栈出栈的资源</li><li>那他与内联函数的区别是什么？<ul><li>宏定义函数只做展开和替换，不检查参数类型。而内联函数需要检查参数类型</li></ul></li></ul></li></ul><h4 id="C99特性"><a href="#C99特性" class="headerlink" title="C99特性"></a>C99特性</h4><p>在keil中可以在“魔术棒”的C&#x2F;C++设置C99模式，指定后可以在<strong>非全局</strong>作用域下定义不定长数组  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ListNum 5<span class="comment">//只能使用宏定义，变量赋值也不行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ItemNum 10</span></span><br><span class="line"><span class="comment">/* 不能在全局作用域下定义，同时也不能加static关键字 */</span></span><br><span class="line"><span class="type">int</span> arr[ListNum][ItemNum];</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">#### 不允许使用<span class="type">void</span>数组  </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="type">void</span> arr[<span class="number">20</span>];<span class="comment">//非法定义，因为无法知道开辟空间的大小</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;项目&quot;&gt;&lt;a href=&quot;#项目&quot; class=&quot;headerlink&quot; title=&quot;项目&quot;&gt;&lt;/a&gt;项目&lt;/h1&gt;&lt;h2 id=&quot;FreeRTOS内核实现&quot;&gt;&lt;a href=&quot;#FreeRTOS内核实现&quot; class=&quot;headerlink&quot; title=&quot;F</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vim复健计划</title>
    <link href="https://wumingzi.top/2024/01/23/Vim%E5%A4%8D%E5%81%A5%E8%AE%A1%E5%88%92/"/>
    <id>https://wumingzi.top/2024/01/23/Vim%E5%A4%8D%E5%81%A5%E8%AE%A1%E5%88%92/</id>
    <published>2024-01-23T03:30:45.000Z</published>
    <updated>2024-01-23T03:30:45.794Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>STM32</title>
    <link href="https://wumingzi.top/2024/01/23/STM32/"/>
    <id>https://wumingzi.top/2024/01/23/STM32/</id>
    <published>2024-01-23T03:29:58.000Z</published>
    <updated>2024-01-23T03:29:58.718Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>C复健计划</title>
    <link href="https://wumingzi.top/2024/01/23/C%E5%A4%8D%E5%81%A5%E8%AE%A1%E5%88%92/"/>
    <id>https://wumingzi.top/2024/01/23/C%E5%A4%8D%E5%81%A5%E8%AE%A1%E5%88%92/</id>
    <published>2024-01-23T02:53:06.000Z</published>
    <updated>2024-01-23T03:19:41.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C复健计划"><a href="#C复健计划" class="headerlink" title="C复健计划"></a>C复健计划</h1><p>printf函数无法打印多行字符串，若要打印多行字符串则需要在每行后加换行符\n<br>\n代表换行，\n\代表下一行是上一行的延续，如果改为\n则会报错<br>变量名第一个字母不能是数字<br>ANSI C C99 C11 关键字数量分别是32 32+5 37+7<br>%11.2f代表输出11个占位符，其中浮点型输出到小数点后2位，如果%a.bf，其中b比a大，则直接输出到小数点后b位而忽略a的值<br>%x: 十六进制 (hex) %o: 八进制(oct) %d: 十进制(dec)  </p><span id="more"></span><p><img src="/images/581673908249386.png" alt="2023-09-19_08-38"><br><img src="/images/90294008237253.png" alt="2023-09-19_08-39"><br>&quot;   代表 “   \ 代表 \<br>&#x2F;*    *&#x2F;代表多行注释<br>&lt;&gt;表示导入系统文件  “”表示导入自定义文件&#96;<br>Tab &#x3D;&#x3D; 8个空格，或者4个空格</p><p>编译分为四步</p><ol><li>预编译：宏定义展开，头文件展开，条件编译等，并将注释删除（条件编译是指根据系统位数，编译库的选择确定编译环境）</li><li>编译：将预编译后的文件生成汇编文件</li><li>汇编：将汇编文件生成为目标文件（二进制代码）</li><li>链接：把库链接到可执行程序中（预编译只是说明函数格式）</li></ol><p><img src="/images/499670009249389.png" alt="2023-09-22_08-5949"><br>float 默认保留六位小数，%.2 表示保留小数点后两位（四舍五入）<br>常量定义方法：（不能对值进行修改）<br>const 数据类型 常量名 &#x3D; 值 或 数据类型 const 常量名 &#x3D; 值 ( 在函数中定义的常量不安全，而全局常量则安全 )<br># define 常量名 值<br>第一种不安全，利用指针可以修改 const 定义的值<br>十六进制用 0x 开头 八进制用 0 开头 C不支持定义二进制数<br>有符号数最高位是符号位，0 代表正数，1 代表负数<br>scanf(“%d”,&amp;a); 不要加\n<br>%hd 短整型 %p 输出指针的地址<br>char ‘单个字母’ 此时 %c 打印字母 %d 打印ASC2码<br>%c 对应的变量如果是整型，则输出ASC2码所对的字符<br>0 的ASC2码是 48 A 65 a 97 小写字母 - 大写字母 &#x3D;&#x3D; 32<br>科学计数法赋值: float a &#x3D; 3.2e3     //3.2*1000<br>%e 以科学计数法表示数字<br>WORD 双字节 16bit   DWORD (double word) 32bit<br><img src="/images/342723609249394.png" alt="2023-09-27_09-3508"><br>正数: 原码 &#x3D;&#x3D; 反码 &#x3D;&#x3D; 补码<br>负数: 反码 &#x3D;&#x3D; 原码除符号位取反        补码 &#x3D;&#x3D; 反码 + 1 (若最高位进位，则进位舍弃)<br>数据存储时，把 -0 定为区间最小值:  1111 1111 (-127) 1000 0000 (-128) 对于8bit数据，取值范围是: 2^7-1 ~ -2^7<br>%s 输出一个字符串，遇到\0停止<br>\0 代表字符串的结尾 printf(“hello\0 word\n”); 输出的只有hello<br>scanf(“%d,%d”,&amp;a,&amp;b);  键盘输入的时候应严格双引号中的格式输入，只能输入 整数，整数 不能输入 整数 整数 或其它格式。<br>putchar getchar 只能对单个字符进行操作<br><img src="/images/54091209249391.png" alt="2023-09-23_16-2638"><br><img src="/images/248901309257424.png" alt="2023-09-23_16-2611"><br><img src="/images/227301209237258.png" alt="2023-09-23_16-5554"><br><img src="/images/543921309250093.png" alt="2023-09-23_17-2827"><br><img src="/images/48801409246648.png" alt="2023-09-23_17-3207"><br>所有非 0 的值都是真值<br>C语言浮点型数据不能取余<br>单目运算符优先级高于双目运算符<br>int a &#x3D; 10; int b &#x3D; 20;  则 a &amp;&amp; b &#x3D;&#x3D; 1<br><img src="/images/259954510230966.png" alt="2023-09-25_10-4453"><br>强制类型转换不考虑四舍五入，后果是损失精度，系统自动类型转换时也会损失精度<br>(int) a*b 是先将 a,b 损失精度，再计算结果  (int) (a*b)是先保留精度计算，再损失精度<br>表达式 ? 语句1 : 语句2  表达式为真，执行语句1，否则执行语句2<br>switch 中可加 default 并且 case 后要接 break<br>for 循环可以有多个判断代码，需用 , 隔开，只要一个表达式不满足就跳出循环<br>goto FLAG;  ………… FLAG: …………<br>数组下标必须是常量，不能写为下例：int i &#x3D; 10;  int arr[i];<br>当一个数组初始化（开辟内存空间）时，内部元素默认是乱码。只有当赋值时，默认才是0<br>eg： int arr[4] &#x3D; {1}; &#x2F;&#x2F;内部元素：1,0,0,0  int arr[4]; arr[0] &#x3D; 1; &#x2F;&#x2F;内部元素：1,数字,数字,数字<br>数字 0 等同于 \0 但不等同于字符 ‘0’<br>char arr[] &#x3D; “hello”; 此时arr数组共有6位（最后一位是\0）<br>char arr[5] &#x3D; {‘h’,’e’,’l’,’l’,’o’}; 此时只有六位，打印的时候到 o 不会停止，会继续打印乱码，所以char arr[n]的数组只能存储n-1个字符<br>scanf接收到空格或回车就代表接收的结束<br>gets() 与 scanf() 的区别是，get 能接收空格，scanf 则不能<br>sizeof() 测量字符串数组长度时包括 &#x2F;0 strlen() 则不包括<br>函数返回值传给寄存器后内存中的函数会被销毁<br>函数声明: extern int fun_name( type a, type b );   &#x3D;&#x3D;   int fun_name( type a, type b );    &#x3D;&#x3D;     int fun_name( type , type  ); 可以不用写在主函数之内<br>声明不需要内存<br>exit(); 在子函数中使用主函数也会退出<br>导入自己的头文件用 “myfile.h”<br>#ifndef “myfile.h” #define    文件名    #endif<br>char 占1个字节分配1个地址    int 占4个字节分配4个地址<br>win 存储方式是小端对齐 即 低位数据存在低位地址中<br>&amp; 是取址符号，是升维的    * 是取值符号，是降维<br>野指针:    指向某一个未知空间的指针变量<br>int const *p &#x3D;&#x3D; const int* p  只能给 p 赋值，不能给 p 指向的变量赋值 因为 const 离 “*”近</p><p>int* const p 只能给 p 指向的变量赋值，不能给 p 赋值，因为 const 离 “p” 近<br>指针 +1 &#x3D;&#x3D; 内存地址 +(sizeof(type 指针))<br>数组做为函数参数时会退化为指针，损失数组的大小信息，所以需要额外的数组长度做为函数参数<br>p[-2] 等于当前指向某一数组的指针 p 向前数2个的那个元素<br>2个指针相减后的结果是步长，不能相加<br>int* arr[3]    指针数组<br>arr[i] &#x3D;&#x3D; *(arr+i)<br>一级指针加偏移量相当于跳过元素，二级指针加偏移量相当于跳过一维数组<br><img src="/images/150863710249470.png" alt="2023-09-27_18-0028"><br><img src="/images/293363710237337.png" alt="2023-09-27_18-0047"><br><img src="/images/58503810257503.png" alt="2023-10-01_12-4448"><br><img src="/images/196183810250172.png" alt="2023-10-03_10-1645"><br><img src="/images/292473810246727.png" alt="2023-10-03_10-2054"><br><img src="/images/488983810242481.png" alt="2023-10-03_10-3451"><br> ‘ 字母 ‘ 代表字母的ASCII码值，并可以用 %c 输出其值<br> while 是先判断后执行<br><img src="/images/194092820260361.png" alt="2023-10-03_20-2457"><br>主函数是程序的入口，是程序首先执行的函数<br>全局变量作用域 : 整个项目的所有文件，其他文件调用时需要声明 extern int a; 生命周期是从程序创建到程序销毁<br>全局变量可以与局部变量重名，调用时程序采用就近原则的方法<br>静态局部变量在数据区存储，只会初始化一次并且发生在函数创建前，作用域 : 函数内部 生命周期 : 从程序创建到销毁 ( 作用域与局部变量一样，生命周期与全局变量一样 )<br>静态全局变量作用域 : 只可在本文件中使用，但不能在其他文件中使用，生命周期 : 从程序创建到程序结束<br><img src="/images/78774614231048.png" alt="2023-10-07_14-4543"><br><img src="/images/117464714237341.png" alt="2023-10-07_13-5845"><br>定义函数默认是全局的，可以在其他文件中调用，静态函数只能在本文件中使用，即使在其他文件中声明也不能使用<br>即使没有声明也可以调用函数，但是在 vstudio 转到定义功能不能使用<br>静态函数可以和全局函数重名<br>malloc 开辟的是连续的堆空间<br><img src="/images/194954608231049.png" alt="2023-10-07_15-0913"><br><img src="/images/383464808257508.png" alt="2023-10-07_16-4537"><br><img src="/images/3774908250177.png" alt="2023-10-07_16-4817"><br><img src="/images/252204908246732.png" alt="2023-10-07_16-5929"><br><img src="/images/380904908242486.png" alt="2023-10-07_17-2152"><br>栈由高地址向低地址增长，栈底是第一个进栈的数据，栈顶就是最后一个进栈的数据。<br><img src="/images/238732719249475.png" alt="2023-10-08_19-2651"><br>同理，申请0字节的空间也会报上述错误<br><img src="/images/94153019237342.png" alt="2023-10-08_19-2937"><br>下图报错原因是对 NULL 指针进行赋值操作。本质上由于68行函数开辟了一个堆空间同时创建形参p，在申请10个int大小的空间后fun08就被销毁了，同时销毁的还有形参p。相当于68行是废语句<br><img src="/images/563595319257508.png" alt="2023-10-08_19-5338"><br>free 空指针不会报错<br>结构体成员大小按最大结构体成员的倍数取，，下图中， char name 的大小为 21( sizeof(name) &#x3D;&#x3D;21 )，但是偏移对齐过后为24 ( int的整数倍 )<br><img src="/images/519123611231050.png" alt="2023-10-09_11-3636"><br>typedef 类型名 别名;<br>struct 结构体类型名 {};    struct 结构体类型名 结构体名 &#x3D; {}；&#x2F;&#x2F;注意{}中的变量用 ; 隔开<br>结构体指针 -&gt; 成员    结构体变量 . 成员<br>联合体 union 所有数据共用一块内存空间，只能输出最后一次被赋值的成员<br><img src="/images/14900717249476.png" alt="2023-10-09_16-5317"><br>文件操作中的分隔符推荐以 &#x2F; 正斜杠表示，如果是反斜杠，则需要输入两次<br>读取文件若干个字符时不能修改文件指针，文件在读取时指针会自动向下加 1<br>文件默认结尾是 -1 和 EOF<br><img src="/images/7011213231052.png" alt="2023-10-11_13-1126"><br>结构变量名不是地址<br>for函数条件用 ; 隔开<br>可以将枚举值赋给其他变量<br>define 只做替换，所以不加 ; 否则会出现 #define NUM  3; printf(“%d”,3;);<br>退出函数后，static的变量不会被销毁，仍然保留在静态区内，但是此变量只能在本函数内部使用<br>define 在预处理阶段有效，仅作字符串替换，typedef 在编译阶段有效，因此会做类型检查<br>&amp;&amp;: 逻辑与    &amp;: 按位与    || : 逻辑或    | : 按位或<br>左移丢弃符号位，右移补偿符号位<br>数字前面补零编译器会认为是八进制数字，因此数字为09时编译器会报错<br><img src="/images/61053117237537.png" alt="2023-12-03_17-2714"><br><a href="http://jeremybai.github.io/blog/2014/01/01/const-volatile">博客链接</a><br>volatile用法：如果开启了编译器优化，或者利用无意义加减变量进行其他工作，亦或者多线程编程，读写与硬件相关的存储器时，需要加volatile关键字，防止编译器优化并提示编译器注意一致性问题，使其每次使用变量时都要去内存中取值。  </p><ul><li><p>一个参数既可以是const又可以是volatile么？</p><ul><li>const volatile常用在对于状态寄存器重新读取数值的时候，因为状态寄存器的值易变，因此加volatile，因为程序不应该修改状态寄存器的值，因此为const</li></ul></li><li><p>一个指针可以是volatile的么？</p><ul><li>可以但不常见，当需要一个经常被修改的指针时需要这么做，比如在中断子程序中修改的buffer指针</li></ul></li></ul><p><a href="https://blog.csdn.net/wujiangguizhen/article/details/10244627">上述答案详解</a>  </p><p>SRAM没有电容结构，因此充放电比DRAM快，读取数据也就比DRAM快，并且也不需要刷新数据<br>需要使用malloc来申请结构体的情况: </p><ol><li>结构体大小需要动态分配(结构体内包含本身的指针)</li><li>结构体生命周期较长，需要在函数结束时不销毁结构体时需要</li><li>对性能要求不大，在栈上分配和释放内存通常比堆上快，对性能不做要求时可以使用malloc<br>即使在函数参数给出了const限定，但是依然有变量被更改的风险<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>* <span class="type">const</span> a,<span class="type">int</span>* <span class="type">const</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* temp1 = a;</span><br><span class="line">    <span class="type">int</span>* temp2 = b;</span><br><span class="line">    *temp1 = <span class="number">6</span>;</span><br><span class="line">    *temp2 = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> *a+*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> c = add(&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>::: alert-danger<br>结果是10<br>:::<br><img src="/images/65104211231269.png" alt="2023-12-28_11-40"><br>对新生成的链表进行操作时，注意新生成的链表的内存是否是malloc动态分配的，否则会出现Segmentation fault(为啥啊？)<br>define定义宏的时候不用括号括起来可能导致运算错误<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 3+2</span></span><br><span class="line"><span class="type">int</span> a = N*N; <span class="comment">//a = 3+2*3+2</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;C复健计划&quot;&gt;&lt;a href=&quot;#C复健计划&quot; class=&quot;headerlink&quot; title=&quot;C复健计划&quot;&gt;&lt;/a&gt;C复健计划&lt;/h1&gt;&lt;p&gt;printf函数无法打印多行字符串，若要打印多行字符串则需要在每行后加换行符\n&lt;br&gt;\n代表换行，\n\代表下一行是上一行的延续，如果改为\n则会报错&lt;br&gt;变量名第一个字母不能是数字&lt;br&gt;ANSI C C99 C11 关键字数量分别是32 32+5 37+7&lt;br&gt;%11.2f代表输出11个占位符，其中浮点型输出到小数点后2位，如果%a.bf，其中b比a大，则直接输出到小数点后b位而忽略a的值&lt;br&gt;%x: 十六进制 (hex) %o: 八进制(oct) %d: 十进制(dec)  &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wumingzi.top/2023/10/13/hello-world/"/>
    <id>https://wumingzi.top/2023/10/13/hello-world/</id>
    <published>2023-10-13T05:36:44.069Z</published>
    <updated>2023-01-29T09:24:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.  </p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.  &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>百年工业</title>
    <link href="https://wumingzi.top/2023/02/07/%E7%99%BE%E5%B9%B4%E5%B7%A5%E4%B8%9A/"/>
    <id>https://wumingzi.top/2023/02/07/%E7%99%BE%E5%B9%B4%E5%B7%A5%E4%B8%9A/</id>
    <published>2023-02-07T06:47:09.000Z</published>
    <updated>2023-02-07T07:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="百年激荡"><a href="#百年激荡" class="headerlink" title="百年激荡"></a>百年激荡</h1><blockquote><p> <font size = 5>资本主义 100 年所创造的物质财富超过了以往一切时代的总和   </p><p align="right" > <font size = 4>—— 卡尔·马克思 </font> </p></font>  </blockquote><span id="more"></span><h2 id="前工业时代"><a href="#前工业时代" class="headerlink" title="前工业时代"></a>前工业时代</h2><p>为了阐述工业体系的奇特之处，我们必须回到广义的工业革命之前，也就是大概1600~1700年。尽管距离珍妮机的出现还有一段不短的时间，但在历史上的科技进步思潮来说，这一段时间，世界发展模式发生了重大变化。欧洲从黑暗的中世纪走了出来，攫取着五大洲的财富，美洲正在开荒，东亚的明王朝余威尚在，南亚印度莫卧儿王朝虽然即将走向分裂，但尚可维持统一，中东的奥斯曼帝国如日中天。更重要的是，对于后世影响极为深刻的发明发现在此时涌现。需要强调的是，这些发明发现连接了人类农业时代与工业时代，沟通了人类的理性认识与感性认识，尽管在不同地区这些特点有所不同，但不可否认的是这一段时间是人类进入定居农耕后绝无仅有的经历。就我个人观点而言，这一段时期的重要性甚至超过了由铜器时代发展到铁器时代的重要性，是仅次于工业革命的辉煌时期。下面列举几例这期间的科技爆点：          </p><ul><li>1596年中国李时珍《本草纲目》</li><li>1637年中国宋应星《天工开物》，同年法国笛卡尔创立解析几何.</li><li>1639年中国徐光启《农政全书》</li><li>1643年意大利托里拆利发现了大气压，11年后马德堡半球公开实验</li><li>1653年法国帕斯卡发现帕斯卡定律</li><li>1661年英国玻义耳提出元素定义,把化学确立为科学</li><li>1665年英国胡克首次用显微镜观察植物细胞</li><li>1670s年牛顿和莱布尼茨分别创立微积分</li><li>1676年丹麦勒麦证明光以有限速度传播</li><li>1676年法国马略特发现气体的玻义耳-马略特定律</li><li>1703年德国施塔尔将燃素说系统化</li><li>1712年英国纽可门制成第一架实用蒸汽机</li></ul><h3 id="前工业时代科技发明发现的特点"><a href="#前工业时代科技发明发现的特点" class="headerlink" title="前工业时代科技发明发现的特点"></a>前工业时代科技发明发现的特点</h3><ol><li>这些发明发现大多是全面性的，总结性的知识或者思想前卫的理论的非直接应用于生产性质的。</li><li>这些发明发现是农业时代的集大成之作，也是工业时代的先导。</li><li>这些发明发现彼此关联不大，即使有关联的因果关系也不明朗，甚至出现实际应用早于理论提出的现象。</li><li>这些发明发现最主要出现在东亚和欧洲，且两个地区的发明发现有着迥然不同的特点。而南亚次大陆，伊斯兰传统地区以及中亚的发明发现则很少，北非以南基本没有。</li><li>这些发明发现集中涌现，频度广度超过了此前任何时代。</li></ol><h3 id="相关特点的解释"><a href="#相关特点的解释" class="headerlink" title="相关特点的解释"></a>相关特点的解释</h3><p>工业革命之前人类首先要满足自己的生存需要，对于事物内在的联系和特点则不太关心，对其有深入研究的多是在社会中占据统治地位的人，他们占据了劳动产品的大多数，少数对事物发展原理有浓厚兴趣的人就成了古典的哲学家和博物学家。受限于知识经验的匮乏，他们的研究多是广博而不深入的，形成的知识经验体系也是框架式的指导性的哲学，所以不能产出深刻的本质理论且难以运用于生产。尽管研究的不彻底，但相关研究的基础是农业时代积攒千年的经验知识。因此，这种工业革命前期的研究具有全面性先导性的特点，且那时人们对庞大的农业手工业知识需要梳理，而因受战争瘟疫影响下人均资源较为丰富的社会环境也有助于人类科技的进一步发展，这两点就导致了发明发现的集中涌现。此时的农业时代的生产力远非之前各种时代所能比的，这样，各种发明发现出现如此的烈度也就不奇怪了。可理论不深刻的后果就是这些发明发现彼此是孤立的，那些这些哲学家和博物学家并没有发现他们之间的内在联系。当时的手工匠人还是依靠经验进行生产，比如，在制糖业中，搅糖师傅要依靠眼力和手感判断出糖的时机，烧火的师傅需要用皮肤和眼睛感受火炉温度的变化，尽管在随后的工业化进程中出现了专职搅拌蔗液的机器来取代制糖师傅，还有仅靠训练几天就看懂温度计的童工来取代烧火师傅，但是此时的生产还是应用高于理论，人们对温度，工艺经验和定量考察的联系认识不足。直有到了第二次工业革命科学家工程师群体才成为推进世界生产技术进步的重要力量，在此之前，成为一名手工匠人依然是普通人最好的出路。从农业社会的历史角度来看，传统的强势农业政权一共有三处，分别是位于地中海沿岸的欧洲，位于两河流域的中东以及地理位置较为封闭的东亚与南亚。其他的地区如中亚或者印度周围强敌环伺，不仅面临传统农业强权的竞争压力还面临着北方骑兵的威胁。对于中东来说，奥斯曼帝国建立后占据着东亚与欧洲沟通的必经之路，这时以国家的名义收过路费显然是收益率最高的方式。于是，本来可以凭借亚欧路上沟通进而搭上工业革命的浪潮的中东终于在欧洲人发现新航线之后落后了，而东亚和南亚本来作为新航线的目的地的打算也在哥伦布误打误撞的发现新大陆的现实下消失，在美洲种植甘蔗和香料远比亚洲容易得多，自此，中国和欧洲的科技模式发生了变化，彼此走向了不同的发展道路。  </p><h2 id="机器时代"><a href="#机器时代" class="headerlink" title="机器时代"></a>机器时代</h2><h3 id="世界背景"><a href="#世界背景" class="headerlink" title="世界背景"></a>世界背景</h3><p>上述的发明发现彼此孤立，倘若没有煤铁，没有自迭代的加工技术的话我们大概率还会停留在比较发达的农业社会，经历着几百年的农业周期。但是，人类运气比较好，自从蒙古铁蹄踏破了亚欧大陆后，蒙古人带来了战争和瘟疫，也同时带来科技与生机。瘟疫战乱使欧洲的人口快速减少，破坏了传统基督文化削弱了教会势力。蒙古势力阻碍中欧交流的同时迫使西方开启大航海时代，间接促进了新大陆的发现。而传统教会势力的孱弱也给了文艺复兴一个绝佳的机会。 这样，绵延百年的战乱瘟疫所导致的中西欧劳动力匮乏与宗教势力的削弱，迫使了新科学的出现，新技术的应用以及新航线新大陆的发现。至此，一个空前的农业周期出现在欧洲，无尽的白银香料糖流入欧洲再流向中国。同时输入性通胀带来的无尽财富使得明政权不思进取，由外部环境导致的内部压力导致了千年来最严格的海禁，这更为欧洲带来了绝佳的机会，此时南亚的莫卧儿王朝也处在分裂中，这里有无限的劳动力和市场等着欧洲来攫取。随着航海时代的来临，荷兰由于其独特的国家模式，迅速的成为一支不可忽视的力量。在荷兰霸权的后期仍然可以组建一支14万人的雇佣兵部队与法国作战，而这时是1687年。但荷兰的霸权是必然的，原因有很多，例如过度投机的国家模式，狭小的国土与过少的人口。无论怎样，荷兰霸权不会永远持续下去，获胜者不管是英国法国还是普鲁士，这都不影响接下来发生的事。  </p><h3 id="煤，铁和布"><a href="#煤，铁和布" class="headerlink" title="煤，铁和布"></a>煤，铁和布</h3><p>早期的工业是分工细化的手工业，例如玻璃作坊有专职烧火的，专职制作玻璃液的，专职吹制玻璃的，纺织工场有专职煮棉的，专职纺线的，专职织布的。在手工业中，最枯燥，最耗费劳动力的莫非纺线和织布。早在珍妮机之前，英国人也在改良生产工具，但是珍妮机及其改进型的效率使得它的前辈都相形见绌。  </p><p>对劳动力渴望的还有煤矿，自古以来，下矿都是一件极其耗费心力体力的事，劳动强度大，死亡率高。在奴隶制时代，也只有奴隶才下矿井，封建时代，就只有卖身奴，契约奴和战俘和囚犯才干这事。人们对煤的需求并不是天生的，但早期农业的燃料获取和战乱破坏了地表植被，人们不得不寻求更廉价更以获取的燃料来源。冶铁业比较发达的国家需要各种炭类来提供普通燃料达不到的高温，但是开采煤矿经常伴随渗水，一旦地下的含水层被打破，排水问题始终难以解决。在蒸汽机出现之前一般靠人力或者畜力运用机械排水，效率低耗时长。在纽可门发明第一台实用化的蒸汽机之后，排水的问题便被解决了。在此强调一点<strong>蒸汽机的材料是铁，燃料是煤，工质是水</strong>。但是这种类型的蒸汽机效率很低，但是无所谓，有了需求总会有人改进的。  </p><p>煤矿里的另一个问题是运力。煤矿多于山上，道路崎岖运煤困难，早期的解决方案是用硬木做成木轨，马拉货车运煤。但是这种方式运力低下费用高昂：在机器时代马还是昂贵的牲畜。解决这一问题的是瓦特，尽管瓦特并没有做出蒸汽机车，但最早的蒸汽机车结构就是把瓦特的蒸汽机小型化搬上了轨道车。此时是1804年。这样，由煤（需要排水） — 铁（需要高温） — 机械加工技术 — 蒸汽机（需要能源和工质） — 煤（需要排水）   的工业循环就初步形成了。</p><p>但是这时的工业爆发还缺少一个临门一脚的条件 — 那就是能够发展上述循环的自迭代的功能。如果没有这个条件的话，这次的技术爆炸可能在人类历史上只不过是一轮非常不错的农业周期，最终农业政权还是会走向分裂，战争，导致人口减少，然后再次重启一个新的周期。然而这个条件是人类走向那时那刻的必要条件，没有它，人类绝不会造出蒸汽机，绝不会改进纺织机，也绝不会把荷兰拉下海上霸主的地位而这个条件就是以机床为代表的机械制造技术和熟练工人。蒸汽机的核心部件是气缸，要想做出不漏气又可滑移的气缸需要足够精密的机械加工技术。为了提高蒸汽机效率需要提高缸内气压，这又进一步对加工技术和材料提出了更高的要求，从而促进了发现品质更好的煤铁矿，改进更优良的工艺。此外，机床的制造也需要更精密的加工技术更优良的材料和更优秀的工人。    </p><p>至此，煤（需要排水） — 铁（需要高温） — 机床（能够自迭代） — 蒸汽机（需要能源和工质） — 煤（需要排水） 的循环已经进化为 更多更好的煤（需要排水） — 更优质的铁（需要高温） — 更精密的机床（能够自迭代） — 性能更好的蒸汽机（需要能源和工质） — 比循环之初还要更多更好的煤（需要排水）。现在只要有一个动力让这个循环持续下去那么工业革命就到来了。那么是什么推动了这个循环呢？—— 是利润。    </p><p>其实推动工业循环可以不是利润，例如初期的苏联采用了指令式的计划经济，那时推动工业循环的是忍受统治压力和竞争压力的技术官僚所推动的。但是在此时的欧洲，资本主义的奴隶贸易风头无两，因此相对于保守的封建主义，发展工业最成熟的工具只剩下资本主义了。利润的条件一旦满足，无论是何种产业，只要利用上述三个条件这个循环就会永无止境的运动下去。最早担当这一重任的产业是纺织和远洋物流。首先说纺织，上文提到，纺织业需要大量劳动力纺线织布，而有了瓦特蒸汽机车作为动力源，珍妮机便织出了巨量财富。又密又匀的机器布远非手工布所能比的。这样，依靠着全球殖民体系，在几十年的时间内英国机械纺织业便打垮了印度持续千年的繁荣手工纺织业。对于远洋物流来说，最早的动力是人力以及风力，而有了蒸汽机之后，船舶的航速航程便极大的提高，更重要的是在逆风条件下的船速稳定性也会显著提高，这不仅提高了民用货船的运输效率，而且还提高了海军和海盗的机动力。于是，物质信息流转速度显著提高，资本周转速度，利润积累速度显著变快，世界被更紧密的连接在了一起。进一步，由机器产生的更多的利润被用来扩大再生产，产生出比原来多得多的利润被再次用于投资，工业体系迎来了指数级别的增长。  </p><p>第一次工业革命爆发了。  </p><h3 id="工业革命的代价"><a href="#工业革命的代价" class="headerlink" title="工业革命的代价"></a>工业革命的代价</h3><p>任何有利事物都有其相反面，这种相反面总给人类不利因素，这就是代价。工业革命作为人类历史上最为重大的事件，极大地便利了民众生活的同时也带来了极其惨痛的代价。欧洲人做梦也想不到，在爆发了两次工业革命的土地上竟然戏剧性的爆发了两次世界大战，在付出了上亿人生命之后把世界霸主的地位送给了美国，并且几乎是错失了第四次工业革命。除了战争外，在工业革命的早期，环境的破坏以及工作环境的恶化甚至让普通民众生活水平还不如农业时代，资本原始积累带来巨大的贫富差距，不合理的城市化政策让数以万计的贫民死于火灾和空气污染，频繁的经贸摩擦带来的政治甚至军事摩擦也为民族主义和世界大战埋下伏笔。    </p><h2 id="电气时代"><a href="#电气时代" class="headerlink" title="电气时代"></a>电气时代</h2><h3 id="世界背景-1"><a href="#世界背景-1" class="headerlink" title="世界背景"></a>世界背景</h3><p>电气革命的源头实际上与机器革命爆发是同一时期的，早在1746年莱茵瓶就诞生了，而在1780年伽伐尼发现的电流更激起科学界的极大兴趣。直到1799年伏特堆诞生，真正意义上的的电力时代开启了。此时工业革命的先发地正处于增长的狂欢中，百年的殖民历程和数十年的工业积累让日不落帝国的赫赫威名响彻全球。但是第二次工业革命首先爆发在德国和美国。早在一战前，德国就已经完成了工业化的整合，凭借着优越的煤铁矿，德国在鲁尔区整合成了欧洲最大的煤钢联合企业，美国由于其得天独厚的自然资源和地理优势以及百年建设，在一战前建成了世界最大的工业国。同时，渴望劳动力与市场的为代表的同盟国与已瓜分完毕现存殖民地的协约国有着结构性矛盾，这一矛盾直接导致了一战的爆发。  </p><h3 id="电气设备，内燃机及化学工程与科研人员"><a href="#电气设备，内燃机及化学工程与科研人员" class="headerlink" title="电气设备，内燃机及化学工程与科研人员"></a>电气设备，内燃机及化学工程与科研人员</h3><p>第二次工业革命与上一次形式相同而内容不同。上一次工业革命的是以 蒸汽机 — 煤铁复合体 — 机床 — 蒸汽机 为循环的，这次是以 电气设备&#x2F;内燃机 — 石油&#x2F;电气寡头 — 机床 — 科学家 — 电气设备&#x2F;内燃机 为循环的。这一循环比第一次周转更快，技术水平更高，初步展现了工业体系的复杂。    </p><p>其中电气设备&#x2F;内燃机为工业循环提供动力，电机的出现使得世界能源格局出现重大调整，人们不必以煤矿为中心建设经济，这直接导致之后的传统工业区衰落。实际上，这种能源格局的调整相比当时重要的电气发明并没有多么立竿见影，把电气设备抬上第二次工业革命宝座的是电子通讯设备。在电子通讯设备出现之前，人类传递信息的能力与传递宏观物质的能力是一样的，除了少部分用生物，光学等耗资巨大且消息传递不准确的途径外人类再也找不出其他更快速更准确的信息传递方式了。但是自从1837年电报诞生后，人类沟通全世界的雄心与日俱增。在仅仅11年后，世界第一条海底电缆横空出世，又过了8年，世界第一条跨洋电缆完工，而此时是1858年，距离我们熟知的近代史开端仅仅过去了18年。</p><p>19世纪中叶就有了内燃机的设想，只不过当时充当燃料的是煤气。随着石化工业的发展，一种在原油中占比巨大的燃料进入了人们的视野。早期机械工艺能力不过关，而汽油机结构复杂，因而第一台实用化的内燃机是用于发电和船用的结构简单的大型柴油机。归根结底，内燃机的原理与蒸汽机相同，只不过工质由水变为燃油。但是内燃机对材料和润滑的要求很高，对机械加工技术要求更甚。但材料依靠上次工业革命的铁基合金，润滑依靠石化工业，做到这两点都不难，唯一的问题是机加工技术，这一点需要足够的时间和市场来保证。</p><p>如果说体现第一次工业革命的化学水平是三酸两碱，那么第二次工业革命的代表化学产物就是代表实际应用的有机化学。此时的化学工程主要为机械产品服务，无论是钢材的冶炼，表面处理，硫化橡胶，还是工业油的生产，木质机械的化学处理，这些都占据了化学产品的大部分。少数其他行业如绝缘塑料，化肥，炸药，医药等产品，虽然在今天看来无比重要，但是在当时这些产品还未发展成熟且产量较低，少数的高产量成熟产品也主要被用于战争，典型的是炸药和医药。那时的发明家无论如何也想不到，为人类移山填海的炸药竟然被用来消灭人类自身，而检验救死扶伤的医药产品的最方便方式竟然是战争。无论如何，化学工业在这次工业革命中雨中春笋般的涌现出来，他将会在二战后迎来属于他的高潮。  </p><p>科学家群体早在前工业时代就活跃于各个领域，但那时的科学家的研究主要依靠个人兴趣，并且大多涉猎广泛。大量直接应用于生产的科学研究发生在此次工业革命。第一次工业革命参与者主要是各种手工匠人，他们依靠经验来改进工艺和机器。这很容易理解，工业革命早期生产资料匮乏，没有足够的试验器具供科学家们研究，少数能靠大脑推理演绎得出可靠结论的都是万里挑一的天才。但自从此次工业革命以来，大量的质量优秀的仪器被开发出来，科学家们首次运用大量仪器以量的角度观察这个世界。更振奋人心的是，此时的原动机，机械加工设备和化工过程的复杂度抽象度远超第一次工业革命，这正需要科学家解密原理以更好的应用在生产过程中。并且从上述分析可知，这时  生产 — 科学家 — 生产 的循环也建立起来了，工业革命将继续以生产出超越以往所有世代物质财富的速度进行下去，甚至包括第一次工业革命。  </p><h3 id="世界大战"><a href="#世界大战" class="headerlink" title="世界大战"></a>世界大战</h3><p>无论如何改进技术更新产品，工业循化的形式是不会发生根本变化的，但是工业循化的内容是会发生变化的，比如原动机由蒸汽机变为内燃机能源由蒸汽变为电力等，这是由于工业自迭代的本质所决定的。另一个不发生变化的是工业循环的动力。无论动力是什么，工业循环总是需要动力持续下去的，只不过现在的动力是利润。  </p><p>产生利润，意味着必须要有劳动力和原材料把产品生产出来，然后再把产品拿到市场上交换，并且必须被交换成功，此时利润便产生了。因而，产生利润需要两点条件：  </p><ul><li>足够的劳动力，原材料和生产工具  </li><li>能够成功交换即产品占有市场<br>一战前夕，殖民地被英法俄瓜分完毕，英国拿到了最肥美的运河，南亚，北非，南非和北美，法国获得了除英国外的绝大部分非洲，俄国得到了东亚，中亚，中东的一部分，以及东北欧的一部分。后发的以德国为代表的国家，因为落后了第一次工业革命而没有足够的殖民地。但在第二次工业革命中，工业的增长速度远远超过第一次工业革命，这样，德国在战前就超过了英国从而取得了欧洲最大工业国的地位，但足够的产品生产出来却又没有足够的市场致使利润无法收回。为了维持工业循环以保持足够的工业产能，防止被国际竞争压力中压溃，所以德国不得不发动战争。</li></ul><p>经过上述分析，一战的爆发可以说是必然。只不过一战的爆发过于戏剧性，包括德国在内每个国家都想保持在第一次工业革命中原有的低烈度战争，可笑的是几乎所有国家都一方面告诫其他国家不要进行动员以保持有限的和平，另一方面惧怕其他国家的动员而又私下进行动员。于是原本不堪重负的工业循环就迅速转向服务于军工产品，而军工产品不直接作用于生产，它的利润是以敌对国家的战败为基础的，要想获得胜利必须在军工业的投资与敌对国家保持同等量级甚至超过对方。随着每个国家都在倍增军工业的投资，欧洲的局势迅速恶化，离大战爆发只差个火星。    </p><p>这次战争让世人第一次看清工业化的战争的残酷，上千万受过工业化基本教育的士兵被派往战场，数百万标准化的栓动枪械源源不断的从工厂运往前线，几万公里铁路的修建只是为了赢得战争。在此次战争中战争的形式也发生了巨大转变，骑兵在机枪和炮弹的火力下难以突破防线，步兵的机动力受到极大阻碍，以战壕为为核心的绵延不断的多层防线便成为战争的最佳选择，上百万士兵在前进中失去生命仅仅为了十几公里。此外，多种新式战争机器在战争中也被首次运用，典型的是装载了内燃机的坦克和飞机，尽管作用有限，在工业产能的加持下产量迅速增长且下次战争中他们中的任何一个都会发挥更为巨大的作用。同时，新兴的化学工业也被运用在战争中，氯气的使用对这种绵延防线有巨大破坏，但是由于难以预测风向而运用较少。海军主要起保证贸易网的作用，主要作战舰艇是受巡洋舰保护的战列舰和潜艇。因德国开启无限制潜艇战之后误伤了美国客轮，这给美国下场留下了借口，随着美国下场，本就在作战兵力和自然资源都难以为继的同盟国更加雪上加霜。</p><p>历经四年的战争以德国战败为结束，原有的阿尔萨斯洛林被割给了法国，莱茵兰也被划为非军事地区，东部的土地被划给了波兰，实际上，德国的战败并未伤害到德国的核心利益，原本意图得到殖民地的德国仅仅是失去了一次机会。相比较协约国的处境就很尴尬，法国人付出了120万人死亡的代价仅仅得到了半个工业区和若有若无的战争赔款，更何况同盟国根本支付不起。英国人付出了90万人死亡的代价仅仅维持了表面的世界霸主地位，而德国付出了170万人死亡的便做到了重创英法联盟，并且顺便把俄国皇帝赶下了台。奥匈帝国被一分为二，匈牙利得到了梦寐以求的独立地位。俄国承受了不能承受的战争负担因此迅速走向分裂，最终退出了战争并且在战争结束后建立了世界第一个无产阶级政权。这次战争最大的受益国是美国和日本，前者大发战争财，后者得到了德国在东亚殖民地的主权以及喘息的时间。  </p><p>这场终结一切战争的战争除了战争外终结了一切，风雨飘摇的德国经济得到了美国的注资，一代人的伤亡会将用一代人的时间来抚平，可仇恨不会。得到了注资的德国重新焕发经济活力，9年后德国经济恢复到战前状态。又过了一年，德国经济地位重新回到世界第二，欧洲第一的战前地位。对殖民地和原材料的渴望同时也夹杂了对英法的民族主义仇恨推动了德国再次走向世界大战。但是这次不同，随着德国进入莱茵兰，吞并奥地利，英国的绥靖政策使法国以及一系列小国彻底失望，强硬的协约国再也不复存在。此时，法国因为一战损失了一代人而不想发动总动员，发动总动员的前提是英国也对等总动员，但随着德国入侵波兰，英国的保独政策终于起效，法国也随之对德宣战。</p><p>这次战争的残酷是绝无仅有的，原本在一战中崭露头角的武器在二战中迅速发展。随着化学技术的提高多种新式炸药被研制出来，炸药的威力逐步增加，安全性和烟尘问题也得到一定改善。在化学技术迅猛发展的同时，传统的机械控制在二战时也达到顶峰，新式的火控系统让坦克和火炮成为新的陆战主力。而空军由于石化技术的提高和飞机整体设计的进步在战争中得到了广泛的应用。在海军方面，以巡洋舰，战列舰保护的航母是主要作战核心，这一配置打败了以战列舰为海战核心的作战思想。在陆战方面，内燃机的运用使陆军的机动力大幅提高。相比一战的弹性防御的堑壕战思想，二战的机动作战能够迅速将堑壕分隔包围，没有补给的堑壕战犹如瓮中之鳖。典型的案例是德国对抗法国，装备了内燃机的坦克和现代化的运输卡车使得德军能够绕道阿登森林直取巴黎，这100公里的行程仅仅用了2天，而一战时，这个数字是2个月。于是从入侵法国到法国投降，德国装甲部队仅用了6个星期就完成了这一壮举。电子设备的出现使得不同部队配合程度大幅提高，因此主动的，进攻式的作战策略占据上风。依靠无线电台，指挥部可在千里之外收到侦察机的信号，这使得战场范围迅速扩大。东线战场上，由于苏联战前准备不足，内部大清洗还有余波，因而战争前期迅速失去大部分土地和工业，好在两个五年计划给了苏联足够的工业实力，使得苏联培养了足够的士兵和技术干部。相比德国的资源匮乏走的技术路线，苏联合理利用资源走了一条数量路线，在人员装备方面量大压倒了质优。在斯大林格勒战役中，前期由于德军战斗经验和装备精良使德军迅速的推进到城内，而在城内，战争的废墟阻挡了德军现代化的坦克和空军部队，并且由于气候的严酷和补给的缺乏更使得德军单兵实力大大下降。终于，苏联的兵力优势以及顽强的抵抗斗志占了上风，德军在斯大林格勒遭到重大挫败。之后在库尔斯克会战中，成群的 T34 击败了 “虎式”“豹式”，量大管饱的炮火让德军吃尽苦头。从美国正式参战开始，德国就必定走向失败的道路，战前的美国工业实力是英法德的总和，控制的资源更是德国急缺的石油和橡胶。于是，二战的结束只是时间问题了。东亚战场上，日本的工业实力甚至没能超越意大利，中国的工业实力连日本都不如。因此亚洲战场不在本文叙述范围内。</p><h2 id="信息时代"><a href="#信息时代" class="headerlink" title="信息时代"></a>信息时代</h2><h3 id="世界背景-2"><a href="#世界背景-2" class="headerlink" title="世界背景"></a>世界背景</h3><p>二战后，世界格局发生重大变化，传统的英帝国被打成废墟，德国被一分为二。美国依靠百万奴工和两次世界大战大发横财，苏联依靠计划经济抄底大萧条崛起。在东欧和东亚，苏联占据主导地位，在中西欧和美洲，美国占据主导地位。两极格局正式形成。从民用工业体系角度来看，美国在汽车，石化，食品，农业等产业占优，基础机械，基础化学更甚。而苏联在军事工业上占优，在枪炮坦，航空航天，纺织，基础材料加工，大宗原材料生产方面占优。但总体而言，苏联的生产效率是远不如美国的。  </p><h3 id="核能，集成电路与传统专门工业的巅峰"><a href="#核能，集成电路与传统专门工业的巅峰" class="headerlink" title="核能，集成电路与传统专门工业的巅峰"></a>核能，集成电路与传统专门工业的巅峰</h3><p>核能一个应用路线是用作武器。核武器的出现尤其是实战令各国震惊不已，特别是当核武器被无法控制战争的烈度的人类掌握时，核武器的威慑力就大大增加了。核不扩散条约于1968年被联大审议通过，尽管我们知道印度，巴基斯坦，朝鲜都“非法”拥有核武器。这使条约看起很可笑，但我们可以从这一点看出，核武器作为平衡国际国际实力的有效手段是可以被“允许的”，前提是要支付代价。这也是在委婉的表达：核武器并不能毁灭世界，甚至连毁灭人类都不可以。从目前的和武器数量来说：它最多只能把人类现有的中大型城市毁灭，广大的乡村地区不属于它的工作职责。  </p><p>核能另一个路线是能源，它与第二次工业革命的成果结合就是核能发电。核裂变发电我这里先不谈，这种发电方式不仅没有什么前途而且在人类总发电量中只占很少一部分。与之对应的核聚变发电的方式被视作解决人类能源的最终方法，因为在已探明宇宙中氢元素丰度最高，按质量算约占宇宙可见物质的四分之三，而可供聚变的氘和氚在氢元素中约占十万分之三，也就是说哪怕是在人类宇宙航行时最可靠的能源来源依然是核聚变。合适的聚变温度应在5千万-2亿度，因此现在聚变发电的难点在于控制高温粒子流不把容器打穿，而保护容器的难点在于研发恰当的材料以及提供快速准确的控制方式。可控核聚变作为庞大的系统工程，其实施难度，应用可行性远超前人预料，在通往解决人类能源问题的道路上我们还要准备过渡方案。  </p><p>但在这里需要强调的是，核聚变作为人类可能的终极能源并不能解决人类社会一切矛盾。一种比较广泛的观点是，廉价的能源有助于人类到达“理想国”。但是不幸的是，包括能源突破在内没有哪项技术是真正的帮助完成这种最终的理想社会的。一千年之前人们把理想社会的实现建立在农业和水利工程的技术进步上，五百年的人认为繁荣和平的航海贸易就能建成人间天堂，到了一百年之前，理想社会就变成了苏维埃和全国电气化。如今只不过是把可控核聚变这层皮给披上去而已，无视了其他因素有尤其是社会因素的重要作用。对于建成理想社会的相关问题我的想法还不成熟，需要时间的磨练，我打算日后再谈。  </p><h3 id="集成电路"><a href="#集成电路" class="headerlink" title="集成电路"></a>集成电路</h3><p>考虑到集成电路的极端重要性，我这里有必要单开一节来论述集成电路。  </p><p>集成电路的出现反映了人类对于计算的需求，自从第二次工业革命以来，人类对于客观世界的认识由质的层面飞跃到量的层面。等待着科学家和工程师们的是无穷尽的客观条件所决定的各种物化参数，这种计算复杂量远远超过传统查表计算和计算尺计算的能力，新的计算工具呼之欲出。最早担任这一重任的是机械式计算机，这种计算机早在二战时期便已大规模应用，具体原理就是利用机械运动来做出能够进行基本计算的零件，进而由这些零件和其他辅助计算的部分组成整体式的机械计算机。无论是密码破译，核定经济，计算强度、产率，还是计算弹道，船舶运行参数，设计飞行器等老式的计算机都有大规模的应用。但是这种计算机有着价格昂贵，速度慢，难以维护等缺点，因此在真空管出现后被迅速取代。  </p><p>早期的真空管也称阴极射线管，其主要结构是一个内部含有电子放射源和收集电子装置的真空管，并且在放射源和收集装置之间还有与真空管外部相连的可以收集电子的回路。这样，只要持续给放射源供电，放射源就会发出电子，这些电子经过未导通的电子回路可以到达收集装置，但如果电子回路被导通，放射电子就会优先被收集电子的回路所吸引，电子就不能到达收集装置。我们把发射源叫做发射极，收集装置叫做集电极，收集电子的回路叫做基级，这样用基极就可以控制集电极的导通与否了。    </p><p>有了基本的真空管和二极管，我们可以做成基本门电路，有了基本门电路后，我们还能做出复杂的逻辑电路。例如，可由四个与非门组成的JK触发器进一步组成T触发器，从而实现计数功能，计数的位数由JK触发器的个数决定，若再由若干门电路和二极管便可组成译码器，使得计数器可以将结果显示在十进制的数码显示管上。有了复杂电路后人们就可以应用于生产和科研，比如新的电子式的显示设备取代了机械式的数字显示设备。  </p><p>集成电路复杂的逻辑首先被用在设计计算机上。高速，高可靠性，结构简单的电子式计算机迅速赢得美国军方的青睐。随着晶体管的小型化和MOS管的诞生，集成电路迅速小型化，使其可以装在飞机，坦克，火炮上。集成电路除了被制成计算机，还被广泛用于自动化控制上。早期的控制原件多采用机械式原理，结构庞大成本很高，当集成电路被小型化后，传统的机械式控制迅速被电气式取代，较低的成本高速的计算性能使得工业生产率大幅提高。在新世纪后，集成电路产业的迅速发展催生了互联网， 信息终端设备，工业自动化，信息处理软件等新兴行业，创造了惊人物质财富。  </p><h3 id="传统专门工业的巅峰"><a href="#传统专门工业的巅峰" class="headerlink" title="传统专门工业的巅峰"></a>传统专门工业的巅峰</h3><p>二战后的废墟并不能阻挡人们重建家园的愿望，消灭了过剩产品和社会不稳定因素的二战虽然给人类造成了永久的创伤但另一方面也促进了人类科技的蓬勃发展，在和平的历史条件下进步缓慢的重工业在二战中迅速发展，同时各个传统工业门类迅速分化。例如机械这个传统工业门类在二战中与控制领域结合，产生了坦克火炮控制系统，并且同领域的航天也衍生出了飞行控制系统。机械领域与化学领域结合，诞生了高品质合金钢，表面处理工艺。在二战后期，由于战后重建的需要，机械与土木结合促进了工程机械大爆发等等。我们可以看到，这种专业门类的深入化和细分化颇有预见性的为接下来70年的工业化道路指明了方向。  </p><p>集成电路出现后各门类工业模式发生了变化，它在取代了原有领域的部分产品的基础上也推动了自己的发展。例如，老式的气动管道物流传输系统被广泛用于医院，传媒和政府机关部门。但是及时，准确，易维护，投资低的电子式信息系统成了最新选择，除了少数对物流要求颇高的应用场合还在维持运行，绝大部分的气动管道系统在之后的电子设备大发展的时代被迅速抛弃。这种变化也是那时工业发展变化的一个缩影：代表着先进生产力的，能够节约劳动力的电子式系统占据了绝大部分发展通道，而催生出这一产业的机械化学和材料等产业却只能停留在改进工艺，探索物质新的组织方式这种古板的发展道路上。这种发展模式让人不得不联想第一次工业革命早期，那时传统的第一产业已经达到了发展的巅峰，它们无法再带领人类继续提高生产力了，只有剥削自己榨出足够的剩余农产品帮助工业成长，才能在此之后依靠工业获得足够的发展机会。两种情形对比来看，这实在让人唏嘘。  </p><p>但总之，无论人类喜不喜欢，这种潮流还会持续下去的，拥抱变化的人努力地活着，墨守成规的人寂静的死去。新式的计算机结合工业的技术在80年代诞生，世纪末已经有了一部分应用，在下个世纪初的头十年是这种技术迅速发展的阶段。  </p><p>在最后我还要强调一件事，那就是我写在文章开头的那句话：“资本主义 100 年所创造的物质财富超过了以往一切时代的总和。”马克思这句话并不准确，资本主义除了传统的工商业资本主义的形式外，还有农业的，宗教的，军事的等等，作为工具的资本主义是不会创造出如此的丰富的物质世界。我个人更喜欢把这句话改写成这样：“大工业生产 100 年所创造的物质财富超过了以往一切时代的总和”。并且这句话在此时依然是成立的，二战的消耗虽然庞大但而工业发展和恢复的速度更为迅速，这种迅速使得人类在此之前一切物质的生产和消耗都相形见绌。在二战中西欧70%的工业被摧毁，而各国50年代初的经济便达到了战前水平，此时离二战结束不过5年。 </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>新世纪前后的工业是我想要论述的重点，但碍于篇幅且本文行文较为抽象，与叙述新世纪的工业模式变化需要详实的数据的情况不，因此关于具体阐释世纪前后的工业变化将另开一文。虽然本文缺失了现代工业发展模式，但强调工业脉络目的已然达成，我们可以从上文总结出工业的特点，这并不妨碍我们所归纳结论的准确性和全面性。这些特点是我从大学四年的学习中获得的经验所总结出来的，我会在力求准确的基础上保证尽量简洁。详细解释将会发在本系列的下篇文章。  </p><h2 id="工业的特点-1"><a href="#工业的特点-1" class="headerlink" title="工业的特点 ^1"></a>工业的特点 <a href="%E6%9C%AC%E8%8A%82%E4%B8%8D%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0">^1</a></h2><ul><li>工业需要自迭代系统，自我循环的结构和推动循环的动力。</li><li>工业的增长脱离了人力畜力的限制，打破了农业社会发展上限。</li><li>工业极度渴望增长，且增长的速度和带来的矛盾前所未有。</li><li>现代的工业与资本主义绑定，于是逐利和过剩也成了其根本标志。   </li><li>经过百年发展，工业中的不同行业分化极其严重，生产过程极其复杂。</li><li>工业时代的社会也有危机，并且这种危机不仅频繁破坏性还更大。</li><li>满足需求新的工业产品收益丰厚，但产品改良到一定程度收益会下降。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;百年激荡&quot;&gt;&lt;a href=&quot;#百年激荡&quot; class=&quot;headerlink&quot; title=&quot;百年激荡&quot;&gt;&lt;/a&gt;百年激荡&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; &lt;font size = 5&gt;资本主义 100 年所创造的物质财富超过了以往一切时代的总和   &lt;/p&gt;
&lt;p align=&quot;right&quot; &gt; &lt;font size = 4&gt;—— 卡尔·马克思 &lt;/font&gt; &lt;/p&gt;&lt;/font&gt;  
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="生产" scheme="https://wumingzi.top/categories/%E7%94%9F%E4%BA%A7/"/>
    
    
    <category term="工业" scheme="https://wumingzi.top/tags/%E5%B7%A5%E4%B8%9A/"/>
    
    <category term="机械" scheme="https://wumingzi.top/tags/%E6%9C%BA%E6%A2%B0/"/>
    
    <category term="历史" scheme="https://wumingzi.top/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>测试</title>
    <link href="https://wumingzi.top/2023/01/19/%E6%B5%8B%E8%AF%95/"/>
    <id>https://wumingzi.top/2023/01/19/%E6%B5%8B%E8%AF%95/</id>
    <published>2023-01-19T09:46:24.000Z</published>
    <updated>2023-01-29T09:24:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文测试 Markdown，网页排版及渲染    </p><span id="more"></span><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p><em>斜体</em><br><strong>重点</strong><br><del>删除</del></p><ul><li>无序列表 1 </li><li>无序列表 2</li></ul><ol><li>有序列表 1</li><li>有序列表 2</li></ol><p><a href="www.baidu.com">链接：百度</a>     </p><p><img src="https://img0.baidu.com/it/u=4021493089,364774701&fm=253&app=138&size=w931&n=0&f=PNG&fmt=auto?sec=1674234000&t=0f6e9227199a396ea9ead701335b431b" alt="图片：Arch Linux "> </p><p>脚注[^1]<br>[^1]: 脚注内容</p><p>上标^上标^      </p><h2 id="下标下标"><a href="#下标下标" class="headerlink" title="下标下标      "></a>下标<del>下标</del>      </h2><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线    "></a>分割线    </h2><blockquote><p>引用1<br>引用2</p><blockquote><p>引用2.1<br>引用2.2  </p></blockquote></blockquote><pre><code class="C"> #include&lt;stdio.h&gt; int main() &#123;    printf(&quot;代码测试&quot;); &#125;</code></pre><p><mark>高亮</mark></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文测试 Markdown，网页排版及渲染    &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
