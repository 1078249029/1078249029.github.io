<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"wumingzi.top","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="基础的Linux应用与驱动开发">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux基础">
<meta property="og:url" content="https://wumingzi.top/2024/02/21/Linux%E5%9F%BA%E7%A1%80/">
<meta property="og:site_name" content="吾铭子">
<meta property="og:description" content="基础的Linux应用与驱动开发">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wumingzi.top/vx_images/102890821240164.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/87705621258590.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/524381910258594.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/350710321240167.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/248472313258593.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/57842413246460.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/28992322246461.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/273505722266627.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/264391211240169.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/494225911258595.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/488490816246462.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/95050916266628.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/393842811240171.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/163195211258597.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/512684309240242.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/555733018240243.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/453645515259373.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/228213118258669.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/133675815255928.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/513115815251682.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/435033118246536.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/54405415246538.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/539235415266704.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/100313218266702.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/405024118259371.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/48475115240245.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/2645315258671.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/598381118240253.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/555341316269562.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/243433321255926.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/202144219267166.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/137870611240256.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/49132822264668.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/262162922245909.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/118373822268349.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/523271523263485.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/143045013240246.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/591831111240254.png">
<meta property="og:image" content="https://wumingzi.top/vx_images/252041211258680.png">
<meta property="article:published_time" content="2024-02-20T16:19:52.000Z">
<meta property="article:modified_time" content="2024-02-20T16:25:04.694Z">
<meta property="article:author" content="吾铭子">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wumingzi.top/vx_images/102890821240164.png">


<link rel="canonical" href="https://wumingzi.top/2024/02/21/Linux%E5%9F%BA%E7%A1%80/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://wumingzi.top/2024/02/21/Linux%E5%9F%BA%E7%A1%80/","path":"2024/02/21/Linux基础/","title":"Linux基础"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Linux基础 | 吾铭子</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="吾铭子" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">吾铭子</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux"><span class="nav-number">1.</span> <span class="nav-text">Linux</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF"><span class="nav-number">1.1.</span> <span class="nav-text">学习路线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E5%9F%BA%E7%A1%80"><span class="nav-number">1.2.</span> <span class="nav-text">Linux基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.1.</span> <span class="nav-text">Linux基础命令与操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-number">1.3.</span> <span class="nav-text">Linux环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AENAT%E4%BB%A5%E5%8F%8A%E6%A1%A5%E6%8E%A5%E7%BD%91%E5%8D%A1"><span class="nav-number">1.3.1.</span> <span class="nav-text">设置NAT以及桥接网卡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%90%AFNFS"><span class="nav-number">1.3.2.</span> <span class="nav-text">开启NFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.3.</span> <span class="nav-text">交叉编译环境的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IMX6ULL%E5%B7%A5%E5%85%B7%E9%93%BE"><span class="nav-number">1.3.4.</span> <span class="nav-text">IMX6ULL工具链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.3.5.</span> <span class="nav-text">编译第一个应用程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.3.6.</span> <span class="nav-text">编译第一个驱动程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80"><span class="nav-number">1.4.</span> <span class="nav-text">Linux应用开发基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GCC"><span class="nav-number">1.4.1.</span> <span class="nav-text">GCC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GCC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">GCC操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">编译过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6IO%E5%92%8C%E6%A0%87%E5%87%86IO"><span class="nav-number">1.5.</span> <span class="nav-text">文件IO和标准IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6IO%E7%9A%84%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">1.5.1.</span> <span class="nav-text">文件IO的内部机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#open%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.2.</span> <span class="nav-text">open函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#write%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.3.</span> <span class="nav-text">write函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#read%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.4.</span> <span class="nav-text">read函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dup%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.5.</span> <span class="nav-text">dup函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#framebuffer"><span class="nav-number">1.6.</span> <span class="nav-text">framebuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E5%8F%8A%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA"><span class="nav-number">1.7.</span> <span class="nav-text">文本及图像显示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E6%98%BE%E7%A4%BA"><span class="nav-number">1.7.1.</span> <span class="nav-text">文本显示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E5%BA%94%E7%94%A8%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.8.</span> <span class="nav-text">Linux应用输入系统编程的四种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%96%B9%E5%BC%8F%E8%AE%BF%E9%97%AE%E7%A1%AC%E4%BB%B6"><span class="nav-number">1.8.1.</span> <span class="nav-text">阻塞非阻塞方式访问硬件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poll-SELECT%E6%96%B9%E5%BC%8F%E8%AE%BF%E9%97%AE%E7%A1%AC%E4%BB%B6"><span class="nav-number">1.8.2.</span> <span class="nav-text">poll&#x2F;SELECT方式访问硬件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5"><span class="nav-number">1.8.3.</span> <span class="nav-text">异步通知</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">1.9.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E7%BC%96%E7%A8%8B"><span class="nav-number">1.9.1.</span> <span class="nav-text">TCP编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP%E7%BC%96%E7%A8%8B"><span class="nav-number">1.9.2.</span> <span class="nav-text">UDP编程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">1.10.</span> <span class="nav-text">多线程编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E7%BC%96%E7%A8%8B"><span class="nav-number">1.11.</span> <span class="nav-text">串口编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TTY"><span class="nav-number">1.11.1.</span> <span class="nav-text">TTY</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I2C%E7%BC%96%E7%A8%8B"><span class="nav-number">1.12.</span> <span class="nav-text">I2C编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SMB%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.13.</span> <span class="nav-text">SMB协议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">Linux驱动开发基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-number">2.1.</span> <span class="nav-text">驱动开发的原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%A1%86%E6%9E%B6"><span class="nav-number">2.2.</span> <span class="nav-text">驱动的框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.2.1.</span> <span class="nav-text">最简单的LED驱动程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%80%9D%E6%83%B3"><span class="nav-number">2.3.</span> <span class="nav-text">驱动设计的思想</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.3.1.</span> <span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B1%82"><span class="nav-number">2.3.2.</span> <span class="nav-text">分层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%A6%BB"><span class="nav-number">2.3.3.</span> <span class="nav-text">分离</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.4.</span> <span class="nav-text">总线设备驱动模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E6%A0%91%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.5.</span> <span class="nav-text">设备树驱动模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E9%A9%B1%E5%8A%A8%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">2.6.</span> <span class="nav-text">Linux驱动输入系统编程的四种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="nav-number">2.6.1.</span> <span class="nav-text">查询方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6"><span class="nav-number">2.6.2.</span> <span class="nav-text">休眠唤醒机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poll%E6%9C%BA%E5%88%B6"><span class="nav-number">2.6.3.</span> <span class="nav-text">poll机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5-1"><span class="nav-number">2.6.4.</span> <span class="nav-text">异步通知</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">2.7.</span> <span class="nav-text">阻塞与非阻塞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.8.</span> <span class="nav-text">Pinctrl子系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%EF%BC%8C%E4%B8%AD%E6%96%AD%E4%B8%8E%E8%BD%AE%E8%AF%A2"><span class="nav-number">2.9.</span> <span class="nav-text">异常，中断与轮询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">2.10.</span> <span class="nav-text">定时器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mmap"><span class="nav-number">2.11.</span> <span class="nav-text">mmap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="nav-number">2.11.1.</span> <span class="nav-text">地址映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache%E4%B8%8E%E5%86%99buffer"><span class="nav-number">2.11.2.</span> <span class="nav-text">cache与写buffer</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">吾铭子</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/31123236" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;31123236" rel="noopener me" target="_blank"><i class="fab fa-bilibili fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://bgm.tv/user/520931" title="Bangumi → https:&#x2F;&#x2F;bgm.tv&#x2F;user&#x2F;520931" rel="noopener me" target="_blank"><i class="fa fa-globe fa-fw"></i>Bangumi</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wumingzi.top/2024/02/21/Linux%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吾铭子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吾铭子">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Linux基础 | 吾铭子">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux基础
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-02-21 00:19:52 / 修改时间：00:25:04" itemprop="dateCreated datePublished" datetime="2024-02-21T00:19:52+08:00">2024-02-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>基础的Linux应用与驱动开发</p>
<span id="more"></span>

<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><p>看完第四篇可以看编写APP操作硬件，看完第五篇可以看70天</p>
<h2 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h2><p>shell负责解析命令，当用户在shell中输入命令时，根据输入的结果，shell根据PATH环境变量的位置找到相应的程序执行，因此可以通过将.o文件复制到PATH来直接在任何目录下执行程序，否则只能使用绝对路径或相对路径的方式来执行</p>
<p>[]代表可选参数 &lt;&gt;代表必选参数</p>
<h3 id="Linux基础命令与操作"><a href="#Linux基础命令与操作" class="headerlink" title="Linux基础命令与操作"></a>Linux基础命令与操作</h3><p>. 当前目录 .. 上一级目录 - 切换前上一次的目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd .. 返回到上一级目录</span><br><span class="line">cd - 返回到切换前上一次的目录</span><br><span class="line">rm -r 递归删除</span><br><span class="line">touch existfile 修改文件更改时间</span><br></pre></td></tr></table></figure>

<p><img src="/vx_images/102890821240164.png" alt="2024-01-23_21-07">  </p>
<p>拥有文件权限的组分别为：book用户，book用户所在组的其他用户，其他用户</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">file 文件名 查看文件详细信息</span><br><span class="line">chmod 777 赋予所有权限</span><br><span class="line">chmod a-x filename 去除所有用户的x权限</span><br><span class="line">chmod u+x filename 加上拥有者的x权限</span><br><span class="line"></span><br><span class="line">chown 用户组:用户组 filename 改变文件的拥有者</span><br><span class="line">su 用户名 切换用户</span><br><span class="line"></span><br><span class="line">find 目录名 选项 查找条件</span><br><span class="line">find directoryname -name &quot;*1.txt*&quot; 在directoryname下找到包含为1.txt的文件</span><br><span class="line"></span><br><span class="line">grep 参数 &quot;字符串&quot; 文件名 </span><br><span class="line">grep -rwn &quot;abc&quot; * 在当前目录中查找含有abc字符串的文件，查找模式是，递归的(r)，整词的(w)，找到行号(n)</span><br><span class="line"></span><br><span class="line">ifconfig 查看网络</span><br></pre></td></tr></table></figure>


<p><img src="/vx_images/87705621258590.png" alt="2024-01-23_21-55">  </p>
<p>tar命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar cjf filename.tar.bz2 filename 文件使用bzip2压缩算法压缩</span><br><span class="line">tar czf filename.tar.gz filename 文件使用gzip压缩算法压缩</span><br><span class="line"></span><br><span class="line">tar xjf filename.tar.bz2 文件使用bzip2压缩算法解压</span><br><span class="line">tar xzf filename.tar.gz 文件使用gzip压缩算法解压 </span><br></pre></td></tr></table></figure>

<h2 id="Linux环境搭建"><a href="#Linux环境搭建" class="headerlink" title="Linux环境搭建"></a>Linux环境搭建</h2><p>为了能够便捷配置环境以及工具链，我们需要在Linux环境下进行开发，因此我们就需要选择<strong>Ubuntu虚拟机作为我们的服务器</strong>，为了能够将Ubuntu上编译后的程序在开发板上也能运行，我们需要配置<strong>交叉编译环境</strong>，为了开发板与Ubuntu能够传输文件，我们需要<strong>设置网口，配置ip，开启nfs服务</strong>，由于我们是小白，以及为了能够使用win下的笔记，截图工具，我们需要win下的通信工具mobaxterm，以及我们<strong>需要保证win，Ubuntu，开发板能够互相通信</strong>  </p>
<p>网络拓扑如下<br><img src="/vx_images/524381910258594.png" alt="100ask开发板网络拓扑"></p>
<h3 id="设置NAT以及桥接网卡"><a href="#设置NAT以及桥接网卡" class="headerlink" title="设置NAT以及桥接网卡"></a>设置NAT以及桥接网卡</h3><p>NAT网卡可以保证Ubuntu可以上网，NAT实现Ubuntu与Windows网络互通<br>桥接网卡保证Ubuntu可以与开发板互通</p>
<ul>
<li>默认ip：<ul>
<li>开发板 192.168.5.9</li>
<li>windows 192.168.5.10</li>
<li>Ubuntu 192.168.5.11</li>
</ul>
</li>
</ul>
<h3 id="开启NFS"><a href="#开启NFS" class="headerlink" title="开启NFS"></a>开启NFS</h3><p>NFS(net file system)，为了方便开发板与Ubuntu之间通信，可以设置开启NFS</p>
<ul>
<li>开启步骤<ul>
<li>在Ubuntu中开启开发板访问Ubuntu的权限，在&#x2F;etc&#x2F;export中加入要共享的文件夹</li>
<li>开启NFS服务</li>
<li>在开发板中挂载Ubuntu中的某个目录(默认为&#x2F;home&#x2F;book&#x2F;nfs_rootfs)到&#x2F;mnt下</li>
</ul>
</li>
</ul>
<h3 id="交叉编译环境的使用"><a href="#交叉编译环境的使用" class="headerlink" title="交叉编译环境的使用"></a>交叉编译环境的使用</h3><ul>
<li>环境变量有三种方式可以修改<ul>
<li>永久修改：<ul>
<li>修改<code>/etc/environment</code>，添加对应的目录，对所有用户有效</li>
<li>修改<code>~/.bashrc</code>，在行尾添加<code>export PATH=$PATH:对应的目录</code>，并执行<code>source ~/.bashrc</code>，只对当前用户有效</li>
</ul>
</li>
<li>临时设置：<ul>
<li>在终端执行<code>export PATH=$PATH:对应的目录</code>，但只对当前终端有效</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>由于开发板使用的是arm架构，虚拟机使用的是x86架构，且环境、资源基本不同，因此为了能够使由Ubuntu编译后的文件在开发板上使用，需要配置交叉环境编译链，百问网使用脚本自动配置，我们只需在编译时使用这些编译工具即可  </p>
<p>如果没有使用交叉编译链编译文件，在开发板上执行时会提示格式错误</p>
<h3 id="IMX6ULL工具链"><a href="#IMX6ULL工具链" class="headerlink" title="IMX6ULL工具链"></a>IMX6ULL工具链</h3><p>IMX6ULL工具链有两种分别为arm-buildroot-linux-gnueabihf-gcc 与 arm-linux-gnueabihf-gcc，前者工具链较全，包含了zlib等库，后者较为精简，有的库没有包含</p>
<h3 id="编译第一个应用程序"><a href="#编译第一个应用程序" class="headerlink" title="编译第一个应用程序"></a>编译第一个应用程序</h3><p>在Ubuntu上执行<code>arm-buildroot-linux-gnueabihf-gcc -o hello hello.c</code>使得编译后的文件能够在开发板上执行  </p>
<h3 id="编译第一个驱动程序"><a href="#编译第一个驱动程序" class="headerlink" title="编译第一个驱动程序"></a>编译第一个驱动程序</h3><p>由于驱动程序依赖内核，因此必须有内核的源码且内核必须编译过，这样驱动程序才能根据配置编译过的内核而运行<br><img src="/vx_images/350710321240167.png" alt="2024-01-26_21-03"></p>
<p>步骤如下：</p>
<ol>
<li>准备好内核，设备树，并编译</li>
<li>将编译后的文件拷贝到nfs文件夹下，以便开发板能够访问</li>
<li>编译驱动模块，将驱动模块安装在nfs文件夹下</li>
<li>将挂载在开发板的&#x2F;mnt下的内核，驱动程序放在&#x2F;boot下，将编译产生的lib放在开发板的lib下</li>
<li>执行sync命令，以便将内存中的内容刷写到flash上</li>
<li>重启开发板，这样就诞生了一个自己编译内核的，驱动的开发板</li>
</ol>
<h2 id="Linux应用开发基础"><a href="#Linux应用开发基础" class="headerlink" title="Linux应用开发基础"></a>Linux应用开发基础</h2><p>在int  main(int argc, char** argv)中，编译执行输入<code>./filename command</code>argc是2，argv[0]是filename，argv[1]是command，argv的值可以传进函数做参数</p>
<ul>
<li><p>引用的头文件在哪？</p>
<ul>
<li>在工具链的系统目录，或者编译时-I指定目录</li>
</ul>
</li>
<li><p>头文件和库文件的区别</p>
<ul>
<li>头文件是文本文件，可供阅读，库文件是二进制文件，不可阅读，因此库文件有一定的保密性</li>
<li>头文件在编译阶段使用，库文件在链接阶段使用</li>
<li>头文件一般只包括声明，库文件包括了内部实现</li>
<li>头文件是手动编写的，库文件是生成的</li>
</ul>
</li>
</ul>
<p><img src="/vx_images/248472313258593.png" alt="2024-01-26_13-22_1">  </p>
<p><img src="/vx_images/57842413246460.png" alt="2024-01-26_13-23">  </p>
<h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><h4 id="GCC操作"><a href="#GCC操作" class="headerlink" title="GCC操作"></a>GCC操作</h4><p>gcc(g++) <options> <sourcefile><br>    options<br>        -o<filename>                    指定文件名<br>        -fexec-charset&#x3D;GBK            指定运行时编码<br>        -finput-charset&#x3D;UTF-8        指定源文件编码<br>        -Wall                                    输出警告信息<br>        -O(0-3)                                 指定代码优化等级(0为不优化)<br>        -I                                          指定文件目录来查找头文件(一般为.&#x2F;)<br>        -L                                         指定文件目录来查找库文件(一般为.&#x2F;)<br>        -v                                         输出编译的信息 </p>
<h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><ul>
<li><p>预处理阶段    (-E，得到.i文件)（巧记：ESC，iso）</p>
<ul>
<li>处理#include预编译指令，将被包含的文件直接插入到预编译指令的位置</li>
<li>处理所有的条件预编译指令，比如#if，#else，#endif，#ifdef等</li>
<li>预处理器将所有的#define删除，并且展开所有的宏定义</li>
<li>删除所有的注释</li>
<li>添加行号和文件标识，以便编译错误时提供错误或警告的行号</li>
<li>保留所有#pragma编译器指令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E -o hello.i hello.c</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>编译阶段    (-S，得到.s文件)</p>
<ul>
<li>将预处理后的file.i文件进行语法词法分析，翻译成文本文件file.s<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S -o hello.s hello.i</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>汇编阶段    (-c，得到.o文件)</p>
<ul>
<li>得到二进制机器码文件，生成各个段，生成符号表<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -o hello.o hello.s</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">* 链接阶段    (gcc file.o)    </span><br><span class="line">    * 将链接文件链接到file.o文件中</span><br><span class="line">    * 静态链接：内存开销大，速度快。将所有需要的函数的二进制代码拷贝到可执行文件中去</span><br><span class="line">    * 动态链接：内存开销小，速度慢。不需要将所有需要的函数的二进制代码拷贝到可执行文件中去，而是记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统将这些动态库加载到内存中，然后当程序运行到指定代码时，去共享执行内存中找到已经加载动态库可执行代码，最终达到运行时链接的目的  </span><br><span class="line">    </span><br><span class="line">```shell</span><br><span class="line">gcc -M hello.c    打印hello.c的依赖</span><br><span class="line">gcc -M -MF hello.d hello.c    输出hello.c的依赖到hello.d文件内</span><br><span class="line">gcc -c -o hello.o hello.c -MD -MF  hello.d    编译hello.c并输出依赖到hello.d文件</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">**为了防止编译大型项目后再对其中某一个文件修改而重新编译整个系统，可以采用先编译大型项目，最后再链接**</span><br><span class="line"></span><br><span class="line">使用&quot;&quot;include文件代表去当前目录下查找库文件</span><br><span class="line">使用&lt;&gt;include文件代表去工具链目录下查找库文件</span><br><span class="line"></span><br><span class="line">静态库以.a结尾，动态库以.so结尾</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Makefile</span></span>    </span><br><span class="line"></span><br><span class="line">* 如何判断哪个文件被更改了？</span><br><span class="line">    * 比较源文件与输出文件的时间，如果源文件更新的话，那就意味着源文件已经被修改了  </span><br><span class="line">    </span><br><span class="line">```makefile    </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">makefile核心：规则</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">目标：依赖1 依赖二...</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[TAB]命令</span>  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下列目标文件<span class="built_in">test</span>由a.o b.o链接生成</span></span><br><span class="line">  </span><br><span class="line">test:a.o b.o</span><br><span class="line">    gcc -o test a.o b.o</span><br><span class="line">    </span><br><span class="line">a.o:a.c</span><br><span class="line">    gcc -c -o a.o a.c</span><br><span class="line"></span><br><span class="line">b.o:b.c</span><br><span class="line">    gcc -c -o b.o b.c</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>通配符：<br>    *： 任意字符，但对于目标文件，优先使用%代替*<br>    $：取值<br>    @：目标值，@后加shell命令可以不显示命令但输出结果<br>    $@：目标文件<br>    $&lt;：第一个依赖文件<br>    $^：所有依赖文件<br>$(shell 命令)可以执行shell命令<br>假想目标文件：.PHONY 用于当目标文件与make命令重名时使用，用法：在makefile文件末尾加上.PHONY: 命令</p>
<p>A &#x3D; xxx 变量赋值<br>$(A) 变量取值<br>&#x3D; 延时变量，makefile分析完成整个文档后才会对变量赋值，没有写程序时的类似顺序执行的逻辑<br>:&#x3D; 即时变量，类似写程序时的顺序执行的关系，需要在当前行之前声明定义变量<br>?&#x3D; 在此行之前就已经定义变量时该语句无效，类似#ifndef<br>+&#x3D; 附加，并不是加，是延时变量还是即时变量取决于前文</p>
<p>$(foreach var,list,text)    在list中的每一个var，都换为text<br>$(filter pattern,text)    在text中取出符合pattern的值<br>$(filter-out pattern,text)    在text中取出不符合pattern的值<br>$(wildcard pattern)    在已存在的文件中取出符合pattern的值<br>$(patsubst pattern,replacement,$(var))    在var中取出符合pattern的值，并替换为replacement<br>CFLAGS 这个变量可以后加gcc的编译选项</p>
<h2 id="文件IO和标准IO"><a href="#文件IO和标准IO" class="headerlink" title="文件IO和标准IO"></a>文件IO和标准IO</h2><p>Linux是参照Unix制作出来的，为了使App能够在Linux与Unix上都能运行，Linux就需要实现与Unix相同的接口，这套接口统称为<strong>POSIX接口</strong>(posix Portable Operating System Interface for uniX)，任何支持POSIX标准的操作系统都支持文件IO</p>
<ul>
<li>文件IO，IO函数包括read&#x2F;open&#x2F;write，每次调用的时候都会直接进入内核，实现了POSIX接口的APP可以在Linux，Unix上运行</li>
<li>标准IO是为了解决App读写数据时频繁进入内核而诞生的，通过App自身的buffer来减少访问内核的次数从而提高效率，标准IO是从POSIX接口封装出来的，标准IO函数包括fread&#x2F;fopen&#x2F;fwrite。同时，如果使用了标准IO开发App，经过编译后还可以Windows上运行</li>
</ul>
<p>文件IO的内部原理是：由glibc实现的open，read等函数在访问文件资源时，需要从用户空间转移到内核空间，此时函数的内部实现会抛出异常，也就是触发软中断，将svc或swi设置为0，对应的异常编号会放在R7寄存器(arm64架构放在R8)，而后转到内核，调用sys_call_table处理异常，这样当CPU处理异常时就知道异常的具体行为<br><img src="/vx_images/28992322246461.png" alt="2024-01-27_22-22">  </p>
<p>文件0代表stdin，以后scanf等操作产生的信息将会发送到此处<br>文件1代表stdout，以后printf等操作产生的信息将会发送到此处<br>文件2代表stderr，以后perror等操作产生的信息将会发送到此处<br>文件3代表文件句柄信息</p>
<p>:::alert-info<br>如果用同一个open程序打开不同的文件，返回的文件操作符有可能值相等，这是为什么呢？原因在于，即使文件操作符相等，但是open程序处理的文件也处于<strong>不同的进程</strong>且有独立的进程号，因此有不同的<strong>文件句柄空间</strong>，这样，文件操作符相等也没有关系。而当不同的句柄指向同一个文件结构体时，这两个句柄也不会相互干扰，例如当一个文件中内容是123，同一个进程读两次这个文件每次读一个字符时，由于两次读文件返回的是不同的句柄，指向file结构体中的f_pos彼此独立，这样读两次的内容分别为1，1，而不是1，2。若想文件句柄相互关联，可以使用dup(fd)函数复制某个文件句柄，这样，对应句柄指向的file结构体中的f_pos也会被复制下来，于是可以读出1，2了。<br>:::</p>
<h3 id="文件IO的内部机制"><a href="#文件IO的内部机制" class="headerlink" title="文件IO的内部机制"></a>文件IO的内部机制</h3><p><img src="/vx_images/273505722266627.png" alt="2024-01-27_22-56"><br>内核中有task结构体，其中包含了files结构体，files内还有fdt(fdtable)结构体，fdt内部有fd数组，这个数组储存了文件操作符与文件的关系，fd中每个元素都指向了一个file结构体，这样在不同task内即使fd的值相同，所指向的文件也会不同</p>
<h3 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h3><p>具体open函数用法和原理见 man 2 open</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打开文件名为argv[1]的文件，以读写模式打开(O_RDWR)，如果没有这个文件就创建这个文件(O_CREAT)，如果文件存在，且权限是读写的话就清空文件(O_TRUNC)，设置文件访问权限为664 */</span></span><br><span class="line">fd = open(argv[<span class="number">1</span>],O_RDWR |  O_CREAT | O_TRUNC, <span class="number">0664</span>); <span class="comment">//0代表8进制</span></span><br></pre></td></tr></table></figure>

<h3 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h3><p>相关函数均可以 man 2 fun</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件指针移到当前位置之后的第9个字符，打开文件时，默认指针位于文件开头 */</span></span><br><span class="line">lseek(fd, <span class="number">9</span>, SEEK_SET); </span><br><span class="line"><span class="comment">/* 对fd文件写not字符串，3为写字符串的长度，第二个参数也可以是argv，这样的话长度使用strlen()来获取 */</span></span><br><span class="line">write(fd, <span class="string">&quot;not&quot;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">/* 上面的结果是覆盖写 */</span></span><br></pre></td></tr></table></figure>

<h3 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对文件读sizeof(buf)-1个内容，并存在bbuf中 */</span></span><br><span class="line">read(fd, buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>当读一个文件时，是从f_pos位置开始读的，f_pos由内核维护，每读一次文件都会更新f_pos的值</p>
<h3 id="dup函数"><a href="#dup函数" class="headerlink" title="dup函数"></a>dup函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将文件句柄复制一份 */</span></span><br><span class="line">new_fd = dup(fd)</span><br></pre></td></tr></table></figure>
<p>使用dup后，文件句柄被复制，对应的f_pos也被复制，下次使用new_fd打开文件时，文件指针就是f_pos的位置  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将old_fd重定向到new_fd，使用dup2后，可以将new_fd的io重定向到old_fd */</span></span><br><span class="line">dup2(old_fd, new_fd)</span><br><span class="line"><span class="comment">/* 可以将stdin重定向到1.txt中，这样在shell内打印的结果就不会显示，而是输出到1.txt */</span></span><br><span class="line">dup2(<span class="number">1</span>_txt_fd,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="framebuffer"><a href="#framebuffer" class="headerlink" title="framebuffer"></a>framebuffer</h2><p>bpp(bits per pixel)</p>
<p>framebuffer是一个由驱动程序分配的在内存中的一段区域，其中存储了每个像素的颜色，具体由LCD的硬件控制器实现，值得注意的是写framebuffer到LCD执行会有一定的延迟，尽管肉眼看不到  </p>
<p>framebuffer有不同的bpp(bits per pixel)，一般而言有以下几种<br><img src="/vx_images/264391211240169.png" alt="2024-01-28_11-12">  </p>
<p>由于framebuffer由驱动掌管，因此读写framebuffer时需要使用mmap函数映射到用户空间</p>
<p>如果将32bit的像素转换为16bit的像素，则需要将RGB的高n位保留，舍弃掉低n位</p>
<h2 id="文本及图像显示"><a href="#文本及图像显示" class="headerlink" title="文本及图像显示"></a>文本及图像显示</h2><h3 id="文本显示"><a href="#文本显示" class="headerlink" title="文本显示"></a>文本显示</h3><p>文本显示 &#x3D; 编码 + 字体</p>
<p>ASCII定义了128个字符，因此在7bit位上始终为0<br>ASNI由Windows提出，包含了ASCII，根据7bit位是否为0来判断该字是否为ASCII，若不为ASCII，则需要使用两个字节表示一个字，并且之后还需要选定字符集<br>Unicode不需要判断字符集，主要分为UTF-16 和 UTF-8两种，UTF-16根据大小端模式分为2种，每种效率相比UTF-8较低，因此主流使用UTF-8编码  </p>
<p>对于UTF-8，内部保存了长度信息，因此即使某部分字节信息丢失也不会影响整体信息<br><img src="/vx_images/494225911258595.png" alt="2024-01-28_11-58">  </p>
<p>若要显示矢量位图文字，需要使用freetype库，注意编译freetype时还需要freetype的依赖</p>
<h2 id="Linux应用输入系统编程的四种方式"><a href="#Linux应用输入系统编程的四种方式" class="headerlink" title="Linux应用输入系统编程的四种方式"></a>Linux应用输入系统编程的四种方式</h2><ul>
<li>对于Linux来说，输入设备多种多样，Linux把所有的输入设备的输入数据处理成3种：<ul>
<li>type：哪类事件？比如EV_ABS类</li>
<li>code：哪个操作？比如ABS_X</li>
<li>value： 值</li>
</ul>
</li>
</ul>
<p><img src="/vx_images/488490816246462.png" alt="2024-01-28_16-08"><br>内核中使用input_event结构体来上报三种数据，除此之外，结构体还有时间信息<br><img src="/vx_images/95050916266628.png" alt="2024-01-28_16-09">  </p>
<p>当type，code，value都为0时，代表已经获得了完整的数据，也称为同步事件，同步事件用来分隔普通事件  </p>
<p>输入系统支持的API操作：阻塞，非阻塞，poll&#x2F;SELECT，异步通知</p>
<h3 id="阻塞非阻塞方式访问硬件"><a href="#阻塞非阻塞方式访问硬件" class="headerlink" title="阻塞非阻塞方式访问硬件"></a>阻塞非阻塞方式访问硬件</h3><p>默认文件API是阻塞执行的，除非在API中或上 O_NONBLOCK，当阻塞执行时，任务收不到数据将会不断的查询，直至硬件产生数据，当非阻塞方式访问硬件资源时，任务如果得不到硬件数据就会休眠，直至内核将其唤醒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc == <span class="number">3</span> &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;noblock&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDWR | O_NONBLOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="poll-SELECT方式访问硬件"><a href="#poll-SELECT方式访问硬件" class="headerlink" title="poll&#x2F;SELECT方式访问硬件"></a>poll&#x2F;SELECT方式访问硬件</h3><p>APP主动访问硬件数据的通信方式，与阻塞非阻塞方式的区别是poll函数支持超时时间，poll函数还可以监测多个文件<br>poll与select区别在于，select单个进程的连接数有限制，由<code>FD_SETSIZE</code>宏定义，而poll由链表实现，对于连接数没有限制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span> <span class="comment">//存放ioctl获得的数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line"><span class="type">nfds_t</span> nfds = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	fds[<span class="number">0</span>].fd = fd;</span><br><span class="line">	fds[<span class="number">0</span>].events  = pollIN; <span class="comment">//想要在硬件中读取数据</span></span><br><span class="line">	fds[<span class="number">0</span>].revents = <span class="number">0</span>; <span class="comment">//存放poll函数的返回值</span></span><br><span class="line">	ret = poll(fds, nfds, <span class="number">5000</span>); <span class="comment">//5000为超时时间</span></span><br><span class="line">	<span class="comment">/* 检查poll是否正常、不超时的返回 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">/* 检查返回事件是否是预期的pollIN事件 */</span></span><br><span class="line">		<span class="keyword">if</span> (fds[<span class="number">0</span>].revents == pollIN)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (read(fd, &amp;event, <span class="keyword">sizeof</span>(event)) == <span class="keyword">sizeof</span>(event))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;get event: type = 0x%x, code = 0x%x, value = 0x%x\n&quot;</span>, event.type, event.code, event.value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;time out\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;poll err\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异步通知"><a href="#异步通知" class="headerlink" title="异步通知"></a>异步通知</h3><p>硬件产生数据了主动通知APP的通信方式</p>
<p>通知流程：</p>
<ol>
<li>编写信号处理函数，当硬件给APP发消息时会自动执行此函数</li>
<li>注册信号处理函数，使用signal函数在内核中注册信号处理函数</li>
<li>打开驱动设备</li>
<li>把进程ID告诉驱动，这样驱动才能通知指定APP</li>
<li>使能驱动FASYNC位，此位控制驱动是否应该发送消息给应用</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Todo */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 注册信号处理函数 */</span></span><br><span class="line">    signal(SIGIO, my_sig_handler);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 打开驱动程序 */</span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR | O_NONBLOCK);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Todo */</span></span><br><span class="line">    <span class="comment">/* Todo */</span></span><br><span class="line">    <span class="comment">/* Todo */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 把APP的进程号告诉驱动程序 */</span></span><br><span class="line">	fcntl(fd, F_SETOWN, getpid());</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 使能&quot;异步通知&quot; */</span></span><br><span class="line">	flags = fcntl(fd, F_GETFL);</span><br><span class="line">	fcntl(fd, F_SETFL, flags | FASYNC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>本课程主要讲授TCP与UDP编程，其他网络编程可自行查找资料<br>TCP是一种可靠的，有连接的网络通信方式，UDP是一种不可靠的，无连接的网络通信方式，相比UDP，TCP会检查双方通信数据是否送达，若不送达还会进行等待操作，对延迟敏感的可能需要考虑是否使用TCP传输数据</p>
<h3 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h3><table>
<thead>
<tr>
<th>服务器</th>
<th>客户端</th>
</tr>
</thead>
<tbody><tr>
<td><strong>int socket(int domain, int type,int protocol);</strong> socket的返回值类似句柄，它负责表明通讯所需要的协议族及协议，函数内需要填入domain（通讯协族），type（通讯协议），protocol（由于通讯协议已经指定了，因此此处可以填0）</td>
<td><strong>int socket(int domain, int type,int protocol);</strong> 用法及参数同服务器</td>
</tr>
<tr>
<td><strong>int bind(int sockfd, struct sockaddr *my_addr, int addrlen);</strong> bind负责连接socket产生的句柄和服务器参数的信息，比如在my_addr结构体内传入端口，ip，协议族信息</td>
<td></td>
</tr>
<tr>
<td><strong>int listen(int sockfd,int backlog);</strong> listen负责监听端口是否被访问，它需要bind之后的socket文件描述符，而backlog指的是最多允许多少个客户端连接端口</td>
<td></td>
</tr>
<tr>
<td><strong>int accept(int sockfd, struct sockaddr *addr,int *addrlen);</strong> accept负责接收客户端的连接请求，addr填入bind的<strong>客户端结构体</strong>的地址，这样服务器才能知道客户端的具体信息</td>
<td><strong>int connect(int sockfd, struct sockaddr * serv_addr,int addrlen);</strong> connect负责连接服务器，sockaddr填入<strong>客户端结构体</strong>的地址，这样才能让服务器知道连接的客户端的具体信息</td>
</tr>
<tr>
<td><strong>ssize_t recv(int sockfd, void *buf, size_t len, int flags);</strong> recv负责接收客户端数据，它需要一个buf来存储数据，len可以使用strlen来获取，flag一般填0</td>
<td><strong>ssize_t send(int sockfd, const void *buf, size_t len, int flags);</strong> 用法及参数类似服务器</td>
</tr>
</tbody></table>
<h3 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h3><table>
<thead>
<tr>
<th>服务器</th>
<th>客户端</th>
</tr>
</thead>
<tbody><tr>
<td><strong>int socket(int domain, int type,int protocol);</strong> 同TCP</td>
<td><strong>int socket(int domain, int type,int protocol);</strong> 用法及参数同服务器</td>
</tr>
<tr>
<td><strong>int bind(int sockfd, struct sockaddr *my_addr, int addrlen);</strong> 同TCP</td>
<td></td>
</tr>
<tr>
<td><strong>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);</strong> 由于TDP是非连接型网络通讯协议，因此不需要listen和accept函数，但是向服务器传输数据时必须指明客户端的ip地址，因此在接收数据时，服务器需要定义一个struct sockaddr *src_addr结构体来储存客户端的本机ip，端口等信息</td>
<td><strong>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);</strong> 用法及参数类似服务器</td>
</tr>
</tbody></table>
<h2 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h2><p>在Linux中，调度的单位是线程，资源分配的单位是进程  </p>
<p>互斥量用于多线程中临界资源的互斥访问，不能控制线程执行的先后顺序<br>信号量用于多线程中程序先后执行顺序的控制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建线程 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,<span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程主动退出 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程被动退出 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程资源回收(阻塞方式)，即使用上面两个函数后，调用此函数会回收系统分配给这个线程的资源，并获得线程的返回值 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程资源回收(非阻塞方式) */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_tryjoin_np</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化互斥量 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">phtread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 互斥量加锁/解锁 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 互斥量加锁(非阻塞方式) */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 互斥量销毁(非阻塞方式) */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destory</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化信号量 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem,<span class="type">int</span> pshared,<span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号量 P/V 操作(默认为阻塞操作) */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号量申请(非阻塞方式) */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号量销毁 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destory</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建和销毁条件变量 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_condattr_t</span> *cond_attr)</span>;<span class="comment">//cond_attr 通常为 NULL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待条件变量 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span>;<span class="comment">//需要与互斥锁共同使用</span></span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;g_tMutex);</span><br><span class="line"><span class="comment">// 如果条件不满足则,会 unlock g_tMutex</span></span><br><span class="line"><span class="comment">// 条件满足后被唤醒,会 lock g_tMutex</span></span><br><span class="line">pthread_cond_wait(&amp;g_tConVar, &amp;g_tMutex);</span><br><span class="line"><span class="comment">/* 操作临界资源 */</span></span><br><span class="line">pthread_mutex_unlock(&amp;g_tMutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通知条件变量 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="串口编程"><a href="#串口编程" class="headerlink" title="串口编程"></a>串口编程</h2><p>UART共有4根线，RX，TX，GND，VCC，默认情况下是低位先行<br>TTL电平为0V<del>5V，RS232为-12V</del>12V，在转换时不仅仅是买个转接口，还需要注意是否购买电平转换芯片  </p>
<ul>
<li>开发板UART发送数据流程：<ul>
<li>开发板从内存中读入数据，并将数据载入FIFO</li>
<li>移位寄存器从FIFO中获得数据，将数据通过TX口发送出去</li>
</ul>
</li>
</ul>
<h3 id="TTY"><a href="#TTY" class="headerlink" title="TTY"></a>TTY</h3><p>tty(teletype，电传机)，以前电脑庞大又昂贵，多个科研院所通过多个硬件终端(tty)共用一台计算机。随着科技发展，现在的计算机可以通过一台硬件终端(键鼠+显示器)来模拟多个虚拟终端</p>
<p>tty0代表位于前台的那个终端，因此，只要将信息发给tty0，无论位于哪个tty，都会收到信息。<br>在当前shell中访问&#x2F;dev&#x2F;tty就可以知道当前shell使用的是哪个tty  </p>
<p>由于历史原因，现在的UART驱动程序都放在了tty中</p>
<p><img src="/vx_images/393842811240171.png" alt="2024-01-30_11-28"></p>
<p>console(控制台)，可以理解为权限更大的终端</p>
<p>当PC机发送lsa+退格键+回车键命令给arm板时，，首先l通过UART被发送给arm板的UART，而后经过UART Driver处理后发送给**line discipline(行规范)**，可以将行规范理解为一个缓冲区，行规范发现l是一个普通字符，于是将l保存在缓冲区中并回显给PC机：首先由行规范将l发送给UART Driver，而后由UART Driver处理将l通过UART发送给PC机，再经由PC机的UART Driver处理后发送给屏幕，此时完成回显。s，a字符同理，但当发送退格键时，行规范会执行退格操作，将缓冲区的a字符清除，之后再次回显。最后当PC发送回车键时，行规范将缓冲区的所有数据发送给APP(此时是shell)，由shell处理后的结果通过串口发送给PC机。</p>
<p>需要注意的是，默认情况行规范会自动处理数据，在UART外接其他模块时(比如GPS)，需要将行规范的数据处理模式改为RAW，默认不处理数据，并且还要设置一有数据就返回<br><img src="/vx_images/163195211258597.png" alt="2024-01-30_11-52"></p>
<h2 id="I2C编程"><a href="#I2C编程" class="headerlink" title="I2C编程"></a>I2C编程</h2><p>i2c高位先行<br>写操作由7位地址位+1位读写方向位构成，读写方向位中0代表写，1代表读<br>为了防止主从设备一个输出高电平一个输出低电平导致短路，而又因为主从设备均操控SDA，SCL，因此i2c的采用了弱上拉结构<br>一旦设备接收到信息了，那么就意味着设备需要驱动三极管使上拉电阻接地，这样ACK信号永远是低电平信号</p>
<p>Linux中，主设备使用i2c_adapter结构体表示，里面保存了需要的传输函数，以及自己位于第几条i2c总线，从设备使用i2c_client结构体表示，里面保存了设备地址，需要与第几条总线的主设备连接，传输时使用i2c_meg结构体保存传输数据，里面有从机地址，数据的buf</p>
<h2 id="SMB协议"><a href="#SMB协议" class="headerlink" title="SMB协议"></a>SMB协议</h2><p>SMB协议是i2c的子集</p>
<p>相比i2c，协议增加了</p>
<ul>
<li>对电压的规定：<ul>
<li>I2C 协议：范围很广,甚至讨论了高达 12V 的情况  </li>
<li>SMBus：1.8V~5V</li>
</ul>
</li>
<li>最小时钟频率、最大的 Clock Stretching(某个设备需要更多时间进行内部的处理时,它可以把 SCL 拉低占住 I2C 总线)<ul>
<li>I2C 协议：时钟频率最小值无限制,Clock Stretching 时长也没有限制</li>
<li>SMBus：时钟频率最小值是 10KHz,Clock Stretching 的最大时间值也有限制</li>
</ul>
</li>
<li>地址回应<ul>
<li>I2C 协议：没有强制要求必须发出回应信号</li>
<li>SMBus：强制要求必须发出回应信号,这样对方才知道该设备的状态：busy,failed,或是被移除了</li>
</ul>
</li>
<li>重复起始条件<ul>
<li>I2C 协议：读写寄存器时，需要发送停止信号p，再发送起始信号s</li>
<li>SMBus：规定了重复起始条件，节省了重复操作</li>
</ul>
</li>
<li>SMBus有低功耗版本</li>
</ul>
<p>Linux推荐使用SMBus，即使从设备缺少硬件支持，Linux也有软件模拟SMBus的功能 </p>
<h1 id="Linux驱动开发基础"><a href="#Linux驱动开发基础" class="headerlink" title="Linux驱动开发基础"></a>Linux驱动开发基础</h1><h2 id="驱动开发的原则"><a href="#驱动开发的原则" class="headerlink" title="驱动开发的原则"></a>驱动开发的原则</h2><p>只提供功能不提供策略，这意味着驱动开发只提供基础的查询，休眠唤醒，poll，寄存器封装等机制，但是对于这些函数怎么使用则由APP决定</p>
<h2 id="驱动的框架"><a href="#驱动的框架" class="headerlink" title="驱动的框架"></a>驱动的框架</h2><p>实现驱动的步骤如下：</p>
<ol>
<li>指定主设备号major，如果为0则代表让系统自动分配</li>
<li>实现具体驱动的相关函数，如open&#x2F;read&#x2F;write&#x2F;close等操作，并将操作保留在<code>file_operations</code>结构体中</li>
<li>在设备初始化函数(也称为入口函数)中调用<code>register_chrdev</code>以及<code>class_create</code>函数注册设备并创建设备类，并调用<code>device_create</code>在&#x2F;dev&#x2F;下创建设备</li>
<li>在设备退出函数(也称为出口函数)中依次调用<code>device_destroy</code>，<code>class_destroy</code>，<code>unregister_chrdev</code>函数注销设备</li>
<li>准备其他信息如<code>module_init</code>，<code>module_exit</code>等函数来初始化第4步的函数，使用<code>MODULE_LICENSE(&quot;GPL&quot;);</code>来表明协议(内核驱动强制开源，应用驱动可以不开源)</li>
</ol>
<p>:::alert-info<br>驱动代码中没有主函数，并且编译时需要与内核一起编译<br>:::</p>
<h3 id="最简单的LED驱动程序"><a href="#最简单的LED驱动程序" class="headerlink" title="最简单的LED驱动程序"></a>最简单的LED驱动程序</h3><p><img src="/vx_images/512684309240242.png" alt="2024-02-01_09-43"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep filename.c <span class="comment">//可以获得在内核中打印的信息，用于检测驱动设备是否正常运行</span></span><br></pre></td></tr></table></figure>

<p>对于读写硬件的驱动程序，具体操作如下</p>
<ol>
<li>指定主设备号major，如果为0则代表让系统自动分配</li>
<li>实现具体驱动的相关函数，如open&#x2F;read&#x2F;write&#x2F;close等操作，并将操作保留在<code>file_operations</code>结构体中，<strong>同时还需要将寄存器的读写操作在具体函数中实现</strong></li>
<li>在设备初始化函数(也称为入口函数)中调用<code>register_chrdev</code>以及<code>class_create</code>函数注册设备并创建设备类，并调用<code>device_create</code>在&#x2F;dev&#x2F;下创建设备，<strong>并且还需要使用<code>ioremap</code>函数来映射硬件地址到虚拟地址中</strong></li>
<li>在设备退出函数(也称为出口函数)中依次调用<code>device_destroy</code>，<code>class_destroy</code>，<code>unregister_chrdev</code>函数注销设备，<strong>并且还需要使用<code>iounmap</code>来解除映射</strong></li>
<li>准备其他信息如<code>module_init</code>，<code>module_exit</code>等函数来初始化第4步的函数，使用<code>MODULE_LICENSE(&quot;GPL&quot;);</code>来表明协议(内核驱动强制开源，应用驱动可以不开源)</li>
</ol>
<h2 id="驱动设计的思想"><a href="#驱动设计的思想" class="headerlink" title="驱动设计的思想"></a>驱动设计的思想</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p><code>file_opration</code>结构体中有函数指针，可以使用指针来进行操作  </p>
<h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************在下层的驱动文件中定义，直接操作硬件*******************/</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> <span class="title">board_demo_led_opr</span> =</span> &#123;</span><br><span class="line">	.num  = <span class="number">2</span>,</span><br><span class="line">	.init = board_demo_led_init,<span class="comment">//这个结构体赋值了.h文件中的结构体，并将返回值付给了get_board_led_opr</span></span><br><span class="line">	.<span class="built_in">exit</span> = board_demo_led_exit,</span><br><span class="line">	.ctl  = board_demo_led_ctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> led_operations *<span class="title function_">get_board_led_opr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;board_demo_led_opr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********在.h文件中定义作为接口，上下层的驱动文件都要包含这个头文件***********/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="type">int</span> (*init) (<span class="type">int</span> which); <span class="comment">/* 初始化LED, which-哪个LED */</span></span><br><span class="line">	<span class="type">void</span> (*<span class="built_in">exit</span>) (<span class="type">int</span> which); <span class="comment">/* 取消初始化LED, which-哪个LED */</span></span><br><span class="line">	<span class="type">int</span> (*ctl) (<span class="type">int</span> which, <span class="type">char</span> status); <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> led_operations *<span class="title function_">get_board_led_opr</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************在上层的驱动文件中定义，注册驱动*******************/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> *<span class="title">p_led_opr</span>;</span></span><br><span class="line"></span><br><span class="line">p_led_opr = get_board_led_opr();<span class="comment">//从.h文件中得到接口的地址</span></span><br><span class="line"></span><br><span class="line">p_led_opr-&gt;init(minor);</span><br><span class="line">p_led_opr-&gt;ctl(minor, status);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给Linux内核的fop函数</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.open    = led_drv_open,</span><br><span class="line">	.read    = led_drv_read,</span><br><span class="line">	.write   = led_drv_write,</span><br><span class="line">	.release = led_drv_close,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>驱动程序分为boarda.c，boardb.c，以及上层的drv.c，在前两者中，只进行寄存器和内存映射操作，是单片机的延续，后者是进行注册驱动等操作  </p>
<h3 id="分离"><a href="#分离" class="headerlink" title="分离"></a>分离</h3><p>除了上下层分层外，有的复杂驱动还需要同层分离，比如对于某种主板来说，尽管LED会有不同，但是芯片是只有一种的，因此对于不同的LED需要一个resource.h文件来管理具体LED寄存器，而board.c文件则需要负责将这些管理好的寄存器进行配置和高级的封装，并将函数在和结构体在resource.h文件声明，日后chip.c会直接调用resource.h的函数和结构体声明</p>
<h2 id="总线设备驱动模型"><a href="#总线设备驱动模型" class="headerlink" title="总线设备驱动模型"></a>总线设备驱动模型</h2><p>为了解决设备和驱动资源的相互关系，更好的解耦两者，Linux推出了Bus(虚拟总线)机制，设备会在内核中注册<code>platform</code>结构体，这个结构体会通过<code>platform_device</code>被挂载到设备链表上，驱动程序也有类似操作，最终会通过<code>platform_driver</code>被挂载到驱动链表上，两个链表由内核统一管理，根据在<code>platform</code>中注册的设备ID，名字等参数来耦合两者</p>
<h2 id="设备树驱动模型"><a href="#设备树驱动模型" class="headerlink" title="设备树驱动模型"></a>设备树驱动模型</h2><p>随着越来越多的设备加入了内核，即使使用总线设备驱动模型也难以让各个设备使用统一的接口来接入Linux，使得相似的驱动程序充斥着内核源码，为了解决这个问题，Linux推出了设备树  </p>
<p>进入内核根目录后执行<code>make dtbs</code>即可编译内核，在编译过程中，内核使用gcc将dtbs文件预处理，而后由内核中的脚本文件将预处理完成的文件转化为dtb文件  </p>
<p>将修改的设备树挂载到设备上的操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 进入Linux内核主目录 */</span><br><span class="line">make dtbs</span><br><span class="line"></span><br><span class="line">/* 将生成的dtb文件拷贝到目标机器的/boot目录下 */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 重启目标设备 */</span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line">/* 查看设备树是否更新,base为设备树的根节点 */</span><br><span class="line">cd /sys/firmware/base</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在设备树模型中，每个节点都会被内核构造成<code>device_node</code>，只有位于根节点下的子节点或者标明了<code>compatile = &quot;xxxbus&quot;</code>属性的父节点下的子节点才会有被转换成<code>platform_device</code>，在根节点下的I2C、SPI节点也会被转换成<code>platform_device</code>，但是I2C、SPI下的子节点<strong>不转换为</strong><code>platform_device</code>，这是因为总线下的子节点应该交由对应的总线控制器(如I2C Controller)处理</p>
<p>在<code>platform_driver</code>中有<code>of_match_table</code>结构体，这个结构体中有<code>compatible</code>，执行<code>probe</code>操作时就是比较<code>compatible</code></p>
<p>:::alert-info<br>采用了设备树后我们应该怎么调用设备树里的资源呢？<br>使用of_开头的函数就可以调用内核解析出来的设备树的资源了，例如of_gpio_count，这是因为根节点被保存在全局变量 of_root 中,从 of_root 开始可以访问到任意节点<br>:::</p>
<h2 id="Linux驱动输入系统编程的四种方式"><a href="#Linux驱动输入系统编程的四种方式" class="headerlink" title="Linux驱动输入系统编程的四种方式"></a>Linux驱动输入系统编程的四种方式</h2><h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><p><img src="/vx_images/555733018240243.png" alt="2024-02-02_18-30"></p>
<p>查询与休眠唤醒对应了应用开发的阻塞非阻塞机制，查询方式是应用层使用open,read函数时调用驱动层的drv_open,drv_read来获得硬件接口状态</p>
<p><img src="/vx_images/453645515259373.png" alt="2024-02-04_15-55"></p>
<h3 id="休眠唤醒机制"><a href="#休眠唤醒机制" class="headerlink" title="休眠唤醒机制"></a>休眠唤醒机制</h3><p><img src="/vx_images/228213118258669.png" alt="2024-02-02_18-31"></p>
<p><img src="/vx_images/133675815255928.png" alt="2024-02-04_15-58"></p>
<p><img src="/vx_images/513115815251682.png" alt="2024-02-04_15-58_1"></p>
<p>休眠唤醒机制需要在驱动层注册中断服务程序，当外部信号触发了驱动层时，会直接将获得的数据发送给应用层</p>
<p>在驱动层中使用<code>wait_event(wq, condition)</code>来完成休眠唤醒操作，但是首先需要初始化等待队列wq，这需要使用<code>DECLARE_WAIT_QUEUE_HEAD</code>宏来初始化</p>
<h3 id="poll机制"><a href="#poll机制" class="headerlink" title="poll机制"></a>poll机制</h3><p><img src="/vx_images/435033118246536.png" alt="2024-02-02_18-31_1"></p>
<p><img src="/vx_images/54405415246538.png" alt="2024-02-04_15-53"></p>
<p><img src="/vx_images/539235415266704.png" alt="2024-02-04_15-54"></p>
<p>在休眠唤醒机制的中断基础上又发展了poll机制，首先驱动层需要在fop中实现poll函数，当应用调用poll函数时会使用驱动层的drv_poll函数，如果在给定的超时时间内触发中断，则会将数据返回，没有数据则会休眠，如果超时时间内都没有触发中断，则在超时时间后程序也会被内核自动唤醒。需要注意的是，poll的超时时间并不是一次性的，而是每隔若干时间去查看是否有数据给APP</p>
<h3 id="异步通知-1"><a href="#异步通知-1" class="headerlink" title="异步通知"></a>异步通知</h3><p><img src="/vx_images/100313218266702.png" alt="2024-02-02_18-32"></p>
<p><img src="/vx_images/405024118259371.png" alt="2024-02-02_18-41"></p>
<p><img src="/vx_images/48475115240245.png" alt="2024-02-04_15-49"></p>
<p><img src="/vx_images/2645315258671.png" alt="2024-02-04_15-52"></p>
<p>对于异步通知来说，驱动层需要实现<code>drv_fasync</code>函数，这个函数中仅仅记录进程号，在应用层需要提供注册信号处理函数signal，当触发外部中断时，由内核统一接管，首先将触发终端的数据保存，然后从驱动程序获得给注册信号处理函数的程序的进程号，并发送<code>kill_fasync</code>信号(kill在Linux中就是发送信号的意思)给注册信号处理函数的程序，从而通知应用程序</p>
<p>异步通知时启动信号函数以及恢复现场的过程：</p>
<ul>
<li>首先根据驱动程序所保存的PID找到进程在内核的task_struct结构体，修改里面的某些成员表示收到了信号</li>
<li>APP从内核态返回到用户态前，内核发现APP有信号在等待处理时，会修改APP的栈，增加一个新的“运行环境”，新环境里“运行地址”是信号处理函数的地址。这样，APP从内核态返回用户态时，运行的是信号处理函数。信号处理函数执行完后，会再次返回到内核态，在内核态里再使用旧的“运行环境”恢复APP的运行</li>
</ul>
<p>:::alert-info<br>kill在Linux中就是发送信号的意思，使用的kill -9是将九号信号发给程序，也就是杀掉程序<br><img src="/vx_images/598381118240253.png" alt="2024-02-12_18-11"><br>:::</p>
<h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>APP调用open函数时，传入O_NONBLOCK，就表示要使用非阻塞方式，默认是阻塞方式<br>:::alert-warning<br>注意：对于普通文件、块设备文件，O_NONBLOCK 不起作用<br>注意：对于字符设备文件，O_NONBLOCK起作用的前提是驱动程序针对O_NONBLOCK做了处理<br>:::</p>
<h2 id="Pinctrl子系统"><a href="#Pinctrl子系统" class="headerlink" title="Pinctrl子系统"></a>Pinctrl子系统</h2><p>由于接入设备过多，即使有数百的引脚的CPU也不能承受，此时就需要通用中断控制器(GIC)，由于此时的映射关系导致了若想知道是哪个外部设备引起的中断就必须经历CPU-&gt;GIC-&gt;GPIO-&gt;具体中断设备，这就要求了在设备树中应有多个cell来描述外部设备<br><img src="/vx_images/555341316269562.png" alt="2024-02-04_16-13"></p>
<p>为了管理数量众多的引脚(一个芯片可引出数百个引脚)，不再频繁使用IOMUX和GPIO，Linux提供了Pinctrl子系统功能，使得可以在设备树中指定资源</p>
<p>有的厂家，像NXP，会推出GUI的设备树代码生成软件</p>
<p>:::alert-info<br>给这些引脚引入Pinctrl功能的一定是对芯片特别熟悉的人，这些人就是<strong>BSP工程师</strong>，我们驱动工程师会使用即可，但是对于优秀的驱动工程师也需要能够实现Pinctrl功能<br>:::</p>
<p>可以从设备树开始学习Pinctrl，在图片中，左侧称为controller，右侧称为client，两侧都处于同一个设备树文件中，controller可以根据client的需求将引脚划分为group，并根据功能划分function，尽管在芯片厂家中并不一定看到这两个关键字，但是思想是一样的。对于client来说，可以配置若干功能，在左侧的controller可以一一对应</p>
<p><img src="/vx_images/243433321255926.png" alt="2024-02-02_21-33">  </p>
<h2 id="异常，中断与轮询"><a href="#异常，中断与轮询" class="headerlink" title="异常，中断与轮询"></a>异常，中断与轮询</h2><p>中断与轮询的区别：<br>中断是CPU处于被动状态下来接受设备的信号，而轮询是CPU主动去查询该设备是否有请求</p>
<ul>
<li>对于一个频繁请求cpu的设备，或者有大量数据请求的网络设备，那么轮询的效率比中断高</li>
<li>如果是一般设备，并且该设备请求cpu的频率比较低，则用中断效率要高一些</li>
</ul>
<p>对于外界的可以屏蔽的信号来源，比如按键，定时器，网络报文等称为中断，对于无法屏蔽的信号来源，比如指令错误，内存访问错误等称为异常，中断属于异常中的一种 </p>
<p>由于Linux任务调度的最小单位是线程，而资源分配的最小单位是进程，因此每个线程都有一个栈，每个进程都有公共资源，比如文件句柄，全局变量</p>
<p>中断流程</p>
<ul>
<li>中断源发出信号，cpu被硬件设置为强制跳转到异常向量表中的某个异常向量的地址</li>
<li>在异常向量表中找到要执行的中断服务函数，跳转到那个函数</li>
<li>保存现场</li>
<li>执行中断服务程序</li>
<li>恢复现场</li>
</ul>
<p>Linux为了防止中断多层嵌套后导致爆栈，因此<strong>不支持中断嵌套</strong>，但是Linux不支持中断嵌套会导致一个中断服务程序执行时间过长而导致其他线程不能响应的问题，所以<strong>中断程序应该执行的越快越好</strong>，但是对于网卡这类需要在中断中读取大量数据的设备则无能为力，解决办法是中断分为上半部和下半部，在上半部分处理紧急的事务，在下半部分处理不那么紧急的事务，这个下半部分由软件中断实现，当执行完硬件中断后，系统会顺便执行软件中断，在软件中断中有标志位，用来识别这个硬件中断是否需要软件中断。</p>
<ul>
<li>当中断下半部耗时不是很长且中断服务程序较简单时，使用<code>tasklet</code>，但是<code>tasklet</code>并不支持与APP竞争</li>
<li>当下半部分耗时比较长时，由于中断下半部分属于软中断，优先级比APP高，会霸占CPU使得APP卡顿，这时就需要<code>work</code>来将中断下半部放入<code>workqueue</code>，使其成为<strong>内核线程</strong>以便与APP共同竞争</li>
<li>但是对于多核处理器来说，使用<code>workqueue</code>会造成一个<code>workqueue</code>中<code>work</code>数量过多，这不利于线程并行，因此又引入了<code>threaded irq</code>操作来将中断线程并行化</li>
</ul>
<p>由于初始化tasklet后需要把tasklet放入内核链表，而运行taklet函数后会把tasklet从链表中删除，因此想要再次执行tasklet函数就需要再次调度</p>
<p>Linux中的内核线程是一个while(1)循环，里面是一个<code>workqueue</code>，驱动程序使用work相关函数将想要执行的函数放入<code>workqueue</code>时会唤醒内核线程，并执行放入的那个函数。但是这种做法有个缺点：当内核线程里有某个线程执行时间过长时会导致下一个线程执行不及时，解决办法是在内核中单开一个内核线程运行这个线程<br><img src="/vx_images/202144219267166.png" alt="2024-02-04_19-42"></p>
<p><img src="/vx_images/137870611240256.png" alt="2024-02-15_11-05"></p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>硬件定时器systick每次中断时就会触发内核中的<code>jiffies</code>加一，我们只要检测<code>jiffies</code>是否超过定时器结构体中的<code>expires</code>参数就能判断是否timer超时<br>timer定时器属于软件中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化timer结构体 */</span></span><br><span class="line">setup_timer(timer, fn, data)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将初始化的timer结构体加入timer链表中 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改定时器的时间 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mod_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer, <span class="type">unsigned</span> <span class="type">long</span> expires)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除定时器 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">del_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>一般情况下，APP数据交换发生在用户态和内核态之间，但是当交换数据量很大时效率会很低，改进的方法是让APP直接读取驱动程序的buffer，这时可以使用mmap，一般读写framebuffer时需要用到此函数</p>
<h3 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h3><p>地址映射是MMU维护的，MMU的两大作用：</p>
<ul>
<li>地址映射：在访问一个被执行两次的程序中的全局变量时，全局变量的地址是一样的，但是真实的物理地址一定不同，这是由MMU维护的</li>
<li>权限保护：CPU访问的硬件地址需要MMU审核后才可访问</li>
</ul>
<p><img src="/vx_images/49132822264668.png" alt="2024-02-04_22-27"><br>执行两次test后发现a的地址相同但值不同，这是因为cpu看到的是MMU给的虚拟地址</p>
<p><img src="/vx_images/262162922245909.png" alt="2024-02-04_22-29"></p>
<p>进程的空间由内核维护，具体的虚拟地址与物理地址映射关系放在了页目录表里，页目录表分为一级页目录表和二级页目录表，一级页目录表大小最小为1M，二级页目录表最小为1k，Linux下默认为4k，以下是通过查找页目录表来寻找物理地址的过程：</p>
<ul>
<li>CPU 发出虚拟地址 vaddr,假设为 0x12345678</li>
<li>MMU 根据 vaddr[31:20](0x123)找到一级页表项里的第123项，根据读取的[1:0]发现这是个一级页表项，从而获得section base address，假如为0xabc00000</li>
<li>将vasddr的剩下的[20:0]与section base address拼接找到偏移地址0xabc45678，此时为真实的物理地址</li>
</ul>
<p>对于二级页表，由于二级页表是放在一级页表中的，因此首先查询一级页表：</p>
<ul>
<li>CPU 发出虚拟地址 vaddr,假设为 0x12345678</li>
<li>MMU 根据 vaddr[31:20](0x123)找到一级页表项里的第123项，根据读取的[1:0]发现这是个二级页表项，从而获得level 2 descriptor base address</li>
<li>使用level 2 descriptor base addres找到二级页表的地址</li>
<li>根据vasddr的[19:12]找到二级页表的第45项，从而得到page base addr，假设为0xabc00000</li>
<li>将vasddr的剩下的[11:0]与page base addr拼接找到偏移地址0xabc00678，此时为真实的物理地址</li>
</ul>
<p><img src="/vx_images/118373822268349.png" alt="2024-02-04_22-38"></p>
<p><img src="/vx_images/523271523263485.png" alt="2024-02-04_23-15"></p>
<p>为了保证数据能够尽快写入其他硬件，cpu应该绕过cache直接访问内存，有如下情况时应该使用这种方法：</p>
<ul>
<li>读写寄存器时</li>
<li>读写framebuffer时</li>
<li>读写DMA控制的区域时</li>
</ul>
<p>新数据由cpu写入cache的同时也从cache写入内存的方式叫做<code>write through</code>(写通)<br>新数据由cpu写入cache，但需要等数据满一章后再从cache写入内存的方式叫做<code>write back</code>(写回)，写回操作经过写缓冲器，其本质是个FIFO</p>
<p><img src="/vx_images/143045013240246.png" alt="2024-02-05_13-49"></p>
<h3 id="cache与写buffer"><a href="#cache与写buffer" class="headerlink" title="cache与写buffer"></a>cache与写buffer</h3><p>cache负责加速CPU读数据的效率，写buffer本质上是个FIFO，能提高cache写内存的效率</p>
<p><img src="/vx_images/591831111240254.png" alt="2024-02-13_11-11">  </p>
<p><img src="/vx_images/252041211258680.png" alt="2024-02-13_11-12">  </p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/01/23/%E9%A1%B9%E7%9B%AE/" rel="prev" title="项目">
                  <i class="fa fa-chevron-left"></i> 项目
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/02/21/Linux%E6%B7%B1%E5%85%A5/" rel="next" title="Linux深入">
                  Linux深入 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2023 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吾铭子</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
